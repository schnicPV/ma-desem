
desenet-sensor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000177a0  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00006500  08017930  08017930  00027930  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801de30  0801de30  00030080  2**0
                  CONTENTS
  4 .ARM          00000008  0801de30  0801de30  0002de30  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801de38  0801de38  00030080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000068  0801de38  0801de38  0002de38  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000068  0801dea0  0801dea0  0002dea0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000080  20000000  0801df08  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001e84  20000080  0801df88  00030080  2**3
                  ALLOC
 10 ._user_heap_stack 00001004  20001f04  0801df88  00031f04  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00030080  2**0
                  CONTENTS, READONLY
 12 .debug_info   00137294  00000000  00000000  000300b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0001a6d2  00000000  00000000  00167344  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00005768  00000000  00000000  00181a18  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00005350  00000000  00000000  00187180  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0003ffcd  00000000  00000000  0018c4d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00060a11  00000000  00000000  001cc49d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00148a40  00000000  00000000  0022ceae  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  003758ee  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00019f94  00000000  00000000  00375940  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000080 	.word	0x20000080
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08017918 	.word	0x08017918

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000084 	.word	0x20000084
 80001cc:	08017918 	.word	0x08017918

080001d0 <memchr>:
 80001d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001d4:	2a10      	cmp	r2, #16
 80001d6:	db2b      	blt.n	8000230 <memchr+0x60>
 80001d8:	f010 0f07 	tst.w	r0, #7
 80001dc:	d008      	beq.n	80001f0 <memchr+0x20>
 80001de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001e2:	3a01      	subs	r2, #1
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d02d      	beq.n	8000244 <memchr+0x74>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	b342      	cbz	r2, 8000240 <memchr+0x70>
 80001ee:	d1f6      	bne.n	80001de <memchr+0xe>
 80001f0:	b4f0      	push	{r4, r5, r6, r7}
 80001f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001fa:	f022 0407 	bic.w	r4, r2, #7
 80001fe:	f07f 0700 	mvns.w	r7, #0
 8000202:	2300      	movs	r3, #0
 8000204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000208:	3c08      	subs	r4, #8
 800020a:	ea85 0501 	eor.w	r5, r5, r1
 800020e:	ea86 0601 	eor.w	r6, r6, r1
 8000212:	fa85 f547 	uadd8	r5, r5, r7
 8000216:	faa3 f587 	sel	r5, r3, r7
 800021a:	fa86 f647 	uadd8	r6, r6, r7
 800021e:	faa5 f687 	sel	r6, r5, r7
 8000222:	b98e      	cbnz	r6, 8000248 <memchr+0x78>
 8000224:	d1ee      	bne.n	8000204 <memchr+0x34>
 8000226:	bcf0      	pop	{r4, r5, r6, r7}
 8000228:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800022c:	f002 0207 	and.w	r2, r2, #7
 8000230:	b132      	cbz	r2, 8000240 <memchr+0x70>
 8000232:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000236:	3a01      	subs	r2, #1
 8000238:	ea83 0301 	eor.w	r3, r3, r1
 800023c:	b113      	cbz	r3, 8000244 <memchr+0x74>
 800023e:	d1f8      	bne.n	8000232 <memchr+0x62>
 8000240:	2000      	movs	r0, #0
 8000242:	4770      	bx	lr
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr
 8000248:	2d00      	cmp	r5, #0
 800024a:	bf06      	itte	eq
 800024c:	4635      	moveq	r5, r6
 800024e:	3803      	subeq	r0, #3
 8000250:	3807      	subne	r0, #7
 8000252:	f015 0f01 	tst.w	r5, #1
 8000256:	d107      	bne.n	8000268 <memchr+0x98>
 8000258:	3001      	adds	r0, #1
 800025a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800025e:	bf02      	ittt	eq
 8000260:	3001      	addeq	r0, #1
 8000262:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000266:	3001      	addeq	r0, #1
 8000268:	bcf0      	pop	{r4, r5, r6, r7}
 800026a:	3801      	subs	r0, #1
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop

08000270 <strlen>:
 8000270:	4603      	mov	r3, r0
 8000272:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000276:	2a00      	cmp	r2, #0
 8000278:	d1fb      	bne.n	8000272 <strlen+0x2>
 800027a:	1a18      	subs	r0, r3, r0
 800027c:	3801      	subs	r0, #1
 800027e:	4770      	bx	lr

08000280 <__aeabi_uldivmod>:
 8000280:	b953      	cbnz	r3, 8000298 <__aeabi_uldivmod+0x18>
 8000282:	b94a      	cbnz	r2, 8000298 <__aeabi_uldivmod+0x18>
 8000284:	2900      	cmp	r1, #0
 8000286:	bf08      	it	eq
 8000288:	2800      	cmpeq	r0, #0
 800028a:	bf1c      	itt	ne
 800028c:	f04f 31ff 	movne.w	r1, #4294967295
 8000290:	f04f 30ff 	movne.w	r0, #4294967295
 8000294:	f000 b974 	b.w	8000580 <__aeabi_idiv0>
 8000298:	f1ad 0c08 	sub.w	ip, sp, #8
 800029c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002a0:	f000 f806 	bl	80002b0 <__udivmoddi4>
 80002a4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002a8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002ac:	b004      	add	sp, #16
 80002ae:	4770      	bx	lr

080002b0 <__udivmoddi4>:
 80002b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002b4:	9d08      	ldr	r5, [sp, #32]
 80002b6:	4604      	mov	r4, r0
 80002b8:	468e      	mov	lr, r1
 80002ba:	2b00      	cmp	r3, #0
 80002bc:	d14d      	bne.n	800035a <__udivmoddi4+0xaa>
 80002be:	428a      	cmp	r2, r1
 80002c0:	4694      	mov	ip, r2
 80002c2:	d969      	bls.n	8000398 <__udivmoddi4+0xe8>
 80002c4:	fab2 f282 	clz	r2, r2
 80002c8:	b152      	cbz	r2, 80002e0 <__udivmoddi4+0x30>
 80002ca:	fa01 f302 	lsl.w	r3, r1, r2
 80002ce:	f1c2 0120 	rsb	r1, r2, #32
 80002d2:	fa20 f101 	lsr.w	r1, r0, r1
 80002d6:	fa0c fc02 	lsl.w	ip, ip, r2
 80002da:	ea41 0e03 	orr.w	lr, r1, r3
 80002de:	4094      	lsls	r4, r2
 80002e0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80002e4:	0c21      	lsrs	r1, r4, #16
 80002e6:	fbbe f6f8 	udiv	r6, lr, r8
 80002ea:	fa1f f78c 	uxth.w	r7, ip
 80002ee:	fb08 e316 	mls	r3, r8, r6, lr
 80002f2:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 80002f6:	fb06 f107 	mul.w	r1, r6, r7
 80002fa:	4299      	cmp	r1, r3
 80002fc:	d90a      	bls.n	8000314 <__udivmoddi4+0x64>
 80002fe:	eb1c 0303 	adds.w	r3, ip, r3
 8000302:	f106 30ff 	add.w	r0, r6, #4294967295
 8000306:	f080 811f 	bcs.w	8000548 <__udivmoddi4+0x298>
 800030a:	4299      	cmp	r1, r3
 800030c:	f240 811c 	bls.w	8000548 <__udivmoddi4+0x298>
 8000310:	3e02      	subs	r6, #2
 8000312:	4463      	add	r3, ip
 8000314:	1a5b      	subs	r3, r3, r1
 8000316:	b2a4      	uxth	r4, r4
 8000318:	fbb3 f0f8 	udiv	r0, r3, r8
 800031c:	fb08 3310 	mls	r3, r8, r0, r3
 8000320:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000324:	fb00 f707 	mul.w	r7, r0, r7
 8000328:	42a7      	cmp	r7, r4
 800032a:	d90a      	bls.n	8000342 <__udivmoddi4+0x92>
 800032c:	eb1c 0404 	adds.w	r4, ip, r4
 8000330:	f100 33ff 	add.w	r3, r0, #4294967295
 8000334:	f080 810a 	bcs.w	800054c <__udivmoddi4+0x29c>
 8000338:	42a7      	cmp	r7, r4
 800033a:	f240 8107 	bls.w	800054c <__udivmoddi4+0x29c>
 800033e:	4464      	add	r4, ip
 8000340:	3802      	subs	r0, #2
 8000342:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000346:	1be4      	subs	r4, r4, r7
 8000348:	2600      	movs	r6, #0
 800034a:	b11d      	cbz	r5, 8000354 <__udivmoddi4+0xa4>
 800034c:	40d4      	lsrs	r4, r2
 800034e:	2300      	movs	r3, #0
 8000350:	e9c5 4300 	strd	r4, r3, [r5]
 8000354:	4631      	mov	r1, r6
 8000356:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800035a:	428b      	cmp	r3, r1
 800035c:	d909      	bls.n	8000372 <__udivmoddi4+0xc2>
 800035e:	2d00      	cmp	r5, #0
 8000360:	f000 80ef 	beq.w	8000542 <__udivmoddi4+0x292>
 8000364:	2600      	movs	r6, #0
 8000366:	e9c5 0100 	strd	r0, r1, [r5]
 800036a:	4630      	mov	r0, r6
 800036c:	4631      	mov	r1, r6
 800036e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000372:	fab3 f683 	clz	r6, r3
 8000376:	2e00      	cmp	r6, #0
 8000378:	d14a      	bne.n	8000410 <__udivmoddi4+0x160>
 800037a:	428b      	cmp	r3, r1
 800037c:	d302      	bcc.n	8000384 <__udivmoddi4+0xd4>
 800037e:	4282      	cmp	r2, r0
 8000380:	f200 80f9 	bhi.w	8000576 <__udivmoddi4+0x2c6>
 8000384:	1a84      	subs	r4, r0, r2
 8000386:	eb61 0303 	sbc.w	r3, r1, r3
 800038a:	2001      	movs	r0, #1
 800038c:	469e      	mov	lr, r3
 800038e:	2d00      	cmp	r5, #0
 8000390:	d0e0      	beq.n	8000354 <__udivmoddi4+0xa4>
 8000392:	e9c5 4e00 	strd	r4, lr, [r5]
 8000396:	e7dd      	b.n	8000354 <__udivmoddi4+0xa4>
 8000398:	b902      	cbnz	r2, 800039c <__udivmoddi4+0xec>
 800039a:	deff      	udf	#255	; 0xff
 800039c:	fab2 f282 	clz	r2, r2
 80003a0:	2a00      	cmp	r2, #0
 80003a2:	f040 8092 	bne.w	80004ca <__udivmoddi4+0x21a>
 80003a6:	eba1 010c 	sub.w	r1, r1, ip
 80003aa:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80003ae:	fa1f fe8c 	uxth.w	lr, ip
 80003b2:	2601      	movs	r6, #1
 80003b4:	0c20      	lsrs	r0, r4, #16
 80003b6:	fbb1 f3f7 	udiv	r3, r1, r7
 80003ba:	fb07 1113 	mls	r1, r7, r3, r1
 80003be:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003c2:	fb0e f003 	mul.w	r0, lr, r3
 80003c6:	4288      	cmp	r0, r1
 80003c8:	d908      	bls.n	80003dc <__udivmoddi4+0x12c>
 80003ca:	eb1c 0101 	adds.w	r1, ip, r1
 80003ce:	f103 38ff 	add.w	r8, r3, #4294967295
 80003d2:	d202      	bcs.n	80003da <__udivmoddi4+0x12a>
 80003d4:	4288      	cmp	r0, r1
 80003d6:	f200 80cb 	bhi.w	8000570 <__udivmoddi4+0x2c0>
 80003da:	4643      	mov	r3, r8
 80003dc:	1a09      	subs	r1, r1, r0
 80003de:	b2a4      	uxth	r4, r4
 80003e0:	fbb1 f0f7 	udiv	r0, r1, r7
 80003e4:	fb07 1110 	mls	r1, r7, r0, r1
 80003e8:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 80003ec:	fb0e fe00 	mul.w	lr, lr, r0
 80003f0:	45a6      	cmp	lr, r4
 80003f2:	d908      	bls.n	8000406 <__udivmoddi4+0x156>
 80003f4:	eb1c 0404 	adds.w	r4, ip, r4
 80003f8:	f100 31ff 	add.w	r1, r0, #4294967295
 80003fc:	d202      	bcs.n	8000404 <__udivmoddi4+0x154>
 80003fe:	45a6      	cmp	lr, r4
 8000400:	f200 80bb 	bhi.w	800057a <__udivmoddi4+0x2ca>
 8000404:	4608      	mov	r0, r1
 8000406:	eba4 040e 	sub.w	r4, r4, lr
 800040a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800040e:	e79c      	b.n	800034a <__udivmoddi4+0x9a>
 8000410:	f1c6 0720 	rsb	r7, r6, #32
 8000414:	40b3      	lsls	r3, r6
 8000416:	fa22 fc07 	lsr.w	ip, r2, r7
 800041a:	ea4c 0c03 	orr.w	ip, ip, r3
 800041e:	fa20 f407 	lsr.w	r4, r0, r7
 8000422:	fa01 f306 	lsl.w	r3, r1, r6
 8000426:	431c      	orrs	r4, r3
 8000428:	40f9      	lsrs	r1, r7
 800042a:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800042e:	fa00 f306 	lsl.w	r3, r0, r6
 8000432:	fbb1 f8f9 	udiv	r8, r1, r9
 8000436:	0c20      	lsrs	r0, r4, #16
 8000438:	fa1f fe8c 	uxth.w	lr, ip
 800043c:	fb09 1118 	mls	r1, r9, r8, r1
 8000440:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000444:	fb08 f00e 	mul.w	r0, r8, lr
 8000448:	4288      	cmp	r0, r1
 800044a:	fa02 f206 	lsl.w	r2, r2, r6
 800044e:	d90b      	bls.n	8000468 <__udivmoddi4+0x1b8>
 8000450:	eb1c 0101 	adds.w	r1, ip, r1
 8000454:	f108 3aff 	add.w	sl, r8, #4294967295
 8000458:	f080 8088 	bcs.w	800056c <__udivmoddi4+0x2bc>
 800045c:	4288      	cmp	r0, r1
 800045e:	f240 8085 	bls.w	800056c <__udivmoddi4+0x2bc>
 8000462:	f1a8 0802 	sub.w	r8, r8, #2
 8000466:	4461      	add	r1, ip
 8000468:	1a09      	subs	r1, r1, r0
 800046a:	b2a4      	uxth	r4, r4
 800046c:	fbb1 f0f9 	udiv	r0, r1, r9
 8000470:	fb09 1110 	mls	r1, r9, r0, r1
 8000474:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 8000478:	fb00 fe0e 	mul.w	lr, r0, lr
 800047c:	458e      	cmp	lr, r1
 800047e:	d908      	bls.n	8000492 <__udivmoddi4+0x1e2>
 8000480:	eb1c 0101 	adds.w	r1, ip, r1
 8000484:	f100 34ff 	add.w	r4, r0, #4294967295
 8000488:	d26c      	bcs.n	8000564 <__udivmoddi4+0x2b4>
 800048a:	458e      	cmp	lr, r1
 800048c:	d96a      	bls.n	8000564 <__udivmoddi4+0x2b4>
 800048e:	3802      	subs	r0, #2
 8000490:	4461      	add	r1, ip
 8000492:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000496:	fba0 9402 	umull	r9, r4, r0, r2
 800049a:	eba1 010e 	sub.w	r1, r1, lr
 800049e:	42a1      	cmp	r1, r4
 80004a0:	46c8      	mov	r8, r9
 80004a2:	46a6      	mov	lr, r4
 80004a4:	d356      	bcc.n	8000554 <__udivmoddi4+0x2a4>
 80004a6:	d053      	beq.n	8000550 <__udivmoddi4+0x2a0>
 80004a8:	b15d      	cbz	r5, 80004c2 <__udivmoddi4+0x212>
 80004aa:	ebb3 0208 	subs.w	r2, r3, r8
 80004ae:	eb61 010e 	sbc.w	r1, r1, lr
 80004b2:	fa01 f707 	lsl.w	r7, r1, r7
 80004b6:	fa22 f306 	lsr.w	r3, r2, r6
 80004ba:	40f1      	lsrs	r1, r6
 80004bc:	431f      	orrs	r7, r3
 80004be:	e9c5 7100 	strd	r7, r1, [r5]
 80004c2:	2600      	movs	r6, #0
 80004c4:	4631      	mov	r1, r6
 80004c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004ca:	f1c2 0320 	rsb	r3, r2, #32
 80004ce:	40d8      	lsrs	r0, r3
 80004d0:	fa0c fc02 	lsl.w	ip, ip, r2
 80004d4:	fa21 f303 	lsr.w	r3, r1, r3
 80004d8:	4091      	lsls	r1, r2
 80004da:	4301      	orrs	r1, r0
 80004dc:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80004e0:	fa1f fe8c 	uxth.w	lr, ip
 80004e4:	fbb3 f0f7 	udiv	r0, r3, r7
 80004e8:	fb07 3610 	mls	r6, r7, r0, r3
 80004ec:	0c0b      	lsrs	r3, r1, #16
 80004ee:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 80004f2:	fb00 f60e 	mul.w	r6, r0, lr
 80004f6:	429e      	cmp	r6, r3
 80004f8:	fa04 f402 	lsl.w	r4, r4, r2
 80004fc:	d908      	bls.n	8000510 <__udivmoddi4+0x260>
 80004fe:	eb1c 0303 	adds.w	r3, ip, r3
 8000502:	f100 38ff 	add.w	r8, r0, #4294967295
 8000506:	d22f      	bcs.n	8000568 <__udivmoddi4+0x2b8>
 8000508:	429e      	cmp	r6, r3
 800050a:	d92d      	bls.n	8000568 <__udivmoddi4+0x2b8>
 800050c:	3802      	subs	r0, #2
 800050e:	4463      	add	r3, ip
 8000510:	1b9b      	subs	r3, r3, r6
 8000512:	b289      	uxth	r1, r1
 8000514:	fbb3 f6f7 	udiv	r6, r3, r7
 8000518:	fb07 3316 	mls	r3, r7, r6, r3
 800051c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000520:	fb06 f30e 	mul.w	r3, r6, lr
 8000524:	428b      	cmp	r3, r1
 8000526:	d908      	bls.n	800053a <__udivmoddi4+0x28a>
 8000528:	eb1c 0101 	adds.w	r1, ip, r1
 800052c:	f106 38ff 	add.w	r8, r6, #4294967295
 8000530:	d216      	bcs.n	8000560 <__udivmoddi4+0x2b0>
 8000532:	428b      	cmp	r3, r1
 8000534:	d914      	bls.n	8000560 <__udivmoddi4+0x2b0>
 8000536:	3e02      	subs	r6, #2
 8000538:	4461      	add	r1, ip
 800053a:	1ac9      	subs	r1, r1, r3
 800053c:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 8000540:	e738      	b.n	80003b4 <__udivmoddi4+0x104>
 8000542:	462e      	mov	r6, r5
 8000544:	4628      	mov	r0, r5
 8000546:	e705      	b.n	8000354 <__udivmoddi4+0xa4>
 8000548:	4606      	mov	r6, r0
 800054a:	e6e3      	b.n	8000314 <__udivmoddi4+0x64>
 800054c:	4618      	mov	r0, r3
 800054e:	e6f8      	b.n	8000342 <__udivmoddi4+0x92>
 8000550:	454b      	cmp	r3, r9
 8000552:	d2a9      	bcs.n	80004a8 <__udivmoddi4+0x1f8>
 8000554:	ebb9 0802 	subs.w	r8, r9, r2
 8000558:	eb64 0e0c 	sbc.w	lr, r4, ip
 800055c:	3801      	subs	r0, #1
 800055e:	e7a3      	b.n	80004a8 <__udivmoddi4+0x1f8>
 8000560:	4646      	mov	r6, r8
 8000562:	e7ea      	b.n	800053a <__udivmoddi4+0x28a>
 8000564:	4620      	mov	r0, r4
 8000566:	e794      	b.n	8000492 <__udivmoddi4+0x1e2>
 8000568:	4640      	mov	r0, r8
 800056a:	e7d1      	b.n	8000510 <__udivmoddi4+0x260>
 800056c:	46d0      	mov	r8, sl
 800056e:	e77b      	b.n	8000468 <__udivmoddi4+0x1b8>
 8000570:	3b02      	subs	r3, #2
 8000572:	4461      	add	r1, ip
 8000574:	e732      	b.n	80003dc <__udivmoddi4+0x12c>
 8000576:	4630      	mov	r0, r6
 8000578:	e709      	b.n	800038e <__udivmoddi4+0xde>
 800057a:	4464      	add	r4, ip
 800057c:	3802      	subs	r0, #2
 800057e:	e742      	b.n	8000406 <__udivmoddi4+0x156>

08000580 <__aeabi_idiv0>:
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop

08000584 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000584:	b580      	push	{r7, lr}
 8000586:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000588:	f000 ff12 	bl	80013b0 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800058c:	f000 f81a 	bl	80005c4 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000590:	f000 fa0a 	bl	80009a8 <MX_GPIO_Init>
  MX_USART2_UART_Init();
 8000594:	f000 f9a8 	bl	80008e8 <MX_USART2_UART_Init>
  MX_SPI2_Init();
 8000598:	f000 f8b6 	bl	8000708 <MX_SPI2_Init>
  MX_SPI3_Init();
 800059c:	f000 f8f2 	bl	8000784 <MX_SPI3_Init>
  MX_I2C3_Init();
 80005a0:	f000 f872 	bl	8000688 <MX_I2C3_Init>
  MX_USART3_UART_Init();
 80005a4:	f000 f9d0 	bl	8000948 <MX_USART3_UART_Init>
  MX_TIM2_Init();
 80005a8:	f000 f92a 	bl	8000800 <MX_TIM2_Init>
  /* USER CODE BEGIN 2 */

  Factory_init(0, NULL);
 80005ac:	2100      	movs	r1, #0
 80005ae:	2000      	movs	r0, #0
 80005b0:	f007 f81c 	bl	80075ec <Factory_init>
  XF_init(10);
 80005b4:	200a      	movs	r0, #10
 80005b6:	f013 fc97 	bl	8013ee8 <XF_init>

  Factory_buildApplication();
 80005ba:	f007 f845 	bl	8007648 <Factory_buildApplication>
  XF_start();
 80005be:	f013 fc9e 	bl	8013efe <XF_start>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 80005c2:	e7fe      	b.n	80005c2 <main+0x3e>

080005c4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80005c4:	b580      	push	{r7, lr}
 80005c6:	b096      	sub	sp, #88	; 0x58
 80005c8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80005ca:	f107 0314 	add.w	r3, r7, #20
 80005ce:	2244      	movs	r2, #68	; 0x44
 80005d0:	2100      	movs	r1, #0
 80005d2:	4618      	mov	r0, r3
 80005d4:	f015 ff76 	bl	80164c4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80005d8:	463b      	mov	r3, r7
 80005da:	2200      	movs	r2, #0
 80005dc:	601a      	str	r2, [r3, #0]
 80005de:	605a      	str	r2, [r3, #4]
 80005e0:	609a      	str	r2, [r3, #8]
 80005e2:	60da      	str	r2, [r3, #12]
 80005e4:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 80005e6:	f44f 7000 	mov.w	r0, #512	; 0x200
 80005ea:	f002 f857 	bl	800269c <HAL_PWREx_ControlVoltageScaling>
 80005ee:	4603      	mov	r3, r0
 80005f0:	2b00      	cmp	r3, #0
 80005f2:	d001      	beq.n	80005f8 <SystemClock_Config+0x34>
  {
    Error_Handler();
 80005f4:	f000 fb26 	bl	8000c44 <Error_Handler>
  }
  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 80005f8:	f002 f832 	bl	8002660 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 80005fc:	4b21      	ldr	r3, [pc, #132]	; (8000684 <SystemClock_Config+0xc0>)
 80005fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000602:	4a20      	ldr	r2, [pc, #128]	; (8000684 <SystemClock_Config+0xc0>)
 8000604:	f023 0318 	bic.w	r3, r3, #24
 8000608:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 800060c:	2314      	movs	r3, #20
 800060e:	617b      	str	r3, [r7, #20]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8000610:	2301      	movs	r3, #1
 8000612:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000614:	2301      	movs	r3, #1
 8000616:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = 0;
 8000618:	2300      	movs	r3, #0
 800061a:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 800061c:	2360      	movs	r3, #96	; 0x60
 800061e:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000620:	2302      	movs	r3, #2
 8000622:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8000624:	2301      	movs	r3, #1
 8000626:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000628:	2301      	movs	r3, #1
 800062a:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 16;
 800062c:	2310      	movs	r3, #16
 800062e:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8000630:	2307      	movs	r3, #7
 8000632:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8000634:	2302      	movs	r3, #2
 8000636:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8000638:	2302      	movs	r3, #2
 800063a:	657b      	str	r3, [r7, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800063c:	f107 0314 	add.w	r3, r7, #20
 8000640:	4618      	mov	r0, r3
 8000642:	f002 f881 	bl	8002748 <HAL_RCC_OscConfig>
 8000646:	4603      	mov	r3, r0
 8000648:	2b00      	cmp	r3, #0
 800064a:	d001      	beq.n	8000650 <SystemClock_Config+0x8c>
  {
    Error_Handler();
 800064c:	f000 fafa 	bl	8000c44 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000650:	230f      	movs	r3, #15
 8000652:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000654:	2303      	movs	r3, #3
 8000656:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000658:	2300      	movs	r3, #0
 800065a:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800065c:	2300      	movs	r3, #0
 800065e:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000660:	2300      	movs	r3, #0
 8000662:	613b      	str	r3, [r7, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000664:	463b      	mov	r3, r7
 8000666:	2101      	movs	r1, #1
 8000668:	4618      	mov	r0, r3
 800066a:	f002 fc55 	bl	8002f18 <HAL_RCC_ClockConfig>
 800066e:	4603      	mov	r3, r0
 8000670:	2b00      	cmp	r3, #0
 8000672:	d001      	beq.n	8000678 <SystemClock_Config+0xb4>
  {
    Error_Handler();
 8000674:	f000 fae6 	bl	8000c44 <Error_Handler>
  }
  /** Enable MSI Auto calibration
  */
  HAL_RCCEx_EnableMSIPLLMode();
 8000678:	f003 f93e 	bl	80038f8 <HAL_RCCEx_EnableMSIPLLMode>
}
 800067c:	bf00      	nop
 800067e:	3758      	adds	r7, #88	; 0x58
 8000680:	46bd      	mov	sp, r7
 8000682:	bd80      	pop	{r7, pc}
 8000684:	40021000 	.word	0x40021000

08000688 <MX_I2C3_Init>:
  * @brief I2C3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C3_Init(void)
{
 8000688:	b580      	push	{r7, lr}
 800068a:	af00      	add	r7, sp, #0
  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
 800068c:	4b1b      	ldr	r3, [pc, #108]	; (80006fc <MX_I2C3_Init+0x74>)
 800068e:	4a1c      	ldr	r2, [pc, #112]	; (8000700 <MX_I2C3_Init+0x78>)
 8000690:	601a      	str	r2, [r3, #0]
  hi2c3.Init.Timing = 0x008081B5;
 8000692:	4b1a      	ldr	r3, [pc, #104]	; (80006fc <MX_I2C3_Init+0x74>)
 8000694:	4a1b      	ldr	r2, [pc, #108]	; (8000704 <MX_I2C3_Init+0x7c>)
 8000696:	605a      	str	r2, [r3, #4]
  hi2c3.Init.OwnAddress1 = 0;
 8000698:	4b18      	ldr	r3, [pc, #96]	; (80006fc <MX_I2C3_Init+0x74>)
 800069a:	2200      	movs	r2, #0
 800069c:	609a      	str	r2, [r3, #8]
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800069e:	4b17      	ldr	r3, [pc, #92]	; (80006fc <MX_I2C3_Init+0x74>)
 80006a0:	2201      	movs	r2, #1
 80006a2:	60da      	str	r2, [r3, #12]
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80006a4:	4b15      	ldr	r3, [pc, #84]	; (80006fc <MX_I2C3_Init+0x74>)
 80006a6:	2200      	movs	r2, #0
 80006a8:	611a      	str	r2, [r3, #16]
  hi2c3.Init.OwnAddress2 = 0;
 80006aa:	4b14      	ldr	r3, [pc, #80]	; (80006fc <MX_I2C3_Init+0x74>)
 80006ac:	2200      	movs	r2, #0
 80006ae:	615a      	str	r2, [r3, #20]
  hi2c3.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 80006b0:	4b12      	ldr	r3, [pc, #72]	; (80006fc <MX_I2C3_Init+0x74>)
 80006b2:	2200      	movs	r2, #0
 80006b4:	619a      	str	r2, [r3, #24]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80006b6:	4b11      	ldr	r3, [pc, #68]	; (80006fc <MX_I2C3_Init+0x74>)
 80006b8:	2200      	movs	r2, #0
 80006ba:	61da      	str	r2, [r3, #28]
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80006bc:	4b0f      	ldr	r3, [pc, #60]	; (80006fc <MX_I2C3_Init+0x74>)
 80006be:	2200      	movs	r2, #0
 80006c0:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 80006c2:	480e      	ldr	r0, [pc, #56]	; (80006fc <MX_I2C3_Init+0x74>)
 80006c4:	f001 fada 	bl	8001c7c <HAL_I2C_Init>
 80006c8:	4603      	mov	r3, r0
 80006ca:	2b00      	cmp	r3, #0
 80006cc:	d001      	beq.n	80006d2 <MX_I2C3_Init+0x4a>
  {
    Error_Handler();
 80006ce:	f000 fab9 	bl	8000c44 <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80006d2:	2100      	movs	r1, #0
 80006d4:	4809      	ldr	r0, [pc, #36]	; (80006fc <MX_I2C3_Init+0x74>)
 80006d6:	f001 ff2b 	bl	8002530 <HAL_I2CEx_ConfigAnalogFilter>
 80006da:	4603      	mov	r3, r0
 80006dc:	2b00      	cmp	r3, #0
 80006de:	d001      	beq.n	80006e4 <MX_I2C3_Init+0x5c>
  {
    Error_Handler();
 80006e0:	f000 fab0 	bl	8000c44 <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 80006e4:	2100      	movs	r1, #0
 80006e6:	4805      	ldr	r0, [pc, #20]	; (80006fc <MX_I2C3_Init+0x74>)
 80006e8:	f001 ff6d 	bl	80025c6 <HAL_I2CEx_ConfigDigitalFilter>
 80006ec:	4603      	mov	r3, r0
 80006ee:	2b00      	cmp	r3, #0
 80006f0:	d001      	beq.n	80006f6 <MX_I2C3_Init+0x6e>
  {
    Error_Handler();
 80006f2:	f000 faa7 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}
 80006f6:	bf00      	nop
 80006f8:	bd80      	pop	{r7, pc}
 80006fa:	bf00      	nop
 80006fc:	2000009c 	.word	0x2000009c
 8000700:	40005c00 	.word	0x40005c00
 8000704:	008081b5 	.word	0x008081b5

08000708 <MX_SPI2_Init>:
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{
 8000708:	b580      	push	{r7, lr}
 800070a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
 800070c:	4b1b      	ldr	r3, [pc, #108]	; (800077c <MX_SPI2_Init+0x74>)
 800070e:	4a1c      	ldr	r2, [pc, #112]	; (8000780 <MX_SPI2_Init+0x78>)
 8000710:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8000712:	4b1a      	ldr	r3, [pc, #104]	; (800077c <MX_SPI2_Init+0x74>)
 8000714:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000718:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 800071a:	4b18      	ldr	r3, [pc, #96]	; (800077c <MX_SPI2_Init+0x74>)
 800071c:	2200      	movs	r2, #0
 800071e:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8000720:	4b16      	ldr	r3, [pc, #88]	; (800077c <MX_SPI2_Init+0x74>)
 8000722:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8000726:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000728:	4b14      	ldr	r3, [pc, #80]	; (800077c <MX_SPI2_Init+0x74>)
 800072a:	2200      	movs	r2, #0
 800072c:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 800072e:	4b13      	ldr	r3, [pc, #76]	; (800077c <MX_SPI2_Init+0x74>)
 8000730:	2200      	movs	r2, #0
 8000732:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8000734:	4b11      	ldr	r3, [pc, #68]	; (800077c <MX_SPI2_Init+0x74>)
 8000736:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800073a:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800073c:	4b0f      	ldr	r3, [pc, #60]	; (800077c <MX_SPI2_Init+0x74>)
 800073e:	2200      	movs	r2, #0
 8000740:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000742:	4b0e      	ldr	r3, [pc, #56]	; (800077c <MX_SPI2_Init+0x74>)
 8000744:	2200      	movs	r2, #0
 8000746:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8000748:	4b0c      	ldr	r3, [pc, #48]	; (800077c <MX_SPI2_Init+0x74>)
 800074a:	2200      	movs	r2, #0
 800074c:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800074e:	4b0b      	ldr	r3, [pc, #44]	; (800077c <MX_SPI2_Init+0x74>)
 8000750:	2200      	movs	r2, #0
 8000752:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 7;
 8000754:	4b09      	ldr	r3, [pc, #36]	; (800077c <MX_SPI2_Init+0x74>)
 8000756:	2207      	movs	r2, #7
 8000758:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800075a:	4b08      	ldr	r3, [pc, #32]	; (800077c <MX_SPI2_Init+0x74>)
 800075c:	2200      	movs	r2, #0
 800075e:	631a      	str	r2, [r3, #48]	; 0x30
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000760:	4b06      	ldr	r3, [pc, #24]	; (800077c <MX_SPI2_Init+0x74>)
 8000762:	2208      	movs	r2, #8
 8000764:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8000766:	4805      	ldr	r0, [pc, #20]	; (800077c <MX_SPI2_Init+0x74>)
 8000768:	f003 faa8 	bl	8003cbc <HAL_SPI_Init>
 800076c:	4603      	mov	r3, r0
 800076e:	2b00      	cmp	r3, #0
 8000770:	d001      	beq.n	8000776 <MX_SPI2_Init+0x6e>
  {
    Error_Handler();
 8000772:	f000 fa67 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
 8000776:	bf00      	nop
 8000778:	bd80      	pop	{r7, pc}
 800077a:	bf00      	nop
 800077c:	200000e8 	.word	0x200000e8
 8000780:	40003800 	.word	0x40003800

08000784 <MX_SPI3_Init>:
  * @brief SPI3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI3_Init(void)
{
 8000784:	b580      	push	{r7, lr}
 8000786:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
 8000788:	4b1b      	ldr	r3, [pc, #108]	; (80007f8 <MX_SPI3_Init+0x74>)
 800078a:	4a1c      	ldr	r2, [pc, #112]	; (80007fc <MX_SPI3_Init+0x78>)
 800078c:	601a      	str	r2, [r3, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 800078e:	4b1a      	ldr	r3, [pc, #104]	; (80007f8 <MX_SPI3_Init+0x74>)
 8000790:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000794:	605a      	str	r2, [r3, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 8000796:	4b18      	ldr	r3, [pc, #96]	; (80007f8 <MX_SPI3_Init+0x74>)
 8000798:	2200      	movs	r2, #0
 800079a:	609a      	str	r2, [r3, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
 800079c:	4b16      	ldr	r3, [pc, #88]	; (80007f8 <MX_SPI3_Init+0x74>)
 800079e:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80007a2:	60da      	str	r2, [r3, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 80007a4:	4b14      	ldr	r3, [pc, #80]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007a6:	2200      	movs	r2, #0
 80007a8:	611a      	str	r2, [r3, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 80007aa:	4b13      	ldr	r3, [pc, #76]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007ac:	2200      	movs	r2, #0
 80007ae:	615a      	str	r2, [r3, #20]
  hspi3.Init.NSS = SPI_NSS_SOFT;
 80007b0:	4b11      	ldr	r3, [pc, #68]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80007b6:	619a      	str	r2, [r3, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80007b8:	4b0f      	ldr	r3, [pc, #60]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007ba:	2218      	movs	r2, #24
 80007bc:	61da      	str	r2, [r3, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80007be:	4b0e      	ldr	r3, [pc, #56]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007c0:	2200      	movs	r2, #0
 80007c2:	621a      	str	r2, [r3, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 80007c4:	4b0c      	ldr	r3, [pc, #48]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007c6:	2200      	movs	r2, #0
 80007c8:	625a      	str	r2, [r3, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80007ca:	4b0b      	ldr	r3, [pc, #44]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007cc:	2200      	movs	r2, #0
 80007ce:	629a      	str	r2, [r3, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 7;
 80007d0:	4b09      	ldr	r3, [pc, #36]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007d2:	2207      	movs	r2, #7
 80007d4:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80007d6:	4b08      	ldr	r3, [pc, #32]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007d8:	2200      	movs	r2, #0
 80007da:	631a      	str	r2, [r3, #48]	; 0x30
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 80007dc:	4b06      	ldr	r3, [pc, #24]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007de:	2208      	movs	r2, #8
 80007e0:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 80007e2:	4805      	ldr	r0, [pc, #20]	; (80007f8 <MX_SPI3_Init+0x74>)
 80007e4:	f003 fa6a 	bl	8003cbc <HAL_SPI_Init>
 80007e8:	4603      	mov	r3, r0
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d001      	beq.n	80007f2 <MX_SPI3_Init+0x6e>
  {
    Error_Handler();
 80007ee:	f000 fa29 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 80007f2:	bf00      	nop
 80007f4:	bd80      	pop	{r7, pc}
 80007f6:	bf00      	nop
 80007f8:	2000014c 	.word	0x2000014c
 80007fc:	40003c00 	.word	0x40003c00

08000800 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 8000800:	b580      	push	{r7, lr}
 8000802:	b08e      	sub	sp, #56	; 0x38
 8000804:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000806:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800080a:	2200      	movs	r2, #0
 800080c:	601a      	str	r2, [r3, #0]
 800080e:	605a      	str	r2, [r3, #4]
 8000810:	609a      	str	r2, [r3, #8]
 8000812:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000814:	f107 031c 	add.w	r3, r7, #28
 8000818:	2200      	movs	r2, #0
 800081a:	601a      	str	r2, [r3, #0]
 800081c:	605a      	str	r2, [r3, #4]
 800081e:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8000820:	463b      	mov	r3, r7
 8000822:	2200      	movs	r2, #0
 8000824:	601a      	str	r2, [r3, #0]
 8000826:	605a      	str	r2, [r3, #4]
 8000828:	609a      	str	r2, [r3, #8]
 800082a:	60da      	str	r2, [r3, #12]
 800082c:	611a      	str	r2, [r3, #16]
 800082e:	615a      	str	r2, [r3, #20]
 8000830:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8000832:	4b2c      	ldr	r3, [pc, #176]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000834:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000838:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 32;
 800083a:	4b2a      	ldr	r3, [pc, #168]	; (80008e4 <MX_TIM2_Init+0xe4>)
 800083c:	2220      	movs	r2, #32
 800083e:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000840:	4b28      	ldr	r3, [pc, #160]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000842:	2200      	movs	r2, #0
 8000844:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 1000;
 8000846:	4b27      	ldr	r3, [pc, #156]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000848:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800084c:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800084e:	4b25      	ldr	r3, [pc, #148]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000850:	2200      	movs	r2, #0
 8000852:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000854:	4b23      	ldr	r3, [pc, #140]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000856:	2200      	movs	r2, #0
 8000858:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 800085a:	4822      	ldr	r0, [pc, #136]	; (80008e4 <MX_TIM2_Init+0xe4>)
 800085c:	f003 ffb2 	bl	80047c4 <HAL_TIM_Base_Init>
 8000860:	4603      	mov	r3, r0
 8000862:	2b00      	cmp	r3, #0
 8000864:	d001      	beq.n	800086a <MX_TIM2_Init+0x6a>
  {
    Error_Handler();
 8000866:	f000 f9ed 	bl	8000c44 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800086a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800086e:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8000870:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8000874:	4619      	mov	r1, r3
 8000876:	481b      	ldr	r0, [pc, #108]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000878:	f004 fc76 	bl	8005168 <HAL_TIM_ConfigClockSource>
 800087c:	4603      	mov	r3, r0
 800087e:	2b00      	cmp	r3, #0
 8000880:	d001      	beq.n	8000886 <MX_TIM2_Init+0x86>
  {
    Error_Handler();
 8000882:	f000 f9df 	bl	8000c44 <Error_Handler>
  }
  if (HAL_TIM_OC_Init(&htim2) != HAL_OK)
 8000886:	4817      	ldr	r0, [pc, #92]	; (80008e4 <MX_TIM2_Init+0xe4>)
 8000888:	f004 f84f 	bl	800492a <HAL_TIM_OC_Init>
 800088c:	4603      	mov	r3, r0
 800088e:	2b00      	cmp	r3, #0
 8000890:	d001      	beq.n	8000896 <MX_TIM2_Init+0x96>
  {
    Error_Handler();
 8000892:	f000 f9d7 	bl	8000c44 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC1REF;
 8000896:	2340      	movs	r3, #64	; 0x40
 8000898:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800089a:	2300      	movs	r3, #0
 800089c:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800089e:	f107 031c 	add.w	r3, r7, #28
 80008a2:	4619      	mov	r1, r3
 80008a4:	480f      	ldr	r0, [pc, #60]	; (80008e4 <MX_TIM2_Init+0xe4>)
 80008a6:	f005 f97d 	bl	8005ba4 <HAL_TIMEx_MasterConfigSynchronization>
 80008aa:	4603      	mov	r3, r0
 80008ac:	2b00      	cmp	r3, #0
 80008ae:	d001      	beq.n	80008b4 <MX_TIM2_Init+0xb4>
  {
    Error_Handler();
 80008b0:	f000 f9c8 	bl	8000c44 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 80008b4:	2300      	movs	r3, #0
 80008b6:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 80008b8:	2300      	movs	r3, #0
 80008ba:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80008bc:	2300      	movs	r3, #0
 80008be:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80008c0:	2300      	movs	r3, #0
 80008c2:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80008c4:	463b      	mov	r3, r7
 80008c6:	2200      	movs	r2, #0
 80008c8:	4619      	mov	r1, r3
 80008ca:	4806      	ldr	r0, [pc, #24]	; (80008e4 <MX_TIM2_Init+0xe4>)
 80008cc:	f004 fbd6 	bl	800507c <HAL_TIM_OC_ConfigChannel>
 80008d0:	4603      	mov	r3, r0
 80008d2:	2b00      	cmp	r3, #0
 80008d4:	d001      	beq.n	80008da <MX_TIM2_Init+0xda>
  {
    Error_Handler();
 80008d6:	f000 f9b5 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 80008da:	bf00      	nop
 80008dc:	3738      	adds	r7, #56	; 0x38
 80008de:	46bd      	mov	sp, r7
 80008e0:	bd80      	pop	{r7, pc}
 80008e2:	bf00      	nop
 80008e4:	200001b0 	.word	0x200001b0

080008e8 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 80008e8:	b580      	push	{r7, lr}
 80008ea:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 80008ec:	4b14      	ldr	r3, [pc, #80]	; (8000940 <MX_USART2_UART_Init+0x58>)
 80008ee:	4a15      	ldr	r2, [pc, #84]	; (8000944 <MX_USART2_UART_Init+0x5c>)
 80008f0:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 80008f2:	4b13      	ldr	r3, [pc, #76]	; (8000940 <MX_USART2_UART_Init+0x58>)
 80008f4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80008f8:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80008fa:	4b11      	ldr	r3, [pc, #68]	; (8000940 <MX_USART2_UART_Init+0x58>)
 80008fc:	2200      	movs	r2, #0
 80008fe:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000900:	4b0f      	ldr	r3, [pc, #60]	; (8000940 <MX_USART2_UART_Init+0x58>)
 8000902:	2200      	movs	r2, #0
 8000904:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000906:	4b0e      	ldr	r3, [pc, #56]	; (8000940 <MX_USART2_UART_Init+0x58>)
 8000908:	2200      	movs	r2, #0
 800090a:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800090c:	4b0c      	ldr	r3, [pc, #48]	; (8000940 <MX_USART2_UART_Init+0x58>)
 800090e:	220c      	movs	r2, #12
 8000910:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000912:	4b0b      	ldr	r3, [pc, #44]	; (8000940 <MX_USART2_UART_Init+0x58>)
 8000914:	2200      	movs	r2, #0
 8000916:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000918:	4b09      	ldr	r3, [pc, #36]	; (8000940 <MX_USART2_UART_Init+0x58>)
 800091a:	2200      	movs	r2, #0
 800091c:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800091e:	4b08      	ldr	r3, [pc, #32]	; (8000940 <MX_USART2_UART_Init+0x58>)
 8000920:	2200      	movs	r2, #0
 8000922:	621a      	str	r2, [r3, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000924:	4b06      	ldr	r3, [pc, #24]	; (8000940 <MX_USART2_UART_Init+0x58>)
 8000926:	2200      	movs	r2, #0
 8000928:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800092a:	4805      	ldr	r0, [pc, #20]	; (8000940 <MX_USART2_UART_Init+0x58>)
 800092c:	f005 f9e0 	bl	8005cf0 <HAL_UART_Init>
 8000930:	4603      	mov	r3, r0
 8000932:	2b00      	cmp	r3, #0
 8000934:	d001      	beq.n	800093a <MX_USART2_UART_Init+0x52>
  {
    Error_Handler();
 8000936:	f000 f985 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800093a:	bf00      	nop
 800093c:	bd80      	pop	{r7, pc}
 800093e:	bf00      	nop
 8000940:	200001fc 	.word	0x200001fc
 8000944:	40004400 	.word	0x40004400

08000948 <MX_USART3_UART_Init>:
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
 8000948:	b580      	push	{r7, lr}
 800094a:	af00      	add	r7, sp, #0
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 800094c:	4b14      	ldr	r3, [pc, #80]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 800094e:	4a15      	ldr	r2, [pc, #84]	; (80009a4 <MX_USART3_UART_Init+0x5c>)
 8000950:	601a      	str	r2, [r3, #0]
  huart3.Init.BaudRate = 115200;
 8000952:	4b13      	ldr	r3, [pc, #76]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000954:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8000958:	605a      	str	r2, [r3, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800095a:	4b11      	ldr	r3, [pc, #68]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 800095c:	2200      	movs	r2, #0
 800095e:	609a      	str	r2, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8000960:	4b0f      	ldr	r3, [pc, #60]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000962:	2200      	movs	r2, #0
 8000964:	60da      	str	r2, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8000966:	4b0e      	ldr	r3, [pc, #56]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000968:	2200      	movs	r2, #0
 800096a:	611a      	str	r2, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 800096c:	4b0c      	ldr	r3, [pc, #48]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 800096e:	220c      	movs	r2, #12
 8000970:	615a      	str	r2, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8000972:	4b0b      	ldr	r3, [pc, #44]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000974:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000978:	619a      	str	r2, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 800097a:	4b09      	ldr	r3, [pc, #36]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 800097c:	2200      	movs	r2, #0
 800097e:	61da      	str	r2, [r3, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000980:	4b07      	ldr	r3, [pc, #28]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000982:	2200      	movs	r2, #0
 8000984:	621a      	str	r2, [r3, #32]
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000986:	4b06      	ldr	r3, [pc, #24]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 8000988:	2200      	movs	r2, #0
 800098a:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart3) != HAL_OK)
 800098c:	4804      	ldr	r0, [pc, #16]	; (80009a0 <MX_USART3_UART_Init+0x58>)
 800098e:	f005 f9af 	bl	8005cf0 <HAL_UART_Init>
 8000992:	4603      	mov	r3, r0
 8000994:	2b00      	cmp	r3, #0
 8000996:	d001      	beq.n	800099c <MX_USART3_UART_Init+0x54>
  {
    Error_Handler();
 8000998:	f000 f954 	bl	8000c44 <Error_Handler>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 800099c:	bf00      	nop
 800099e:	bd80      	pop	{r7, pc}
 80009a0:	20000280 	.word	0x20000280
 80009a4:	40004800 	.word	0x40004800

080009a8 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80009a8:	b580      	push	{r7, lr}
 80009aa:	b08a      	sub	sp, #40	; 0x28
 80009ac:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80009ae:	f107 0314 	add.w	r3, r7, #20
 80009b2:	2200      	movs	r2, #0
 80009b4:	601a      	str	r2, [r3, #0]
 80009b6:	605a      	str	r2, [r3, #4]
 80009b8:	609a      	str	r2, [r3, #8]
 80009ba:	60da      	str	r2, [r3, #12]
 80009bc:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80009be:	4b9a      	ldr	r3, [pc, #616]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009c0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009c2:	4a99      	ldr	r2, [pc, #612]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009c4:	f043 0304 	orr.w	r3, r3, #4
 80009c8:	64d3      	str	r3, [r2, #76]	; 0x4c
 80009ca:	4b97      	ldr	r3, [pc, #604]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009ce:	f003 0304 	and.w	r3, r3, #4
 80009d2:	613b      	str	r3, [r7, #16]
 80009d4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80009d6:	4b94      	ldr	r3, [pc, #592]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009da:	4a93      	ldr	r2, [pc, #588]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80009e0:	64d3      	str	r3, [r2, #76]	; 0x4c
 80009e2:	4b91      	ldr	r3, [pc, #580]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009e6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80009ea:	60fb      	str	r3, [r7, #12]
 80009ec:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80009ee:	4b8e      	ldr	r3, [pc, #568]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009f2:	4a8d      	ldr	r2, [pc, #564]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009f4:	f043 0301 	orr.w	r3, r3, #1
 80009f8:	64d3      	str	r3, [r2, #76]	; 0x4c
 80009fa:	4b8b      	ldr	r3, [pc, #556]	; (8000c28 <MX_GPIO_Init+0x280>)
 80009fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80009fe:	f003 0301 	and.w	r3, r3, #1
 8000a02:	60bb      	str	r3, [r7, #8]
 8000a04:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000a06:	4b88      	ldr	r3, [pc, #544]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a0a:	4a87      	ldr	r2, [pc, #540]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a0c:	f043 0302 	orr.w	r3, r3, #2
 8000a10:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000a12:	4b85      	ldr	r3, [pc, #532]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a14:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a16:	f003 0302 	and.w	r3, r3, #2
 8000a1a:	607b      	str	r3, [r7, #4]
 8000a1c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000a1e:	4b82      	ldr	r3, [pc, #520]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a20:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a22:	4a81      	ldr	r2, [pc, #516]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a24:	f043 0308 	orr.w	r3, r3, #8
 8000a28:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000a2a:	4b7f      	ldr	r3, [pc, #508]	; (8000c28 <MX_GPIO_Init+0x280>)
 8000a2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a2e:	f003 0308 	and.w	r3, r3, #8
 8000a32:	603b      	str	r3, [r7, #0]
 8000a34:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, ACCEL_CS_Pin|DISP_RESET_Pin, GPIO_PIN_SET);
 8000a36:	2201      	movs	r2, #1
 8000a38:	2184      	movs	r1, #132	; 0x84
 8000a3a:	487c      	ldr	r0, [pc, #496]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000a3c:	f001 f8ee 	bl	8001c1c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, LD2_Pin|DISP_DATA_Pin|NRF_CS_Pin, GPIO_PIN_RESET);
 8000a40:	2200      	movs	r2, #0
 8000a42:	f248 2120 	movw	r1, #33312	; 0x8220
 8000a46:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000a4a:	f001 f8e7 	bl	8001c1c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(NRF_CE_GPIO_Port, NRF_CE_Pin, GPIO_PIN_RESET);
 8000a4e:	2200      	movs	r2, #0
 8000a50:	2104      	movs	r1, #4
 8000a52:	4877      	ldr	r0, [pc, #476]	; (8000c30 <MX_GPIO_Init+0x288>)
 8000a54:	f001 f8e2 	bl	8001c1c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 8000a58:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000a5c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000a5e:	4b75      	ldr	r3, [pc, #468]	; (8000c34 <MX_GPIO_Init+0x28c>)
 8000a60:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a62:	2300      	movs	r3, #0
 8000a64:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8000a66:	f107 0314 	add.w	r3, r7, #20
 8000a6a:	4619      	mov	r1, r3
 8000a6c:	486f      	ldr	r0, [pc, #444]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000a6e:	f000 ff13 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : ACCEL_CS_Pin */
  GPIO_InitStruct.Pin = ACCEL_CS_Pin;
 8000a72:	2304      	movs	r3, #4
 8000a74:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 8000a76:	2311      	movs	r3, #17
 8000a78:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a7a:	2300      	movs	r3, #0
 8000a7c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000a7e:	2300      	movs	r3, #0
 8000a80:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(ACCEL_CS_GPIO_Port, &GPIO_InitStruct);
 8000a82:	f107 0314 	add.w	r3, r7, #20
 8000a86:	4619      	mov	r1, r3
 8000a88:	4868      	ldr	r0, [pc, #416]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000a8a:	f000 ff05 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : ACCEL_IRQ1_Pin */
  GPIO_InitStruct.Pin = ACCEL_IRQ1_Pin;
 8000a8e:	2308      	movs	r3, #8
 8000a90:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000a92:	4b69      	ldr	r3, [pc, #420]	; (8000c38 <MX_GPIO_Init+0x290>)
 8000a94:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a96:	2300      	movs	r3, #0
 8000a98:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(ACCEL_IRQ1_GPIO_Port, &GPIO_InitStruct);
 8000a9a:	f107 0314 	add.w	r3, r7, #20
 8000a9e:	4619      	mov	r1, r3
 8000aa0:	4862      	ldr	r0, [pc, #392]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000aa2:	f000 fef9 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pins : ACCEL_ADC1_Pin ACCEL_ADC2_Pin ACCEL_ADC3_Pin */
  GPIO_InitStruct.Pin = ACCEL_ADC1_Pin|ACCEL_ADC2_Pin|ACCEL_ADC3_Pin;
 8000aa6:	2313      	movs	r3, #19
 8000aa8:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 8000aaa:	230b      	movs	r3, #11
 8000aac:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000aae:	2300      	movs	r3, #0
 8000ab0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000ab2:	f107 0314 	add.w	r3, r7, #20
 8000ab6:	4619      	mov	r1, r3
 8000ab8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000abc:	f000 feec 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD2_Pin NRF_CS_Pin */
  GPIO_InitStruct.Pin = LD2_Pin|NRF_CS_Pin;
 8000ac0:	f248 0320 	movw	r3, #32800	; 0x8020
 8000ac4:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000ac6:	2301      	movs	r3, #1
 8000ac8:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000aca:	2300      	movs	r3, #0
 8000acc:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000ace:	2300      	movs	r3, #0
 8000ad0:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000ad2:	f107 0314 	add.w	r3, r7, #20
 8000ad6:	4619      	mov	r1, r3
 8000ad8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000adc:	f000 fedc 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : ACCEL_IRQ2_Pin */
  GPIO_InitStruct.Pin = ACCEL_IRQ2_Pin;
 8000ae0:	2301      	movs	r3, #1
 8000ae2:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000ae4:	4b54      	ldr	r3, [pc, #336]	; (8000c38 <MX_GPIO_Init+0x290>)
 8000ae6:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ae8:	2300      	movs	r3, #0
 8000aea:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(ACCEL_IRQ2_GPIO_Port, &GPIO_InitStruct);
 8000aec:	f107 0314 	add.w	r3, r7, #20
 8000af0:	4619      	mov	r1, r3
 8000af2:	4852      	ldr	r0, [pc, #328]	; (8000c3c <MX_GPIO_Init+0x294>)
 8000af4:	f000 fed0 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : DISP_RESET_Pin */
  GPIO_InitStruct.Pin = DISP_RESET_Pin;
 8000af8:	2380      	movs	r3, #128	; 0x80
 8000afa:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000afc:	2301      	movs	r3, #1
 8000afe:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000b00:	2301      	movs	r3, #1
 8000b02:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000b04:	2300      	movs	r3, #0
 8000b06:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(DISP_RESET_GPIO_Port, &GPIO_InitStruct);
 8000b08:	f107 0314 	add.w	r3, r7, #20
 8000b0c:	4619      	mov	r1, r3
 8000b0e:	4847      	ldr	r0, [pc, #284]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000b10:	f000 fec2 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pins : NAVS_RIGHT_Pin NAVS_UP_Pin */
  GPIO_InitStruct.Pin = NAVS_RIGHT_Pin|NAVS_UP_Pin;
 8000b14:	f44f 7340 	mov.w	r3, #768	; 0x300
 8000b18:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 8000b1a:	4b49      	ldr	r3, [pc, #292]	; (8000c40 <MX_GPIO_Init+0x298>)
 8000b1c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b1e:	2300      	movs	r3, #0
 8000b20:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000b22:	f107 0314 	add.w	r3, r7, #20
 8000b26:	4619      	mov	r1, r3
 8000b28:	4840      	ldr	r0, [pc, #256]	; (8000c2c <MX_GPIO_Init+0x284>)
 8000b2a:	f000 feb5 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : DISP_DATA_Pin */
  GPIO_InitStruct.Pin = DISP_DATA_Pin;
 8000b2e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000b32:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000b34:	2301      	movs	r3, #1
 8000b36:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000b38:	2301      	movs	r3, #1
 8000b3a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000b3c:	2300      	movs	r3, #0
 8000b3e:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(DISP_DATA_GPIO_Port, &GPIO_InitStruct);
 8000b40:	f107 0314 	add.w	r3, r7, #20
 8000b44:	4619      	mov	r1, r3
 8000b46:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000b4a:	f000 fea5 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : NAVS_DOWN_Pin */
  GPIO_InitStruct.Pin = NAVS_DOWN_Pin;
 8000b4e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000b52:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 8000b54:	4b3a      	ldr	r3, [pc, #232]	; (8000c40 <MX_GPIO_Init+0x298>)
 8000b56:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b58:	2300      	movs	r3, #0
 8000b5a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(NAVS_DOWN_GPIO_Port, &GPIO_InitStruct);
 8000b5c:	f107 0314 	add.w	r3, r7, #20
 8000b60:	4619      	mov	r1, r3
 8000b62:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000b66:	f000 fe97 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : NRF_CE_Pin */
  GPIO_InitStruct.Pin = NRF_CE_Pin;
 8000b6a:	2304      	movs	r3, #4
 8000b6c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000b6e:	2301      	movs	r3, #1
 8000b70:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b72:	2300      	movs	r3, #0
 8000b74:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000b76:	2300      	movs	r3, #0
 8000b78:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(NRF_CE_GPIO_Port, &GPIO_InitStruct);
 8000b7a:	f107 0314 	add.w	r3, r7, #20
 8000b7e:	4619      	mov	r1, r3
 8000b80:	482b      	ldr	r0, [pc, #172]	; (8000c30 <MX_GPIO_Init+0x288>)
 8000b82:	f000 fe89 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pins : NAVS_LEFT_Pin NAVS_CENTER_Pin */
  GPIO_InitStruct.Pin = NAVS_LEFT_Pin|NAVS_CENTER_Pin;
 8000b86:	2330      	movs	r3, #48	; 0x30
 8000b88:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 8000b8a:	4b2d      	ldr	r3, [pc, #180]	; (8000c40 <MX_GPIO_Init+0x298>)
 8000b8c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b8e:	2300      	movs	r3, #0
 8000b90:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000b92:	f107 0314 	add.w	r3, r7, #20
 8000b96:	4619      	mov	r1, r3
 8000b98:	4828      	ldr	r0, [pc, #160]	; (8000c3c <MX_GPIO_Init+0x294>)
 8000b9a:	f000 fe7d 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : DISP_BUSY_Pin */
  GPIO_InitStruct.Pin = DISP_BUSY_Pin;
 8000b9e:	2340      	movs	r3, #64	; 0x40
 8000ba0:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000ba2:	2300      	movs	r3, #0
 8000ba4:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ba6:	2300      	movs	r3, #0
 8000ba8:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(DISP_BUSY_GPIO_Port, &GPIO_InitStruct);
 8000baa:	f107 0314 	add.w	r3, r7, #20
 8000bae:	4619      	mov	r1, r3
 8000bb0:	4822      	ldr	r0, [pc, #136]	; (8000c3c <MX_GPIO_Init+0x294>)
 8000bb2:	f000 fe71 	bl	8001898 <HAL_GPIO_Init>

  /*Configure GPIO pin : NRF_IRQ_Pin */
  GPIO_InitStruct.Pin = NRF_IRQ_Pin;
 8000bb6:	2380      	movs	r3, #128	; 0x80
 8000bb8:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000bba:	4b1e      	ldr	r3, [pc, #120]	; (8000c34 <MX_GPIO_Init+0x28c>)
 8000bbc:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000bbe:	2300      	movs	r3, #0
 8000bc0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(NRF_IRQ_GPIO_Port, &GPIO_InitStruct);
 8000bc2:	f107 0314 	add.w	r3, r7, #20
 8000bc6:	4619      	mov	r1, r3
 8000bc8:	481c      	ldr	r0, [pc, #112]	; (8000c3c <MX_GPIO_Init+0x294>)
 8000bca:	f000 fe65 	bl	8001898 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 10, 0);
 8000bce:	2200      	movs	r2, #0
 8000bd0:	210a      	movs	r1, #10
 8000bd2:	2006      	movs	r0, #6
 8000bd4:	f000 fd8b 	bl	80016ee <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 8000bd8:	2006      	movs	r0, #6
 8000bda:	f000 fda4 	bl	8001726 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI3_IRQn, 10, 0);
 8000bde:	2200      	movs	r2, #0
 8000be0:	210a      	movs	r1, #10
 8000be2:	2009      	movs	r0, #9
 8000be4:	f000 fd83 	bl	80016ee <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 8000be8:	2009      	movs	r0, #9
 8000bea:	f000 fd9c 	bl	8001726 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI4_IRQn, 10, 0);
 8000bee:	2200      	movs	r2, #0
 8000bf0:	210a      	movs	r1, #10
 8000bf2:	200a      	movs	r0, #10
 8000bf4:	f000 fd7b 	bl	80016ee <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 8000bf8:	200a      	movs	r0, #10
 8000bfa:	f000 fd94 	bl	8001726 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 10, 0);
 8000bfe:	2200      	movs	r2, #0
 8000c00:	210a      	movs	r1, #10
 8000c02:	2017      	movs	r0, #23
 8000c04:	f000 fd73 	bl	80016ee <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8000c08:	2017      	movs	r0, #23
 8000c0a:	f000 fd8c 	bl	8001726 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 10, 0);
 8000c0e:	2200      	movs	r2, #0
 8000c10:	210a      	movs	r1, #10
 8000c12:	2028      	movs	r0, #40	; 0x28
 8000c14:	f000 fd6b 	bl	80016ee <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8000c18:	2028      	movs	r0, #40	; 0x28
 8000c1a:	f000 fd84 	bl	8001726 <HAL_NVIC_EnableIRQ>

}
 8000c1e:	bf00      	nop
 8000c20:	3728      	adds	r7, #40	; 0x28
 8000c22:	46bd      	mov	sp, r7
 8000c24:	bd80      	pop	{r7, pc}
 8000c26:	bf00      	nop
 8000c28:	40021000 	.word	0x40021000
 8000c2c:	48000800 	.word	0x48000800
 8000c30:	48000c00 	.word	0x48000c00
 8000c34:	10210000 	.word	0x10210000
 8000c38:	10110000 	.word	0x10110000
 8000c3c:	48000400 	.word	0x48000400
 8000c40:	10310000 	.word	0x10310000

08000c44 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000c44:	b480      	push	{r7}
 8000c46:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c48:	b672      	cpsid	i
}
 8000c4a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000c4c:	e7fe      	b.n	8000c4c <Error_Handler+0x8>
	...

08000c50 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000c50:	b480      	push	{r7}
 8000c52:	b083      	sub	sp, #12
 8000c54:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c56:	4b0f      	ldr	r3, [pc, #60]	; (8000c94 <HAL_MspInit+0x44>)
 8000c58:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000c5a:	4a0e      	ldr	r2, [pc, #56]	; (8000c94 <HAL_MspInit+0x44>)
 8000c5c:	f043 0301 	orr.w	r3, r3, #1
 8000c60:	6613      	str	r3, [r2, #96]	; 0x60
 8000c62:	4b0c      	ldr	r3, [pc, #48]	; (8000c94 <HAL_MspInit+0x44>)
 8000c64:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000c66:	f003 0301 	and.w	r3, r3, #1
 8000c6a:	607b      	str	r3, [r7, #4]
 8000c6c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000c6e:	4b09      	ldr	r3, [pc, #36]	; (8000c94 <HAL_MspInit+0x44>)
 8000c70:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000c72:	4a08      	ldr	r2, [pc, #32]	; (8000c94 <HAL_MspInit+0x44>)
 8000c74:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000c78:	6593      	str	r3, [r2, #88]	; 0x58
 8000c7a:	4b06      	ldr	r3, [pc, #24]	; (8000c94 <HAL_MspInit+0x44>)
 8000c7c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000c7e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000c82:	603b      	str	r3, [r7, #0]
 8000c84:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000c86:	bf00      	nop
 8000c88:	370c      	adds	r7, #12
 8000c8a:	46bd      	mov	sp, r7
 8000c8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c90:	4770      	bx	lr
 8000c92:	bf00      	nop
 8000c94:	40021000 	.word	0x40021000

08000c98 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8000c98:	b580      	push	{r7, lr}
 8000c9a:	b0ac      	sub	sp, #176	; 0xb0
 8000c9c:	af00      	add	r7, sp, #0
 8000c9e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000ca0:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8000ca4:	2200      	movs	r2, #0
 8000ca6:	601a      	str	r2, [r3, #0]
 8000ca8:	605a      	str	r2, [r3, #4]
 8000caa:	609a      	str	r2, [r3, #8]
 8000cac:	60da      	str	r2, [r3, #12]
 8000cae:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000cb0:	f107 0314 	add.w	r3, r7, #20
 8000cb4:	2288      	movs	r2, #136	; 0x88
 8000cb6:	2100      	movs	r1, #0
 8000cb8:	4618      	mov	r0, r3
 8000cba:	f015 fc03 	bl	80164c4 <memset>
  if(hi2c->Instance==I2C3)
 8000cbe:	687b      	ldr	r3, [r7, #4]
 8000cc0:	681b      	ldr	r3, [r3, #0]
 8000cc2:	4a21      	ldr	r2, [pc, #132]	; (8000d48 <HAL_I2C_MspInit+0xb0>)
 8000cc4:	4293      	cmp	r3, r2
 8000cc6:	d13b      	bne.n	8000d40 <HAL_I2C_MspInit+0xa8>
  /* USER CODE BEGIN I2C3_MspInit 0 */

  /* USER CODE END I2C3_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 8000cc8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ccc:	617b      	str	r3, [r7, #20]
    PeriphClkInit.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
 8000cce:	2300      	movs	r3, #0
 8000cd0:	66fb      	str	r3, [r7, #108]	; 0x6c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000cd2:	f107 0314 	add.w	r3, r7, #20
 8000cd6:	4618      	mov	r0, r3
 8000cd8:	f002 fb24 	bl	8003324 <HAL_RCCEx_PeriphCLKConfig>
 8000cdc:	4603      	mov	r3, r0
 8000cde:	2b00      	cmp	r3, #0
 8000ce0:	d001      	beq.n	8000ce6 <HAL_I2C_MspInit+0x4e>
    {
      Error_Handler();
 8000ce2:	f7ff ffaf 	bl	8000c44 <Error_Handler>
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000ce6:	4b19      	ldr	r3, [pc, #100]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000ce8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000cea:	4a18      	ldr	r2, [pc, #96]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000cec:	f043 0304 	orr.w	r3, r3, #4
 8000cf0:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000cf2:	4b16      	ldr	r3, [pc, #88]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000cf4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000cf6:	f003 0304 	and.w	r3, r3, #4
 8000cfa:	613b      	str	r3, [r7, #16]
 8000cfc:	693b      	ldr	r3, [r7, #16]
    /**I2C3 GPIO Configuration
    PC0     ------> I2C3_SCL
    PC1     ------> I2C3_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8000cfe:	2303      	movs	r3, #3
 8000d00:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8000d04:	2312      	movs	r3, #18
 8000d06:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000d0a:	2300      	movs	r3, #0
 8000d0c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8000d10:	2301      	movs	r3, #1
 8000d12:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8000d16:	2304      	movs	r3, #4
 8000d18:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000d1c:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8000d20:	4619      	mov	r1, r3
 8000d22:	480b      	ldr	r0, [pc, #44]	; (8000d50 <HAL_I2C_MspInit+0xb8>)
 8000d24:	f000 fdb8 	bl	8001898 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C3_CLK_ENABLE();
 8000d28:	4b08      	ldr	r3, [pc, #32]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000d2a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000d2c:	4a07      	ldr	r2, [pc, #28]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000d2e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000d32:	6593      	str	r3, [r2, #88]	; 0x58
 8000d34:	4b05      	ldr	r3, [pc, #20]	; (8000d4c <HAL_I2C_MspInit+0xb4>)
 8000d36:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000d38:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8000d3c:	60fb      	str	r3, [r7, #12]
 8000d3e:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }

}
 8000d40:	bf00      	nop
 8000d42:	37b0      	adds	r7, #176	; 0xb0
 8000d44:	46bd      	mov	sp, r7
 8000d46:	bd80      	pop	{r7, pc}
 8000d48:	40005c00 	.word	0x40005c00
 8000d4c:	40021000 	.word	0x40021000
 8000d50:	48000800 	.word	0x48000800

08000d54 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000d54:	b580      	push	{r7, lr}
 8000d56:	b08c      	sub	sp, #48	; 0x30
 8000d58:	af00      	add	r7, sp, #0
 8000d5a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000d5c:	f107 031c 	add.w	r3, r7, #28
 8000d60:	2200      	movs	r2, #0
 8000d62:	601a      	str	r2, [r3, #0]
 8000d64:	605a      	str	r2, [r3, #4]
 8000d66:	609a      	str	r2, [r3, #8]
 8000d68:	60da      	str	r2, [r3, #12]
 8000d6a:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI2)
 8000d6c:	687b      	ldr	r3, [r7, #4]
 8000d6e:	681b      	ldr	r3, [r3, #0]
 8000d70:	4a2f      	ldr	r2, [pc, #188]	; (8000e30 <HAL_SPI_MspInit+0xdc>)
 8000d72:	4293      	cmp	r3, r2
 8000d74:	d129      	bne.n	8000dca <HAL_SPI_MspInit+0x76>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 8000d76:	4b2f      	ldr	r3, [pc, #188]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d78:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000d7a:	4a2e      	ldr	r2, [pc, #184]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d7c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000d80:	6593      	str	r3, [r2, #88]	; 0x58
 8000d82:	4b2c      	ldr	r3, [pc, #176]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d84:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000d86:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000d8a:	61bb      	str	r3, [r7, #24]
 8000d8c:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000d8e:	4b29      	ldr	r3, [pc, #164]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000d92:	4a28      	ldr	r2, [pc, #160]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d94:	f043 0302 	orr.w	r3, r3, #2
 8000d98:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000d9a:	4b26      	ldr	r3, [pc, #152]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000d9c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000d9e:	f003 0302 	and.w	r3, r3, #2
 8000da2:	617b      	str	r3, [r7, #20]
 8000da4:	697b      	ldr	r3, [r7, #20]
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|DISP_SPI2_SCK_Pin|DISP_SPI2_MISO_Pin|DISP_SPI2_MOSI_Pin;
 8000da6:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000daa:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000dac:	2302      	movs	r3, #2
 8000dae:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000db0:	2300      	movs	r3, #0
 8000db2:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000db4:	2303      	movs	r3, #3
 8000db6:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8000db8:	2305      	movs	r3, #5
 8000dba:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000dbc:	f107 031c 	add.w	r3, r7, #28
 8000dc0:	4619      	mov	r1, r3
 8000dc2:	481d      	ldr	r0, [pc, #116]	; (8000e38 <HAL_SPI_MspInit+0xe4>)
 8000dc4:	f000 fd68 	bl	8001898 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }

}
 8000dc8:	e02d      	b.n	8000e26 <HAL_SPI_MspInit+0xd2>
  else if(hspi->Instance==SPI3)
 8000dca:	687b      	ldr	r3, [r7, #4]
 8000dcc:	681b      	ldr	r3, [r3, #0]
 8000dce:	4a1b      	ldr	r2, [pc, #108]	; (8000e3c <HAL_SPI_MspInit+0xe8>)
 8000dd0:	4293      	cmp	r3, r2
 8000dd2:	d128      	bne.n	8000e26 <HAL_SPI_MspInit+0xd2>
    __HAL_RCC_SPI3_CLK_ENABLE();
 8000dd4:	4b17      	ldr	r3, [pc, #92]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000dd6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000dd8:	4a16      	ldr	r2, [pc, #88]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000dda:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000dde:	6593      	str	r3, [r2, #88]	; 0x58
 8000de0:	4b14      	ldr	r3, [pc, #80]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000de2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000de4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8000de8:	613b      	str	r3, [r7, #16]
 8000dea:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000dec:	4b11      	ldr	r3, [pc, #68]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000dee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000df0:	4a10      	ldr	r2, [pc, #64]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000df2:	f043 0304 	orr.w	r3, r3, #4
 8000df6:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000df8:	4b0e      	ldr	r3, [pc, #56]	; (8000e34 <HAL_SPI_MspInit+0xe0>)
 8000dfa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000dfc:	f003 0304 	and.w	r3, r3, #4
 8000e00:	60fb      	str	r3, [r7, #12]
 8000e02:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = NRF_CLK_Pin|NRF_MISO_Pin|NRF_MOSI_Pin;
 8000e04:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8000e08:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000e0a:	2302      	movs	r3, #2
 8000e0c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000e0e:	2300      	movs	r3, #0
 8000e10:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8000e12:	2301      	movs	r3, #1
 8000e14:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000e16:	2306      	movs	r3, #6
 8000e18:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000e1a:	f107 031c 	add.w	r3, r7, #28
 8000e1e:	4619      	mov	r1, r3
 8000e20:	4807      	ldr	r0, [pc, #28]	; (8000e40 <HAL_SPI_MspInit+0xec>)
 8000e22:	f000 fd39 	bl	8001898 <HAL_GPIO_Init>
}
 8000e26:	bf00      	nop
 8000e28:	3730      	adds	r7, #48	; 0x30
 8000e2a:	46bd      	mov	sp, r7
 8000e2c:	bd80      	pop	{r7, pc}
 8000e2e:	bf00      	nop
 8000e30:	40003800 	.word	0x40003800
 8000e34:	40021000 	.word	0x40021000
 8000e38:	48000400 	.word	0x48000400
 8000e3c:	40003c00 	.word	0x40003c00
 8000e40:	48000800 	.word	0x48000800

08000e44 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8000e44:	b580      	push	{r7, lr}
 8000e46:	b084      	sub	sp, #16
 8000e48:	af00      	add	r7, sp, #0
 8000e4a:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM2)
 8000e4c:	687b      	ldr	r3, [r7, #4]
 8000e4e:	681b      	ldr	r3, [r3, #0]
 8000e50:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8000e54:	d113      	bne.n	8000e7e <HAL_TIM_Base_MspInit+0x3a>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8000e56:	4b0c      	ldr	r3, [pc, #48]	; (8000e88 <HAL_TIM_Base_MspInit+0x44>)
 8000e58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000e5a:	4a0b      	ldr	r2, [pc, #44]	; (8000e88 <HAL_TIM_Base_MspInit+0x44>)
 8000e5c:	f043 0301 	orr.w	r3, r3, #1
 8000e60:	6593      	str	r3, [r2, #88]	; 0x58
 8000e62:	4b09      	ldr	r3, [pc, #36]	; (8000e88 <HAL_TIM_Base_MspInit+0x44>)
 8000e64:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000e66:	f003 0301 	and.w	r3, r3, #1
 8000e6a:	60fb      	str	r3, [r7, #12]
 8000e6c:	68fb      	ldr	r3, [r7, #12]
    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);
 8000e6e:	2200      	movs	r2, #0
 8000e70:	2103      	movs	r1, #3
 8000e72:	201c      	movs	r0, #28
 8000e74:	f000 fc3b 	bl	80016ee <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8000e78:	201c      	movs	r0, #28
 8000e7a:	f000 fc54 	bl	8001726 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8000e7e:	bf00      	nop
 8000e80:	3710      	adds	r7, #16
 8000e82:	46bd      	mov	sp, r7
 8000e84:	bd80      	pop	{r7, pc}
 8000e86:	bf00      	nop
 8000e88:	40021000 	.word	0x40021000

08000e8c <HAL_TIM_Base_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* htim_base)
{
 8000e8c:	b580      	push	{r7, lr}
 8000e8e:	b082      	sub	sp, #8
 8000e90:	af00      	add	r7, sp, #0
 8000e92:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM2)
 8000e94:	687b      	ldr	r3, [r7, #4]
 8000e96:	681b      	ldr	r3, [r3, #0]
 8000e98:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8000e9c:	d108      	bne.n	8000eb0 <HAL_TIM_Base_MspDeInit+0x24>
  {
  /* USER CODE BEGIN TIM2_MspDeInit 0 */

  /* USER CODE END TIM2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM2_CLK_DISABLE();
 8000e9e:	4b06      	ldr	r3, [pc, #24]	; (8000eb8 <HAL_TIM_Base_MspDeInit+0x2c>)
 8000ea0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000ea2:	4a05      	ldr	r2, [pc, #20]	; (8000eb8 <HAL_TIM_Base_MspDeInit+0x2c>)
 8000ea4:	f023 0301 	bic.w	r3, r3, #1
 8000ea8:	6593      	str	r3, [r2, #88]	; 0x58

    /* TIM2 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM2_IRQn);
 8000eaa:	201c      	movs	r0, #28
 8000eac:	f000 fc49 	bl	8001742 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN TIM2_MspDeInit 1 */

  /* USER CODE END TIM2_MspDeInit 1 */
  }

}
 8000eb0:	bf00      	nop
 8000eb2:	3708      	adds	r7, #8
 8000eb4:	46bd      	mov	sp, r7
 8000eb6:	bd80      	pop	{r7, pc}
 8000eb8:	40021000 	.word	0x40021000

08000ebc <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8000ebc:	b580      	push	{r7, lr}
 8000ebe:	b0b0      	sub	sp, #192	; 0xc0
 8000ec0:	af00      	add	r7, sp, #0
 8000ec2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000ec4:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8000ec8:	2200      	movs	r2, #0
 8000eca:	601a      	str	r2, [r3, #0]
 8000ecc:	605a      	str	r2, [r3, #4]
 8000ece:	609a      	str	r2, [r3, #8]
 8000ed0:	60da      	str	r2, [r3, #12]
 8000ed2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000ed4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000ed8:	2288      	movs	r2, #136	; 0x88
 8000eda:	2100      	movs	r1, #0
 8000edc:	4618      	mov	r0, r3
 8000ede:	f015 faf1 	bl	80164c4 <memset>
  if(huart->Instance==USART2)
 8000ee2:	687b      	ldr	r3, [r7, #4]
 8000ee4:	681b      	ldr	r3, [r3, #0]
 8000ee6:	4a63      	ldr	r2, [pc, #396]	; (8001074 <HAL_UART_MspInit+0x1b8>)
 8000ee8:	4293      	cmp	r3, r2
 8000eea:	d13c      	bne.n	8000f66 <HAL_UART_MspInit+0xaa>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8000eec:	2302      	movs	r3, #2
 8000eee:	627b      	str	r3, [r7, #36]	; 0x24
    PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8000ef0:	2300      	movs	r3, #0
 8000ef2:	663b      	str	r3, [r7, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000ef4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000ef8:	4618      	mov	r0, r3
 8000efa:	f002 fa13 	bl	8003324 <HAL_RCCEx_PeriphCLKConfig>
 8000efe:	4603      	mov	r3, r0
 8000f00:	2b00      	cmp	r3, #0
 8000f02:	d001      	beq.n	8000f08 <HAL_UART_MspInit+0x4c>
    {
      Error_Handler();
 8000f04:	f7ff fe9e 	bl	8000c44 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000f08:	4b5b      	ldr	r3, [pc, #364]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f0a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000f0c:	4a5a      	ldr	r2, [pc, #360]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000f12:	6593      	str	r3, [r2, #88]	; 0x58
 8000f14:	4b58      	ldr	r3, [pc, #352]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f16:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000f18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000f1c:	623b      	str	r3, [r7, #32]
 8000f1e:	6a3b      	ldr	r3, [r7, #32]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000f20:	4b55      	ldr	r3, [pc, #340]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f22:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f24:	4a54      	ldr	r2, [pc, #336]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f26:	f043 0301 	orr.w	r3, r3, #1
 8000f2a:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000f2c:	4b52      	ldr	r3, [pc, #328]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f2e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f30:	f003 0301 	and.w	r3, r3, #1
 8000f34:	61fb      	str	r3, [r7, #28]
 8000f36:	69fb      	ldr	r3, [r7, #28]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = STLINK_TX_Pin|STLINK_RX_Pin;
 8000f38:	230c      	movs	r3, #12
 8000f3a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f3e:	2302      	movs	r3, #2
 8000f40:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f44:	2300      	movs	r3, #0
 8000f46:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000f4a:	2303      	movs	r3, #3
 8000f4c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8000f50:	2307      	movs	r3, #7
 8000f52:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000f56:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8000f5a:	4619      	mov	r1, r3
 8000f5c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000f60:	f000 fc9a 	bl	8001898 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8000f64:	e082      	b.n	800106c <HAL_UART_MspInit+0x1b0>
  else if(huart->Instance==USART3)
 8000f66:	687b      	ldr	r3, [r7, #4]
 8000f68:	681b      	ldr	r3, [r3, #0]
 8000f6a:	4a44      	ldr	r2, [pc, #272]	; (800107c <HAL_UART_MspInit+0x1c0>)
 8000f6c:	4293      	cmp	r3, r2
 8000f6e:	d17d      	bne.n	800106c <HAL_UART_MspInit+0x1b0>
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 8000f70:	2304      	movs	r3, #4
 8000f72:	627b      	str	r3, [r7, #36]	; 0x24
    PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 8000f74:	2300      	movs	r3, #0
 8000f76:	667b      	str	r3, [r7, #100]	; 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000f78:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000f7c:	4618      	mov	r0, r3
 8000f7e:	f002 f9d1 	bl	8003324 <HAL_RCCEx_PeriphCLKConfig>
 8000f82:	4603      	mov	r3, r0
 8000f84:	2b00      	cmp	r3, #0
 8000f86:	d001      	beq.n	8000f8c <HAL_UART_MspInit+0xd0>
      Error_Handler();
 8000f88:	f7ff fe5c 	bl	8000c44 <Error_Handler>
    __HAL_RCC_USART3_CLK_ENABLE();
 8000f8c:	4b3a      	ldr	r3, [pc, #232]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000f90:	4a39      	ldr	r2, [pc, #228]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f92:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000f96:	6593      	str	r3, [r2, #88]	; 0x58
 8000f98:	4b37      	ldr	r3, [pc, #220]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000f9a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000f9c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8000fa0:	61bb      	str	r3, [r7, #24]
 8000fa2:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000fa4:	4b34      	ldr	r3, [pc, #208]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fa6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fa8:	4a33      	ldr	r2, [pc, #204]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000faa:	f043 0301 	orr.w	r3, r3, #1
 8000fae:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000fb0:	4b31      	ldr	r3, [pc, #196]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fb2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fb4:	f003 0301 	and.w	r3, r3, #1
 8000fb8:	617b      	str	r3, [r7, #20]
 8000fba:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000fbc:	4b2e      	ldr	r3, [pc, #184]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fbe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fc0:	4a2d      	ldr	r2, [pc, #180]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fc2:	f043 0304 	orr.w	r3, r3, #4
 8000fc6:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000fc8:	4b2b      	ldr	r3, [pc, #172]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fcc:	f003 0304 	and.w	r3, r3, #4
 8000fd0:	613b      	str	r3, [r7, #16]
 8000fd2:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000fd4:	4b28      	ldr	r3, [pc, #160]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fd6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fd8:	4a27      	ldr	r2, [pc, #156]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fda:	f043 0302 	orr.w	r3, r3, #2
 8000fde:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000fe0:	4b25      	ldr	r3, [pc, #148]	; (8001078 <HAL_UART_MspInit+0x1bc>)
 8000fe2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fe4:	f003 0302 	and.w	r3, r3, #2
 8000fe8:	60fb      	str	r3, [r7, #12]
 8000fea:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = TRACE_CTS_Pin;
 8000fec:	2340      	movs	r3, #64	; 0x40
 8000fee:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000ff2:	2302      	movs	r3, #2
 8000ff4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff8:	2300      	movs	r3, #0
 8000ffa:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000ffe:	2303      	movs	r3, #3
 8001000:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001004:	2307      	movs	r3, #7
 8001006:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    HAL_GPIO_Init(TRACE_CTS_GPIO_Port, &GPIO_InitStruct);
 800100a:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 800100e:	4619      	mov	r1, r3
 8001010:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001014:	f000 fc40 	bl	8001898 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = TRACE_TX_Pin|TRACE_RX_Pin;
 8001018:	2330      	movs	r3, #48	; 0x30
 800101a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800101e:	2302      	movs	r3, #2
 8001020:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001024:	2300      	movs	r3, #0
 8001026:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800102a:	2303      	movs	r3, #3
 800102c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001030:	2307      	movs	r3, #7
 8001032:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001036:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 800103a:	4619      	mov	r1, r3
 800103c:	4810      	ldr	r0, [pc, #64]	; (8001080 <HAL_UART_MspInit+0x1c4>)
 800103e:	f000 fc2b 	bl	8001898 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = TRACE_RTS_Pin;
 8001042:	2302      	movs	r3, #2
 8001044:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001048:	2302      	movs	r3, #2
 800104a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800104e:	2300      	movs	r3, #0
 8001050:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001054:	2303      	movs	r3, #3
 8001056:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800105a:	2307      	movs	r3, #7
 800105c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    HAL_GPIO_Init(TRACE_RTS_GPIO_Port, &GPIO_InitStruct);
 8001060:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8001064:	4619      	mov	r1, r3
 8001066:	4807      	ldr	r0, [pc, #28]	; (8001084 <HAL_UART_MspInit+0x1c8>)
 8001068:	f000 fc16 	bl	8001898 <HAL_GPIO_Init>
}
 800106c:	bf00      	nop
 800106e:	37c0      	adds	r7, #192	; 0xc0
 8001070:	46bd      	mov	sp, r7
 8001072:	bd80      	pop	{r7, pc}
 8001074:	40004400 	.word	0x40004400
 8001078:	40021000 	.word	0x40021000
 800107c:	40004800 	.word	0x40004800
 8001080:	48000800 	.word	0x48000800
 8001084:	48000400 	.word	0x48000400

08001088 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001088:	b480      	push	{r7}
 800108a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800108c:	e7fe      	b.n	800108c <NMI_Handler+0x4>

0800108e <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800108e:	b480      	push	{r7}
 8001090:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001092:	e7fe      	b.n	8001092 <HardFault_Handler+0x4>

08001094 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001094:	b480      	push	{r7}
 8001096:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001098:	e7fe      	b.n	8001098 <MemManage_Handler+0x4>

0800109a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800109a:	b480      	push	{r7}
 800109c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800109e:	e7fe      	b.n	800109e <BusFault_Handler+0x4>

080010a0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80010a0:	b480      	push	{r7}
 80010a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80010a4:	e7fe      	b.n	80010a4 <UsageFault_Handler+0x4>

080010a6 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80010a6:	b480      	push	{r7}
 80010a8:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80010aa:	bf00      	nop
 80010ac:	46bd      	mov	sp, r7
 80010ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010b2:	4770      	bx	lr

080010b4 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80010b4:	b480      	push	{r7}
 80010b6:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80010b8:	bf00      	nop
 80010ba:	46bd      	mov	sp, r7
 80010bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010c0:	4770      	bx	lr

080010c2 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80010c2:	b480      	push	{r7}
 80010c4:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80010c6:	bf00      	nop
 80010c8:	46bd      	mov	sp, r7
 80010ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010ce:	4770      	bx	lr

080010d0 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80010d0:	b598      	push	{r3, r4, r7, lr}
 80010d2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80010d4:	f000 f9c8 	bl	8001468 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  // SysTick handler gets called every millisecond (is given by code
  // generated by STM32CubeIDE). Check which interval is needed by the
  // XF (typically slower) and call XF_tick() accordingly.
  if (XF_isRunning() &&
 80010d8:	f012 ff17 	bl	8013f0a <XF_isRunning>
 80010dc:	4603      	mov	r3, r0
 80010de:	2b00      	cmp	r3, #0
 80010e0:	d00e      	beq.n	8001100 <SysTick_Handler+0x30>
      (HAL_GetTick() % XF_tickIntervalInMilliseconds()) == 0)
 80010e2:	f000 f9d5 	bl	8001490 <HAL_GetTick>
 80010e6:	4604      	mov	r4, r0
 80010e8:	f012 ff2e 	bl	8013f48 <XF_tickIntervalInMilliseconds>
 80010ec:	4603      	mov	r3, r0
 80010ee:	fbb4 f2f3 	udiv	r2, r4, r3
 80010f2:	fb02 f303 	mul.w	r3, r2, r3
 80010f6:	1ae3      	subs	r3, r4, r3
  if (XF_isRunning() &&
 80010f8:	2b00      	cmp	r3, #0
 80010fa:	d101      	bne.n	8001100 <SysTick_Handler+0x30>
  {
    XF_tick();
 80010fc:	f012 ff0c 	bl	8013f18 <XF_tick>
  }

  /* USER CODE END SysTick_IRQn 1 */
}
 8001100:	bf00      	nop
 8001102:	bd98      	pop	{r3, r4, r7, pc}

08001104 <EXTI0_IRQHandler>:

/**
  * @brief This function handles EXTI line0 interrupt.
  */
void EXTI0_IRQHandler(void)
{
 8001104:	b580      	push	{r7, lr}
 8001106:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 8001108:	2001      	movs	r0, #1
 800110a:	f000 fd9f 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}
 800110e:	bf00      	nop
 8001110:	bd80      	pop	{r7, pc}

08001112 <EXTI3_IRQHandler>:

/**
  * @brief This function handles EXTI line3 interrupt.
  */
void EXTI3_IRQHandler(void)
{
 8001112:	b580      	push	{r7, lr}
 8001114:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI3_IRQn 0 */

  /* USER CODE END EXTI3_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 8001116:	2008      	movs	r0, #8
 8001118:	f000 fd98 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI3_IRQn 1 */

  /* USER CODE END EXTI3_IRQn 1 */
}
 800111c:	bf00      	nop
 800111e:	bd80      	pop	{r7, pc}

08001120 <EXTI4_IRQHandler>:

/**
  * @brief This function handles EXTI line4 interrupt.
  */
void EXTI4_IRQHandler(void)
{
 8001120:	b580      	push	{r7, lr}
 8001122:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_IRQn 0 */

  /* USER CODE END EXTI4_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 8001124:	2010      	movs	r0, #16
 8001126:	f000 fd91 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_IRQn 1 */

  /* USER CODE END EXTI4_IRQn 1 */
}
 800112a:	bf00      	nop
 800112c:	bd80      	pop	{r7, pc}

0800112e <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 800112e:	b580      	push	{r7, lr}
 8001130:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 8001132:	2020      	movs	r0, #32
 8001134:	f000 fd8a 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
 8001138:	2080      	movs	r0, #128	; 0x80
 800113a:	f000 fd87 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 800113e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001142:	f000 fd83 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_9);
 8001146:	f44f 7000 	mov.w	r0, #512	; 0x200
 800114a:	f000 fd7f 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 800114e:	bf00      	nop
 8001150:	bd80      	pop	{r7, pc}
	...

08001154 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 8001154:	b580      	push	{r7, lr}
 8001156:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8001158:	4802      	ldr	r0, [pc, #8]	; (8001164 <TIM2_IRQHandler+0x10>)
 800115a:	f003 fe6f 	bl	8004e3c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 800115e:	bf00      	nop
 8001160:	bd80      	pop	{r7, pc}
 8001162:	bf00      	nop
 8001164:	200001b0 	.word	0x200001b0

08001168 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8001168:	b580      	push	{r7, lr}
 800116a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 800116c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001170:	f000 fd6c 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 8001174:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001178:	f000 fd68 	bl	8001c4c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 800117c:	bf00      	nop
 800117e:	bd80      	pop	{r7, pc}

08001180 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8001180:	b480      	push	{r7}
 8001182:	af00      	add	r7, sp, #0
	return 1;
 8001184:	2301      	movs	r3, #1
}
 8001186:	4618      	mov	r0, r3
 8001188:	46bd      	mov	sp, r7
 800118a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800118e:	4770      	bx	lr

08001190 <_kill>:

int _kill(int pid, int sig)
{
 8001190:	b580      	push	{r7, lr}
 8001192:	b082      	sub	sp, #8
 8001194:	af00      	add	r7, sp, #0
 8001196:	6078      	str	r0, [r7, #4]
 8001198:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 800119a:	f015 f91f 	bl	80163dc <__errno>
 800119e:	4603      	mov	r3, r0
 80011a0:	2216      	movs	r2, #22
 80011a2:	601a      	str	r2, [r3, #0]
	return -1;
 80011a4:	f04f 33ff 	mov.w	r3, #4294967295
}
 80011a8:	4618      	mov	r0, r3
 80011aa:	3708      	adds	r7, #8
 80011ac:	46bd      	mov	sp, r7
 80011ae:	bd80      	pop	{r7, pc}

080011b0 <_exit>:

void _exit (int status)
{
 80011b0:	b580      	push	{r7, lr}
 80011b2:	b082      	sub	sp, #8
 80011b4:	af00      	add	r7, sp, #0
 80011b6:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 80011b8:	f04f 31ff 	mov.w	r1, #4294967295
 80011bc:	6878      	ldr	r0, [r7, #4]
 80011be:	f7ff ffe7 	bl	8001190 <_kill>
  __ASM volatile ("cpsid i" : : : "memory");
 80011c2:	b672      	cpsid	i
}
 80011c4:	bf00      	nop
	__disable_irq();
	while (1)   /* Make sure we hang here */
	{
	    // Add breakpoint only during development
#ifndef NDEBUG
	    __asm__("BKPT");
 80011c6:	be00      	bkpt	0x0000
 80011c8:	e7fd      	b.n	80011c6 <_exit+0x16>

080011ca <_read>:
#endif
	}
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80011ca:	b580      	push	{r7, lr}
 80011cc:	b086      	sub	sp, #24
 80011ce:	af00      	add	r7, sp, #0
 80011d0:	60f8      	str	r0, [r7, #12]
 80011d2:	60b9      	str	r1, [r7, #8]
 80011d4:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80011d6:	2300      	movs	r3, #0
 80011d8:	617b      	str	r3, [r7, #20]
 80011da:	e00a      	b.n	80011f2 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 80011dc:	f3af 8000 	nop.w
 80011e0:	4601      	mov	r1, r0
 80011e2:	68bb      	ldr	r3, [r7, #8]
 80011e4:	1c5a      	adds	r2, r3, #1
 80011e6:	60ba      	str	r2, [r7, #8]
 80011e8:	b2ca      	uxtb	r2, r1
 80011ea:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80011ec:	697b      	ldr	r3, [r7, #20]
 80011ee:	3301      	adds	r3, #1
 80011f0:	617b      	str	r3, [r7, #20]
 80011f2:	697a      	ldr	r2, [r7, #20]
 80011f4:	687b      	ldr	r3, [r7, #4]
 80011f6:	429a      	cmp	r2, r3
 80011f8:	dbf0      	blt.n	80011dc <_read+0x12>
	}

return len;
 80011fa:	687b      	ldr	r3, [r7, #4]
}
 80011fc:	4618      	mov	r0, r3
 80011fe:	3718      	adds	r7, #24
 8001200:	46bd      	mov	sp, r7
 8001202:	bd80      	pop	{r7, pc}

08001204 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001204:	b580      	push	{r7, lr}
 8001206:	b084      	sub	sp, #16
 8001208:	af00      	add	r7, sp, #0
 800120a:	60f8      	str	r0, [r7, #12]
 800120c:	60b9      	str	r1, [r7, #8]
 800120e:	607a      	str	r2, [r7, #4]
	trace(ptr, len);
 8001210:	6879      	ldr	r1, [r7, #4]
 8001212:	68b8      	ldr	r0, [r7, #8]
 8001214:	f00e fa34 	bl	800f680 <trace>
	return len;
 8001218:	687b      	ldr	r3, [r7, #4]
}
 800121a:	4618      	mov	r0, r3
 800121c:	3710      	adds	r7, #16
 800121e:	46bd      	mov	sp, r7
 8001220:	bd80      	pop	{r7, pc}

08001222 <_close>:

int _close(int file)
{
 8001222:	b480      	push	{r7}
 8001224:	b083      	sub	sp, #12
 8001226:	af00      	add	r7, sp, #0
 8001228:	6078      	str	r0, [r7, #4]
	return -1;
 800122a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800122e:	4618      	mov	r0, r3
 8001230:	370c      	adds	r7, #12
 8001232:	46bd      	mov	sp, r7
 8001234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001238:	4770      	bx	lr

0800123a <_fstat>:


int _fstat(int file, struct stat *st)
{
 800123a:	b480      	push	{r7}
 800123c:	b083      	sub	sp, #12
 800123e:	af00      	add	r7, sp, #0
 8001240:	6078      	str	r0, [r7, #4]
 8001242:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 8001244:	683b      	ldr	r3, [r7, #0]
 8001246:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800124a:	605a      	str	r2, [r3, #4]
	return 0;
 800124c:	2300      	movs	r3, #0
}
 800124e:	4618      	mov	r0, r3
 8001250:	370c      	adds	r7, #12
 8001252:	46bd      	mov	sp, r7
 8001254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001258:	4770      	bx	lr

0800125a <_isatty>:

int _isatty(int file)
{
 800125a:	b480      	push	{r7}
 800125c:	b083      	sub	sp, #12
 800125e:	af00      	add	r7, sp, #0
 8001260:	6078      	str	r0, [r7, #4]
	return 1;
 8001262:	2301      	movs	r3, #1
}
 8001264:	4618      	mov	r0, r3
 8001266:	370c      	adds	r7, #12
 8001268:	46bd      	mov	sp, r7
 800126a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800126e:	4770      	bx	lr

08001270 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8001270:	b480      	push	{r7}
 8001272:	b085      	sub	sp, #20
 8001274:	af00      	add	r7, sp, #0
 8001276:	60f8      	str	r0, [r7, #12]
 8001278:	60b9      	str	r1, [r7, #8]
 800127a:	607a      	str	r2, [r7, #4]
	return 0;
 800127c:	2300      	movs	r3, #0
}
 800127e:	4618      	mov	r0, r3
 8001280:	3714      	adds	r7, #20
 8001282:	46bd      	mov	sp, r7
 8001284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001288:	4770      	bx	lr
	...

0800128c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800128c:	b580      	push	{r7, lr}
 800128e:	b086      	sub	sp, #24
 8001290:	af00      	add	r7, sp, #0
 8001292:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001294:	4a14      	ldr	r2, [pc, #80]	; (80012e8 <_sbrk+0x5c>)
 8001296:	4b15      	ldr	r3, [pc, #84]	; (80012ec <_sbrk+0x60>)
 8001298:	1ad3      	subs	r3, r2, r3
 800129a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800129c:	697b      	ldr	r3, [r7, #20]
 800129e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80012a0:	4b13      	ldr	r3, [pc, #76]	; (80012f0 <_sbrk+0x64>)
 80012a2:	681b      	ldr	r3, [r3, #0]
 80012a4:	2b00      	cmp	r3, #0
 80012a6:	d102      	bne.n	80012ae <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 80012a8:	4b11      	ldr	r3, [pc, #68]	; (80012f0 <_sbrk+0x64>)
 80012aa:	4a12      	ldr	r2, [pc, #72]	; (80012f4 <_sbrk+0x68>)
 80012ac:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80012ae:	4b10      	ldr	r3, [pc, #64]	; (80012f0 <_sbrk+0x64>)
 80012b0:	681a      	ldr	r2, [r3, #0]
 80012b2:	687b      	ldr	r3, [r7, #4]
 80012b4:	4413      	add	r3, r2
 80012b6:	693a      	ldr	r2, [r7, #16]
 80012b8:	429a      	cmp	r2, r3
 80012ba:	d207      	bcs.n	80012cc <_sbrk+0x40>
  {
    errno = ENOMEM;
 80012bc:	f015 f88e 	bl	80163dc <__errno>
 80012c0:	4603      	mov	r3, r0
 80012c2:	220c      	movs	r2, #12
 80012c4:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80012c6:	f04f 33ff 	mov.w	r3, #4294967295
 80012ca:	e009      	b.n	80012e0 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80012cc:	4b08      	ldr	r3, [pc, #32]	; (80012f0 <_sbrk+0x64>)
 80012ce:	681b      	ldr	r3, [r3, #0]
 80012d0:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80012d2:	4b07      	ldr	r3, [pc, #28]	; (80012f0 <_sbrk+0x64>)
 80012d4:	681a      	ldr	r2, [r3, #0]
 80012d6:	687b      	ldr	r3, [r7, #4]
 80012d8:	4413      	add	r3, r2
 80012da:	4a05      	ldr	r2, [pc, #20]	; (80012f0 <_sbrk+0x64>)
 80012dc:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80012de:	68fb      	ldr	r3, [r7, #12]
}
 80012e0:	4618      	mov	r0, r3
 80012e2:	3718      	adds	r7, #24
 80012e4:	46bd      	mov	sp, r7
 80012e6:	bd80      	pop	{r7, pc}
 80012e8:	20018000 	.word	0x20018000
 80012ec:	00000800 	.word	0x00000800
 80012f0:	20000304 	.word	0x20000304
 80012f4:	20001f08 	.word	0x20001f08

080012f8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
 80012f8:	b480      	push	{r7}
 80012fa:	af00      	add	r7, sp, #0
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 80012fc:	4b15      	ldr	r3, [pc, #84]	; (8001354 <SystemInit+0x5c>)
 80012fe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8001302:	4a14      	ldr	r2, [pc, #80]	; (8001354 <SystemInit+0x5c>)
 8001304:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001308:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800130c:	4b12      	ldr	r3, [pc, #72]	; (8001358 <SystemInit+0x60>)
 800130e:	681b      	ldr	r3, [r3, #0]
 8001310:	4a11      	ldr	r2, [pc, #68]	; (8001358 <SystemInit+0x60>)
 8001312:	f043 0301 	orr.w	r3, r3, #1
 8001316:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001318:	4b0f      	ldr	r3, [pc, #60]	; (8001358 <SystemInit+0x60>)
 800131a:	2200      	movs	r2, #0
 800131c:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 800131e:	4b0e      	ldr	r3, [pc, #56]	; (8001358 <SystemInit+0x60>)
 8001320:	681b      	ldr	r3, [r3, #0]
 8001322:	4a0d      	ldr	r2, [pc, #52]	; (8001358 <SystemInit+0x60>)
 8001324:	f023 53a8 	bic.w	r3, r3, #352321536	; 0x15000000
 8001328:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 800132c:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 800132e:	4b0a      	ldr	r3, [pc, #40]	; (8001358 <SystemInit+0x60>)
 8001330:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001334:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001336:	4b08      	ldr	r3, [pc, #32]	; (8001358 <SystemInit+0x60>)
 8001338:	681b      	ldr	r3, [r3, #0]
 800133a:	4a07      	ldr	r2, [pc, #28]	; (8001358 <SystemInit+0x60>)
 800133c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001340:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8001342:	4b05      	ldr	r3, [pc, #20]	; (8001358 <SystemInit+0x60>)
 8001344:	2200      	movs	r2, #0
 8001346:	619a      	str	r2, [r3, #24]
}
 8001348:	bf00      	nop
 800134a:	46bd      	mov	sp, r7
 800134c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001350:	4770      	bx	lr
 8001352:	bf00      	nop
 8001354:	e000ed00 	.word	0xe000ed00
 8001358:	40021000 	.word	0x40021000

0800135c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 800135c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001394 <LoopForever+0x2>

/* Call the clock system initialization function.*/
    bl  SystemInit
 8001360:	f7ff ffca 	bl	80012f8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8001364:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8001366:	e003      	b.n	8001370 <LoopCopyDataInit>

08001368 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001368:	4b0b      	ldr	r3, [pc, #44]	; (8001398 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800136a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800136c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800136e:	3104      	adds	r1, #4

08001370 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8001370:	480a      	ldr	r0, [pc, #40]	; (800139c <LoopForever+0xa>)
	ldr	r3, =_edata
 8001372:	4b0b      	ldr	r3, [pc, #44]	; (80013a0 <LoopForever+0xe>)
	adds	r2, r0, r1
 8001374:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8001376:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8001378:	d3f6      	bcc.n	8001368 <CopyDataInit>
	ldr	r2, =_sbss
 800137a:	4a0a      	ldr	r2, [pc, #40]	; (80013a4 <LoopForever+0x12>)
	b	LoopFillZerobss
 800137c:	e002      	b.n	8001384 <LoopFillZerobss>

0800137e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800137e:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8001380:	f842 3b04 	str.w	r3, [r2], #4

08001384 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8001384:	4b08      	ldr	r3, [pc, #32]	; (80013a8 <LoopForever+0x16>)
	cmp	r2, r3
 8001386:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8001388:	d3f9      	bcc.n	800137e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800138a:	f015 f83f 	bl	801640c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800138e:	f7ff f8f9 	bl	8000584 <main>

08001392 <LoopForever>:

LoopForever:
    b LoopForever
 8001392:	e7fe      	b.n	8001392 <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 8001394:	20018000 	.word	0x20018000
	ldr	r3, =_sidata
 8001398:	0801df08 	.word	0x0801df08
	ldr	r0, =_sdata
 800139c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80013a0:	20000080 	.word	0x20000080
	ldr	r2, =_sbss
 80013a4:	20000080 	.word	0x20000080
	ldr	r3, = _ebss
 80013a8:	20001f04 	.word	0x20001f04

080013ac <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80013ac:	e7fe      	b.n	80013ac <ADC1_2_IRQHandler>
	...

080013b0 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80013b0:	b580      	push	{r7, lr}
 80013b2:	b082      	sub	sp, #8
 80013b4:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80013b6:	2300      	movs	r3, #0
 80013b8:	71fb      	strb	r3, [r7, #7]
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80013ba:	4b0c      	ldr	r3, [pc, #48]	; (80013ec <HAL_Init+0x3c>)
 80013bc:	681b      	ldr	r3, [r3, #0]
 80013be:	4a0b      	ldr	r2, [pc, #44]	; (80013ec <HAL_Init+0x3c>)
 80013c0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80013c4:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80013c6:	2003      	movs	r0, #3
 80013c8:	f000 f986 	bl	80016d8 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80013cc:	2000      	movs	r0, #0
 80013ce:	f000 f80f 	bl	80013f0 <HAL_InitTick>
 80013d2:	4603      	mov	r3, r0
 80013d4:	2b00      	cmp	r3, #0
 80013d6:	d002      	beq.n	80013de <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 80013d8:	2301      	movs	r3, #1
 80013da:	71fb      	strb	r3, [r7, #7]
 80013dc:	e001      	b.n	80013e2 <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80013de:	f7ff fc37 	bl	8000c50 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80013e2:	79fb      	ldrb	r3, [r7, #7]
}
 80013e4:	4618      	mov	r0, r3
 80013e6:	3708      	adds	r7, #8
 80013e8:	46bd      	mov	sp, r7
 80013ea:	bd80      	pop	{r7, pc}
 80013ec:	40022000 	.word	0x40022000

080013f0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80013f0:	b580      	push	{r7, lr}
 80013f2:	b084      	sub	sp, #16
 80013f4:	af00      	add	r7, sp, #0
 80013f6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 80013f8:	2300      	movs	r3, #0
 80013fa:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 80013fc:	4b17      	ldr	r3, [pc, #92]	; (800145c <HAL_InitTick+0x6c>)
 80013fe:	781b      	ldrb	r3, [r3, #0]
 8001400:	2b00      	cmp	r3, #0
 8001402:	d023      	beq.n	800144c <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 8001404:	4b16      	ldr	r3, [pc, #88]	; (8001460 <HAL_InitTick+0x70>)
 8001406:	681a      	ldr	r2, [r3, #0]
 8001408:	4b14      	ldr	r3, [pc, #80]	; (800145c <HAL_InitTick+0x6c>)
 800140a:	781b      	ldrb	r3, [r3, #0]
 800140c:	4619      	mov	r1, r3
 800140e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001412:	fbb3 f3f1 	udiv	r3, r3, r1
 8001416:	fbb2 f3f3 	udiv	r3, r2, r3
 800141a:	4618      	mov	r0, r3
 800141c:	f000 f99f 	bl	800175e <HAL_SYSTICK_Config>
 8001420:	4603      	mov	r3, r0
 8001422:	2b00      	cmp	r3, #0
 8001424:	d10f      	bne.n	8001446 <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001426:	687b      	ldr	r3, [r7, #4]
 8001428:	2b0f      	cmp	r3, #15
 800142a:	d809      	bhi.n	8001440 <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800142c:	2200      	movs	r2, #0
 800142e:	6879      	ldr	r1, [r7, #4]
 8001430:	f04f 30ff 	mov.w	r0, #4294967295
 8001434:	f000 f95b 	bl	80016ee <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8001438:	4a0a      	ldr	r2, [pc, #40]	; (8001464 <HAL_InitTick+0x74>)
 800143a:	687b      	ldr	r3, [r7, #4]
 800143c:	6013      	str	r3, [r2, #0]
 800143e:	e007      	b.n	8001450 <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
 8001440:	2301      	movs	r3, #1
 8001442:	73fb      	strb	r3, [r7, #15]
 8001444:	e004      	b.n	8001450 <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
 8001446:	2301      	movs	r3, #1
 8001448:	73fb      	strb	r3, [r7, #15]
 800144a:	e001      	b.n	8001450 <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
 800144c:	2301      	movs	r3, #1
 800144e:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8001450:	7bfb      	ldrb	r3, [r7, #15]
}
 8001452:	4618      	mov	r0, r3
 8001454:	3710      	adds	r7, #16
 8001456:	46bd      	mov	sp, r7
 8001458:	bd80      	pop	{r7, pc}
 800145a:	bf00      	nop
 800145c:	20000008 	.word	0x20000008
 8001460:	20000000 	.word	0x20000000
 8001464:	20000004 	.word	0x20000004

08001468 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001468:	b480      	push	{r7}
 800146a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800146c:	4b06      	ldr	r3, [pc, #24]	; (8001488 <HAL_IncTick+0x20>)
 800146e:	781b      	ldrb	r3, [r3, #0]
 8001470:	461a      	mov	r2, r3
 8001472:	4b06      	ldr	r3, [pc, #24]	; (800148c <HAL_IncTick+0x24>)
 8001474:	681b      	ldr	r3, [r3, #0]
 8001476:	4413      	add	r3, r2
 8001478:	4a04      	ldr	r2, [pc, #16]	; (800148c <HAL_IncTick+0x24>)
 800147a:	6013      	str	r3, [r2, #0]
}
 800147c:	bf00      	nop
 800147e:	46bd      	mov	sp, r7
 8001480:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001484:	4770      	bx	lr
 8001486:	bf00      	nop
 8001488:	20000008 	.word	0x20000008
 800148c:	20000308 	.word	0x20000308

08001490 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001490:	b480      	push	{r7}
 8001492:	af00      	add	r7, sp, #0
  return uwTick;
 8001494:	4b03      	ldr	r3, [pc, #12]	; (80014a4 <HAL_GetTick+0x14>)
 8001496:	681b      	ldr	r3, [r3, #0]
}
 8001498:	4618      	mov	r0, r3
 800149a:	46bd      	mov	sp, r7
 800149c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014a0:	4770      	bx	lr
 80014a2:	bf00      	nop
 80014a4:	20000308 	.word	0x20000308

080014a8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80014a8:	b580      	push	{r7, lr}
 80014aa:	b084      	sub	sp, #16
 80014ac:	af00      	add	r7, sp, #0
 80014ae:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80014b0:	f7ff ffee 	bl	8001490 <HAL_GetTick>
 80014b4:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 80014b6:	687b      	ldr	r3, [r7, #4]
 80014b8:	60fb      	str	r3, [r7, #12]

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 80014ba:	68fb      	ldr	r3, [r7, #12]
 80014bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80014c0:	d005      	beq.n	80014ce <HAL_Delay+0x26>
  {
    wait += (uint32_t)uwTickFreq;
 80014c2:	4b0a      	ldr	r3, [pc, #40]	; (80014ec <HAL_Delay+0x44>)
 80014c4:	781b      	ldrb	r3, [r3, #0]
 80014c6:	461a      	mov	r2, r3
 80014c8:	68fb      	ldr	r3, [r7, #12]
 80014ca:	4413      	add	r3, r2
 80014cc:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80014ce:	bf00      	nop
 80014d0:	f7ff ffde 	bl	8001490 <HAL_GetTick>
 80014d4:	4602      	mov	r2, r0
 80014d6:	68bb      	ldr	r3, [r7, #8]
 80014d8:	1ad3      	subs	r3, r2, r3
 80014da:	68fa      	ldr	r2, [r7, #12]
 80014dc:	429a      	cmp	r2, r3
 80014de:	d8f7      	bhi.n	80014d0 <HAL_Delay+0x28>
  {
  }
}
 80014e0:	bf00      	nop
 80014e2:	bf00      	nop
 80014e4:	3710      	adds	r7, #16
 80014e6:	46bd      	mov	sp, r7
 80014e8:	bd80      	pop	{r7, pc}
 80014ea:	bf00      	nop
 80014ec:	20000008 	.word	0x20000008

080014f0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80014f0:	b480      	push	{r7}
 80014f2:	b085      	sub	sp, #20
 80014f4:	af00      	add	r7, sp, #0
 80014f6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80014f8:	687b      	ldr	r3, [r7, #4]
 80014fa:	f003 0307 	and.w	r3, r3, #7
 80014fe:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001500:	4b0c      	ldr	r3, [pc, #48]	; (8001534 <__NVIC_SetPriorityGrouping+0x44>)
 8001502:	68db      	ldr	r3, [r3, #12]
 8001504:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001506:	68ba      	ldr	r2, [r7, #8]
 8001508:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800150c:	4013      	ands	r3, r2
 800150e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001510:	68fb      	ldr	r3, [r7, #12]
 8001512:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001514:	68bb      	ldr	r3, [r7, #8]
 8001516:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001518:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800151c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001520:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001522:	4a04      	ldr	r2, [pc, #16]	; (8001534 <__NVIC_SetPriorityGrouping+0x44>)
 8001524:	68bb      	ldr	r3, [r7, #8]
 8001526:	60d3      	str	r3, [r2, #12]
}
 8001528:	bf00      	nop
 800152a:	3714      	adds	r7, #20
 800152c:	46bd      	mov	sp, r7
 800152e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001532:	4770      	bx	lr
 8001534:	e000ed00 	.word	0xe000ed00

08001538 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001538:	b480      	push	{r7}
 800153a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800153c:	4b04      	ldr	r3, [pc, #16]	; (8001550 <__NVIC_GetPriorityGrouping+0x18>)
 800153e:	68db      	ldr	r3, [r3, #12]
 8001540:	0a1b      	lsrs	r3, r3, #8
 8001542:	f003 0307 	and.w	r3, r3, #7
}
 8001546:	4618      	mov	r0, r3
 8001548:	46bd      	mov	sp, r7
 800154a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800154e:	4770      	bx	lr
 8001550:	e000ed00 	.word	0xe000ed00

08001554 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001554:	b480      	push	{r7}
 8001556:	b083      	sub	sp, #12
 8001558:	af00      	add	r7, sp, #0
 800155a:	4603      	mov	r3, r0
 800155c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800155e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001562:	2b00      	cmp	r3, #0
 8001564:	db0b      	blt.n	800157e <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001566:	79fb      	ldrb	r3, [r7, #7]
 8001568:	f003 021f 	and.w	r2, r3, #31
 800156c:	4907      	ldr	r1, [pc, #28]	; (800158c <__NVIC_EnableIRQ+0x38>)
 800156e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001572:	095b      	lsrs	r3, r3, #5
 8001574:	2001      	movs	r0, #1
 8001576:	fa00 f202 	lsl.w	r2, r0, r2
 800157a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800157e:	bf00      	nop
 8001580:	370c      	adds	r7, #12
 8001582:	46bd      	mov	sp, r7
 8001584:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001588:	4770      	bx	lr
 800158a:	bf00      	nop
 800158c:	e000e100 	.word	0xe000e100

08001590 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8001590:	b480      	push	{r7}
 8001592:	b083      	sub	sp, #12
 8001594:	af00      	add	r7, sp, #0
 8001596:	4603      	mov	r3, r0
 8001598:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800159a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800159e:	2b00      	cmp	r3, #0
 80015a0:	db12      	blt.n	80015c8 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80015a2:	79fb      	ldrb	r3, [r7, #7]
 80015a4:	f003 021f 	and.w	r2, r3, #31
 80015a8:	490a      	ldr	r1, [pc, #40]	; (80015d4 <__NVIC_DisableIRQ+0x44>)
 80015aa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80015ae:	095b      	lsrs	r3, r3, #5
 80015b0:	2001      	movs	r0, #1
 80015b2:	fa00 f202 	lsl.w	r2, r0, r2
 80015b6:	3320      	adds	r3, #32
 80015b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80015bc:	f3bf 8f4f 	dsb	sy
}
 80015c0:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80015c2:	f3bf 8f6f 	isb	sy
}
 80015c6:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 80015c8:	bf00      	nop
 80015ca:	370c      	adds	r7, #12
 80015cc:	46bd      	mov	sp, r7
 80015ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015d2:	4770      	bx	lr
 80015d4:	e000e100 	.word	0xe000e100

080015d8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80015d8:	b480      	push	{r7}
 80015da:	b083      	sub	sp, #12
 80015dc:	af00      	add	r7, sp, #0
 80015de:	4603      	mov	r3, r0
 80015e0:	6039      	str	r1, [r7, #0]
 80015e2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80015e4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80015e8:	2b00      	cmp	r3, #0
 80015ea:	db0a      	blt.n	8001602 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80015ec:	683b      	ldr	r3, [r7, #0]
 80015ee:	b2da      	uxtb	r2, r3
 80015f0:	490c      	ldr	r1, [pc, #48]	; (8001624 <__NVIC_SetPriority+0x4c>)
 80015f2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80015f6:	0112      	lsls	r2, r2, #4
 80015f8:	b2d2      	uxtb	r2, r2
 80015fa:	440b      	add	r3, r1
 80015fc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001600:	e00a      	b.n	8001618 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001602:	683b      	ldr	r3, [r7, #0]
 8001604:	b2da      	uxtb	r2, r3
 8001606:	4908      	ldr	r1, [pc, #32]	; (8001628 <__NVIC_SetPriority+0x50>)
 8001608:	79fb      	ldrb	r3, [r7, #7]
 800160a:	f003 030f 	and.w	r3, r3, #15
 800160e:	3b04      	subs	r3, #4
 8001610:	0112      	lsls	r2, r2, #4
 8001612:	b2d2      	uxtb	r2, r2
 8001614:	440b      	add	r3, r1
 8001616:	761a      	strb	r2, [r3, #24]
}
 8001618:	bf00      	nop
 800161a:	370c      	adds	r7, #12
 800161c:	46bd      	mov	sp, r7
 800161e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001622:	4770      	bx	lr
 8001624:	e000e100 	.word	0xe000e100
 8001628:	e000ed00 	.word	0xe000ed00

0800162c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800162c:	b480      	push	{r7}
 800162e:	b089      	sub	sp, #36	; 0x24
 8001630:	af00      	add	r7, sp, #0
 8001632:	60f8      	str	r0, [r7, #12]
 8001634:	60b9      	str	r1, [r7, #8]
 8001636:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001638:	68fb      	ldr	r3, [r7, #12]
 800163a:	f003 0307 	and.w	r3, r3, #7
 800163e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001640:	69fb      	ldr	r3, [r7, #28]
 8001642:	f1c3 0307 	rsb	r3, r3, #7
 8001646:	2b04      	cmp	r3, #4
 8001648:	bf28      	it	cs
 800164a:	2304      	movcs	r3, #4
 800164c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800164e:	69fb      	ldr	r3, [r7, #28]
 8001650:	3304      	adds	r3, #4
 8001652:	2b06      	cmp	r3, #6
 8001654:	d902      	bls.n	800165c <NVIC_EncodePriority+0x30>
 8001656:	69fb      	ldr	r3, [r7, #28]
 8001658:	3b03      	subs	r3, #3
 800165a:	e000      	b.n	800165e <NVIC_EncodePriority+0x32>
 800165c:	2300      	movs	r3, #0
 800165e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001660:	f04f 32ff 	mov.w	r2, #4294967295
 8001664:	69bb      	ldr	r3, [r7, #24]
 8001666:	fa02 f303 	lsl.w	r3, r2, r3
 800166a:	43da      	mvns	r2, r3
 800166c:	68bb      	ldr	r3, [r7, #8]
 800166e:	401a      	ands	r2, r3
 8001670:	697b      	ldr	r3, [r7, #20]
 8001672:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001674:	f04f 31ff 	mov.w	r1, #4294967295
 8001678:	697b      	ldr	r3, [r7, #20]
 800167a:	fa01 f303 	lsl.w	r3, r1, r3
 800167e:	43d9      	mvns	r1, r3
 8001680:	687b      	ldr	r3, [r7, #4]
 8001682:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001684:	4313      	orrs	r3, r2
         );
}
 8001686:	4618      	mov	r0, r3
 8001688:	3724      	adds	r7, #36	; 0x24
 800168a:	46bd      	mov	sp, r7
 800168c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001690:	4770      	bx	lr
	...

08001694 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001694:	b580      	push	{r7, lr}
 8001696:	b082      	sub	sp, #8
 8001698:	af00      	add	r7, sp, #0
 800169a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	3b01      	subs	r3, #1
 80016a0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80016a4:	d301      	bcc.n	80016aa <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 80016a6:	2301      	movs	r3, #1
 80016a8:	e00f      	b.n	80016ca <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80016aa:	4a0a      	ldr	r2, [pc, #40]	; (80016d4 <SysTick_Config+0x40>)
 80016ac:	687b      	ldr	r3, [r7, #4]
 80016ae:	3b01      	subs	r3, #1
 80016b0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80016b2:	210f      	movs	r1, #15
 80016b4:	f04f 30ff 	mov.w	r0, #4294967295
 80016b8:	f7ff ff8e 	bl	80015d8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80016bc:	4b05      	ldr	r3, [pc, #20]	; (80016d4 <SysTick_Config+0x40>)
 80016be:	2200      	movs	r2, #0
 80016c0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80016c2:	4b04      	ldr	r3, [pc, #16]	; (80016d4 <SysTick_Config+0x40>)
 80016c4:	2207      	movs	r2, #7
 80016c6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80016c8:	2300      	movs	r3, #0
}
 80016ca:	4618      	mov	r0, r3
 80016cc:	3708      	adds	r7, #8
 80016ce:	46bd      	mov	sp, r7
 80016d0:	bd80      	pop	{r7, pc}
 80016d2:	bf00      	nop
 80016d4:	e000e010 	.word	0xe000e010

080016d8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80016d8:	b580      	push	{r7, lr}
 80016da:	b082      	sub	sp, #8
 80016dc:	af00      	add	r7, sp, #0
 80016de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80016e0:	6878      	ldr	r0, [r7, #4]
 80016e2:	f7ff ff05 	bl	80014f0 <__NVIC_SetPriorityGrouping>
}
 80016e6:	bf00      	nop
 80016e8:	3708      	adds	r7, #8
 80016ea:	46bd      	mov	sp, r7
 80016ec:	bd80      	pop	{r7, pc}

080016ee <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80016ee:	b580      	push	{r7, lr}
 80016f0:	b086      	sub	sp, #24
 80016f2:	af00      	add	r7, sp, #0
 80016f4:	4603      	mov	r3, r0
 80016f6:	60b9      	str	r1, [r7, #8]
 80016f8:	607a      	str	r2, [r7, #4]
 80016fa:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 80016fc:	2300      	movs	r3, #0
 80016fe:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8001700:	f7ff ff1a 	bl	8001538 <__NVIC_GetPriorityGrouping>
 8001704:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001706:	687a      	ldr	r2, [r7, #4]
 8001708:	68b9      	ldr	r1, [r7, #8]
 800170a:	6978      	ldr	r0, [r7, #20]
 800170c:	f7ff ff8e 	bl	800162c <NVIC_EncodePriority>
 8001710:	4602      	mov	r2, r0
 8001712:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001716:	4611      	mov	r1, r2
 8001718:	4618      	mov	r0, r3
 800171a:	f7ff ff5d 	bl	80015d8 <__NVIC_SetPriority>
}
 800171e:	bf00      	nop
 8001720:	3718      	adds	r7, #24
 8001722:	46bd      	mov	sp, r7
 8001724:	bd80      	pop	{r7, pc}

08001726 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001726:	b580      	push	{r7, lr}
 8001728:	b082      	sub	sp, #8
 800172a:	af00      	add	r7, sp, #0
 800172c:	4603      	mov	r3, r0
 800172e:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001730:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001734:	4618      	mov	r0, r3
 8001736:	f7ff ff0d 	bl	8001554 <__NVIC_EnableIRQ>
}
 800173a:	bf00      	nop
 800173c:	3708      	adds	r7, #8
 800173e:	46bd      	mov	sp, r7
 8001740:	bd80      	pop	{r7, pc}

08001742 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8001742:	b580      	push	{r7, lr}
 8001744:	b082      	sub	sp, #8
 8001746:	af00      	add	r7, sp, #0
 8001748:	4603      	mov	r3, r0
 800174a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800174c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001750:	4618      	mov	r0, r3
 8001752:	f7ff ff1d 	bl	8001590 <__NVIC_DisableIRQ>
}
 8001756:	bf00      	nop
 8001758:	3708      	adds	r7, #8
 800175a:	46bd      	mov	sp, r7
 800175c:	bd80      	pop	{r7, pc}

0800175e <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800175e:	b580      	push	{r7, lr}
 8001760:	b082      	sub	sp, #8
 8001762:	af00      	add	r7, sp, #0
 8001764:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8001766:	6878      	ldr	r0, [r7, #4]
 8001768:	f7ff ff94 	bl	8001694 <SysTick_Config>
 800176c:	4603      	mov	r3, r0
}
 800176e:	4618      	mov	r0, r3
 8001770:	3708      	adds	r7, #8
 8001772:	46bd      	mov	sp, r7
 8001774:	bd80      	pop	{r7, pc}

08001776 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8001776:	b580      	push	{r7, lr}
 8001778:	b086      	sub	sp, #24
 800177a:	af00      	add	r7, sp, #0
 800177c:	60f8      	str	r0, [r7, #12]
 800177e:	60b9      	str	r1, [r7, #8]
 8001780:	607a      	str	r2, [r7, #4]
 8001782:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8001784:	2300      	movs	r3, #0
 8001786:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8001788:	68fb      	ldr	r3, [r7, #12]
 800178a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800178e:	2b01      	cmp	r3, #1
 8001790:	d101      	bne.n	8001796 <HAL_DMA_Start_IT+0x20>
 8001792:	2302      	movs	r3, #2
 8001794:	e04b      	b.n	800182e <HAL_DMA_Start_IT+0xb8>
 8001796:	68fb      	ldr	r3, [r7, #12]
 8001798:	2201      	movs	r2, #1
 800179a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if(HAL_DMA_STATE_READY == hdma->State)
 800179e:	68fb      	ldr	r3, [r7, #12]
 80017a0:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80017a4:	b2db      	uxtb	r3, r3
 80017a6:	2b01      	cmp	r3, #1
 80017a8:	d13a      	bne.n	8001820 <HAL_DMA_Start_IT+0xaa>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80017aa:	68fb      	ldr	r3, [r7, #12]
 80017ac:	2202      	movs	r2, #2
 80017ae:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80017b2:	68fb      	ldr	r3, [r7, #12]
 80017b4:	2200      	movs	r2, #0
 80017b6:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 80017b8:	68fb      	ldr	r3, [r7, #12]
 80017ba:	681b      	ldr	r3, [r3, #0]
 80017bc:	681a      	ldr	r2, [r3, #0]
 80017be:	68fb      	ldr	r3, [r7, #12]
 80017c0:	681b      	ldr	r3, [r3, #0]
 80017c2:	f022 0201 	bic.w	r2, r2, #1
 80017c6:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length & clear flags*/
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80017c8:	683b      	ldr	r3, [r7, #0]
 80017ca:	687a      	ldr	r2, [r7, #4]
 80017cc:	68b9      	ldr	r1, [r7, #8]
 80017ce:	68f8      	ldr	r0, [r7, #12]
 80017d0:	f000 f831 	bl	8001836 <DMA_SetConfig>

    /* Enable the transfer complete interrupt */
    /* Enable the transfer Error interrupt */
    if(NULL != hdma->XferHalfCpltCallback )
 80017d4:	68fb      	ldr	r3, [r7, #12]
 80017d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80017d8:	2b00      	cmp	r3, #0
 80017da:	d008      	beq.n	80017ee <HAL_DMA_Start_IT+0x78>
    {
      /* Enable the Half transfer complete interrupt as well */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80017dc:	68fb      	ldr	r3, [r7, #12]
 80017de:	681b      	ldr	r3, [r3, #0]
 80017e0:	681a      	ldr	r2, [r3, #0]
 80017e2:	68fb      	ldr	r3, [r7, #12]
 80017e4:	681b      	ldr	r3, [r3, #0]
 80017e6:	f042 020e 	orr.w	r2, r2, #14
 80017ea:	601a      	str	r2, [r3, #0]
 80017ec:	e00f      	b.n	800180e <HAL_DMA_Start_IT+0x98>
    }
    else
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80017ee:	68fb      	ldr	r3, [r7, #12]
 80017f0:	681b      	ldr	r3, [r3, #0]
 80017f2:	681a      	ldr	r2, [r3, #0]
 80017f4:	68fb      	ldr	r3, [r7, #12]
 80017f6:	681b      	ldr	r3, [r3, #0]
 80017f8:	f022 0204 	bic.w	r2, r2, #4
 80017fc:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 80017fe:	68fb      	ldr	r3, [r7, #12]
 8001800:	681b      	ldr	r3, [r3, #0]
 8001802:	681a      	ldr	r2, [r3, #0]
 8001804:	68fb      	ldr	r3, [r7, #12]
 8001806:	681b      	ldr	r3, [r3, #0]
 8001808:	f042 020a 	orr.w	r2, r2, #10
 800180c:	601a      	str	r2, [r3, #0]
    }

#endif /* DMAMUX1 */

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 800180e:	68fb      	ldr	r3, [r7, #12]
 8001810:	681b      	ldr	r3, [r3, #0]
 8001812:	681a      	ldr	r2, [r3, #0]
 8001814:	68fb      	ldr	r3, [r7, #12]
 8001816:	681b      	ldr	r3, [r3, #0]
 8001818:	f042 0201 	orr.w	r2, r2, #1
 800181c:	601a      	str	r2, [r3, #0]
 800181e:	e005      	b.n	800182c <HAL_DMA_Start_IT+0xb6>
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8001820:	68fb      	ldr	r3, [r7, #12]
 8001822:	2200      	movs	r2, #0
 8001824:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Remain BUSY */
    status = HAL_BUSY;
 8001828:	2302      	movs	r3, #2
 800182a:	75fb      	strb	r3, [r7, #23]
  }
  return status;
 800182c:	7dfb      	ldrb	r3, [r7, #23]
}
 800182e:	4618      	mov	r0, r3
 8001830:	3718      	adds	r7, #24
 8001832:	46bd      	mov	sp, r7
 8001834:	bd80      	pop	{r7, pc}

08001836 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8001836:	b480      	push	{r7}
 8001838:	b085      	sub	sp, #20
 800183a:	af00      	add	r7, sp, #0
 800183c:	60f8      	str	r0, [r7, #12]
 800183e:	60b9      	str	r1, [r7, #8]
 8001840:	607a      	str	r2, [r7, #4]
 8001842:	603b      	str	r3, [r7, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
  }
#endif

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8001844:	68fb      	ldr	r3, [r7, #12]
 8001846:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001848:	f003 021c 	and.w	r2, r3, #28
 800184c:	68fb      	ldr	r3, [r7, #12]
 800184e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001850:	2101      	movs	r1, #1
 8001852:	fa01 f202 	lsl.w	r2, r1, r2
 8001856:	605a      	str	r2, [r3, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 8001858:	68fb      	ldr	r3, [r7, #12]
 800185a:	681b      	ldr	r3, [r3, #0]
 800185c:	683a      	ldr	r2, [r7, #0]
 800185e:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001860:	68fb      	ldr	r3, [r7, #12]
 8001862:	689b      	ldr	r3, [r3, #8]
 8001864:	2b10      	cmp	r3, #16
 8001866:	d108      	bne.n	800187a <DMA_SetConfig+0x44>
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8001868:	68fb      	ldr	r3, [r7, #12]
 800186a:	681b      	ldr	r3, [r3, #0]
 800186c:	687a      	ldr	r2, [r7, #4]
 800186e:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 8001870:	68fb      	ldr	r3, [r7, #12]
 8001872:	681b      	ldr	r3, [r3, #0]
 8001874:	68ba      	ldr	r2, [r7, #8]
 8001876:	60da      	str	r2, [r3, #12]
    hdma->Instance->CPAR = SrcAddress;

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
  }
}
 8001878:	e007      	b.n	800188a <DMA_SetConfig+0x54>
    hdma->Instance->CPAR = SrcAddress;
 800187a:	68fb      	ldr	r3, [r7, #12]
 800187c:	681b      	ldr	r3, [r3, #0]
 800187e:	68ba      	ldr	r2, [r7, #8]
 8001880:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = DstAddress;
 8001882:	68fb      	ldr	r3, [r7, #12]
 8001884:	681b      	ldr	r3, [r3, #0]
 8001886:	687a      	ldr	r2, [r7, #4]
 8001888:	60da      	str	r2, [r3, #12]
}
 800188a:	bf00      	nop
 800188c:	3714      	adds	r7, #20
 800188e:	46bd      	mov	sp, r7
 8001890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001894:	4770      	bx	lr
	...

08001898 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001898:	b480      	push	{r7}
 800189a:	b087      	sub	sp, #28
 800189c:	af00      	add	r7, sp, #0
 800189e:	6078      	str	r0, [r7, #4]
 80018a0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 80018a2:	2300      	movs	r3, #0
 80018a4:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80018a6:	e17f      	b.n	8001ba8 <HAL_GPIO_Init+0x310>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 80018a8:	683b      	ldr	r3, [r7, #0]
 80018aa:	681a      	ldr	r2, [r3, #0]
 80018ac:	2101      	movs	r1, #1
 80018ae:	697b      	ldr	r3, [r7, #20]
 80018b0:	fa01 f303 	lsl.w	r3, r1, r3
 80018b4:	4013      	ands	r3, r2
 80018b6:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 80018b8:	68fb      	ldr	r3, [r7, #12]
 80018ba:	2b00      	cmp	r3, #0
 80018bc:	f000 8171 	beq.w	8001ba2 <HAL_GPIO_Init+0x30a>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80018c0:	683b      	ldr	r3, [r7, #0]
 80018c2:	685b      	ldr	r3, [r3, #4]
 80018c4:	2b01      	cmp	r3, #1
 80018c6:	d00b      	beq.n	80018e0 <HAL_GPIO_Init+0x48>
 80018c8:	683b      	ldr	r3, [r7, #0]
 80018ca:	685b      	ldr	r3, [r3, #4]
 80018cc:	2b02      	cmp	r3, #2
 80018ce:	d007      	beq.n	80018e0 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80018d0:	683b      	ldr	r3, [r7, #0]
 80018d2:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80018d4:	2b11      	cmp	r3, #17
 80018d6:	d003      	beq.n	80018e0 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80018d8:	683b      	ldr	r3, [r7, #0]
 80018da:	685b      	ldr	r3, [r3, #4]
 80018dc:	2b12      	cmp	r3, #18
 80018de:	d130      	bne.n	8001942 <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 80018e0:	687b      	ldr	r3, [r7, #4]
 80018e2:	689b      	ldr	r3, [r3, #8]
 80018e4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 80018e6:	697b      	ldr	r3, [r7, #20]
 80018e8:	005b      	lsls	r3, r3, #1
 80018ea:	2203      	movs	r2, #3
 80018ec:	fa02 f303 	lsl.w	r3, r2, r3
 80018f0:	43db      	mvns	r3, r3
 80018f2:	693a      	ldr	r2, [r7, #16]
 80018f4:	4013      	ands	r3, r2
 80018f6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 80018f8:	683b      	ldr	r3, [r7, #0]
 80018fa:	68da      	ldr	r2, [r3, #12]
 80018fc:	697b      	ldr	r3, [r7, #20]
 80018fe:	005b      	lsls	r3, r3, #1
 8001900:	fa02 f303 	lsl.w	r3, r2, r3
 8001904:	693a      	ldr	r2, [r7, #16]
 8001906:	4313      	orrs	r3, r2
 8001908:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800190a:	687b      	ldr	r3, [r7, #4]
 800190c:	693a      	ldr	r2, [r7, #16]
 800190e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001910:	687b      	ldr	r3, [r7, #4]
 8001912:	685b      	ldr	r3, [r3, #4]
 8001914:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001916:	2201      	movs	r2, #1
 8001918:	697b      	ldr	r3, [r7, #20]
 800191a:	fa02 f303 	lsl.w	r3, r2, r3
 800191e:	43db      	mvns	r3, r3
 8001920:	693a      	ldr	r2, [r7, #16]
 8001922:	4013      	ands	r3, r2
 8001924:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8001926:	683b      	ldr	r3, [r7, #0]
 8001928:	685b      	ldr	r3, [r3, #4]
 800192a:	091b      	lsrs	r3, r3, #4
 800192c:	f003 0201 	and.w	r2, r3, #1
 8001930:	697b      	ldr	r3, [r7, #20]
 8001932:	fa02 f303 	lsl.w	r3, r2, r3
 8001936:	693a      	ldr	r2, [r7, #16]
 8001938:	4313      	orrs	r3, r2
 800193a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800193c:	687b      	ldr	r3, [r7, #4]
 800193e:	693a      	ldr	r2, [r7, #16]
 8001940:	605a      	str	r2, [r3, #4]
      }

#if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 8001942:	683b      	ldr	r3, [r7, #0]
 8001944:	685b      	ldr	r3, [r3, #4]
 8001946:	f003 0303 	and.w	r3, r3, #3
 800194a:	2b03      	cmp	r3, #3
 800194c:	d118      	bne.n	8001980 <HAL_GPIO_Init+0xe8>
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
 800194e:	687b      	ldr	r3, [r7, #4]
 8001950:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001952:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_ASCR_ASC0 << position) ;
 8001954:	2201      	movs	r2, #1
 8001956:	697b      	ldr	r3, [r7, #20]
 8001958:	fa02 f303 	lsl.w	r3, r2, r3
 800195c:	43db      	mvns	r3, r3
 800195e:	693a      	ldr	r2, [r7, #16]
 8001960:	4013      	ands	r3, r2
 8001962:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8001964:	683b      	ldr	r3, [r7, #0]
 8001966:	685b      	ldr	r3, [r3, #4]
 8001968:	08db      	lsrs	r3, r3, #3
 800196a:	f003 0201 	and.w	r2, r3, #1
 800196e:	697b      	ldr	r3, [r7, #20]
 8001970:	fa02 f303 	lsl.w	r3, r2, r3
 8001974:	693a      	ldr	r2, [r7, #16]
 8001976:	4313      	orrs	r3, r2
 8001978:	613b      	str	r3, [r7, #16]
        GPIOx->ASCR = temp;
 800197a:	687b      	ldr	r3, [r7, #4]
 800197c:	693a      	ldr	r2, [r7, #16]
 800197e:	62da      	str	r2, [r3, #44]	; 0x2c
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001980:	687b      	ldr	r3, [r7, #4]
 8001982:	68db      	ldr	r3, [r3, #12]
 8001984:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8001986:	697b      	ldr	r3, [r7, #20]
 8001988:	005b      	lsls	r3, r3, #1
 800198a:	2203      	movs	r2, #3
 800198c:	fa02 f303 	lsl.w	r3, r2, r3
 8001990:	43db      	mvns	r3, r3
 8001992:	693a      	ldr	r2, [r7, #16]
 8001994:	4013      	ands	r3, r2
 8001996:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8001998:	683b      	ldr	r3, [r7, #0]
 800199a:	689a      	ldr	r2, [r3, #8]
 800199c:	697b      	ldr	r3, [r7, #20]
 800199e:	005b      	lsls	r3, r3, #1
 80019a0:	fa02 f303 	lsl.w	r3, r2, r3
 80019a4:	693a      	ldr	r2, [r7, #16]
 80019a6:	4313      	orrs	r3, r2
 80019a8:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 80019aa:	687b      	ldr	r3, [r7, #4]
 80019ac:	693a      	ldr	r2, [r7, #16]
 80019ae:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80019b0:	683b      	ldr	r3, [r7, #0]
 80019b2:	685b      	ldr	r3, [r3, #4]
 80019b4:	2b02      	cmp	r3, #2
 80019b6:	d003      	beq.n	80019c0 <HAL_GPIO_Init+0x128>
 80019b8:	683b      	ldr	r3, [r7, #0]
 80019ba:	685b      	ldr	r3, [r3, #4]
 80019bc:	2b12      	cmp	r3, #18
 80019be:	d123      	bne.n	8001a08 <HAL_GPIO_Init+0x170>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 80019c0:	697b      	ldr	r3, [r7, #20]
 80019c2:	08da      	lsrs	r2, r3, #3
 80019c4:	687b      	ldr	r3, [r7, #4]
 80019c6:	3208      	adds	r2, #8
 80019c8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80019cc:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80019ce:	697b      	ldr	r3, [r7, #20]
 80019d0:	f003 0307 	and.w	r3, r3, #7
 80019d4:	009b      	lsls	r3, r3, #2
 80019d6:	220f      	movs	r2, #15
 80019d8:	fa02 f303 	lsl.w	r3, r2, r3
 80019dc:	43db      	mvns	r3, r3
 80019de:	693a      	ldr	r2, [r7, #16]
 80019e0:	4013      	ands	r3, r2
 80019e2:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80019e4:	683b      	ldr	r3, [r7, #0]
 80019e6:	691a      	ldr	r2, [r3, #16]
 80019e8:	697b      	ldr	r3, [r7, #20]
 80019ea:	f003 0307 	and.w	r3, r3, #7
 80019ee:	009b      	lsls	r3, r3, #2
 80019f0:	fa02 f303 	lsl.w	r3, r2, r3
 80019f4:	693a      	ldr	r2, [r7, #16]
 80019f6:	4313      	orrs	r3, r2
 80019f8:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 80019fa:	697b      	ldr	r3, [r7, #20]
 80019fc:	08da      	lsrs	r2, r3, #3
 80019fe:	687b      	ldr	r3, [r7, #4]
 8001a00:	3208      	adds	r2, #8
 8001a02:	6939      	ldr	r1, [r7, #16]
 8001a04:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001a08:	687b      	ldr	r3, [r7, #4]
 8001a0a:	681b      	ldr	r3, [r3, #0]
 8001a0c:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001a0e:	697b      	ldr	r3, [r7, #20]
 8001a10:	005b      	lsls	r3, r3, #1
 8001a12:	2203      	movs	r2, #3
 8001a14:	fa02 f303 	lsl.w	r3, r2, r3
 8001a18:	43db      	mvns	r3, r3
 8001a1a:	693a      	ldr	r2, [r7, #16]
 8001a1c:	4013      	ands	r3, r2
 8001a1e:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001a20:	683b      	ldr	r3, [r7, #0]
 8001a22:	685b      	ldr	r3, [r3, #4]
 8001a24:	f003 0203 	and.w	r2, r3, #3
 8001a28:	697b      	ldr	r3, [r7, #20]
 8001a2a:	005b      	lsls	r3, r3, #1
 8001a2c:	fa02 f303 	lsl.w	r3, r2, r3
 8001a30:	693a      	ldr	r2, [r7, #16]
 8001a32:	4313      	orrs	r3, r2
 8001a34:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8001a36:	687b      	ldr	r3, [r7, #4]
 8001a38:	693a      	ldr	r2, [r7, #16]
 8001a3a:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001a3c:	683b      	ldr	r3, [r7, #0]
 8001a3e:	685b      	ldr	r3, [r3, #4]
 8001a40:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001a44:	2b00      	cmp	r3, #0
 8001a46:	f000 80ac 	beq.w	8001ba2 <HAL_GPIO_Init+0x30a>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001a4a:	4b5f      	ldr	r3, [pc, #380]	; (8001bc8 <HAL_GPIO_Init+0x330>)
 8001a4c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001a4e:	4a5e      	ldr	r2, [pc, #376]	; (8001bc8 <HAL_GPIO_Init+0x330>)
 8001a50:	f043 0301 	orr.w	r3, r3, #1
 8001a54:	6613      	str	r3, [r2, #96]	; 0x60
 8001a56:	4b5c      	ldr	r3, [pc, #368]	; (8001bc8 <HAL_GPIO_Init+0x330>)
 8001a58:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001a5a:	f003 0301 	and.w	r3, r3, #1
 8001a5e:	60bb      	str	r3, [r7, #8]
 8001a60:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2u];
 8001a62:	4a5a      	ldr	r2, [pc, #360]	; (8001bcc <HAL_GPIO_Init+0x334>)
 8001a64:	697b      	ldr	r3, [r7, #20]
 8001a66:	089b      	lsrs	r3, r3, #2
 8001a68:	3302      	adds	r3, #2
 8001a6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001a6e:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001a70:	697b      	ldr	r3, [r7, #20]
 8001a72:	f003 0303 	and.w	r3, r3, #3
 8001a76:	009b      	lsls	r3, r3, #2
 8001a78:	220f      	movs	r2, #15
 8001a7a:	fa02 f303 	lsl.w	r3, r2, r3
 8001a7e:	43db      	mvns	r3, r3
 8001a80:	693a      	ldr	r2, [r7, #16]
 8001a82:	4013      	ands	r3, r2
 8001a84:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001a86:	687b      	ldr	r3, [r7, #4]
 8001a88:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 8001a8c:	d025      	beq.n	8001ada <HAL_GPIO_Init+0x242>
 8001a8e:	687b      	ldr	r3, [r7, #4]
 8001a90:	4a4f      	ldr	r2, [pc, #316]	; (8001bd0 <HAL_GPIO_Init+0x338>)
 8001a92:	4293      	cmp	r3, r2
 8001a94:	d01f      	beq.n	8001ad6 <HAL_GPIO_Init+0x23e>
 8001a96:	687b      	ldr	r3, [r7, #4]
 8001a98:	4a4e      	ldr	r2, [pc, #312]	; (8001bd4 <HAL_GPIO_Init+0x33c>)
 8001a9a:	4293      	cmp	r3, r2
 8001a9c:	d019      	beq.n	8001ad2 <HAL_GPIO_Init+0x23a>
 8001a9e:	687b      	ldr	r3, [r7, #4]
 8001aa0:	4a4d      	ldr	r2, [pc, #308]	; (8001bd8 <HAL_GPIO_Init+0x340>)
 8001aa2:	4293      	cmp	r3, r2
 8001aa4:	d013      	beq.n	8001ace <HAL_GPIO_Init+0x236>
 8001aa6:	687b      	ldr	r3, [r7, #4]
 8001aa8:	4a4c      	ldr	r2, [pc, #304]	; (8001bdc <HAL_GPIO_Init+0x344>)
 8001aaa:	4293      	cmp	r3, r2
 8001aac:	d00d      	beq.n	8001aca <HAL_GPIO_Init+0x232>
 8001aae:	687b      	ldr	r3, [r7, #4]
 8001ab0:	4a4b      	ldr	r2, [pc, #300]	; (8001be0 <HAL_GPIO_Init+0x348>)
 8001ab2:	4293      	cmp	r3, r2
 8001ab4:	d007      	beq.n	8001ac6 <HAL_GPIO_Init+0x22e>
 8001ab6:	687b      	ldr	r3, [r7, #4]
 8001ab8:	4a4a      	ldr	r2, [pc, #296]	; (8001be4 <HAL_GPIO_Init+0x34c>)
 8001aba:	4293      	cmp	r3, r2
 8001abc:	d101      	bne.n	8001ac2 <HAL_GPIO_Init+0x22a>
 8001abe:	2306      	movs	r3, #6
 8001ac0:	e00c      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ac2:	2307      	movs	r3, #7
 8001ac4:	e00a      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ac6:	2305      	movs	r3, #5
 8001ac8:	e008      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001aca:	2304      	movs	r3, #4
 8001acc:	e006      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ace:	2303      	movs	r3, #3
 8001ad0:	e004      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ad2:	2302      	movs	r3, #2
 8001ad4:	e002      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ad6:	2301      	movs	r3, #1
 8001ad8:	e000      	b.n	8001adc <HAL_GPIO_Init+0x244>
 8001ada:	2300      	movs	r3, #0
 8001adc:	697a      	ldr	r2, [r7, #20]
 8001ade:	f002 0203 	and.w	r2, r2, #3
 8001ae2:	0092      	lsls	r2, r2, #2
 8001ae4:	4093      	lsls	r3, r2
 8001ae6:	693a      	ldr	r2, [r7, #16]
 8001ae8:	4313      	orrs	r3, r2
 8001aea:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 8001aec:	4937      	ldr	r1, [pc, #220]	; (8001bcc <HAL_GPIO_Init+0x334>)
 8001aee:	697b      	ldr	r3, [r7, #20]
 8001af0:	089b      	lsrs	r3, r3, #2
 8001af2:	3302      	adds	r3, #2
 8001af4:	693a      	ldr	r2, [r7, #16]
 8001af6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001afa:	4b3b      	ldr	r3, [pc, #236]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001afc:	681b      	ldr	r3, [r3, #0]
 8001afe:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8001b00:	68fb      	ldr	r3, [r7, #12]
 8001b02:	43db      	mvns	r3, r3
 8001b04:	693a      	ldr	r2, [r7, #16]
 8001b06:	4013      	ands	r3, r2
 8001b08:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001b0a:	683b      	ldr	r3, [r7, #0]
 8001b0c:	685b      	ldr	r3, [r3, #4]
 8001b0e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001b12:	2b00      	cmp	r3, #0
 8001b14:	d003      	beq.n	8001b1e <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 8001b16:	693a      	ldr	r2, [r7, #16]
 8001b18:	68fb      	ldr	r3, [r7, #12]
 8001b1a:	4313      	orrs	r3, r2
 8001b1c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 8001b1e:	4a32      	ldr	r2, [pc, #200]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b20:	693b      	ldr	r3, [r7, #16]
 8001b22:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR1;
 8001b24:	4b30      	ldr	r3, [pc, #192]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b26:	685b      	ldr	r3, [r3, #4]
 8001b28:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8001b2a:	68fb      	ldr	r3, [r7, #12]
 8001b2c:	43db      	mvns	r3, r3
 8001b2e:	693a      	ldr	r2, [r7, #16]
 8001b30:	4013      	ands	r3, r2
 8001b32:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001b34:	683b      	ldr	r3, [r7, #0]
 8001b36:	685b      	ldr	r3, [r3, #4]
 8001b38:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001b3c:	2b00      	cmp	r3, #0
 8001b3e:	d003      	beq.n	8001b48 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
 8001b40:	693a      	ldr	r2, [r7, #16]
 8001b42:	68fb      	ldr	r3, [r7, #12]
 8001b44:	4313      	orrs	r3, r2
 8001b46:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 8001b48:	4a27      	ldr	r2, [pc, #156]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b4a:	693b      	ldr	r3, [r7, #16]
 8001b4c:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001b4e:	4b26      	ldr	r3, [pc, #152]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b50:	689b      	ldr	r3, [r3, #8]
 8001b52:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8001b54:	68fb      	ldr	r3, [r7, #12]
 8001b56:	43db      	mvns	r3, r3
 8001b58:	693a      	ldr	r2, [r7, #16]
 8001b5a:	4013      	ands	r3, r2
 8001b5c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001b5e:	683b      	ldr	r3, [r7, #0]
 8001b60:	685b      	ldr	r3, [r3, #4]
 8001b62:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001b66:	2b00      	cmp	r3, #0
 8001b68:	d003      	beq.n	8001b72 <HAL_GPIO_Init+0x2da>
        {
          temp |= iocurrent;
 8001b6a:	693a      	ldr	r2, [r7, #16]
 8001b6c:	68fb      	ldr	r3, [r7, #12]
 8001b6e:	4313      	orrs	r3, r2
 8001b70:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8001b72:	4a1d      	ldr	r2, [pc, #116]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b74:	693b      	ldr	r3, [r7, #16]
 8001b76:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR1;
 8001b78:	4b1b      	ldr	r3, [pc, #108]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b7a:	68db      	ldr	r3, [r3, #12]
 8001b7c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8001b7e:	68fb      	ldr	r3, [r7, #12]
 8001b80:	43db      	mvns	r3, r3
 8001b82:	693a      	ldr	r2, [r7, #16]
 8001b84:	4013      	ands	r3, r2
 8001b86:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001b88:	683b      	ldr	r3, [r7, #0]
 8001b8a:	685b      	ldr	r3, [r3, #4]
 8001b8c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001b90:	2b00      	cmp	r3, #0
 8001b92:	d003      	beq.n	8001b9c <HAL_GPIO_Init+0x304>
        {
          temp |= iocurrent;
 8001b94:	693a      	ldr	r2, [r7, #16]
 8001b96:	68fb      	ldr	r3, [r7, #12]
 8001b98:	4313      	orrs	r3, r2
 8001b9a:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8001b9c:	4a12      	ldr	r2, [pc, #72]	; (8001be8 <HAL_GPIO_Init+0x350>)
 8001b9e:	693b      	ldr	r3, [r7, #16]
 8001ba0:	60d3      	str	r3, [r2, #12]
      }
    }

    position++;
 8001ba2:	697b      	ldr	r3, [r7, #20]
 8001ba4:	3301      	adds	r3, #1
 8001ba6:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001ba8:	683b      	ldr	r3, [r7, #0]
 8001baa:	681a      	ldr	r2, [r3, #0]
 8001bac:	697b      	ldr	r3, [r7, #20]
 8001bae:	fa22 f303 	lsr.w	r3, r2, r3
 8001bb2:	2b00      	cmp	r3, #0
 8001bb4:	f47f ae78 	bne.w	80018a8 <HAL_GPIO_Init+0x10>
  }
}
 8001bb8:	bf00      	nop
 8001bba:	bf00      	nop
 8001bbc:	371c      	adds	r7, #28
 8001bbe:	46bd      	mov	sp, r7
 8001bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bc4:	4770      	bx	lr
 8001bc6:	bf00      	nop
 8001bc8:	40021000 	.word	0x40021000
 8001bcc:	40010000 	.word	0x40010000
 8001bd0:	48000400 	.word	0x48000400
 8001bd4:	48000800 	.word	0x48000800
 8001bd8:	48000c00 	.word	0x48000c00
 8001bdc:	48001000 	.word	0x48001000
 8001be0:	48001400 	.word	0x48001400
 8001be4:	48001800 	.word	0x48001800
 8001be8:	40010400 	.word	0x40010400

08001bec <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001bec:	b480      	push	{r7}
 8001bee:	b085      	sub	sp, #20
 8001bf0:	af00      	add	r7, sp, #0
 8001bf2:	6078      	str	r0, [r7, #4]
 8001bf4:	460b      	mov	r3, r1
 8001bf6:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8001bf8:	687b      	ldr	r3, [r7, #4]
 8001bfa:	691a      	ldr	r2, [r3, #16]
 8001bfc:	887b      	ldrh	r3, [r7, #2]
 8001bfe:	4013      	ands	r3, r2
 8001c00:	2b00      	cmp	r3, #0
 8001c02:	d002      	beq.n	8001c0a <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8001c04:	2301      	movs	r3, #1
 8001c06:	73fb      	strb	r3, [r7, #15]
 8001c08:	e001      	b.n	8001c0e <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8001c0a:	2300      	movs	r3, #0
 8001c0c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8001c0e:	7bfb      	ldrb	r3, [r7, #15]
}
 8001c10:	4618      	mov	r0, r3
 8001c12:	3714      	adds	r7, #20
 8001c14:	46bd      	mov	sp, r7
 8001c16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c1a:	4770      	bx	lr

08001c1c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001c1c:	b480      	push	{r7}
 8001c1e:	b083      	sub	sp, #12
 8001c20:	af00      	add	r7, sp, #0
 8001c22:	6078      	str	r0, [r7, #4]
 8001c24:	460b      	mov	r3, r1
 8001c26:	807b      	strh	r3, [r7, #2]
 8001c28:	4613      	mov	r3, r2
 8001c2a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001c2c:	787b      	ldrb	r3, [r7, #1]
 8001c2e:	2b00      	cmp	r3, #0
 8001c30:	d003      	beq.n	8001c3a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8001c32:	887a      	ldrh	r2, [r7, #2]
 8001c34:	687b      	ldr	r3, [r7, #4]
 8001c36:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8001c38:	e002      	b.n	8001c40 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8001c3a:	887a      	ldrh	r2, [r7, #2]
 8001c3c:	687b      	ldr	r3, [r7, #4]
 8001c3e:	629a      	str	r2, [r3, #40]	; 0x28
}
 8001c40:	bf00      	nop
 8001c42:	370c      	adds	r7, #12
 8001c44:	46bd      	mov	sp, r7
 8001c46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c4a:	4770      	bx	lr

08001c4c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8001c4c:	b580      	push	{r7, lr}
 8001c4e:	b082      	sub	sp, #8
 8001c50:	af00      	add	r7, sp, #0
 8001c52:	4603      	mov	r3, r0
 8001c54:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8001c56:	4b08      	ldr	r3, [pc, #32]	; (8001c78 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8001c58:	695a      	ldr	r2, [r3, #20]
 8001c5a:	88fb      	ldrh	r3, [r7, #6]
 8001c5c:	4013      	ands	r3, r2
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	d006      	beq.n	8001c70 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8001c62:	4a05      	ldr	r2, [pc, #20]	; (8001c78 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8001c64:	88fb      	ldrh	r3, [r7, #6]
 8001c66:	6153      	str	r3, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8001c68:	88fb      	ldrh	r3, [r7, #6]
 8001c6a:	4618      	mov	r0, r3
 8001c6c:	f011 ff92 	bl	8013b94 <HAL_GPIO_EXTI_Callback>
  }
}
 8001c70:	bf00      	nop
 8001c72:	3708      	adds	r7, #8
 8001c74:	46bd      	mov	sp, r7
 8001c76:	bd80      	pop	{r7, pc}
 8001c78:	40010400 	.word	0x40010400

08001c7c <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8001c7c:	b580      	push	{r7, lr}
 8001c7e:	b082      	sub	sp, #8
 8001c80:	af00      	add	r7, sp, #0
 8001c82:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8001c84:	687b      	ldr	r3, [r7, #4]
 8001c86:	2b00      	cmp	r3, #0
 8001c88:	d101      	bne.n	8001c8e <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 8001c8a:	2301      	movs	r3, #1
 8001c8c:	e081      	b.n	8001d92 <HAL_I2C_Init+0x116>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8001c8e:	687b      	ldr	r3, [r7, #4]
 8001c90:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8001c94:	b2db      	uxtb	r3, r3
 8001c96:	2b00      	cmp	r3, #0
 8001c98:	d106      	bne.n	8001ca8 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8001c9a:	687b      	ldr	r3, [r7, #4]
 8001c9c:	2200      	movs	r2, #0
 8001c9e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8001ca2:	6878      	ldr	r0, [r7, #4]
 8001ca4:	f7fe fff8 	bl	8000c98 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8001ca8:	687b      	ldr	r3, [r7, #4]
 8001caa:	2224      	movs	r2, #36	; 0x24
 8001cac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8001cb0:	687b      	ldr	r3, [r7, #4]
 8001cb2:	681b      	ldr	r3, [r3, #0]
 8001cb4:	681a      	ldr	r2, [r3, #0]
 8001cb6:	687b      	ldr	r3, [r7, #4]
 8001cb8:	681b      	ldr	r3, [r3, #0]
 8001cba:	f022 0201 	bic.w	r2, r2, #1
 8001cbe:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8001cc0:	687b      	ldr	r3, [r7, #4]
 8001cc2:	685a      	ldr	r2, [r3, #4]
 8001cc4:	687b      	ldr	r3, [r7, #4]
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001ccc:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8001cce:	687b      	ldr	r3, [r7, #4]
 8001cd0:	681b      	ldr	r3, [r3, #0]
 8001cd2:	689a      	ldr	r2, [r3, #8]
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	681b      	ldr	r3, [r3, #0]
 8001cd8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001cdc:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	68db      	ldr	r3, [r3, #12]
 8001ce2:	2b01      	cmp	r3, #1
 8001ce4:	d107      	bne.n	8001cf6 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8001ce6:	687b      	ldr	r3, [r7, #4]
 8001ce8:	689a      	ldr	r2, [r3, #8]
 8001cea:	687b      	ldr	r3, [r7, #4]
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001cf2:	609a      	str	r2, [r3, #8]
 8001cf4:	e006      	b.n	8001d04 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8001cf6:	687b      	ldr	r3, [r7, #4]
 8001cf8:	689a      	ldr	r2, [r3, #8]
 8001cfa:	687b      	ldr	r3, [r7, #4]
 8001cfc:	681b      	ldr	r3, [r3, #0]
 8001cfe:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
 8001d02:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8001d04:	687b      	ldr	r3, [r7, #4]
 8001d06:	68db      	ldr	r3, [r3, #12]
 8001d08:	2b02      	cmp	r3, #2
 8001d0a:	d104      	bne.n	8001d16 <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8001d0c:	687b      	ldr	r3, [r7, #4]
 8001d0e:	681b      	ldr	r3, [r3, #0]
 8001d10:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001d14:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8001d16:	687b      	ldr	r3, [r7, #4]
 8001d18:	681b      	ldr	r3, [r3, #0]
 8001d1a:	685b      	ldr	r3, [r3, #4]
 8001d1c:	687a      	ldr	r2, [r7, #4]
 8001d1e:	6812      	ldr	r2, [r2, #0]
 8001d20:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8001d24:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001d28:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8001d2a:	687b      	ldr	r3, [r7, #4]
 8001d2c:	681b      	ldr	r3, [r3, #0]
 8001d2e:	68da      	ldr	r2, [r3, #12]
 8001d30:	687b      	ldr	r3, [r7, #4]
 8001d32:	681b      	ldr	r3, [r3, #0]
 8001d34:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001d38:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8001d3a:	687b      	ldr	r3, [r7, #4]
 8001d3c:	691a      	ldr	r2, [r3, #16]
 8001d3e:	687b      	ldr	r3, [r7, #4]
 8001d40:	695b      	ldr	r3, [r3, #20]
 8001d42:	ea42 0103 	orr.w	r1, r2, r3
 8001d46:	687b      	ldr	r3, [r7, #4]
 8001d48:	699b      	ldr	r3, [r3, #24]
 8001d4a:	021a      	lsls	r2, r3, #8
 8001d4c:	687b      	ldr	r3, [r7, #4]
 8001d4e:	681b      	ldr	r3, [r3, #0]
 8001d50:	430a      	orrs	r2, r1
 8001d52:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001d54:	687b      	ldr	r3, [r7, #4]
 8001d56:	69d9      	ldr	r1, [r3, #28]
 8001d58:	687b      	ldr	r3, [r7, #4]
 8001d5a:	6a1a      	ldr	r2, [r3, #32]
 8001d5c:	687b      	ldr	r3, [r7, #4]
 8001d5e:	681b      	ldr	r3, [r3, #0]
 8001d60:	430a      	orrs	r2, r1
 8001d62:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8001d64:	687b      	ldr	r3, [r7, #4]
 8001d66:	681b      	ldr	r3, [r3, #0]
 8001d68:	681a      	ldr	r2, [r3, #0]
 8001d6a:	687b      	ldr	r3, [r7, #4]
 8001d6c:	681b      	ldr	r3, [r3, #0]
 8001d6e:	f042 0201 	orr.w	r2, r2, #1
 8001d72:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001d74:	687b      	ldr	r3, [r7, #4]
 8001d76:	2200      	movs	r2, #0
 8001d78:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	2220      	movs	r2, #32
 8001d7e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	2200      	movs	r2, #0
 8001d86:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d88:	687b      	ldr	r3, [r7, #4]
 8001d8a:	2200      	movs	r2, #0
 8001d8c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
 8001d90:	2300      	movs	r3, #0
}
 8001d92:	4618      	mov	r0, r3
 8001d94:	3708      	adds	r7, #8
 8001d96:	46bd      	mov	sp, r7
 8001d98:	bd80      	pop	{r7, pc}
	...

08001d9c <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 8001d9c:	b580      	push	{r7, lr}
 8001d9e:	b088      	sub	sp, #32
 8001da0:	af02      	add	r7, sp, #8
 8001da2:	60f8      	str	r0, [r7, #12]
 8001da4:	607a      	str	r2, [r7, #4]
 8001da6:	461a      	mov	r2, r3
 8001da8:	460b      	mov	r3, r1
 8001daa:	817b      	strh	r3, [r7, #10]
 8001dac:	4613      	mov	r3, r2
 8001dae:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001db0:	68fb      	ldr	r3, [r7, #12]
 8001db2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8001db6:	b2db      	uxtb	r3, r3
 8001db8:	2b20      	cmp	r3, #32
 8001dba:	f040 80da 	bne.w	8001f72 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001dbe:	68fb      	ldr	r3, [r7, #12]
 8001dc0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8001dc4:	2b01      	cmp	r3, #1
 8001dc6:	d101      	bne.n	8001dcc <HAL_I2C_Master_Transmit+0x30>
 8001dc8:	2302      	movs	r3, #2
 8001dca:	e0d3      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
 8001dcc:	68fb      	ldr	r3, [r7, #12]
 8001dce:	2201      	movs	r2, #1
 8001dd0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8001dd4:	f7ff fb5c 	bl	8001490 <HAL_GetTick>
 8001dd8:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001dda:	697b      	ldr	r3, [r7, #20]
 8001ddc:	9300      	str	r3, [sp, #0]
 8001dde:	2319      	movs	r3, #25
 8001de0:	2201      	movs	r2, #1
 8001de2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001de6:	68f8      	ldr	r0, [r7, #12]
 8001de8:	f000 f9e6 	bl	80021b8 <I2C_WaitOnFlagUntilTimeout>
 8001dec:	4603      	mov	r3, r0
 8001dee:	2b00      	cmp	r3, #0
 8001df0:	d001      	beq.n	8001df6 <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
 8001df2:	2301      	movs	r3, #1
 8001df4:	e0be      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8001df6:	68fb      	ldr	r3, [r7, #12]
 8001df8:	2221      	movs	r2, #33	; 0x21
 8001dfa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8001dfe:	68fb      	ldr	r3, [r7, #12]
 8001e00:	2210      	movs	r2, #16
 8001e02:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001e06:	68fb      	ldr	r3, [r7, #12]
 8001e08:	2200      	movs	r2, #0
 8001e0a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8001e0c:	68fb      	ldr	r3, [r7, #12]
 8001e0e:	687a      	ldr	r2, [r7, #4]
 8001e10:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 8001e12:	68fb      	ldr	r3, [r7, #12]
 8001e14:	893a      	ldrh	r2, [r7, #8]
 8001e16:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8001e18:	68fb      	ldr	r3, [r7, #12]
 8001e1a:	2200      	movs	r2, #0
 8001e1c:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001e1e:	68fb      	ldr	r3, [r7, #12]
 8001e20:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001e22:	b29b      	uxth	r3, r3
 8001e24:	2bff      	cmp	r3, #255	; 0xff
 8001e26:	d90e      	bls.n	8001e46 <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8001e28:	68fb      	ldr	r3, [r7, #12]
 8001e2a:	22ff      	movs	r2, #255	; 0xff
 8001e2c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8001e2e:	68fb      	ldr	r3, [r7, #12]
 8001e30:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001e32:	b2da      	uxtb	r2, r3
 8001e34:	8979      	ldrh	r1, [r7, #10]
 8001e36:	4b51      	ldr	r3, [pc, #324]	; (8001f7c <HAL_I2C_Master_Transmit+0x1e0>)
 8001e38:	9300      	str	r3, [sp, #0]
 8001e3a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001e3e:	68f8      	ldr	r0, [r7, #12]
 8001e40:	f000 fb48 	bl	80024d4 <I2C_TransferConfig>
 8001e44:	e06c      	b.n	8001f20 <HAL_I2C_Master_Transmit+0x184>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8001e46:	68fb      	ldr	r3, [r7, #12]
 8001e48:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001e4a:	b29a      	uxth	r2, r3
 8001e4c:	68fb      	ldr	r3, [r7, #12]
 8001e4e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 8001e50:	68fb      	ldr	r3, [r7, #12]
 8001e52:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001e54:	b2da      	uxtb	r2, r3
 8001e56:	8979      	ldrh	r1, [r7, #10]
 8001e58:	4b48      	ldr	r3, [pc, #288]	; (8001f7c <HAL_I2C_Master_Transmit+0x1e0>)
 8001e5a:	9300      	str	r3, [sp, #0]
 8001e5c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001e60:	68f8      	ldr	r0, [r7, #12]
 8001e62:	f000 fb37 	bl	80024d4 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
 8001e66:	e05b      	b.n	8001f20 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001e68:	697a      	ldr	r2, [r7, #20]
 8001e6a:	6a39      	ldr	r1, [r7, #32]
 8001e6c:	68f8      	ldr	r0, [r7, #12]
 8001e6e:	f000 f9e3 	bl	8002238 <I2C_WaitOnTXISFlagUntilTimeout>
 8001e72:	4603      	mov	r3, r0
 8001e74:	2b00      	cmp	r3, #0
 8001e76:	d001      	beq.n	8001e7c <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
 8001e78:	2301      	movs	r3, #1
 8001e7a:	e07b      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8001e7c:	68fb      	ldr	r3, [r7, #12]
 8001e7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e80:	781a      	ldrb	r2, [r3, #0]
 8001e82:	68fb      	ldr	r3, [r7, #12]
 8001e84:	681b      	ldr	r3, [r3, #0]
 8001e86:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8001e88:	68fb      	ldr	r3, [r7, #12]
 8001e8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e8c:	1c5a      	adds	r2, r3, #1
 8001e8e:	68fb      	ldr	r3, [r7, #12]
 8001e90:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 8001e92:	68fb      	ldr	r3, [r7, #12]
 8001e94:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001e96:	b29b      	uxth	r3, r3
 8001e98:	3b01      	subs	r3, #1
 8001e9a:	b29a      	uxth	r2, r3
 8001e9c:	68fb      	ldr	r3, [r7, #12]
 8001e9e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 8001ea0:	68fb      	ldr	r3, [r7, #12]
 8001ea2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001ea4:	3b01      	subs	r3, #1
 8001ea6:	b29a      	uxth	r2, r3
 8001ea8:	68fb      	ldr	r3, [r7, #12]
 8001eaa:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001eac:	68fb      	ldr	r3, [r7, #12]
 8001eae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001eb0:	b29b      	uxth	r3, r3
 8001eb2:	2b00      	cmp	r3, #0
 8001eb4:	d034      	beq.n	8001f20 <HAL_I2C_Master_Transmit+0x184>
 8001eb6:	68fb      	ldr	r3, [r7, #12]
 8001eb8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001eba:	2b00      	cmp	r3, #0
 8001ebc:	d130      	bne.n	8001f20 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8001ebe:	697b      	ldr	r3, [r7, #20]
 8001ec0:	9300      	str	r3, [sp, #0]
 8001ec2:	6a3b      	ldr	r3, [r7, #32]
 8001ec4:	2200      	movs	r2, #0
 8001ec6:	2180      	movs	r1, #128	; 0x80
 8001ec8:	68f8      	ldr	r0, [r7, #12]
 8001eca:	f000 f975 	bl	80021b8 <I2C_WaitOnFlagUntilTimeout>
 8001ece:	4603      	mov	r3, r0
 8001ed0:	2b00      	cmp	r3, #0
 8001ed2:	d001      	beq.n	8001ed8 <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
 8001ed4:	2301      	movs	r3, #1
 8001ed6:	e04d      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001ed8:	68fb      	ldr	r3, [r7, #12]
 8001eda:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001edc:	b29b      	uxth	r3, r3
 8001ede:	2bff      	cmp	r3, #255	; 0xff
 8001ee0:	d90e      	bls.n	8001f00 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8001ee2:	68fb      	ldr	r3, [r7, #12]
 8001ee4:	22ff      	movs	r2, #255	; 0xff
 8001ee6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8001ee8:	68fb      	ldr	r3, [r7, #12]
 8001eea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001eec:	b2da      	uxtb	r2, r3
 8001eee:	8979      	ldrh	r1, [r7, #10]
 8001ef0:	2300      	movs	r3, #0
 8001ef2:	9300      	str	r3, [sp, #0]
 8001ef4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001ef8:	68f8      	ldr	r0, [r7, #12]
 8001efa:	f000 faeb 	bl	80024d4 <I2C_TransferConfig>
 8001efe:	e00f      	b.n	8001f20 <HAL_I2C_Master_Transmit+0x184>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8001f00:	68fb      	ldr	r3, [r7, #12]
 8001f02:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001f04:	b29a      	uxth	r2, r3
 8001f06:	68fb      	ldr	r3, [r7, #12]
 8001f08:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001f0a:	68fb      	ldr	r3, [r7, #12]
 8001f0c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8001f0e:	b2da      	uxtb	r2, r3
 8001f10:	8979      	ldrh	r1, [r7, #10]
 8001f12:	2300      	movs	r3, #0
 8001f14:	9300      	str	r3, [sp, #0]
 8001f16:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001f1a:	68f8      	ldr	r0, [r7, #12]
 8001f1c:	f000 fada 	bl	80024d4 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8001f20:	68fb      	ldr	r3, [r7, #12]
 8001f22:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8001f24:	b29b      	uxth	r3, r3
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d19e      	bne.n	8001e68 <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001f2a:	697a      	ldr	r2, [r7, #20]
 8001f2c:	6a39      	ldr	r1, [r7, #32]
 8001f2e:	68f8      	ldr	r0, [r7, #12]
 8001f30:	f000 f9c2 	bl	80022b8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8001f34:	4603      	mov	r3, r0
 8001f36:	2b00      	cmp	r3, #0
 8001f38:	d001      	beq.n	8001f3e <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
 8001f3a:	2301      	movs	r3, #1
 8001f3c:	e01a      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001f3e:	68fb      	ldr	r3, [r7, #12]
 8001f40:	681b      	ldr	r3, [r3, #0]
 8001f42:	2220      	movs	r2, #32
 8001f44:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8001f46:	68fb      	ldr	r3, [r7, #12]
 8001f48:	681b      	ldr	r3, [r3, #0]
 8001f4a:	6859      	ldr	r1, [r3, #4]
 8001f4c:	68fb      	ldr	r3, [r7, #12]
 8001f4e:	681a      	ldr	r2, [r3, #0]
 8001f50:	4b0b      	ldr	r3, [pc, #44]	; (8001f80 <HAL_I2C_Master_Transmit+0x1e4>)
 8001f52:	400b      	ands	r3, r1
 8001f54:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8001f56:	68fb      	ldr	r3, [r7, #12]
 8001f58:	2220      	movs	r2, #32
 8001f5a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8001f5e:	68fb      	ldr	r3, [r7, #12]
 8001f60:	2200      	movs	r2, #0
 8001f62:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001f66:	68fb      	ldr	r3, [r7, #12]
 8001f68:	2200      	movs	r2, #0
 8001f6a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 8001f6e:	2300      	movs	r3, #0
 8001f70:	e000      	b.n	8001f74 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
 8001f72:	2302      	movs	r3, #2
  }
}
 8001f74:	4618      	mov	r0, r3
 8001f76:	3718      	adds	r7, #24
 8001f78:	46bd      	mov	sp, r7
 8001f7a:	bd80      	pop	{r7, pc}
 8001f7c:	80002000 	.word	0x80002000
 8001f80:	fe00e800 	.word	0xfe00e800

08001f84 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 8001f84:	b580      	push	{r7, lr}
 8001f86:	b088      	sub	sp, #32
 8001f88:	af02      	add	r7, sp, #8
 8001f8a:	60f8      	str	r0, [r7, #12]
 8001f8c:	607a      	str	r2, [r7, #4]
 8001f8e:	461a      	mov	r2, r3
 8001f90:	460b      	mov	r3, r1
 8001f92:	817b      	strh	r3, [r7, #10]
 8001f94:	4613      	mov	r3, r2
 8001f96:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001f98:	68fb      	ldr	r3, [r7, #12]
 8001f9a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8001f9e:	b2db      	uxtb	r3, r3
 8001fa0:	2b20      	cmp	r3, #32
 8001fa2:	f040 80db 	bne.w	800215c <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001fa6:	68fb      	ldr	r3, [r7, #12]
 8001fa8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8001fac:	2b01      	cmp	r3, #1
 8001fae:	d101      	bne.n	8001fb4 <HAL_I2C_Master_Receive+0x30>
 8001fb0:	2302      	movs	r3, #2
 8001fb2:	e0d4      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
 8001fb4:	68fb      	ldr	r3, [r7, #12]
 8001fb6:	2201      	movs	r2, #1
 8001fb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8001fbc:	f7ff fa68 	bl	8001490 <HAL_GetTick>
 8001fc0:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001fc2:	697b      	ldr	r3, [r7, #20]
 8001fc4:	9300      	str	r3, [sp, #0]
 8001fc6:	2319      	movs	r3, #25
 8001fc8:	2201      	movs	r2, #1
 8001fca:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001fce:	68f8      	ldr	r0, [r7, #12]
 8001fd0:	f000 f8f2 	bl	80021b8 <I2C_WaitOnFlagUntilTimeout>
 8001fd4:	4603      	mov	r3, r0
 8001fd6:	2b00      	cmp	r3, #0
 8001fd8:	d001      	beq.n	8001fde <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
 8001fda:	2301      	movs	r3, #1
 8001fdc:	e0bf      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8001fde:	68fb      	ldr	r3, [r7, #12]
 8001fe0:	2222      	movs	r2, #34	; 0x22
 8001fe2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8001fe6:	68fb      	ldr	r3, [r7, #12]
 8001fe8:	2210      	movs	r2, #16
 8001fea:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001fee:	68fb      	ldr	r3, [r7, #12]
 8001ff0:	2200      	movs	r2, #0
 8001ff2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8001ff4:	68fb      	ldr	r3, [r7, #12]
 8001ff6:	687a      	ldr	r2, [r7, #4]
 8001ff8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 8001ffa:	68fb      	ldr	r3, [r7, #12]
 8001ffc:	893a      	ldrh	r2, [r7, #8]
 8001ffe:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8002000:	68fb      	ldr	r3, [r7, #12]
 8002002:	2200      	movs	r2, #0
 8002004:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8002006:	68fb      	ldr	r3, [r7, #12]
 8002008:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800200a:	b29b      	uxth	r3, r3
 800200c:	2bff      	cmp	r3, #255	; 0xff
 800200e:	d90e      	bls.n	800202e <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8002010:	68fb      	ldr	r3, [r7, #12]
 8002012:	22ff      	movs	r2, #255	; 0xff
 8002014:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8002016:	68fb      	ldr	r3, [r7, #12]
 8002018:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800201a:	b2da      	uxtb	r2, r3
 800201c:	8979      	ldrh	r1, [r7, #10]
 800201e:	4b52      	ldr	r3, [pc, #328]	; (8002168 <HAL_I2C_Master_Receive+0x1e4>)
 8002020:	9300      	str	r3, [sp, #0]
 8002022:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002026:	68f8      	ldr	r0, [r7, #12]
 8002028:	f000 fa54 	bl	80024d4 <I2C_TransferConfig>
 800202c:	e06d      	b.n	800210a <HAL_I2C_Master_Receive+0x186>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800202e:	68fb      	ldr	r3, [r7, #12]
 8002030:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8002032:	b29a      	uxth	r2, r3
 8002034:	68fb      	ldr	r3, [r7, #12]
 8002036:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8002038:	68fb      	ldr	r3, [r7, #12]
 800203a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800203c:	b2da      	uxtb	r2, r3
 800203e:	8979      	ldrh	r1, [r7, #10]
 8002040:	4b49      	ldr	r3, [pc, #292]	; (8002168 <HAL_I2C_Master_Receive+0x1e4>)
 8002042:	9300      	str	r3, [sp, #0]
 8002044:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8002048:	68f8      	ldr	r0, [r7, #12]
 800204a:	f000 fa43 	bl	80024d4 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
 800204e:	e05c      	b.n	800210a <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002050:	697a      	ldr	r2, [r7, #20]
 8002052:	6a39      	ldr	r1, [r7, #32]
 8002054:	68f8      	ldr	r0, [r7, #12]
 8002056:	f000 f96b 	bl	8002330 <I2C_WaitOnRXNEFlagUntilTimeout>
 800205a:	4603      	mov	r3, r0
 800205c:	2b00      	cmp	r3, #0
 800205e:	d001      	beq.n	8002064 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
 8002060:	2301      	movs	r3, #1
 8002062:	e07c      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8002064:	68fb      	ldr	r3, [r7, #12]
 8002066:	681b      	ldr	r3, [r3, #0]
 8002068:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800206a:	68fb      	ldr	r3, [r7, #12]
 800206c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800206e:	b2d2      	uxtb	r2, r2
 8002070:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8002072:	68fb      	ldr	r3, [r7, #12]
 8002074:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002076:	1c5a      	adds	r2, r3, #1
 8002078:	68fb      	ldr	r3, [r7, #12]
 800207a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 800207c:	68fb      	ldr	r3, [r7, #12]
 800207e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002080:	3b01      	subs	r3, #1
 8002082:	b29a      	uxth	r2, r3
 8002084:	68fb      	ldr	r3, [r7, #12]
 8002086:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8002088:	68fb      	ldr	r3, [r7, #12]
 800208a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800208c:	b29b      	uxth	r3, r3
 800208e:	3b01      	subs	r3, #1
 8002090:	b29a      	uxth	r2, r3
 8002092:	68fb      	ldr	r3, [r7, #12]
 8002094:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002096:	68fb      	ldr	r3, [r7, #12]
 8002098:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800209a:	b29b      	uxth	r3, r3
 800209c:	2b00      	cmp	r3, #0
 800209e:	d034      	beq.n	800210a <HAL_I2C_Master_Receive+0x186>
 80020a0:	68fb      	ldr	r3, [r7, #12]
 80020a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80020a4:	2b00      	cmp	r3, #0
 80020a6:	d130      	bne.n	800210a <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80020a8:	697b      	ldr	r3, [r7, #20]
 80020aa:	9300      	str	r3, [sp, #0]
 80020ac:	6a3b      	ldr	r3, [r7, #32]
 80020ae:	2200      	movs	r2, #0
 80020b0:	2180      	movs	r1, #128	; 0x80
 80020b2:	68f8      	ldr	r0, [r7, #12]
 80020b4:	f000 f880 	bl	80021b8 <I2C_WaitOnFlagUntilTimeout>
 80020b8:	4603      	mov	r3, r0
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d001      	beq.n	80020c2 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
 80020be:	2301      	movs	r3, #1
 80020c0:	e04d      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80020c2:	68fb      	ldr	r3, [r7, #12]
 80020c4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80020c6:	b29b      	uxth	r3, r3
 80020c8:	2bff      	cmp	r3, #255	; 0xff
 80020ca:	d90e      	bls.n	80020ea <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80020cc:	68fb      	ldr	r3, [r7, #12]
 80020ce:	22ff      	movs	r2, #255	; 0xff
 80020d0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 80020d2:	68fb      	ldr	r3, [r7, #12]
 80020d4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80020d6:	b2da      	uxtb	r2, r3
 80020d8:	8979      	ldrh	r1, [r7, #10]
 80020da:	2300      	movs	r3, #0
 80020dc:	9300      	str	r3, [sp, #0]
 80020de:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80020e2:	68f8      	ldr	r0, [r7, #12]
 80020e4:	f000 f9f6 	bl	80024d4 <I2C_TransferConfig>
 80020e8:	e00f      	b.n	800210a <HAL_I2C_Master_Receive+0x186>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 80020ea:	68fb      	ldr	r3, [r7, #12]
 80020ec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80020ee:	b29a      	uxth	r2, r3
 80020f0:	68fb      	ldr	r3, [r7, #12]
 80020f2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80020f4:	68fb      	ldr	r3, [r7, #12]
 80020f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80020f8:	b2da      	uxtb	r2, r3
 80020fa:	8979      	ldrh	r1, [r7, #10]
 80020fc:	2300      	movs	r3, #0
 80020fe:	9300      	str	r3, [sp, #0]
 8002100:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8002104:	68f8      	ldr	r0, [r7, #12]
 8002106:	f000 f9e5 	bl	80024d4 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 800210a:	68fb      	ldr	r3, [r7, #12]
 800210c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800210e:	b29b      	uxth	r3, r3
 8002110:	2b00      	cmp	r3, #0
 8002112:	d19d      	bne.n	8002050 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002114:	697a      	ldr	r2, [r7, #20]
 8002116:	6a39      	ldr	r1, [r7, #32]
 8002118:	68f8      	ldr	r0, [r7, #12]
 800211a:	f000 f8cd 	bl	80022b8 <I2C_WaitOnSTOPFlagUntilTimeout>
 800211e:	4603      	mov	r3, r0
 8002120:	2b00      	cmp	r3, #0
 8002122:	d001      	beq.n	8002128 <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
 8002124:	2301      	movs	r3, #1
 8002126:	e01a      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002128:	68fb      	ldr	r3, [r7, #12]
 800212a:	681b      	ldr	r3, [r3, #0]
 800212c:	2220      	movs	r2, #32
 800212e:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002130:	68fb      	ldr	r3, [r7, #12]
 8002132:	681b      	ldr	r3, [r3, #0]
 8002134:	6859      	ldr	r1, [r3, #4]
 8002136:	68fb      	ldr	r3, [r7, #12]
 8002138:	681a      	ldr	r2, [r3, #0]
 800213a:	4b0c      	ldr	r3, [pc, #48]	; (800216c <HAL_I2C_Master_Receive+0x1e8>)
 800213c:	400b      	ands	r3, r1
 800213e:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8002140:	68fb      	ldr	r3, [r7, #12]
 8002142:	2220      	movs	r2, #32
 8002144:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8002148:	68fb      	ldr	r3, [r7, #12]
 800214a:	2200      	movs	r2, #0
 800214c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002150:	68fb      	ldr	r3, [r7, #12]
 8002152:	2200      	movs	r2, #0
 8002154:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 8002158:	2300      	movs	r3, #0
 800215a:	e000      	b.n	800215e <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
 800215c:	2302      	movs	r3, #2
  }
}
 800215e:	4618      	mov	r0, r3
 8002160:	3718      	adds	r7, #24
 8002162:	46bd      	mov	sp, r7
 8002164:	bd80      	pop	{r7, pc}
 8002166:	bf00      	nop
 8002168:	80002400 	.word	0x80002400
 800216c:	fe00e800 	.word	0xfe00e800

08002170 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 8002170:	b480      	push	{r7}
 8002172:	b083      	sub	sp, #12
 8002174:	af00      	add	r7, sp, #0
 8002176:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8002178:	687b      	ldr	r3, [r7, #4]
 800217a:	681b      	ldr	r3, [r3, #0]
 800217c:	699b      	ldr	r3, [r3, #24]
 800217e:	f003 0302 	and.w	r3, r3, #2
 8002182:	2b02      	cmp	r3, #2
 8002184:	d103      	bne.n	800218e <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 8002186:	687b      	ldr	r3, [r7, #4]
 8002188:	681b      	ldr	r3, [r3, #0]
 800218a:	2200      	movs	r2, #0
 800218c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800218e:	687b      	ldr	r3, [r7, #4]
 8002190:	681b      	ldr	r3, [r3, #0]
 8002192:	699b      	ldr	r3, [r3, #24]
 8002194:	f003 0301 	and.w	r3, r3, #1
 8002198:	2b01      	cmp	r3, #1
 800219a:	d007      	beq.n	80021ac <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800219c:	687b      	ldr	r3, [r7, #4]
 800219e:	681b      	ldr	r3, [r3, #0]
 80021a0:	699a      	ldr	r2, [r3, #24]
 80021a2:	687b      	ldr	r3, [r7, #4]
 80021a4:	681b      	ldr	r3, [r3, #0]
 80021a6:	f042 0201 	orr.w	r2, r2, #1
 80021aa:	619a      	str	r2, [r3, #24]
  }
}
 80021ac:	bf00      	nop
 80021ae:	370c      	adds	r7, #12
 80021b0:	46bd      	mov	sp, r7
 80021b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021b6:	4770      	bx	lr

080021b8 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 80021b8:	b580      	push	{r7, lr}
 80021ba:	b084      	sub	sp, #16
 80021bc:	af00      	add	r7, sp, #0
 80021be:	60f8      	str	r0, [r7, #12]
 80021c0:	60b9      	str	r1, [r7, #8]
 80021c2:	603b      	str	r3, [r7, #0]
 80021c4:	4613      	mov	r3, r2
 80021c6:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80021c8:	e022      	b.n	8002210 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80021ca:	683b      	ldr	r3, [r7, #0]
 80021cc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80021d0:	d01e      	beq.n	8002210 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80021d2:	f7ff f95d 	bl	8001490 <HAL_GetTick>
 80021d6:	4602      	mov	r2, r0
 80021d8:	69bb      	ldr	r3, [r7, #24]
 80021da:	1ad3      	subs	r3, r2, r3
 80021dc:	683a      	ldr	r2, [r7, #0]
 80021de:	429a      	cmp	r2, r3
 80021e0:	d302      	bcc.n	80021e8 <I2C_WaitOnFlagUntilTimeout+0x30>
 80021e2:	683b      	ldr	r3, [r7, #0]
 80021e4:	2b00      	cmp	r3, #0
 80021e6:	d113      	bne.n	8002210 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80021e8:	68fb      	ldr	r3, [r7, #12]
 80021ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80021ec:	f043 0220 	orr.w	r2, r3, #32
 80021f0:	68fb      	ldr	r3, [r7, #12]
 80021f2:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80021f4:	68fb      	ldr	r3, [r7, #12]
 80021f6:	2220      	movs	r2, #32
 80021f8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80021fc:	68fb      	ldr	r3, [r7, #12]
 80021fe:	2200      	movs	r2, #0
 8002200:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002204:	68fb      	ldr	r3, [r7, #12]
 8002206:	2200      	movs	r2, #0
 8002208:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
 800220c:	2301      	movs	r3, #1
 800220e:	e00f      	b.n	8002230 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8002210:	68fb      	ldr	r3, [r7, #12]
 8002212:	681b      	ldr	r3, [r3, #0]
 8002214:	699a      	ldr	r2, [r3, #24]
 8002216:	68bb      	ldr	r3, [r7, #8]
 8002218:	4013      	ands	r3, r2
 800221a:	68ba      	ldr	r2, [r7, #8]
 800221c:	429a      	cmp	r2, r3
 800221e:	bf0c      	ite	eq
 8002220:	2301      	moveq	r3, #1
 8002222:	2300      	movne	r3, #0
 8002224:	b2db      	uxtb	r3, r3
 8002226:	461a      	mov	r2, r3
 8002228:	79fb      	ldrb	r3, [r7, #7]
 800222a:	429a      	cmp	r2, r3
 800222c:	d0cd      	beq.n	80021ca <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800222e:	2300      	movs	r3, #0
}
 8002230:	4618      	mov	r0, r3
 8002232:	3710      	adds	r7, #16
 8002234:	46bd      	mov	sp, r7
 8002236:	bd80      	pop	{r7, pc}

08002238 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8002238:	b580      	push	{r7, lr}
 800223a:	b084      	sub	sp, #16
 800223c:	af00      	add	r7, sp, #0
 800223e:	60f8      	str	r0, [r7, #12]
 8002240:	60b9      	str	r1, [r7, #8]
 8002242:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8002244:	e02c      	b.n	80022a0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8002246:	687a      	ldr	r2, [r7, #4]
 8002248:	68b9      	ldr	r1, [r7, #8]
 800224a:	68f8      	ldr	r0, [r7, #12]
 800224c:	f000 f8dc 	bl	8002408 <I2C_IsAcknowledgeFailed>
 8002250:	4603      	mov	r3, r0
 8002252:	2b00      	cmp	r3, #0
 8002254:	d001      	beq.n	800225a <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8002256:	2301      	movs	r3, #1
 8002258:	e02a      	b.n	80022b0 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800225a:	68bb      	ldr	r3, [r7, #8]
 800225c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002260:	d01e      	beq.n	80022a0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002262:	f7ff f915 	bl	8001490 <HAL_GetTick>
 8002266:	4602      	mov	r2, r0
 8002268:	687b      	ldr	r3, [r7, #4]
 800226a:	1ad3      	subs	r3, r2, r3
 800226c:	68ba      	ldr	r2, [r7, #8]
 800226e:	429a      	cmp	r2, r3
 8002270:	d302      	bcc.n	8002278 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 8002272:	68bb      	ldr	r3, [r7, #8]
 8002274:	2b00      	cmp	r3, #0
 8002276:	d113      	bne.n	80022a0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002278:	68fb      	ldr	r3, [r7, #12]
 800227a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800227c:	f043 0220 	orr.w	r2, r3, #32
 8002280:	68fb      	ldr	r3, [r7, #12]
 8002282:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002284:	68fb      	ldr	r3, [r7, #12]
 8002286:	2220      	movs	r2, #32
 8002288:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800228c:	68fb      	ldr	r3, [r7, #12]
 800228e:	2200      	movs	r2, #0
 8002290:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002294:	68fb      	ldr	r3, [r7, #12]
 8002296:	2200      	movs	r2, #0
 8002298:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
 800229c:	2301      	movs	r3, #1
 800229e:	e007      	b.n	80022b0 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80022a0:	68fb      	ldr	r3, [r7, #12]
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	699b      	ldr	r3, [r3, #24]
 80022a6:	f003 0302 	and.w	r3, r3, #2
 80022aa:	2b02      	cmp	r3, #2
 80022ac:	d1cb      	bne.n	8002246 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 80022ae:	2300      	movs	r3, #0
}
 80022b0:	4618      	mov	r0, r3
 80022b2:	3710      	adds	r7, #16
 80022b4:	46bd      	mov	sp, r7
 80022b6:	bd80      	pop	{r7, pc}

080022b8 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 80022b8:	b580      	push	{r7, lr}
 80022ba:	b084      	sub	sp, #16
 80022bc:	af00      	add	r7, sp, #0
 80022be:	60f8      	str	r0, [r7, #12]
 80022c0:	60b9      	str	r1, [r7, #8]
 80022c2:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80022c4:	e028      	b.n	8002318 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80022c6:	687a      	ldr	r2, [r7, #4]
 80022c8:	68b9      	ldr	r1, [r7, #8]
 80022ca:	68f8      	ldr	r0, [r7, #12]
 80022cc:	f000 f89c 	bl	8002408 <I2C_IsAcknowledgeFailed>
 80022d0:	4603      	mov	r3, r0
 80022d2:	2b00      	cmp	r3, #0
 80022d4:	d001      	beq.n	80022da <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 80022d6:	2301      	movs	r3, #1
 80022d8:	e026      	b.n	8002328 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80022da:	f7ff f8d9 	bl	8001490 <HAL_GetTick>
 80022de:	4602      	mov	r2, r0
 80022e0:	687b      	ldr	r3, [r7, #4]
 80022e2:	1ad3      	subs	r3, r2, r3
 80022e4:	68ba      	ldr	r2, [r7, #8]
 80022e6:	429a      	cmp	r2, r3
 80022e8:	d302      	bcc.n	80022f0 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 80022ea:	68bb      	ldr	r3, [r7, #8]
 80022ec:	2b00      	cmp	r3, #0
 80022ee:	d113      	bne.n	8002318 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80022f0:	68fb      	ldr	r3, [r7, #12]
 80022f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80022f4:	f043 0220 	orr.w	r2, r3, #32
 80022f8:	68fb      	ldr	r3, [r7, #12]
 80022fa:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 80022fc:	68fb      	ldr	r3, [r7, #12]
 80022fe:	2220      	movs	r2, #32
 8002300:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002304:	68fb      	ldr	r3, [r7, #12]
 8002306:	2200      	movs	r2, #0
 8002308:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800230c:	68fb      	ldr	r3, [r7, #12]
 800230e:	2200      	movs	r2, #0
 8002310:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 8002314:	2301      	movs	r3, #1
 8002316:	e007      	b.n	8002328 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002318:	68fb      	ldr	r3, [r7, #12]
 800231a:	681b      	ldr	r3, [r3, #0]
 800231c:	699b      	ldr	r3, [r3, #24]
 800231e:	f003 0320 	and.w	r3, r3, #32
 8002322:	2b20      	cmp	r3, #32
 8002324:	d1cf      	bne.n	80022c6 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 8002326:	2300      	movs	r3, #0
}
 8002328:	4618      	mov	r0, r3
 800232a:	3710      	adds	r7, #16
 800232c:	46bd      	mov	sp, r7
 800232e:	bd80      	pop	{r7, pc}

08002330 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8002330:	b580      	push	{r7, lr}
 8002332:	b084      	sub	sp, #16
 8002334:	af00      	add	r7, sp, #0
 8002336:	60f8      	str	r0, [r7, #12]
 8002338:	60b9      	str	r1, [r7, #8]
 800233a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800233c:	e055      	b.n	80023ea <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800233e:	687a      	ldr	r2, [r7, #4]
 8002340:	68b9      	ldr	r1, [r7, #8]
 8002342:	68f8      	ldr	r0, [r7, #12]
 8002344:	f000 f860 	bl	8002408 <I2C_IsAcknowledgeFailed>
 8002348:	4603      	mov	r3, r0
 800234a:	2b00      	cmp	r3, #0
 800234c:	d001      	beq.n	8002352 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800234e:	2301      	movs	r3, #1
 8002350:	e053      	b.n	80023fa <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8002352:	68fb      	ldr	r3, [r7, #12]
 8002354:	681b      	ldr	r3, [r3, #0]
 8002356:	699b      	ldr	r3, [r3, #24]
 8002358:	f003 0320 	and.w	r3, r3, #32
 800235c:	2b20      	cmp	r3, #32
 800235e:	d129      	bne.n	80023b4 <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 8002360:	68fb      	ldr	r3, [r7, #12]
 8002362:	681b      	ldr	r3, [r3, #0]
 8002364:	699b      	ldr	r3, [r3, #24]
 8002366:	f003 0304 	and.w	r3, r3, #4
 800236a:	2b04      	cmp	r3, #4
 800236c:	d105      	bne.n	800237a <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
 800236e:	68fb      	ldr	r3, [r7, #12]
 8002370:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002372:	2b00      	cmp	r3, #0
 8002374:	d001      	beq.n	800237a <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
 8002376:	2300      	movs	r3, #0
 8002378:	e03f      	b.n	80023fa <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800237a:	68fb      	ldr	r3, [r7, #12]
 800237c:	681b      	ldr	r3, [r3, #0]
 800237e:	2220      	movs	r2, #32
 8002380:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8002382:	68fb      	ldr	r3, [r7, #12]
 8002384:	681b      	ldr	r3, [r3, #0]
 8002386:	6859      	ldr	r1, [r3, #4]
 8002388:	68fb      	ldr	r3, [r7, #12]
 800238a:	681a      	ldr	r2, [r3, #0]
 800238c:	4b1d      	ldr	r3, [pc, #116]	; (8002404 <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
 800238e:	400b      	ands	r3, r1
 8002390:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002392:	68fb      	ldr	r3, [r7, #12]
 8002394:	2200      	movs	r2, #0
 8002396:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002398:	68fb      	ldr	r3, [r7, #12]
 800239a:	2220      	movs	r2, #32
 800239c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80023a0:	68fb      	ldr	r3, [r7, #12]
 80023a2:	2200      	movs	r2, #0
 80023a4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80023a8:	68fb      	ldr	r3, [r7, #12]
 80023aa:	2200      	movs	r2, #0
 80023ac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
 80023b0:	2301      	movs	r3, #1
 80023b2:	e022      	b.n	80023fa <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80023b4:	f7ff f86c 	bl	8001490 <HAL_GetTick>
 80023b8:	4602      	mov	r2, r0
 80023ba:	687b      	ldr	r3, [r7, #4]
 80023bc:	1ad3      	subs	r3, r2, r3
 80023be:	68ba      	ldr	r2, [r7, #8]
 80023c0:	429a      	cmp	r2, r3
 80023c2:	d302      	bcc.n	80023ca <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
 80023c4:	68bb      	ldr	r3, [r7, #8]
 80023c6:	2b00      	cmp	r3, #0
 80023c8:	d10f      	bne.n	80023ea <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80023ca:	68fb      	ldr	r3, [r7, #12]
 80023cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80023ce:	f043 0220 	orr.w	r2, r3, #32
 80023d2:	68fb      	ldr	r3, [r7, #12]
 80023d4:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 80023d6:	68fb      	ldr	r3, [r7, #12]
 80023d8:	2220      	movs	r2, #32
 80023da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80023de:	68fb      	ldr	r3, [r7, #12]
 80023e0:	2200      	movs	r2, #0
 80023e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 80023e6:	2301      	movs	r3, #1
 80023e8:	e007      	b.n	80023fa <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 80023ea:	68fb      	ldr	r3, [r7, #12]
 80023ec:	681b      	ldr	r3, [r3, #0]
 80023ee:	699b      	ldr	r3, [r3, #24]
 80023f0:	f003 0304 	and.w	r3, r3, #4
 80023f4:	2b04      	cmp	r3, #4
 80023f6:	d1a2      	bne.n	800233e <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 80023f8:	2300      	movs	r3, #0
}
 80023fa:	4618      	mov	r0, r3
 80023fc:	3710      	adds	r7, #16
 80023fe:	46bd      	mov	sp, r7
 8002400:	bd80      	pop	{r7, pc}
 8002402:	bf00      	nop
 8002404:	fe00e800 	.word	0xfe00e800

08002408 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8002408:	b580      	push	{r7, lr}
 800240a:	b084      	sub	sp, #16
 800240c:	af00      	add	r7, sp, #0
 800240e:	60f8      	str	r0, [r7, #12]
 8002410:	60b9      	str	r1, [r7, #8]
 8002412:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002414:	68fb      	ldr	r3, [r7, #12]
 8002416:	681b      	ldr	r3, [r3, #0]
 8002418:	699b      	ldr	r3, [r3, #24]
 800241a:	f003 0310 	and.w	r3, r3, #16
 800241e:	2b10      	cmp	r3, #16
 8002420:	d151      	bne.n	80024c6 <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002422:	e022      	b.n	800246a <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8002424:	68bb      	ldr	r3, [r7, #8]
 8002426:	f1b3 3fff 	cmp.w	r3, #4294967295
 800242a:	d01e      	beq.n	800246a <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800242c:	f7ff f830 	bl	8001490 <HAL_GetTick>
 8002430:	4602      	mov	r2, r0
 8002432:	687b      	ldr	r3, [r7, #4]
 8002434:	1ad3      	subs	r3, r2, r3
 8002436:	68ba      	ldr	r2, [r7, #8]
 8002438:	429a      	cmp	r2, r3
 800243a:	d302      	bcc.n	8002442 <I2C_IsAcknowledgeFailed+0x3a>
 800243c:	68bb      	ldr	r3, [r7, #8]
 800243e:	2b00      	cmp	r3, #0
 8002440:	d113      	bne.n	800246a <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002442:	68fb      	ldr	r3, [r7, #12]
 8002444:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002446:	f043 0220 	orr.w	r2, r3, #32
 800244a:	68fb      	ldr	r3, [r7, #12]
 800244c:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 800244e:	68fb      	ldr	r3, [r7, #12]
 8002450:	2220      	movs	r2, #32
 8002452:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8002456:	68fb      	ldr	r3, [r7, #12]
 8002458:	2200      	movs	r2, #0
 800245a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800245e:	68fb      	ldr	r3, [r7, #12]
 8002460:	2200      	movs	r2, #0
 8002462:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
 8002466:	2301      	movs	r3, #1
 8002468:	e02e      	b.n	80024c8 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800246a:	68fb      	ldr	r3, [r7, #12]
 800246c:	681b      	ldr	r3, [r3, #0]
 800246e:	699b      	ldr	r3, [r3, #24]
 8002470:	f003 0320 	and.w	r3, r3, #32
 8002474:	2b20      	cmp	r3, #32
 8002476:	d1d5      	bne.n	8002424 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002478:	68fb      	ldr	r3, [r7, #12]
 800247a:	681b      	ldr	r3, [r3, #0]
 800247c:	2210      	movs	r2, #16
 800247e:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002480:	68fb      	ldr	r3, [r7, #12]
 8002482:	681b      	ldr	r3, [r3, #0]
 8002484:	2220      	movs	r2, #32
 8002486:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 8002488:	68f8      	ldr	r0, [r7, #12]
 800248a:	f7ff fe71 	bl	8002170 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800248e:	68fb      	ldr	r3, [r7, #12]
 8002490:	681b      	ldr	r3, [r3, #0]
 8002492:	6859      	ldr	r1, [r3, #4]
 8002494:	68fb      	ldr	r3, [r7, #12]
 8002496:	681a      	ldr	r2, [r3, #0]
 8002498:	4b0d      	ldr	r3, [pc, #52]	; (80024d0 <I2C_IsAcknowledgeFailed+0xc8>)
 800249a:	400b      	ands	r3, r1
 800249c:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800249e:	68fb      	ldr	r3, [r7, #12]
 80024a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80024a2:	f043 0204 	orr.w	r2, r3, #4
 80024a6:	68fb      	ldr	r3, [r7, #12]
 80024a8:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80024aa:	68fb      	ldr	r3, [r7, #12]
 80024ac:	2220      	movs	r2, #32
 80024ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80024b2:	68fb      	ldr	r3, [r7, #12]
 80024b4:	2200      	movs	r2, #0
 80024b6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80024ba:	68fb      	ldr	r3, [r7, #12]
 80024bc:	2200      	movs	r2, #0
 80024be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
 80024c2:	2301      	movs	r3, #1
 80024c4:	e000      	b.n	80024c8 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
 80024c6:	2300      	movs	r3, #0
}
 80024c8:	4618      	mov	r0, r3
 80024ca:	3710      	adds	r7, #16
 80024cc:	46bd      	mov	sp, r7
 80024ce:	bd80      	pop	{r7, pc}
 80024d0:	fe00e800 	.word	0xfe00e800

080024d4 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 80024d4:	b480      	push	{r7}
 80024d6:	b085      	sub	sp, #20
 80024d8:	af00      	add	r7, sp, #0
 80024da:	60f8      	str	r0, [r7, #12]
 80024dc:	607b      	str	r3, [r7, #4]
 80024de:	460b      	mov	r3, r1
 80024e0:	817b      	strh	r3, [r7, #10]
 80024e2:	4613      	mov	r3, r2
 80024e4:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 80024e6:	68fb      	ldr	r3, [r7, #12]
 80024e8:	681b      	ldr	r3, [r3, #0]
 80024ea:	685a      	ldr	r2, [r3, #4]
 80024ec:	69bb      	ldr	r3, [r7, #24]
 80024ee:	0d5b      	lsrs	r3, r3, #21
 80024f0:	f403 6180 	and.w	r1, r3, #1024	; 0x400
 80024f4:	4b0d      	ldr	r3, [pc, #52]	; (800252c <I2C_TransferConfig+0x58>)
 80024f6:	430b      	orrs	r3, r1
 80024f8:	43db      	mvns	r3, r3
 80024fa:	ea02 0103 	and.w	r1, r2, r3
 80024fe:	897b      	ldrh	r3, [r7, #10]
 8002500:	f3c3 0209 	ubfx	r2, r3, #0, #10
 8002504:	7a7b      	ldrb	r3, [r7, #9]
 8002506:	041b      	lsls	r3, r3, #16
 8002508:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800250c:	431a      	orrs	r2, r3
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	431a      	orrs	r2, r3
 8002512:	69bb      	ldr	r3, [r7, #24]
 8002514:	431a      	orrs	r2, r3
 8002516:	68fb      	ldr	r3, [r7, #12]
 8002518:	681b      	ldr	r3, [r3, #0]
 800251a:	430a      	orrs	r2, r1
 800251c:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 800251e:	bf00      	nop
 8002520:	3714      	adds	r7, #20
 8002522:	46bd      	mov	sp, r7
 8002524:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002528:	4770      	bx	lr
 800252a:	bf00      	nop
 800252c:	03ff63ff 	.word	0x03ff63ff

08002530 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8002530:	b480      	push	{r7}
 8002532:	b083      	sub	sp, #12
 8002534:	af00      	add	r7, sp, #0
 8002536:	6078      	str	r0, [r7, #4]
 8002538:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800253a:	687b      	ldr	r3, [r7, #4]
 800253c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002540:	b2db      	uxtb	r3, r3
 8002542:	2b20      	cmp	r3, #32
 8002544:	d138      	bne.n	80025b8 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002546:	687b      	ldr	r3, [r7, #4]
 8002548:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800254c:	2b01      	cmp	r3, #1
 800254e:	d101      	bne.n	8002554 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 8002550:	2302      	movs	r3, #2
 8002552:	e032      	b.n	80025ba <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 8002554:	687b      	ldr	r3, [r7, #4]
 8002556:	2201      	movs	r2, #1
 8002558:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800255c:	687b      	ldr	r3, [r7, #4]
 800255e:	2224      	movs	r2, #36	; 0x24
 8002560:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8002564:	687b      	ldr	r3, [r7, #4]
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	681a      	ldr	r2, [r3, #0]
 800256a:	687b      	ldr	r3, [r7, #4]
 800256c:	681b      	ldr	r3, [r3, #0]
 800256e:	f022 0201 	bic.w	r2, r2, #1
 8002572:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	681b      	ldr	r3, [r3, #0]
 8002578:	681a      	ldr	r2, [r3, #0]
 800257a:	687b      	ldr	r3, [r7, #4]
 800257c:	681b      	ldr	r3, [r3, #0]
 800257e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8002582:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8002584:	687b      	ldr	r3, [r7, #4]
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	6819      	ldr	r1, [r3, #0]
 800258a:	687b      	ldr	r3, [r7, #4]
 800258c:	681b      	ldr	r3, [r3, #0]
 800258e:	683a      	ldr	r2, [r7, #0]
 8002590:	430a      	orrs	r2, r1
 8002592:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8002594:	687b      	ldr	r3, [r7, #4]
 8002596:	681b      	ldr	r3, [r3, #0]
 8002598:	681a      	ldr	r2, [r3, #0]
 800259a:	687b      	ldr	r3, [r7, #4]
 800259c:	681b      	ldr	r3, [r3, #0]
 800259e:	f042 0201 	orr.w	r2, r2, #1
 80025a2:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80025a4:	687b      	ldr	r3, [r7, #4]
 80025a6:	2220      	movs	r2, #32
 80025a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80025ac:	687b      	ldr	r3, [r7, #4]
 80025ae:	2200      	movs	r2, #0
 80025b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 80025b4:	2300      	movs	r3, #0
 80025b6:	e000      	b.n	80025ba <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 80025b8:	2302      	movs	r3, #2
  }
}
 80025ba:	4618      	mov	r0, r3
 80025bc:	370c      	adds	r7, #12
 80025be:	46bd      	mov	sp, r7
 80025c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80025c4:	4770      	bx	lr

080025c6 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 80025c6:	b480      	push	{r7}
 80025c8:	b085      	sub	sp, #20
 80025ca:	af00      	add	r7, sp, #0
 80025cc:	6078      	str	r0, [r7, #4]
 80025ce:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80025d0:	687b      	ldr	r3, [r7, #4]
 80025d2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80025d6:	b2db      	uxtb	r3, r3
 80025d8:	2b20      	cmp	r3, #32
 80025da:	d139      	bne.n	8002650 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80025e2:	2b01      	cmp	r3, #1
 80025e4:	d101      	bne.n	80025ea <HAL_I2CEx_ConfigDigitalFilter+0x24>
 80025e6:	2302      	movs	r3, #2
 80025e8:	e033      	b.n	8002652 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	2201      	movs	r2, #1
 80025ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 80025f2:	687b      	ldr	r3, [r7, #4]
 80025f4:	2224      	movs	r2, #36	; 0x24
 80025f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	681b      	ldr	r3, [r3, #0]
 80025fe:	681a      	ldr	r2, [r3, #0]
 8002600:	687b      	ldr	r3, [r7, #4]
 8002602:	681b      	ldr	r3, [r3, #0]
 8002604:	f022 0201 	bic.w	r2, r2, #1
 8002608:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 800260a:	687b      	ldr	r3, [r7, #4]
 800260c:	681b      	ldr	r3, [r3, #0]
 800260e:	681b      	ldr	r3, [r3, #0]
 8002610:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8002612:	68fb      	ldr	r3, [r7, #12]
 8002614:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8002618:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800261a:	683b      	ldr	r3, [r7, #0]
 800261c:	021b      	lsls	r3, r3, #8
 800261e:	68fa      	ldr	r2, [r7, #12]
 8002620:	4313      	orrs	r3, r2
 8002622:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8002624:	687b      	ldr	r3, [r7, #4]
 8002626:	681b      	ldr	r3, [r3, #0]
 8002628:	68fa      	ldr	r2, [r7, #12]
 800262a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800262c:	687b      	ldr	r3, [r7, #4]
 800262e:	681b      	ldr	r3, [r3, #0]
 8002630:	681a      	ldr	r2, [r3, #0]
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	681b      	ldr	r3, [r3, #0]
 8002636:	f042 0201 	orr.w	r2, r2, #1
 800263a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800263c:	687b      	ldr	r3, [r7, #4]
 800263e:	2220      	movs	r2, #32
 8002640:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	2200      	movs	r2, #0
 8002648:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800264c:	2300      	movs	r3, #0
 800264e:	e000      	b.n	8002652 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 8002650:	2302      	movs	r3, #2
  }
}
 8002652:	4618      	mov	r0, r3
 8002654:	3714      	adds	r7, #20
 8002656:	46bd      	mov	sp, r7
 8002658:	f85d 7b04 	ldr.w	r7, [sp], #4
 800265c:	4770      	bx	lr
	...

08002660 <HAL_PWR_EnableBkUpAccess>:
  * @note  LSEON bit that switches on and off the LSE crystal belongs as well to the
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 8002660:	b480      	push	{r7}
 8002662:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8002664:	4b05      	ldr	r3, [pc, #20]	; (800267c <HAL_PWR_EnableBkUpAccess+0x1c>)
 8002666:	681b      	ldr	r3, [r3, #0]
 8002668:	4a04      	ldr	r2, [pc, #16]	; (800267c <HAL_PWR_EnableBkUpAccess+0x1c>)
 800266a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800266e:	6013      	str	r3, [r2, #0]
}
 8002670:	bf00      	nop
 8002672:	46bd      	mov	sp, r7
 8002674:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002678:	4770      	bx	lr
 800267a:	bf00      	nop
 800267c:	40007000 	.word	0x40007000

08002680 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8002680:	b480      	push	{r7}
 8002682:	af00      	add	r7, sp, #0
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8002684:	4b04      	ldr	r3, [pc, #16]	; (8002698 <HAL_PWREx_GetVoltageRange+0x18>)
 8002686:	681b      	ldr	r3, [r3, #0]
 8002688:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
#endif
}
 800268c:	4618      	mov	r0, r3
 800268e:	46bd      	mov	sp, r7
 8002690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002694:	4770      	bx	lr
 8002696:	bf00      	nop
 8002698:	40007000 	.word	0x40007000

0800269c <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 800269c:	b480      	push	{r7}
 800269e:	b085      	sub	sp, #20
 80026a0:	af00      	add	r7, sp, #0
 80026a2:	6078      	str	r0, [r7, #4]
  }

#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80026a4:	687b      	ldr	r3, [r7, #4]
 80026a6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80026aa:	d130      	bne.n	800270e <HAL_PWREx_ControlVoltageScaling+0x72>
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 80026ac:	4b23      	ldr	r3, [pc, #140]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80026ae:	681b      	ldr	r3, [r3, #0]
 80026b0:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80026b4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80026b8:	d038      	beq.n	800272c <HAL_PWREx_ControlVoltageScaling+0x90>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80026ba:	4b20      	ldr	r3, [pc, #128]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80026bc:	681b      	ldr	r3, [r3, #0]
 80026be:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80026c2:	4a1e      	ldr	r2, [pc, #120]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80026c4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80026c8:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80026ca:	4b1d      	ldr	r3, [pc, #116]	; (8002740 <HAL_PWREx_ControlVoltageScaling+0xa4>)
 80026cc:	681b      	ldr	r3, [r3, #0]
 80026ce:	2232      	movs	r2, #50	; 0x32
 80026d0:	fb02 f303 	mul.w	r3, r2, r3
 80026d4:	4a1b      	ldr	r2, [pc, #108]	; (8002744 <HAL_PWREx_ControlVoltageScaling+0xa8>)
 80026d6:	fba2 2303 	umull	r2, r3, r2, r3
 80026da:	0c9b      	lsrs	r3, r3, #18
 80026dc:	3301      	adds	r3, #1
 80026de:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80026e0:	e002      	b.n	80026e8 <HAL_PWREx_ControlVoltageScaling+0x4c>
      {
        wait_loop_index--;
 80026e2:	68fb      	ldr	r3, [r7, #12]
 80026e4:	3b01      	subs	r3, #1
 80026e6:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80026e8:	4b14      	ldr	r3, [pc, #80]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80026ea:	695b      	ldr	r3, [r3, #20]
 80026ec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80026f0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80026f4:	d102      	bne.n	80026fc <HAL_PWREx_ControlVoltageScaling+0x60>
 80026f6:	68fb      	ldr	r3, [r7, #12]
 80026f8:	2b00      	cmp	r3, #0
 80026fa:	d1f2      	bne.n	80026e2 <HAL_PWREx_ControlVoltageScaling+0x46>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80026fc:	4b0f      	ldr	r3, [pc, #60]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80026fe:	695b      	ldr	r3, [r3, #20]
 8002700:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002704:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002708:	d110      	bne.n	800272c <HAL_PWREx_ControlVoltageScaling+0x90>
      {
        return HAL_TIMEOUT;
 800270a:	2303      	movs	r3, #3
 800270c:	e00f      	b.n	800272e <HAL_PWREx_ControlVoltageScaling+0x92>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 800270e:	4b0b      	ldr	r3, [pc, #44]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 8002710:	681b      	ldr	r3, [r3, #0]
 8002712:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8002716:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800271a:	d007      	beq.n	800272c <HAL_PWREx_ControlVoltageScaling+0x90>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800271c:	4b07      	ldr	r3, [pc, #28]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 800271e:	681b      	ldr	r3, [r3, #0]
 8002720:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8002724:	4a05      	ldr	r2, [pc, #20]	; (800273c <HAL_PWREx_ControlVoltageScaling+0xa0>)
 8002726:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800272a:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 800272c:	2300      	movs	r3, #0
}
 800272e:	4618      	mov	r0, r3
 8002730:	3714      	adds	r7, #20
 8002732:	46bd      	mov	sp, r7
 8002734:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002738:	4770      	bx	lr
 800273a:	bf00      	nop
 800273c:	40007000 	.word	0x40007000
 8002740:	20000000 	.word	0x20000000
 8002744:	431bde83 	.word	0x431bde83

08002748 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002748:	b580      	push	{r7, lr}
 800274a:	b088      	sub	sp, #32
 800274c:	af00      	add	r7, sp, #0
 800274e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	2b00      	cmp	r3, #0
 8002754:	d101      	bne.n	800275a <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8002756:	2301      	movs	r3, #1
 8002758:	e3d8      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800275a:	4b97      	ldr	r3, [pc, #604]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800275c:	689b      	ldr	r3, [r3, #8]
 800275e:	f003 030c 	and.w	r3, r3, #12
 8002762:	61bb      	str	r3, [r7, #24]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002764:	4b94      	ldr	r3, [pc, #592]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002766:	68db      	ldr	r3, [r3, #12]
 8002768:	f003 0303 	and.w	r3, r3, #3
 800276c:	617b      	str	r3, [r7, #20]

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800276e:	687b      	ldr	r3, [r7, #4]
 8002770:	681b      	ldr	r3, [r3, #0]
 8002772:	f003 0310 	and.w	r3, r3, #16
 8002776:	2b00      	cmp	r3, #0
 8002778:	f000 80e4 	beq.w	8002944 <HAL_RCC_OscConfig+0x1fc>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 800277c:	69bb      	ldr	r3, [r7, #24]
 800277e:	2b00      	cmp	r3, #0
 8002780:	d007      	beq.n	8002792 <HAL_RCC_OscConfig+0x4a>
 8002782:	69bb      	ldr	r3, [r7, #24]
 8002784:	2b0c      	cmp	r3, #12
 8002786:	f040 808b 	bne.w	80028a0 <HAL_RCC_OscConfig+0x158>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 800278a:	697b      	ldr	r3, [r7, #20]
 800278c:	2b01      	cmp	r3, #1
 800278e:	f040 8087 	bne.w	80028a0 <HAL_RCC_OscConfig+0x158>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8002792:	4b89      	ldr	r3, [pc, #548]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002794:	681b      	ldr	r3, [r3, #0]
 8002796:	f003 0302 	and.w	r3, r3, #2
 800279a:	2b00      	cmp	r3, #0
 800279c:	d005      	beq.n	80027aa <HAL_RCC_OscConfig+0x62>
 800279e:	687b      	ldr	r3, [r7, #4]
 80027a0:	699b      	ldr	r3, [r3, #24]
 80027a2:	2b00      	cmp	r3, #0
 80027a4:	d101      	bne.n	80027aa <HAL_RCC_OscConfig+0x62>
      {
        return HAL_ERROR;
 80027a6:	2301      	movs	r3, #1
 80027a8:	e3b0      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80027aa:	687b      	ldr	r3, [r7, #4]
 80027ac:	6a1a      	ldr	r2, [r3, #32]
 80027ae:	4b82      	ldr	r3, [pc, #520]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027b0:	681b      	ldr	r3, [r3, #0]
 80027b2:	f003 0308 	and.w	r3, r3, #8
 80027b6:	2b00      	cmp	r3, #0
 80027b8:	d004      	beq.n	80027c4 <HAL_RCC_OscConfig+0x7c>
 80027ba:	4b7f      	ldr	r3, [pc, #508]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027bc:	681b      	ldr	r3, [r3, #0]
 80027be:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80027c2:	e005      	b.n	80027d0 <HAL_RCC_OscConfig+0x88>
 80027c4:	4b7c      	ldr	r3, [pc, #496]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027c6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80027ca:	091b      	lsrs	r3, r3, #4
 80027cc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80027d0:	4293      	cmp	r3, r2
 80027d2:	d223      	bcs.n	800281c <HAL_RCC_OscConfig+0xd4>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	6a1b      	ldr	r3, [r3, #32]
 80027d8:	4618      	mov	r0, r3
 80027da:	f000 fd43 	bl	8003264 <RCC_SetFlashLatencyFromMSIRange>
 80027de:	4603      	mov	r3, r0
 80027e0:	2b00      	cmp	r3, #0
 80027e2:	d001      	beq.n	80027e8 <HAL_RCC_OscConfig+0xa0>
          {
            return HAL_ERROR;
 80027e4:	2301      	movs	r3, #1
 80027e6:	e391      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80027e8:	4b73      	ldr	r3, [pc, #460]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027ea:	681b      	ldr	r3, [r3, #0]
 80027ec:	4a72      	ldr	r2, [pc, #456]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027ee:	f043 0308 	orr.w	r3, r3, #8
 80027f2:	6013      	str	r3, [r2, #0]
 80027f4:	4b70      	ldr	r3, [pc, #448]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80027f6:	681b      	ldr	r3, [r3, #0]
 80027f8:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80027fc:	687b      	ldr	r3, [r7, #4]
 80027fe:	6a1b      	ldr	r3, [r3, #32]
 8002800:	496d      	ldr	r1, [pc, #436]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002802:	4313      	orrs	r3, r2
 8002804:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002806:	4b6c      	ldr	r3, [pc, #432]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002808:	685b      	ldr	r3, [r3, #4]
 800280a:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 800280e:	687b      	ldr	r3, [r7, #4]
 8002810:	69db      	ldr	r3, [r3, #28]
 8002812:	021b      	lsls	r3, r3, #8
 8002814:	4968      	ldr	r1, [pc, #416]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002816:	4313      	orrs	r3, r2
 8002818:	604b      	str	r3, [r1, #4]
 800281a:	e025      	b.n	8002868 <HAL_RCC_OscConfig+0x120>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800281c:	4b66      	ldr	r3, [pc, #408]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800281e:	681b      	ldr	r3, [r3, #0]
 8002820:	4a65      	ldr	r2, [pc, #404]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002822:	f043 0308 	orr.w	r3, r3, #8
 8002826:	6013      	str	r3, [r2, #0]
 8002828:	4b63      	ldr	r3, [pc, #396]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800282a:	681b      	ldr	r3, [r3, #0]
 800282c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8002830:	687b      	ldr	r3, [r7, #4]
 8002832:	6a1b      	ldr	r3, [r3, #32]
 8002834:	4960      	ldr	r1, [pc, #384]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002836:	4313      	orrs	r3, r2
 8002838:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800283a:	4b5f      	ldr	r3, [pc, #380]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800283c:	685b      	ldr	r3, [r3, #4]
 800283e:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8002842:	687b      	ldr	r3, [r7, #4]
 8002844:	69db      	ldr	r3, [r3, #28]
 8002846:	021b      	lsls	r3, r3, #8
 8002848:	495b      	ldr	r1, [pc, #364]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800284a:	4313      	orrs	r3, r2
 800284c:	604b      	str	r3, [r1, #4]

          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 800284e:	69bb      	ldr	r3, [r7, #24]
 8002850:	2b00      	cmp	r3, #0
 8002852:	d109      	bne.n	8002868 <HAL_RCC_OscConfig+0x120>
          {
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8002854:	687b      	ldr	r3, [r7, #4]
 8002856:	6a1b      	ldr	r3, [r3, #32]
 8002858:	4618      	mov	r0, r3
 800285a:	f000 fd03 	bl	8003264 <RCC_SetFlashLatencyFromMSIRange>
 800285e:	4603      	mov	r3, r0
 8002860:	2b00      	cmp	r3, #0
 8002862:	d001      	beq.n	8002868 <HAL_RCC_OscConfig+0x120>
            {
              return HAL_ERROR;
 8002864:	2301      	movs	r3, #1
 8002866:	e351      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002868:	f000 fc38 	bl	80030dc <HAL_RCC_GetSysClockFreq>
 800286c:	4602      	mov	r2, r0
 800286e:	4b52      	ldr	r3, [pc, #328]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002870:	689b      	ldr	r3, [r3, #8]
 8002872:	091b      	lsrs	r3, r3, #4
 8002874:	f003 030f 	and.w	r3, r3, #15
 8002878:	4950      	ldr	r1, [pc, #320]	; (80029bc <HAL_RCC_OscConfig+0x274>)
 800287a:	5ccb      	ldrb	r3, [r1, r3]
 800287c:	f003 031f 	and.w	r3, r3, #31
 8002880:	fa22 f303 	lsr.w	r3, r2, r3
 8002884:	4a4e      	ldr	r2, [pc, #312]	; (80029c0 <HAL_RCC_OscConfig+0x278>)
 8002886:	6013      	str	r3, [r2, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8002888:	4b4e      	ldr	r3, [pc, #312]	; (80029c4 <HAL_RCC_OscConfig+0x27c>)
 800288a:	681b      	ldr	r3, [r3, #0]
 800288c:	4618      	mov	r0, r3
 800288e:	f7fe fdaf 	bl	80013f0 <HAL_InitTick>
 8002892:	4603      	mov	r3, r0
 8002894:	73fb      	strb	r3, [r7, #15]
        if(status != HAL_OK)
 8002896:	7bfb      	ldrb	r3, [r7, #15]
 8002898:	2b00      	cmp	r3, #0
 800289a:	d052      	beq.n	8002942 <HAL_RCC_OscConfig+0x1fa>
        {
          return status;
 800289c:	7bfb      	ldrb	r3, [r7, #15]
 800289e:	e335      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80028a0:	687b      	ldr	r3, [r7, #4]
 80028a2:	699b      	ldr	r3, [r3, #24]
 80028a4:	2b00      	cmp	r3, #0
 80028a6:	d032      	beq.n	800290e <HAL_RCC_OscConfig+0x1c6>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80028a8:	4b43      	ldr	r3, [pc, #268]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028aa:	681b      	ldr	r3, [r3, #0]
 80028ac:	4a42      	ldr	r2, [pc, #264]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028ae:	f043 0301 	orr.w	r3, r3, #1
 80028b2:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80028b4:	f7fe fdec 	bl	8001490 <HAL_GetTick>
 80028b8:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80028ba:	e008      	b.n	80028ce <HAL_RCC_OscConfig+0x186>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80028bc:	f7fe fde8 	bl	8001490 <HAL_GetTick>
 80028c0:	4602      	mov	r2, r0
 80028c2:	693b      	ldr	r3, [r7, #16]
 80028c4:	1ad3      	subs	r3, r2, r3
 80028c6:	2b02      	cmp	r3, #2
 80028c8:	d901      	bls.n	80028ce <HAL_RCC_OscConfig+0x186>
          {
            return HAL_TIMEOUT;
 80028ca:	2303      	movs	r3, #3
 80028cc:	e31e      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80028ce:	4b3a      	ldr	r3, [pc, #232]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028d0:	681b      	ldr	r3, [r3, #0]
 80028d2:	f003 0302 	and.w	r3, r3, #2
 80028d6:	2b00      	cmp	r3, #0
 80028d8:	d0f0      	beq.n	80028bc <HAL_RCC_OscConfig+0x174>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80028da:	4b37      	ldr	r3, [pc, #220]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028dc:	681b      	ldr	r3, [r3, #0]
 80028de:	4a36      	ldr	r2, [pc, #216]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028e0:	f043 0308 	orr.w	r3, r3, #8
 80028e4:	6013      	str	r3, [r2, #0]
 80028e6:	4b34      	ldr	r3, [pc, #208]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028e8:	681b      	ldr	r3, [r3, #0]
 80028ea:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	6a1b      	ldr	r3, [r3, #32]
 80028f2:	4931      	ldr	r1, [pc, #196]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028f4:	4313      	orrs	r3, r2
 80028f6:	600b      	str	r3, [r1, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80028f8:	4b2f      	ldr	r3, [pc, #188]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80028fa:	685b      	ldr	r3, [r3, #4]
 80028fc:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8002900:	687b      	ldr	r3, [r7, #4]
 8002902:	69db      	ldr	r3, [r3, #28]
 8002904:	021b      	lsls	r3, r3, #8
 8002906:	492c      	ldr	r1, [pc, #176]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002908:	4313      	orrs	r3, r2
 800290a:	604b      	str	r3, [r1, #4]
 800290c:	e01a      	b.n	8002944 <HAL_RCC_OscConfig+0x1fc>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 800290e:	4b2a      	ldr	r3, [pc, #168]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002910:	681b      	ldr	r3, [r3, #0]
 8002912:	4a29      	ldr	r2, [pc, #164]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002914:	f023 0301 	bic.w	r3, r3, #1
 8002918:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 800291a:	f7fe fdb9 	bl	8001490 <HAL_GetTick>
 800291e:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8002920:	e008      	b.n	8002934 <HAL_RCC_OscConfig+0x1ec>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002922:	f7fe fdb5 	bl	8001490 <HAL_GetTick>
 8002926:	4602      	mov	r2, r0
 8002928:	693b      	ldr	r3, [r7, #16]
 800292a:	1ad3      	subs	r3, r2, r3
 800292c:	2b02      	cmp	r3, #2
 800292e:	d901      	bls.n	8002934 <HAL_RCC_OscConfig+0x1ec>
          {
            return HAL_TIMEOUT;
 8002930:	2303      	movs	r3, #3
 8002932:	e2eb      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8002934:	4b20      	ldr	r3, [pc, #128]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002936:	681b      	ldr	r3, [r3, #0]
 8002938:	f003 0302 	and.w	r3, r3, #2
 800293c:	2b00      	cmp	r3, #0
 800293e:	d1f0      	bne.n	8002922 <HAL_RCC_OscConfig+0x1da>
 8002940:	e000      	b.n	8002944 <HAL_RCC_OscConfig+0x1fc>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8002942:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002944:	687b      	ldr	r3, [r7, #4]
 8002946:	681b      	ldr	r3, [r3, #0]
 8002948:	f003 0301 	and.w	r3, r3, #1
 800294c:	2b00      	cmp	r3, #0
 800294e:	d074      	beq.n	8002a3a <HAL_RCC_OscConfig+0x2f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8002950:	69bb      	ldr	r3, [r7, #24]
 8002952:	2b08      	cmp	r3, #8
 8002954:	d005      	beq.n	8002962 <HAL_RCC_OscConfig+0x21a>
 8002956:	69bb      	ldr	r3, [r7, #24]
 8002958:	2b0c      	cmp	r3, #12
 800295a:	d10e      	bne.n	800297a <HAL_RCC_OscConfig+0x232>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 800295c:	697b      	ldr	r3, [r7, #20]
 800295e:	2b03      	cmp	r3, #3
 8002960:	d10b      	bne.n	800297a <HAL_RCC_OscConfig+0x232>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002962:	4b15      	ldr	r3, [pc, #84]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002964:	681b      	ldr	r3, [r3, #0]
 8002966:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800296a:	2b00      	cmp	r3, #0
 800296c:	d064      	beq.n	8002a38 <HAL_RCC_OscConfig+0x2f0>
 800296e:	687b      	ldr	r3, [r7, #4]
 8002970:	685b      	ldr	r3, [r3, #4]
 8002972:	2b00      	cmp	r3, #0
 8002974:	d160      	bne.n	8002a38 <HAL_RCC_OscConfig+0x2f0>
      {
        return HAL_ERROR;
 8002976:	2301      	movs	r3, #1
 8002978:	e2c8      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800297a:	687b      	ldr	r3, [r7, #4]
 800297c:	685b      	ldr	r3, [r3, #4]
 800297e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002982:	d106      	bne.n	8002992 <HAL_RCC_OscConfig+0x24a>
 8002984:	4b0c      	ldr	r3, [pc, #48]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 8002986:	681b      	ldr	r3, [r3, #0]
 8002988:	4a0b      	ldr	r2, [pc, #44]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800298a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800298e:	6013      	str	r3, [r2, #0]
 8002990:	e026      	b.n	80029e0 <HAL_RCC_OscConfig+0x298>
 8002992:	687b      	ldr	r3, [r7, #4]
 8002994:	685b      	ldr	r3, [r3, #4]
 8002996:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800299a:	d115      	bne.n	80029c8 <HAL_RCC_OscConfig+0x280>
 800299c:	4b06      	ldr	r3, [pc, #24]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 800299e:	681b      	ldr	r3, [r3, #0]
 80029a0:	4a05      	ldr	r2, [pc, #20]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80029a2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80029a6:	6013      	str	r3, [r2, #0]
 80029a8:	4b03      	ldr	r3, [pc, #12]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80029aa:	681b      	ldr	r3, [r3, #0]
 80029ac:	4a02      	ldr	r2, [pc, #8]	; (80029b8 <HAL_RCC_OscConfig+0x270>)
 80029ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80029b2:	6013      	str	r3, [r2, #0]
 80029b4:	e014      	b.n	80029e0 <HAL_RCC_OscConfig+0x298>
 80029b6:	bf00      	nop
 80029b8:	40021000 	.word	0x40021000
 80029bc:	0801b840 	.word	0x0801b840
 80029c0:	20000000 	.word	0x20000000
 80029c4:	20000004 	.word	0x20000004
 80029c8:	4ba0      	ldr	r3, [pc, #640]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 80029ca:	681b      	ldr	r3, [r3, #0]
 80029cc:	4a9f      	ldr	r2, [pc, #636]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 80029ce:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80029d2:	6013      	str	r3, [r2, #0]
 80029d4:	4b9d      	ldr	r3, [pc, #628]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	4a9c      	ldr	r2, [pc, #624]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 80029da:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80029de:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80029e0:	687b      	ldr	r3, [r7, #4]
 80029e2:	685b      	ldr	r3, [r3, #4]
 80029e4:	2b00      	cmp	r3, #0
 80029e6:	d013      	beq.n	8002a10 <HAL_RCC_OscConfig+0x2c8>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80029e8:	f7fe fd52 	bl	8001490 <HAL_GetTick>
 80029ec:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80029ee:	e008      	b.n	8002a02 <HAL_RCC_OscConfig+0x2ba>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80029f0:	f7fe fd4e 	bl	8001490 <HAL_GetTick>
 80029f4:	4602      	mov	r2, r0
 80029f6:	693b      	ldr	r3, [r7, #16]
 80029f8:	1ad3      	subs	r3, r2, r3
 80029fa:	2b64      	cmp	r3, #100	; 0x64
 80029fc:	d901      	bls.n	8002a02 <HAL_RCC_OscConfig+0x2ba>
          {
            return HAL_TIMEOUT;
 80029fe:	2303      	movs	r3, #3
 8002a00:	e284      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002a02:	4b92      	ldr	r3, [pc, #584]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a04:	681b      	ldr	r3, [r3, #0]
 8002a06:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002a0a:	2b00      	cmp	r3, #0
 8002a0c:	d0f0      	beq.n	80029f0 <HAL_RCC_OscConfig+0x2a8>
 8002a0e:	e014      	b.n	8002a3a <HAL_RCC_OscConfig+0x2f2>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002a10:	f7fe fd3e 	bl	8001490 <HAL_GetTick>
 8002a14:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8002a16:	e008      	b.n	8002a2a <HAL_RCC_OscConfig+0x2e2>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002a18:	f7fe fd3a 	bl	8001490 <HAL_GetTick>
 8002a1c:	4602      	mov	r2, r0
 8002a1e:	693b      	ldr	r3, [r7, #16]
 8002a20:	1ad3      	subs	r3, r2, r3
 8002a22:	2b64      	cmp	r3, #100	; 0x64
 8002a24:	d901      	bls.n	8002a2a <HAL_RCC_OscConfig+0x2e2>
          {
            return HAL_TIMEOUT;
 8002a26:	2303      	movs	r3, #3
 8002a28:	e270      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8002a2a:	4b88      	ldr	r3, [pc, #544]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a2c:	681b      	ldr	r3, [r3, #0]
 8002a2e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d1f0      	bne.n	8002a18 <HAL_RCC_OscConfig+0x2d0>
 8002a36:	e000      	b.n	8002a3a <HAL_RCC_OscConfig+0x2f2>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002a38:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002a3a:	687b      	ldr	r3, [r7, #4]
 8002a3c:	681b      	ldr	r3, [r3, #0]
 8002a3e:	f003 0302 	and.w	r3, r3, #2
 8002a42:	2b00      	cmp	r3, #0
 8002a44:	d060      	beq.n	8002b08 <HAL_RCC_OscConfig+0x3c0>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 8002a46:	69bb      	ldr	r3, [r7, #24]
 8002a48:	2b04      	cmp	r3, #4
 8002a4a:	d005      	beq.n	8002a58 <HAL_RCC_OscConfig+0x310>
 8002a4c:	69bb      	ldr	r3, [r7, #24]
 8002a4e:	2b0c      	cmp	r3, #12
 8002a50:	d119      	bne.n	8002a86 <HAL_RCC_OscConfig+0x33e>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 8002a52:	697b      	ldr	r3, [r7, #20]
 8002a54:	2b02      	cmp	r3, #2
 8002a56:	d116      	bne.n	8002a86 <HAL_RCC_OscConfig+0x33e>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002a58:	4b7c      	ldr	r3, [pc, #496]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a5a:	681b      	ldr	r3, [r3, #0]
 8002a5c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002a60:	2b00      	cmp	r3, #0
 8002a62:	d005      	beq.n	8002a70 <HAL_RCC_OscConfig+0x328>
 8002a64:	687b      	ldr	r3, [r7, #4]
 8002a66:	68db      	ldr	r3, [r3, #12]
 8002a68:	2b00      	cmp	r3, #0
 8002a6a:	d101      	bne.n	8002a70 <HAL_RCC_OscConfig+0x328>
      {
        return HAL_ERROR;
 8002a6c:	2301      	movs	r3, #1
 8002a6e:	e24d      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002a70:	4b76      	ldr	r3, [pc, #472]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a72:	685b      	ldr	r3, [r3, #4]
 8002a74:	f023 52f8 	bic.w	r2, r3, #520093696	; 0x1f000000
 8002a78:	687b      	ldr	r3, [r7, #4]
 8002a7a:	691b      	ldr	r3, [r3, #16]
 8002a7c:	061b      	lsls	r3, r3, #24
 8002a7e:	4973      	ldr	r1, [pc, #460]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a80:	4313      	orrs	r3, r2
 8002a82:	604b      	str	r3, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002a84:	e040      	b.n	8002b08 <HAL_RCC_OscConfig+0x3c0>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8002a86:	687b      	ldr	r3, [r7, #4]
 8002a88:	68db      	ldr	r3, [r3, #12]
 8002a8a:	2b00      	cmp	r3, #0
 8002a8c:	d023      	beq.n	8002ad6 <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002a8e:	4b6f      	ldr	r3, [pc, #444]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a90:	681b      	ldr	r3, [r3, #0]
 8002a92:	4a6e      	ldr	r2, [pc, #440]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002a94:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002a98:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002a9a:	f7fe fcf9 	bl	8001490 <HAL_GetTick>
 8002a9e:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002aa0:	e008      	b.n	8002ab4 <HAL_RCC_OscConfig+0x36c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002aa2:	f7fe fcf5 	bl	8001490 <HAL_GetTick>
 8002aa6:	4602      	mov	r2, r0
 8002aa8:	693b      	ldr	r3, [r7, #16]
 8002aaa:	1ad3      	subs	r3, r2, r3
 8002aac:	2b02      	cmp	r3, #2
 8002aae:	d901      	bls.n	8002ab4 <HAL_RCC_OscConfig+0x36c>
          {
            return HAL_TIMEOUT;
 8002ab0:	2303      	movs	r3, #3
 8002ab2:	e22b      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002ab4:	4b65      	ldr	r3, [pc, #404]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002ab6:	681b      	ldr	r3, [r3, #0]
 8002ab8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002abc:	2b00      	cmp	r3, #0
 8002abe:	d0f0      	beq.n	8002aa2 <HAL_RCC_OscConfig+0x35a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002ac0:	4b62      	ldr	r3, [pc, #392]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002ac2:	685b      	ldr	r3, [r3, #4]
 8002ac4:	f023 52f8 	bic.w	r2, r3, #520093696	; 0x1f000000
 8002ac8:	687b      	ldr	r3, [r7, #4]
 8002aca:	691b      	ldr	r3, [r3, #16]
 8002acc:	061b      	lsls	r3, r3, #24
 8002ace:	495f      	ldr	r1, [pc, #380]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002ad0:	4313      	orrs	r3, r2
 8002ad2:	604b      	str	r3, [r1, #4]
 8002ad4:	e018      	b.n	8002b08 <HAL_RCC_OscConfig+0x3c0>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8002ad6:	4b5d      	ldr	r3, [pc, #372]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002ad8:	681b      	ldr	r3, [r3, #0]
 8002ada:	4a5c      	ldr	r2, [pc, #368]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002adc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002ae0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002ae2:	f7fe fcd5 	bl	8001490 <HAL_GetTick>
 8002ae6:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8002ae8:	e008      	b.n	8002afc <HAL_RCC_OscConfig+0x3b4>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002aea:	f7fe fcd1 	bl	8001490 <HAL_GetTick>
 8002aee:	4602      	mov	r2, r0
 8002af0:	693b      	ldr	r3, [r7, #16]
 8002af2:	1ad3      	subs	r3, r2, r3
 8002af4:	2b02      	cmp	r3, #2
 8002af6:	d901      	bls.n	8002afc <HAL_RCC_OscConfig+0x3b4>
          {
            return HAL_TIMEOUT;
 8002af8:	2303      	movs	r3, #3
 8002afa:	e207      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8002afc:	4b53      	ldr	r3, [pc, #332]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002afe:	681b      	ldr	r3, [r3, #0]
 8002b00:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002b04:	2b00      	cmp	r3, #0
 8002b06:	d1f0      	bne.n	8002aea <HAL_RCC_OscConfig+0x3a2>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002b08:	687b      	ldr	r3, [r7, #4]
 8002b0a:	681b      	ldr	r3, [r3, #0]
 8002b0c:	f003 0308 	and.w	r3, r3, #8
 8002b10:	2b00      	cmp	r3, #0
 8002b12:	d03c      	beq.n	8002b8e <HAL_RCC_OscConfig+0x446>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002b14:	687b      	ldr	r3, [r7, #4]
 8002b16:	695b      	ldr	r3, [r3, #20]
 8002b18:	2b00      	cmp	r3, #0
 8002b1a:	d01c      	beq.n	8002b56 <HAL_RCC_OscConfig+0x40e>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
      }
#endif /* RCC_CSR_LSIPREDIV */

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002b1c:	4b4b      	ldr	r3, [pc, #300]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b1e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b22:	4a4a      	ldr	r2, [pc, #296]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b24:	f043 0301 	orr.w	r3, r3, #1
 8002b28:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002b2c:	f7fe fcb0 	bl	8001490 <HAL_GetTick>
 8002b30:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8002b32:	e008      	b.n	8002b46 <HAL_RCC_OscConfig+0x3fe>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002b34:	f7fe fcac 	bl	8001490 <HAL_GetTick>
 8002b38:	4602      	mov	r2, r0
 8002b3a:	693b      	ldr	r3, [r7, #16]
 8002b3c:	1ad3      	subs	r3, r2, r3
 8002b3e:	2b02      	cmp	r3, #2
 8002b40:	d901      	bls.n	8002b46 <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
 8002b42:	2303      	movs	r3, #3
 8002b44:	e1e2      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8002b46:	4b41      	ldr	r3, [pc, #260]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b48:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b4c:	f003 0302 	and.w	r3, r3, #2
 8002b50:	2b00      	cmp	r3, #0
 8002b52:	d0ef      	beq.n	8002b34 <HAL_RCC_OscConfig+0x3ec>
 8002b54:	e01b      	b.n	8002b8e <HAL_RCC_OscConfig+0x446>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002b56:	4b3d      	ldr	r3, [pc, #244]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b58:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b5c:	4a3b      	ldr	r2, [pc, #236]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b5e:	f023 0301 	bic.w	r3, r3, #1
 8002b62:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002b66:	f7fe fc93 	bl	8001490 <HAL_GetTick>
 8002b6a:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8002b6c:	e008      	b.n	8002b80 <HAL_RCC_OscConfig+0x438>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002b6e:	f7fe fc8f 	bl	8001490 <HAL_GetTick>
 8002b72:	4602      	mov	r2, r0
 8002b74:	693b      	ldr	r3, [r7, #16]
 8002b76:	1ad3      	subs	r3, r2, r3
 8002b78:	2b02      	cmp	r3, #2
 8002b7a:	d901      	bls.n	8002b80 <HAL_RCC_OscConfig+0x438>
        {
          return HAL_TIMEOUT;
 8002b7c:	2303      	movs	r3, #3
 8002b7e:	e1c5      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8002b80:	4b32      	ldr	r3, [pc, #200]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002b82:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b86:	f003 0302 	and.w	r3, r3, #2
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	d1ef      	bne.n	8002b6e <HAL_RCC_OscConfig+0x426>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002b8e:	687b      	ldr	r3, [r7, #4]
 8002b90:	681b      	ldr	r3, [r3, #0]
 8002b92:	f003 0304 	and.w	r3, r3, #4
 8002b96:	2b00      	cmp	r3, #0
 8002b98:	f000 80a6 	beq.w	8002ce8 <HAL_RCC_OscConfig+0x5a0>
  {
    FlagStatus       pwrclkchanged = RESET;
 8002b9c:	2300      	movs	r3, #0
 8002b9e:	77fb      	strb	r3, [r7, #31]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8002ba0:	4b2a      	ldr	r3, [pc, #168]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002ba2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002ba4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002ba8:	2b00      	cmp	r3, #0
 8002baa:	d10d      	bne.n	8002bc8 <HAL_RCC_OscConfig+0x480>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8002bac:	4b27      	ldr	r3, [pc, #156]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002bae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002bb0:	4a26      	ldr	r2, [pc, #152]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002bb2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002bb6:	6593      	str	r3, [r2, #88]	; 0x58
 8002bb8:	4b24      	ldr	r3, [pc, #144]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002bba:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002bbc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002bc0:	60bb      	str	r3, [r7, #8]
 8002bc2:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8002bc4:	2301      	movs	r3, #1
 8002bc6:	77fb      	strb	r3, [r7, #31]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8002bc8:	4b21      	ldr	r3, [pc, #132]	; (8002c50 <HAL_RCC_OscConfig+0x508>)
 8002bca:	681b      	ldr	r3, [r3, #0]
 8002bcc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002bd0:	2b00      	cmp	r3, #0
 8002bd2:	d118      	bne.n	8002c06 <HAL_RCC_OscConfig+0x4be>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8002bd4:	4b1e      	ldr	r3, [pc, #120]	; (8002c50 <HAL_RCC_OscConfig+0x508>)
 8002bd6:	681b      	ldr	r3, [r3, #0]
 8002bd8:	4a1d      	ldr	r2, [pc, #116]	; (8002c50 <HAL_RCC_OscConfig+0x508>)
 8002bda:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002bde:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002be0:	f7fe fc56 	bl	8001490 <HAL_GetTick>
 8002be4:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8002be6:	e008      	b.n	8002bfa <HAL_RCC_OscConfig+0x4b2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002be8:	f7fe fc52 	bl	8001490 <HAL_GetTick>
 8002bec:	4602      	mov	r2, r0
 8002bee:	693b      	ldr	r3, [r7, #16]
 8002bf0:	1ad3      	subs	r3, r2, r3
 8002bf2:	2b02      	cmp	r3, #2
 8002bf4:	d901      	bls.n	8002bfa <HAL_RCC_OscConfig+0x4b2>
        {
          return HAL_TIMEOUT;
 8002bf6:	2303      	movs	r3, #3
 8002bf8:	e188      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8002bfa:	4b15      	ldr	r3, [pc, #84]	; (8002c50 <HAL_RCC_OscConfig+0x508>)
 8002bfc:	681b      	ldr	r3, [r3, #0]
 8002bfe:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002c02:	2b00      	cmp	r3, #0
 8002c04:	d0f0      	beq.n	8002be8 <HAL_RCC_OscConfig+0x4a0>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002c06:	687b      	ldr	r3, [r7, #4]
 8002c08:	689b      	ldr	r3, [r3, #8]
 8002c0a:	2b01      	cmp	r3, #1
 8002c0c:	d108      	bne.n	8002c20 <HAL_RCC_OscConfig+0x4d8>
 8002c0e:	4b0f      	ldr	r3, [pc, #60]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c10:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002c14:	4a0d      	ldr	r2, [pc, #52]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c16:	f043 0301 	orr.w	r3, r3, #1
 8002c1a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8002c1e:	e029      	b.n	8002c74 <HAL_RCC_OscConfig+0x52c>
 8002c20:	687b      	ldr	r3, [r7, #4]
 8002c22:	689b      	ldr	r3, [r3, #8]
 8002c24:	2b05      	cmp	r3, #5
 8002c26:	d115      	bne.n	8002c54 <HAL_RCC_OscConfig+0x50c>
 8002c28:	4b08      	ldr	r3, [pc, #32]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c2a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002c2e:	4a07      	ldr	r2, [pc, #28]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c30:	f043 0304 	orr.w	r3, r3, #4
 8002c34:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8002c38:	4b04      	ldr	r3, [pc, #16]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002c3e:	4a03      	ldr	r2, [pc, #12]	; (8002c4c <HAL_RCC_OscConfig+0x504>)
 8002c40:	f043 0301 	orr.w	r3, r3, #1
 8002c44:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8002c48:	e014      	b.n	8002c74 <HAL_RCC_OscConfig+0x52c>
 8002c4a:	bf00      	nop
 8002c4c:	40021000 	.word	0x40021000
 8002c50:	40007000 	.word	0x40007000
 8002c54:	4b91      	ldr	r3, [pc, #580]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002c56:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002c5a:	4a90      	ldr	r2, [pc, #576]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002c5c:	f023 0301 	bic.w	r3, r3, #1
 8002c60:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8002c64:	4b8d      	ldr	r3, [pc, #564]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002c66:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002c6a:	4a8c      	ldr	r2, [pc, #560]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002c6c:	f023 0304 	bic.w	r3, r3, #4
 8002c70:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* RCC_BDCR_LSESYSDIS */

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8002c74:	687b      	ldr	r3, [r7, #4]
 8002c76:	689b      	ldr	r3, [r3, #8]
 8002c78:	2b00      	cmp	r3, #0
 8002c7a:	d016      	beq.n	8002caa <HAL_RCC_OscConfig+0x562>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002c7c:	f7fe fc08 	bl	8001490 <HAL_GetTick>
 8002c80:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8002c82:	e00a      	b.n	8002c9a <HAL_RCC_OscConfig+0x552>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002c84:	f7fe fc04 	bl	8001490 <HAL_GetTick>
 8002c88:	4602      	mov	r2, r0
 8002c8a:	693b      	ldr	r3, [r7, #16]
 8002c8c:	1ad3      	subs	r3, r2, r3
 8002c8e:	f241 3288 	movw	r2, #5000	; 0x1388
 8002c92:	4293      	cmp	r3, r2
 8002c94:	d901      	bls.n	8002c9a <HAL_RCC_OscConfig+0x552>
        {
          return HAL_TIMEOUT;
 8002c96:	2303      	movs	r3, #3
 8002c98:	e138      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8002c9a:	4b80      	ldr	r3, [pc, #512]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002c9c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002ca0:	f003 0302 	and.w	r3, r3, #2
 8002ca4:	2b00      	cmp	r3, #0
 8002ca6:	d0ed      	beq.n	8002c84 <HAL_RCC_OscConfig+0x53c>
 8002ca8:	e015      	b.n	8002cd6 <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002caa:	f7fe fbf1 	bl	8001490 <HAL_GetTick>
 8002cae:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002cb0:	e00a      	b.n	8002cc8 <HAL_RCC_OscConfig+0x580>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002cb2:	f7fe fbed 	bl	8001490 <HAL_GetTick>
 8002cb6:	4602      	mov	r2, r0
 8002cb8:	693b      	ldr	r3, [r7, #16]
 8002cba:	1ad3      	subs	r3, r2, r3
 8002cbc:	f241 3288 	movw	r2, #5000	; 0x1388
 8002cc0:	4293      	cmp	r3, r2
 8002cc2:	d901      	bls.n	8002cc8 <HAL_RCC_OscConfig+0x580>
        {
          return HAL_TIMEOUT;
 8002cc4:	2303      	movs	r3, #3
 8002cc6:	e121      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002cc8:	4b74      	ldr	r3, [pc, #464]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002cca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002cce:	f003 0302 	and.w	r3, r3, #2
 8002cd2:	2b00      	cmp	r3, #0
 8002cd4:	d1ed      	bne.n	8002cb2 <HAL_RCC_OscConfig+0x56a>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
#endif /* RCC_BDCR_LSESYSDIS */
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8002cd6:	7ffb      	ldrb	r3, [r7, #31]
 8002cd8:	2b01      	cmp	r3, #1
 8002cda:	d105      	bne.n	8002ce8 <HAL_RCC_OscConfig+0x5a0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8002cdc:	4b6f      	ldr	r3, [pc, #444]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002cde:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002ce0:	4a6e      	ldr	r2, [pc, #440]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002ce2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002ce6:	6593      	str	r3, [r2, #88]	; 0x58
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8002ce8:	687b      	ldr	r3, [r7, #4]
 8002cea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002cec:	2b00      	cmp	r3, #0
 8002cee:	f000 810c 	beq.w	8002f0a <HAL_RCC_OscConfig+0x7c2>
  {
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8002cf2:	687b      	ldr	r3, [r7, #4]
 8002cf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002cf6:	2b02      	cmp	r3, #2
 8002cf8:	f040 80d4 	bne.w	8002ea4 <HAL_RCC_OscConfig+0x75c>
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 8002cfc:	4b67      	ldr	r3, [pc, #412]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002cfe:	68db      	ldr	r3, [r3, #12]
 8002d00:	617b      	str	r3, [r7, #20]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8002d02:	697b      	ldr	r3, [r7, #20]
 8002d04:	f003 0203 	and.w	r2, r3, #3
 8002d08:	687b      	ldr	r3, [r7, #4]
 8002d0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002d0c:	429a      	cmp	r2, r3
 8002d0e:	d130      	bne.n	8002d72 <HAL_RCC_OscConfig+0x62a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8002d10:	697b      	ldr	r3, [r7, #20]
 8002d12:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8002d16:	687b      	ldr	r3, [r7, #4]
 8002d18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d1a:	3b01      	subs	r3, #1
 8002d1c:	011b      	lsls	r3, r3, #4
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8002d1e:	429a      	cmp	r2, r3
 8002d20:	d127      	bne.n	8002d72 <HAL_RCC_OscConfig+0x62a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8002d22:	697b      	ldr	r3, [r7, #20]
 8002d24:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 8002d28:	687b      	ldr	r3, [r7, #4]
 8002d2a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d2c:	021b      	lsls	r3, r3, #8
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8002d2e:	429a      	cmp	r2, r3
 8002d30:	d11f      	bne.n	8002d72 <HAL_RCC_OscConfig+0x62a>
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
#else
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
 8002d32:	697b      	ldr	r3, [r7, #20]
 8002d34:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002d38:	687a      	ldr	r2, [r7, #4]
 8002d3a:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8002d3c:	2a07      	cmp	r2, #7
 8002d3e:	bf14      	ite	ne
 8002d40:	2201      	movne	r2, #1
 8002d42:	2200      	moveq	r2, #0
 8002d44:	b2d2      	uxtb	r2, r2
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8002d46:	4293      	cmp	r3, r2
 8002d48:	d113      	bne.n	8002d72 <HAL_RCC_OscConfig+0x62a>
#endif
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8002d4a:	697b      	ldr	r3, [r7, #20]
 8002d4c:	f403 02c0 	and.w	r2, r3, #6291456	; 0x600000
 8002d50:	687b      	ldr	r3, [r7, #4]
 8002d52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002d54:	085b      	lsrs	r3, r3, #1
 8002d56:	3b01      	subs	r3, #1
 8002d58:	055b      	lsls	r3, r3, #21
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
 8002d5a:	429a      	cmp	r2, r3
 8002d5c:	d109      	bne.n	8002d72 <HAL_RCC_OscConfig+0x62a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8002d5e:	697b      	ldr	r3, [r7, #20]
 8002d60:	f003 62c0 	and.w	r2, r3, #100663296	; 0x6000000
 8002d64:	687b      	ldr	r3, [r7, #4]
 8002d66:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d68:	085b      	lsrs	r3, r3, #1
 8002d6a:	3b01      	subs	r3, #1
 8002d6c:	065b      	lsls	r3, r3, #25
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8002d6e:	429a      	cmp	r2, r3
 8002d70:	d06e      	beq.n	8002e50 <HAL_RCC_OscConfig+0x708>
      {
        /* Check if the PLL is used as system clock or not */
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8002d72:	69bb      	ldr	r3, [r7, #24]
 8002d74:	2b0c      	cmp	r3, #12
 8002d76:	d069      	beq.n	8002e4c <HAL_RCC_OscConfig+0x704>
        {
#if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8002d78:	4b48      	ldr	r3, [pc, #288]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002d7a:	681b      	ldr	r3, [r3, #0]
 8002d7c:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8002d80:	2b00      	cmp	r3, #0
 8002d82:	d105      	bne.n	8002d90 <HAL_RCC_OscConfig+0x648>
#if defined(RCC_PLLSAI2_SUPPORT)
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 8002d84:	4b45      	ldr	r3, [pc, #276]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002d86:	681b      	ldr	r3, [r3, #0]
 8002d88:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002d8c:	2b00      	cmp	r3, #0
 8002d8e:	d001      	beq.n	8002d94 <HAL_RCC_OscConfig+0x64c>
#endif
            )
          {
            return HAL_ERROR;
 8002d90:	2301      	movs	r3, #1
 8002d92:	e0bb      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
          }
          else
#endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 8002d94:	4b41      	ldr	r3, [pc, #260]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002d96:	681b      	ldr	r3, [r3, #0]
 8002d98:	4a40      	ldr	r2, [pc, #256]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002d9a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002d9e:	6013      	str	r3, [r2, #0]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8002da0:	f7fe fb76 	bl	8001490 <HAL_GetTick>
 8002da4:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8002da6:	e008      	b.n	8002dba <HAL_RCC_OscConfig+0x672>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002da8:	f7fe fb72 	bl	8001490 <HAL_GetTick>
 8002dac:	4602      	mov	r2, r0
 8002dae:	693b      	ldr	r3, [r7, #16]
 8002db0:	1ad3      	subs	r3, r2, r3
 8002db2:	2b02      	cmp	r3, #2
 8002db4:	d901      	bls.n	8002dba <HAL_RCC_OscConfig+0x672>
              {
                return HAL_TIMEOUT;
 8002db6:	2303      	movs	r3, #3
 8002db8:	e0a8      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8002dba:	4b38      	ldr	r3, [pc, #224]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002dbc:	681b      	ldr	r3, [r3, #0]
 8002dbe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002dc2:	2b00      	cmp	r3, #0
 8002dc4:	d1f0      	bne.n	8002da8 <HAL_RCC_OscConfig+0x660>
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002dc6:	4b35      	ldr	r3, [pc, #212]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002dc8:	68da      	ldr	r2, [r3, #12]
 8002dca:	4b35      	ldr	r3, [pc, #212]	; (8002ea0 <HAL_RCC_OscConfig+0x758>)
 8002dcc:	4013      	ands	r3, r2
 8002dce:	687a      	ldr	r2, [r7, #4]
 8002dd0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8002dd2:	687a      	ldr	r2, [r7, #4]
 8002dd4:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002dd6:	3a01      	subs	r2, #1
 8002dd8:	0112      	lsls	r2, r2, #4
 8002dda:	4311      	orrs	r1, r2
 8002ddc:	687a      	ldr	r2, [r7, #4]
 8002dde:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8002de0:	0212      	lsls	r2, r2, #8
 8002de2:	4311      	orrs	r1, r2
 8002de4:	687a      	ldr	r2, [r7, #4]
 8002de6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8002de8:	0852      	lsrs	r2, r2, #1
 8002dea:	3a01      	subs	r2, #1
 8002dec:	0552      	lsls	r2, r2, #21
 8002dee:	4311      	orrs	r1, r2
 8002df0:	687a      	ldr	r2, [r7, #4]
 8002df2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002df4:	0852      	lsrs	r2, r2, #1
 8002df6:	3a01      	subs	r2, #1
 8002df8:	0652      	lsls	r2, r2, #25
 8002dfa:	4311      	orrs	r1, r2
 8002dfc:	687a      	ldr	r2, [r7, #4]
 8002dfe:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8002e00:	0912      	lsrs	r2, r2, #4
 8002e02:	0452      	lsls	r2, r2, #17
 8002e04:	430a      	orrs	r2, r1
 8002e06:	4925      	ldr	r1, [pc, #148]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e08:	4313      	orrs	r3, r2
 8002e0a:	60cb      	str	r3, [r1, #12]
#endif
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 8002e0c:	4b23      	ldr	r3, [pc, #140]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e0e:	681b      	ldr	r3, [r3, #0]
 8002e10:	4a22      	ldr	r2, [pc, #136]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e12:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002e16:	6013      	str	r3, [r2, #0]

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8002e18:	4b20      	ldr	r3, [pc, #128]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e1a:	68db      	ldr	r3, [r3, #12]
 8002e1c:	4a1f      	ldr	r2, [pc, #124]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e1e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002e22:	60d3      	str	r3, [r2, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8002e24:	f7fe fb34 	bl	8001490 <HAL_GetTick>
 8002e28:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002e2a:	e008      	b.n	8002e3e <HAL_RCC_OscConfig+0x6f6>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002e2c:	f7fe fb30 	bl	8001490 <HAL_GetTick>
 8002e30:	4602      	mov	r2, r0
 8002e32:	693b      	ldr	r3, [r7, #16]
 8002e34:	1ad3      	subs	r3, r2, r3
 8002e36:	2b02      	cmp	r3, #2
 8002e38:	d901      	bls.n	8002e3e <HAL_RCC_OscConfig+0x6f6>
              {
                return HAL_TIMEOUT;
 8002e3a:	2303      	movs	r3, #3
 8002e3c:	e066      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002e3e:	4b17      	ldr	r3, [pc, #92]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e40:	681b      	ldr	r3, [r3, #0]
 8002e42:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002e46:	2b00      	cmp	r3, #0
 8002e48:	d0f0      	beq.n	8002e2c <HAL_RCC_OscConfig+0x6e4>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8002e4a:	e05e      	b.n	8002f0a <HAL_RCC_OscConfig+0x7c2>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8002e4c:	2301      	movs	r3, #1
 8002e4e:	e05d      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002e50:	4b12      	ldr	r3, [pc, #72]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e52:	681b      	ldr	r3, [r3, #0]
 8002e54:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002e58:	2b00      	cmp	r3, #0
 8002e5a:	d156      	bne.n	8002f0a <HAL_RCC_OscConfig+0x7c2>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8002e5c:	4b0f      	ldr	r3, [pc, #60]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e5e:	681b      	ldr	r3, [r3, #0]
 8002e60:	4a0e      	ldr	r2, [pc, #56]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e62:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002e66:	6013      	str	r3, [r2, #0]

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8002e68:	4b0c      	ldr	r3, [pc, #48]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e6a:	68db      	ldr	r3, [r3, #12]
 8002e6c:	4a0b      	ldr	r2, [pc, #44]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e6e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002e72:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8002e74:	f7fe fb0c 	bl	8001490 <HAL_GetTick>
 8002e78:	6138      	str	r0, [r7, #16]

          /* Wait till PLL is ready */
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002e7a:	e008      	b.n	8002e8e <HAL_RCC_OscConfig+0x746>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002e7c:	f7fe fb08 	bl	8001490 <HAL_GetTick>
 8002e80:	4602      	mov	r2, r0
 8002e82:	693b      	ldr	r3, [r7, #16]
 8002e84:	1ad3      	subs	r3, r2, r3
 8002e86:	2b02      	cmp	r3, #2
 8002e88:	d901      	bls.n	8002e8e <HAL_RCC_OscConfig+0x746>
            {
              return HAL_TIMEOUT;
 8002e8a:	2303      	movs	r3, #3
 8002e8c:	e03e      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002e8e:	4b03      	ldr	r3, [pc, #12]	; (8002e9c <HAL_RCC_OscConfig+0x754>)
 8002e90:	681b      	ldr	r3, [r3, #0]
 8002e92:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002e96:	2b00      	cmp	r3, #0
 8002e98:	d0f0      	beq.n	8002e7c <HAL_RCC_OscConfig+0x734>
 8002e9a:	e036      	b.n	8002f0a <HAL_RCC_OscConfig+0x7c2>
 8002e9c:	40021000 	.word	0x40021000
 8002ea0:	f99d808c 	.word	0xf99d808c
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8002ea4:	69bb      	ldr	r3, [r7, #24]
 8002ea6:	2b0c      	cmp	r3, #12
 8002ea8:	d02d      	beq.n	8002f06 <HAL_RCC_OscConfig+0x7be>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8002eaa:	4b1a      	ldr	r3, [pc, #104]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002eac:	681b      	ldr	r3, [r3, #0]
 8002eae:	4a19      	ldr	r2, [pc, #100]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002eb0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002eb4:	6013      	str	r3, [r2, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
#if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8002eb6:	4b17      	ldr	r3, [pc, #92]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002eb8:	681b      	ldr	r3, [r3, #0]
 8002eba:	f003 5320 	and.w	r3, r3, #671088640	; 0x28000000
 8002ebe:	2b00      	cmp	r3, #0
 8002ec0:	d105      	bne.n	8002ece <HAL_RCC_OscConfig+0x786>
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8002ec2:	4b14      	ldr	r3, [pc, #80]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002ec4:	68db      	ldr	r3, [r3, #12]
 8002ec6:	4a13      	ldr	r2, [pc, #76]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002ec8:	f023 0303 	bic.w	r3, r3, #3
 8002ecc:	60d3      	str	r3, [r2, #12]
#else
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
#endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8002ece:	4b11      	ldr	r3, [pc, #68]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002ed0:	68db      	ldr	r3, [r3, #12]
 8002ed2:	4a10      	ldr	r2, [pc, #64]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002ed4:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8002ed8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002edc:	60d3      	str	r3, [r2, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002ede:	f7fe fad7 	bl	8001490 <HAL_GetTick>
 8002ee2:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8002ee4:	e008      	b.n	8002ef8 <HAL_RCC_OscConfig+0x7b0>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002ee6:	f7fe fad3 	bl	8001490 <HAL_GetTick>
 8002eea:	4602      	mov	r2, r0
 8002eec:	693b      	ldr	r3, [r7, #16]
 8002eee:	1ad3      	subs	r3, r2, r3
 8002ef0:	2b02      	cmp	r3, #2
 8002ef2:	d901      	bls.n	8002ef8 <HAL_RCC_OscConfig+0x7b0>
          {
            return HAL_TIMEOUT;
 8002ef4:	2303      	movs	r3, #3
 8002ef6:	e009      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8002ef8:	4b06      	ldr	r3, [pc, #24]	; (8002f14 <HAL_RCC_OscConfig+0x7cc>)
 8002efa:	681b      	ldr	r3, [r3, #0]
 8002efc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002f00:	2b00      	cmp	r3, #0
 8002f02:	d1f0      	bne.n	8002ee6 <HAL_RCC_OscConfig+0x79e>
 8002f04:	e001      	b.n	8002f0a <HAL_RCC_OscConfig+0x7c2>
        }
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 8002f06:	2301      	movs	r3, #1
 8002f08:	e000      	b.n	8002f0c <HAL_RCC_OscConfig+0x7c4>
      }
    }
  }
  return HAL_OK;
 8002f0a:	2300      	movs	r3, #0
}
 8002f0c:	4618      	mov	r0, r3
 8002f0e:	3720      	adds	r7, #32
 8002f10:	46bd      	mov	sp, r7
 8002f12:	bd80      	pop	{r7, pc}
 8002f14:	40021000 	.word	0x40021000

08002f18 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002f18:	b580      	push	{r7, lr}
 8002f1a:	b084      	sub	sp, #16
 8002f1c:	af00      	add	r7, sp, #0
 8002f1e:	6078      	str	r0, [r7, #4]
 8002f20:	6039      	str	r1, [r7, #0]
  uint32_t hpre = RCC_SYSCLK_DIV1;
#endif
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	2b00      	cmp	r3, #0
 8002f26:	d101      	bne.n	8002f2c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8002f28:	2301      	movs	r3, #1
 8002f2a:	e0c8      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002f2c:	4b66      	ldr	r3, [pc, #408]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8002f2e:	681b      	ldr	r3, [r3, #0]
 8002f30:	f003 0307 	and.w	r3, r3, #7
 8002f34:	683a      	ldr	r2, [r7, #0]
 8002f36:	429a      	cmp	r2, r3
 8002f38:	d910      	bls.n	8002f5c <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002f3a:	4b63      	ldr	r3, [pc, #396]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8002f3c:	681b      	ldr	r3, [r3, #0]
 8002f3e:	f023 0207 	bic.w	r2, r3, #7
 8002f42:	4961      	ldr	r1, [pc, #388]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8002f44:	683b      	ldr	r3, [r7, #0]
 8002f46:	4313      	orrs	r3, r2
 8002f48:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8002f4a:	4b5f      	ldr	r3, [pc, #380]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8002f4c:	681b      	ldr	r3, [r3, #0]
 8002f4e:	f003 0307 	and.w	r3, r3, #7
 8002f52:	683a      	ldr	r2, [r7, #0]
 8002f54:	429a      	cmp	r2, r3
 8002f56:	d001      	beq.n	8002f5c <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8002f58:	2301      	movs	r3, #1
 8002f5a:	e0b0      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002f5c:	687b      	ldr	r3, [r7, #4]
 8002f5e:	681b      	ldr	r3, [r3, #0]
 8002f60:	f003 0301 	and.w	r3, r3, #1
 8002f64:	2b00      	cmp	r3, #0
 8002f66:	d04c      	beq.n	8003002 <HAL_RCC_ClockConfig+0xea>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002f68:	687b      	ldr	r3, [r7, #4]
 8002f6a:	685b      	ldr	r3, [r3, #4]
 8002f6c:	2b03      	cmp	r3, #3
 8002f6e:	d107      	bne.n	8002f80 <HAL_RCC_ClockConfig+0x68>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002f70:	4b56      	ldr	r3, [pc, #344]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002f72:	681b      	ldr	r3, [r3, #0]
 8002f74:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002f78:	2b00      	cmp	r3, #0
 8002f7a:	d121      	bne.n	8002fc0 <HAL_RCC_ClockConfig+0xa8>
      {
        return HAL_ERROR;
 8002f7c:	2301      	movs	r3, #1
 8002f7e:	e09e      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002f80:	687b      	ldr	r3, [r7, #4]
 8002f82:	685b      	ldr	r3, [r3, #4]
 8002f84:	2b02      	cmp	r3, #2
 8002f86:	d107      	bne.n	8002f98 <HAL_RCC_ClockConfig+0x80>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002f88:	4b50      	ldr	r3, [pc, #320]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002f8a:	681b      	ldr	r3, [r3, #0]
 8002f8c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002f90:	2b00      	cmp	r3, #0
 8002f92:	d115      	bne.n	8002fc0 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8002f94:	2301      	movs	r3, #1
 8002f96:	e092      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8002f98:	687b      	ldr	r3, [r7, #4]
 8002f9a:	685b      	ldr	r3, [r3, #4]
 8002f9c:	2b00      	cmp	r3, #0
 8002f9e:	d107      	bne.n	8002fb0 <HAL_RCC_ClockConfig+0x98>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8002fa0:	4b4a      	ldr	r3, [pc, #296]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002fa2:	681b      	ldr	r3, [r3, #0]
 8002fa4:	f003 0302 	and.w	r3, r3, #2
 8002fa8:	2b00      	cmp	r3, #0
 8002faa:	d109      	bne.n	8002fc0 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8002fac:	2301      	movs	r3, #1
 8002fae:	e086      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002fb0:	4b46      	ldr	r3, [pc, #280]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002fb8:	2b00      	cmp	r3, #0
 8002fba:	d101      	bne.n	8002fc0 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8002fbc:	2301      	movs	r3, #1
 8002fbe:	e07e      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002fc0:	4b42      	ldr	r3, [pc, #264]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002fc2:	689b      	ldr	r3, [r3, #8]
 8002fc4:	f023 0203 	bic.w	r2, r3, #3
 8002fc8:	687b      	ldr	r3, [r7, #4]
 8002fca:	685b      	ldr	r3, [r3, #4]
 8002fcc:	493f      	ldr	r1, [pc, #252]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002fce:	4313      	orrs	r3, r2
 8002fd0:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8002fd2:	f7fe fa5d 	bl	8001490 <HAL_GetTick>
 8002fd6:	60f8      	str	r0, [r7, #12]

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002fd8:	e00a      	b.n	8002ff0 <HAL_RCC_ClockConfig+0xd8>
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002fda:	f7fe fa59 	bl	8001490 <HAL_GetTick>
 8002fde:	4602      	mov	r2, r0
 8002fe0:	68fb      	ldr	r3, [r7, #12]
 8002fe2:	1ad3      	subs	r3, r2, r3
 8002fe4:	f241 3288 	movw	r2, #5000	; 0x1388
 8002fe8:	4293      	cmp	r3, r2
 8002fea:	d901      	bls.n	8002ff0 <HAL_RCC_ClockConfig+0xd8>
      {
        return HAL_TIMEOUT;
 8002fec:	2303      	movs	r3, #3
 8002fee:	e066      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002ff0:	4b36      	ldr	r3, [pc, #216]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8002ff2:	689b      	ldr	r3, [r3, #8]
 8002ff4:	f003 020c 	and.w	r2, r3, #12
 8002ff8:	687b      	ldr	r3, [r7, #4]
 8002ffa:	685b      	ldr	r3, [r3, #4]
 8002ffc:	009b      	lsls	r3, r3, #2
 8002ffe:	429a      	cmp	r2, r3
 8003000:	d1eb      	bne.n	8002fda <HAL_RCC_ClockConfig+0xc2>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003002:	687b      	ldr	r3, [r7, #4]
 8003004:	681b      	ldr	r3, [r3, #0]
 8003006:	f003 0302 	and.w	r3, r3, #2
 800300a:	2b00      	cmp	r3, #0
 800300c:	d008      	beq.n	8003020 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800300e:	4b2f      	ldr	r3, [pc, #188]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8003010:	689b      	ldr	r3, [r3, #8]
 8003012:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003016:	687b      	ldr	r3, [r7, #4]
 8003018:	689b      	ldr	r3, [r3, #8]
 800301a:	492c      	ldr	r1, [pc, #176]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 800301c:	4313      	orrs	r3, r2
 800301e:	608b      	str	r3, [r1, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003020:	4b29      	ldr	r3, [pc, #164]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8003022:	681b      	ldr	r3, [r3, #0]
 8003024:	f003 0307 	and.w	r3, r3, #7
 8003028:	683a      	ldr	r2, [r7, #0]
 800302a:	429a      	cmp	r2, r3
 800302c:	d210      	bcs.n	8003050 <HAL_RCC_ClockConfig+0x138>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800302e:	4b26      	ldr	r3, [pc, #152]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8003030:	681b      	ldr	r3, [r3, #0]
 8003032:	f023 0207 	bic.w	r2, r3, #7
 8003036:	4924      	ldr	r1, [pc, #144]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8003038:	683b      	ldr	r3, [r7, #0]
 800303a:	4313      	orrs	r3, r2
 800303c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800303e:	4b22      	ldr	r3, [pc, #136]	; (80030c8 <HAL_RCC_ClockConfig+0x1b0>)
 8003040:	681b      	ldr	r3, [r3, #0]
 8003042:	f003 0307 	and.w	r3, r3, #7
 8003046:	683a      	ldr	r2, [r7, #0]
 8003048:	429a      	cmp	r2, r3
 800304a:	d001      	beq.n	8003050 <HAL_RCC_ClockConfig+0x138>
    {
      return HAL_ERROR;
 800304c:	2301      	movs	r3, #1
 800304e:	e036      	b.n	80030be <HAL_RCC_ClockConfig+0x1a6>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	681b      	ldr	r3, [r3, #0]
 8003054:	f003 0304 	and.w	r3, r3, #4
 8003058:	2b00      	cmp	r3, #0
 800305a:	d008      	beq.n	800306e <HAL_RCC_ClockConfig+0x156>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800305c:	4b1b      	ldr	r3, [pc, #108]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 800305e:	689b      	ldr	r3, [r3, #8]
 8003060:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8003064:	687b      	ldr	r3, [r7, #4]
 8003066:	68db      	ldr	r3, [r3, #12]
 8003068:	4918      	ldr	r1, [pc, #96]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 800306a:	4313      	orrs	r3, r2
 800306c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800306e:	687b      	ldr	r3, [r7, #4]
 8003070:	681b      	ldr	r3, [r3, #0]
 8003072:	f003 0308 	and.w	r3, r3, #8
 8003076:	2b00      	cmp	r3, #0
 8003078:	d009      	beq.n	800308e <HAL_RCC_ClockConfig+0x176>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800307a:	4b14      	ldr	r3, [pc, #80]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 800307c:	689b      	ldr	r3, [r3, #8]
 800307e:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8003082:	687b      	ldr	r3, [r7, #4]
 8003084:	691b      	ldr	r3, [r3, #16]
 8003086:	00db      	lsls	r3, r3, #3
 8003088:	4910      	ldr	r1, [pc, #64]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 800308a:	4313      	orrs	r3, r2
 800308c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800308e:	f000 f825 	bl	80030dc <HAL_RCC_GetSysClockFreq>
 8003092:	4602      	mov	r2, r0
 8003094:	4b0d      	ldr	r3, [pc, #52]	; (80030cc <HAL_RCC_ClockConfig+0x1b4>)
 8003096:	689b      	ldr	r3, [r3, #8]
 8003098:	091b      	lsrs	r3, r3, #4
 800309a:	f003 030f 	and.w	r3, r3, #15
 800309e:	490c      	ldr	r1, [pc, #48]	; (80030d0 <HAL_RCC_ClockConfig+0x1b8>)
 80030a0:	5ccb      	ldrb	r3, [r1, r3]
 80030a2:	f003 031f 	and.w	r3, r3, #31
 80030a6:	fa22 f303 	lsr.w	r3, r2, r3
 80030aa:	4a0a      	ldr	r2, [pc, #40]	; (80030d4 <HAL_RCC_ClockConfig+0x1bc>)
 80030ac:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 80030ae:	4b0a      	ldr	r3, [pc, #40]	; (80030d8 <HAL_RCC_ClockConfig+0x1c0>)
 80030b0:	681b      	ldr	r3, [r3, #0]
 80030b2:	4618      	mov	r0, r3
 80030b4:	f7fe f99c 	bl	80013f0 <HAL_InitTick>
 80030b8:	4603      	mov	r3, r0
 80030ba:	72fb      	strb	r3, [r7, #11]

  return status;
 80030bc:	7afb      	ldrb	r3, [r7, #11]
}
 80030be:	4618      	mov	r0, r3
 80030c0:	3710      	adds	r7, #16
 80030c2:	46bd      	mov	sp, r7
 80030c4:	bd80      	pop	{r7, pc}
 80030c6:	bf00      	nop
 80030c8:	40022000 	.word	0x40022000
 80030cc:	40021000 	.word	0x40021000
 80030d0:	0801b840 	.word	0x0801b840
 80030d4:	20000000 	.word	0x20000000
 80030d8:	20000004 	.word	0x20000004

080030dc <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80030dc:	b480      	push	{r7}
 80030de:	b089      	sub	sp, #36	; 0x24
 80030e0:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80030e2:	2300      	movs	r3, #0
 80030e4:	61fb      	str	r3, [r7, #28]
 80030e6:	2300      	movs	r3, #0
 80030e8:	61bb      	str	r3, [r7, #24]
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80030ea:	4b3e      	ldr	r3, [pc, #248]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 80030ec:	689b      	ldr	r3, [r3, #8]
 80030ee:	f003 030c 	and.w	r3, r3, #12
 80030f2:	613b      	str	r3, [r7, #16]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80030f4:	4b3b      	ldr	r3, [pc, #236]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 80030f6:	68db      	ldr	r3, [r3, #12]
 80030f8:	f003 0303 	and.w	r3, r3, #3
 80030fc:	60fb      	str	r3, [r7, #12]

  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 80030fe:	693b      	ldr	r3, [r7, #16]
 8003100:	2b00      	cmp	r3, #0
 8003102:	d005      	beq.n	8003110 <HAL_RCC_GetSysClockFreq+0x34>
 8003104:	693b      	ldr	r3, [r7, #16]
 8003106:	2b0c      	cmp	r3, #12
 8003108:	d121      	bne.n	800314e <HAL_RCC_GetSysClockFreq+0x72>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 800310a:	68fb      	ldr	r3, [r7, #12]
 800310c:	2b01      	cmp	r3, #1
 800310e:	d11e      	bne.n	800314e <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8003110:	4b34      	ldr	r3, [pc, #208]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 8003112:	681b      	ldr	r3, [r3, #0]
 8003114:	f003 0308 	and.w	r3, r3, #8
 8003118:	2b00      	cmp	r3, #0
 800311a:	d107      	bne.n	800312c <HAL_RCC_GetSysClockFreq+0x50>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800311c:	4b31      	ldr	r3, [pc, #196]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 800311e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003122:	0a1b      	lsrs	r3, r3, #8
 8003124:	f003 030f 	and.w	r3, r3, #15
 8003128:	61fb      	str	r3, [r7, #28]
 800312a:	e005      	b.n	8003138 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 800312c:	4b2d      	ldr	r3, [pc, #180]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 800312e:	681b      	ldr	r3, [r3, #0]
 8003130:	091b      	lsrs	r3, r3, #4
 8003132:	f003 030f 	and.w	r3, r3, #15
 8003136:	61fb      	str	r3, [r7, #28]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8003138:	4a2b      	ldr	r2, [pc, #172]	; (80031e8 <HAL_RCC_GetSysClockFreq+0x10c>)
 800313a:	69fb      	ldr	r3, [r7, #28]
 800313c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003140:	61fb      	str	r3, [r7, #28]

    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8003142:	693b      	ldr	r3, [r7, #16]
 8003144:	2b00      	cmp	r3, #0
 8003146:	d10d      	bne.n	8003164 <HAL_RCC_GetSysClockFreq+0x88>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8003148:	69fb      	ldr	r3, [r7, #28]
 800314a:	61bb      	str	r3, [r7, #24]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 800314c:	e00a      	b.n	8003164 <HAL_RCC_GetSysClockFreq+0x88>
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 800314e:	693b      	ldr	r3, [r7, #16]
 8003150:	2b04      	cmp	r3, #4
 8003152:	d102      	bne.n	800315a <HAL_RCC_GetSysClockFreq+0x7e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8003154:	4b25      	ldr	r3, [pc, #148]	; (80031ec <HAL_RCC_GetSysClockFreq+0x110>)
 8003156:	61bb      	str	r3, [r7, #24]
 8003158:	e004      	b.n	8003164 <HAL_RCC_GetSysClockFreq+0x88>
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 800315a:	693b      	ldr	r3, [r7, #16]
 800315c:	2b08      	cmp	r3, #8
 800315e:	d101      	bne.n	8003164 <HAL_RCC_GetSysClockFreq+0x88>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8003160:	4b23      	ldr	r3, [pc, #140]	; (80031f0 <HAL_RCC_GetSysClockFreq+0x114>)
 8003162:	61bb      	str	r3, [r7, #24]
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8003164:	693b      	ldr	r3, [r7, #16]
 8003166:	2b0c      	cmp	r3, #12
 8003168:	d134      	bne.n	80031d4 <HAL_RCC_GetSysClockFreq+0xf8>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800316a:	4b1e      	ldr	r3, [pc, #120]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 800316c:	68db      	ldr	r3, [r3, #12]
 800316e:	f003 0303 	and.w	r3, r3, #3
 8003172:	60bb      	str	r3, [r7, #8]

    switch (pllsource)
 8003174:	68bb      	ldr	r3, [r7, #8]
 8003176:	2b02      	cmp	r3, #2
 8003178:	d003      	beq.n	8003182 <HAL_RCC_GetSysClockFreq+0xa6>
 800317a:	68bb      	ldr	r3, [r7, #8]
 800317c:	2b03      	cmp	r3, #3
 800317e:	d003      	beq.n	8003188 <HAL_RCC_GetSysClockFreq+0xac>
 8003180:	e005      	b.n	800318e <HAL_RCC_GetSysClockFreq+0xb2>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
 8003182:	4b1a      	ldr	r3, [pc, #104]	; (80031ec <HAL_RCC_GetSysClockFreq+0x110>)
 8003184:	617b      	str	r3, [r7, #20]
      break;
 8003186:	e005      	b.n	8003194 <HAL_RCC_GetSysClockFreq+0xb8>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = HSE_VALUE;
 8003188:	4b19      	ldr	r3, [pc, #100]	; (80031f0 <HAL_RCC_GetSysClockFreq+0x114>)
 800318a:	617b      	str	r3, [r7, #20]
      break;
 800318c:	e002      	b.n	8003194 <HAL_RCC_GetSysClockFreq+0xb8>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = msirange;
 800318e:	69fb      	ldr	r3, [r7, #28]
 8003190:	617b      	str	r3, [r7, #20]
      break;
 8003192:	bf00      	nop
    }
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8003194:	4b13      	ldr	r3, [pc, #76]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 8003196:	68db      	ldr	r3, [r3, #12]
 8003198:	091b      	lsrs	r3, r3, #4
 800319a:	f003 0307 	and.w	r3, r3, #7
 800319e:	3301      	adds	r3, #1
 80031a0:	607b      	str	r3, [r7, #4]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80031a2:	4b10      	ldr	r3, [pc, #64]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 80031a4:	68db      	ldr	r3, [r3, #12]
 80031a6:	0a1b      	lsrs	r3, r3, #8
 80031a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80031ac:	697a      	ldr	r2, [r7, #20]
 80031ae:	fb03 f202 	mul.w	r2, r3, r2
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	fbb2 f3f3 	udiv	r3, r2, r3
 80031b8:	617b      	str	r3, [r7, #20]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80031ba:	4b0a      	ldr	r3, [pc, #40]	; (80031e4 <HAL_RCC_GetSysClockFreq+0x108>)
 80031bc:	68db      	ldr	r3, [r3, #12]
 80031be:	0e5b      	lsrs	r3, r3, #25
 80031c0:	f003 0303 	and.w	r3, r3, #3
 80031c4:	3301      	adds	r3, #1
 80031c6:	005b      	lsls	r3, r3, #1
 80031c8:	603b      	str	r3, [r7, #0]
    sysclockfreq = pllvco / pllr;
 80031ca:	697a      	ldr	r2, [r7, #20]
 80031cc:	683b      	ldr	r3, [r7, #0]
 80031ce:	fbb2 f3f3 	udiv	r3, r2, r3
 80031d2:	61bb      	str	r3, [r7, #24]
  }

  return sysclockfreq;
 80031d4:	69bb      	ldr	r3, [r7, #24]
}
 80031d6:	4618      	mov	r0, r3
 80031d8:	3724      	adds	r7, #36	; 0x24
 80031da:	46bd      	mov	sp, r7
 80031dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031e0:	4770      	bx	lr
 80031e2:	bf00      	nop
 80031e4:	40021000 	.word	0x40021000
 80031e8:	0801b858 	.word	0x0801b858
 80031ec:	00f42400 	.word	0x00f42400
 80031f0:	007a1200 	.word	0x007a1200

080031f4 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80031f4:	b480      	push	{r7}
 80031f6:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 80031f8:	4b03      	ldr	r3, [pc, #12]	; (8003208 <HAL_RCC_GetHCLKFreq+0x14>)
 80031fa:	681b      	ldr	r3, [r3, #0]
}
 80031fc:	4618      	mov	r0, r3
 80031fe:	46bd      	mov	sp, r7
 8003200:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003204:	4770      	bx	lr
 8003206:	bf00      	nop
 8003208:	20000000 	.word	0x20000000

0800320c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800320c:	b580      	push	{r7, lr}
 800320e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8003210:	f7ff fff0 	bl	80031f4 <HAL_RCC_GetHCLKFreq>
 8003214:	4602      	mov	r2, r0
 8003216:	4b06      	ldr	r3, [pc, #24]	; (8003230 <HAL_RCC_GetPCLK1Freq+0x24>)
 8003218:	689b      	ldr	r3, [r3, #8]
 800321a:	0a1b      	lsrs	r3, r3, #8
 800321c:	f003 0307 	and.w	r3, r3, #7
 8003220:	4904      	ldr	r1, [pc, #16]	; (8003234 <HAL_RCC_GetPCLK1Freq+0x28>)
 8003222:	5ccb      	ldrb	r3, [r1, r3]
 8003224:	f003 031f 	and.w	r3, r3, #31
 8003228:	fa22 f303 	lsr.w	r3, r2, r3
}
 800322c:	4618      	mov	r0, r3
 800322e:	bd80      	pop	{r7, pc}
 8003230:	40021000 	.word	0x40021000
 8003234:	0801b850 	.word	0x0801b850

08003238 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8003238:	b580      	push	{r7, lr}
 800323a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 800323c:	f7ff ffda 	bl	80031f4 <HAL_RCC_GetHCLKFreq>
 8003240:	4602      	mov	r2, r0
 8003242:	4b06      	ldr	r3, [pc, #24]	; (800325c <HAL_RCC_GetPCLK2Freq+0x24>)
 8003244:	689b      	ldr	r3, [r3, #8]
 8003246:	0adb      	lsrs	r3, r3, #11
 8003248:	f003 0307 	and.w	r3, r3, #7
 800324c:	4904      	ldr	r1, [pc, #16]	; (8003260 <HAL_RCC_GetPCLK2Freq+0x28>)
 800324e:	5ccb      	ldrb	r3, [r1, r3]
 8003250:	f003 031f 	and.w	r3, r3, #31
 8003254:	fa22 f303 	lsr.w	r3, r2, r3
}
 8003258:	4618      	mov	r0, r3
 800325a:	bd80      	pop	{r7, pc}
 800325c:	40021000 	.word	0x40021000
 8003260:	0801b850 	.word	0x0801b850

08003264 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8003264:	b580      	push	{r7, lr}
 8003266:	b086      	sub	sp, #24
 8003268:	af00      	add	r7, sp, #0
 800326a:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 800326c:	2300      	movs	r3, #0
 800326e:	613b      	str	r3, [r7, #16]

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8003270:	4b2a      	ldr	r3, [pc, #168]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8003272:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003274:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003278:	2b00      	cmp	r3, #0
 800327a:	d003      	beq.n	8003284 <RCC_SetFlashLatencyFromMSIRange+0x20>
  {
    vos = HAL_PWREx_GetVoltageRange();
 800327c:	f7ff fa00 	bl	8002680 <HAL_PWREx_GetVoltageRange>
 8003280:	6178      	str	r0, [r7, #20]
 8003282:	e014      	b.n	80032ae <RCC_SetFlashLatencyFromMSIRange+0x4a>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8003284:	4b25      	ldr	r3, [pc, #148]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8003286:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003288:	4a24      	ldr	r2, [pc, #144]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 800328a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800328e:	6593      	str	r3, [r2, #88]	; 0x58
 8003290:	4b22      	ldr	r3, [pc, #136]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8003292:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003294:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003298:	60fb      	str	r3, [r7, #12]
 800329a:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 800329c:	f7ff f9f0 	bl	8002680 <HAL_PWREx_GetVoltageRange>
 80032a0:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 80032a2:	4b1e      	ldr	r3, [pc, #120]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 80032a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80032a6:	4a1d      	ldr	r2, [pc, #116]	; (800331c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 80032a8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80032ac:	6593      	str	r3, [r2, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80032ae:	697b      	ldr	r3, [r7, #20]
 80032b0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80032b4:	d10b      	bne.n	80032ce <RCC_SetFlashLatencyFromMSIRange+0x6a>
  {
    if(msirange > RCC_MSIRANGE_8)
 80032b6:	687b      	ldr	r3, [r7, #4]
 80032b8:	2b80      	cmp	r3, #128	; 0x80
 80032ba:	d919      	bls.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 80032bc:	687b      	ldr	r3, [r7, #4]
 80032be:	2ba0      	cmp	r3, #160	; 0xa0
 80032c0:	d902      	bls.n	80032c8 <RCC_SetFlashLatencyFromMSIRange+0x64>
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80032c2:	2302      	movs	r3, #2
 80032c4:	613b      	str	r3, [r7, #16]
 80032c6:	e013      	b.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80032c8:	2301      	movs	r3, #1
 80032ca:	613b      	str	r3, [r7, #16]
 80032cc:	e010      	b.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 80032ce:	687b      	ldr	r3, [r7, #4]
 80032d0:	2b80      	cmp	r3, #128	; 0x80
 80032d2:	d902      	bls.n	80032da <RCC_SetFlashLatencyFromMSIRange+0x76>
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 80032d4:	2303      	movs	r3, #3
 80032d6:	613b      	str	r3, [r7, #16]
 80032d8:	e00a      	b.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 80032da:	687b      	ldr	r3, [r7, #4]
 80032dc:	2b80      	cmp	r3, #128	; 0x80
 80032de:	d102      	bne.n	80032e6 <RCC_SetFlashLatencyFromMSIRange+0x82>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80032e0:	2302      	movs	r3, #2
 80032e2:	613b      	str	r3, [r7, #16]
 80032e4:	e004      	b.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      }
      else if(msirange == RCC_MSIRANGE_7)
 80032e6:	687b      	ldr	r3, [r7, #4]
 80032e8:	2b70      	cmp	r3, #112	; 0x70
 80032ea:	d101      	bne.n	80032f0 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        /* MSI 8Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80032ec:	2301      	movs	r3, #1
 80032ee:	613b      	str	r3, [r7, #16]
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 80032f0:	4b0b      	ldr	r3, [pc, #44]	; (8003320 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 80032f2:	681b      	ldr	r3, [r3, #0]
 80032f4:	f023 0207 	bic.w	r2, r3, #7
 80032f8:	4909      	ldr	r1, [pc, #36]	; (8003320 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 80032fa:	693b      	ldr	r3, [r7, #16]
 80032fc:	4313      	orrs	r3, r2
 80032fe:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8003300:	4b07      	ldr	r3, [pc, #28]	; (8003320 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 8003302:	681b      	ldr	r3, [r3, #0]
 8003304:	f003 0307 	and.w	r3, r3, #7
 8003308:	693a      	ldr	r2, [r7, #16]
 800330a:	429a      	cmp	r2, r3
 800330c:	d001      	beq.n	8003312 <RCC_SetFlashLatencyFromMSIRange+0xae>
  {
    return HAL_ERROR;
 800330e:	2301      	movs	r3, #1
 8003310:	e000      	b.n	8003314 <RCC_SetFlashLatencyFromMSIRange+0xb0>
  }

  return HAL_OK;
 8003312:	2300      	movs	r3, #0
}
 8003314:	4618      	mov	r0, r3
 8003316:	3718      	adds	r7, #24
 8003318:	46bd      	mov	sp, r7
 800331a:	bd80      	pop	{r7, pc}
 800331c:	40021000 	.word	0x40021000
 8003320:	40022000 	.word	0x40022000

08003324 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003324:	b580      	push	{r7, lr}
 8003326:	b086      	sub	sp, #24
 8003328:	af00      	add	r7, sp, #0
 800332a:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister, tickstart;     /* no init needed */
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 800332c:	2300      	movs	r3, #0
 800332e:	74fb      	strb	r3, [r7, #19]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8003330:	2300      	movs	r3, #0
 8003332:	74bb      	strb	r3, [r7, #18]
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8003334:	687b      	ldr	r3, [r7, #4]
 8003336:	681b      	ldr	r3, [r3, #0]
 8003338:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800333c:	2b00      	cmp	r3, #0
 800333e:	d041      	beq.n	80033c4 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8003340:	687b      	ldr	r3, [r7, #4]
 8003342:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003344:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8003348:	d02a      	beq.n	80033a0 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 800334a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800334e:	d824      	bhi.n	800339a <HAL_RCCEx_PeriphCLKConfig+0x76>
 8003350:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8003354:	d008      	beq.n	8003368 <HAL_RCCEx_PeriphCLKConfig+0x44>
 8003356:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800335a:	d81e      	bhi.n	800339a <HAL_RCCEx_PeriphCLKConfig+0x76>
 800335c:	2b00      	cmp	r3, #0
 800335e:	d00a      	beq.n	8003376 <HAL_RCCEx_PeriphCLKConfig+0x52>
 8003360:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8003364:	d010      	beq.n	8003388 <HAL_RCCEx_PeriphCLKConfig+0x64>
 8003366:	e018      	b.n	800339a <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated from System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8003368:	4b86      	ldr	r3, [pc, #536]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800336a:	68db      	ldr	r3, [r3, #12]
 800336c:	4a85      	ldr	r2, [pc, #532]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800336e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003372:	60d3      	str	r3, [r2, #12]
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8003374:	e015      	b.n	80033a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8003376:	687b      	ldr	r3, [r7, #4]
 8003378:	3304      	adds	r3, #4
 800337a:	2100      	movs	r1, #0
 800337c:	4618      	mov	r0, r3
 800337e:	f000 facb 	bl	8003918 <RCCEx_PLLSAI1_Config>
 8003382:	4603      	mov	r3, r0
 8003384:	74fb      	strb	r3, [r7, #19]
      /* SAI1 clock source config set later after clock selection check */
      break;
 8003386:	e00c      	b.n	80033a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	3320      	adds	r3, #32
 800338c:	2100      	movs	r1, #0
 800338e:	4618      	mov	r0, r3
 8003390:	f000 fbb6 	bl	8003b00 <RCCEx_PLLSAI2_Config>
 8003394:	4603      	mov	r3, r0
 8003396:	74fb      	strb	r3, [r7, #19]
      /* SAI1 clock source config set later after clock selection check */
      break;
 8003398:	e003      	b.n	80033a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800339a:	2301      	movs	r3, #1
 800339c:	74fb      	strb	r3, [r7, #19]
      break;
 800339e:	e000      	b.n	80033a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      break;
 80033a0:	bf00      	nop
    }

    if(ret == HAL_OK)
 80033a2:	7cfb      	ldrb	r3, [r7, #19]
 80033a4:	2b00      	cmp	r3, #0
 80033a6:	d10b      	bne.n	80033c0 <HAL_RCCEx_PeriphCLKConfig+0x9c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80033a8:	4b76      	ldr	r3, [pc, #472]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80033aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80033ae:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 80033b2:	687b      	ldr	r3, [r7, #4]
 80033b4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80033b6:	4973      	ldr	r1, [pc, #460]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80033b8:	4313      	orrs	r3, r2
 80033ba:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 80033be:	e001      	b.n	80033c4 <HAL_RCCEx_PeriphCLKConfig+0xa0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80033c0:	7cfb      	ldrb	r3, [r7, #19]
 80033c2:	74bb      	strb	r3, [r7, #18]
#endif /* SAI1 */

#if defined(SAI2)

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 80033c4:	687b      	ldr	r3, [r7, #4]
 80033c6:	681b      	ldr	r3, [r3, #0]
 80033c8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d041      	beq.n	8003454 <HAL_RCCEx_PeriphCLKConfig+0x130>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 80033d0:	687b      	ldr	r3, [r7, #4]
 80033d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80033d4:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 80033d8:	d02a      	beq.n	8003430 <HAL_RCCEx_PeriphCLKConfig+0x10c>
 80033da:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 80033de:	d824      	bhi.n	800342a <HAL_RCCEx_PeriphCLKConfig+0x106>
 80033e0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80033e4:	d008      	beq.n	80033f8 <HAL_RCCEx_PeriphCLKConfig+0xd4>
 80033e6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80033ea:	d81e      	bhi.n	800342a <HAL_RCCEx_PeriphCLKConfig+0x106>
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	d00a      	beq.n	8003406 <HAL_RCCEx_PeriphCLKConfig+0xe2>
 80033f0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80033f4:	d010      	beq.n	8003418 <HAL_RCCEx_PeriphCLKConfig+0xf4>
 80033f6:	e018      	b.n	800342a <HAL_RCCEx_PeriphCLKConfig+0x106>
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated from System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80033f8:	4b62      	ldr	r3, [pc, #392]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80033fa:	68db      	ldr	r3, [r3, #12]
 80033fc:	4a61      	ldr	r2, [pc, #388]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80033fe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003402:	60d3      	str	r3, [r2, #12]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8003404:	e015      	b.n	8003432 <HAL_RCCEx_PeriphCLKConfig+0x10e>

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8003406:	687b      	ldr	r3, [r7, #4]
 8003408:	3304      	adds	r3, #4
 800340a:	2100      	movs	r1, #0
 800340c:	4618      	mov	r0, r3
 800340e:	f000 fa83 	bl	8003918 <RCCEx_PLLSAI1_Config>
 8003412:	4603      	mov	r3, r0
 8003414:	74fb      	strb	r3, [r7, #19]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8003416:	e00c      	b.n	8003432 <HAL_RCCEx_PeriphCLKConfig+0x10e>

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003418:	687b      	ldr	r3, [r7, #4]
 800341a:	3320      	adds	r3, #32
 800341c:	2100      	movs	r1, #0
 800341e:	4618      	mov	r0, r3
 8003420:	f000 fb6e 	bl	8003b00 <RCCEx_PLLSAI2_Config>
 8003424:	4603      	mov	r3, r0
 8003426:	74fb      	strb	r3, [r7, #19]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8003428:	e003      	b.n	8003432 <HAL_RCCEx_PeriphCLKConfig+0x10e>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800342a:	2301      	movs	r3, #1
 800342c:	74fb      	strb	r3, [r7, #19]
      break;
 800342e:	e000      	b.n	8003432 <HAL_RCCEx_PeriphCLKConfig+0x10e>
      break;
 8003430:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003432:	7cfb      	ldrb	r3, [r7, #19]
 8003434:	2b00      	cmp	r3, #0
 8003436:	d10b      	bne.n	8003450 <HAL_RCCEx_PeriphCLKConfig+0x12c>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8003438:	4b52      	ldr	r3, [pc, #328]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800343a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800343e:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 8003442:	687b      	ldr	r3, [r7, #4]
 8003444:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8003446:	494f      	ldr	r1, [pc, #316]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003448:	4313      	orrs	r3, r2
 800344a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 800344e:	e001      	b.n	8003454 <HAL_RCCEx_PeriphCLKConfig+0x130>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003450:	7cfb      	ldrb	r3, [r7, #19]
 8003452:	74bb      	strb	r3, [r7, #18]
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003454:	687b      	ldr	r3, [r7, #4]
 8003456:	681b      	ldr	r3, [r3, #0]
 8003458:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800345c:	2b00      	cmp	r3, #0
 800345e:	f000 80a0 	beq.w	80035a2 <HAL_RCCEx_PeriphCLKConfig+0x27e>
  {
    FlagStatus       pwrclkchanged = RESET;
 8003462:	2300      	movs	r3, #0
 8003464:	747b      	strb	r3, [r7, #17]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8003466:	4b47      	ldr	r3, [pc, #284]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003468:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800346a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800346e:	2b00      	cmp	r3, #0
 8003470:	d101      	bne.n	8003476 <HAL_RCCEx_PeriphCLKConfig+0x152>
 8003472:	2301      	movs	r3, #1
 8003474:	e000      	b.n	8003478 <HAL_RCCEx_PeriphCLKConfig+0x154>
 8003476:	2300      	movs	r3, #0
 8003478:	2b00      	cmp	r3, #0
 800347a:	d00d      	beq.n	8003498 <HAL_RCCEx_PeriphCLKConfig+0x174>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800347c:	4b41      	ldr	r3, [pc, #260]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800347e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003480:	4a40      	ldr	r2, [pc, #256]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003482:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003486:	6593      	str	r3, [r2, #88]	; 0x58
 8003488:	4b3e      	ldr	r3, [pc, #248]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800348a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800348c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003490:	60bb      	str	r3, [r7, #8]
 8003492:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8003494:	2301      	movs	r3, #1
 8003496:	747b      	strb	r3, [r7, #17]
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003498:	4b3b      	ldr	r3, [pc, #236]	; (8003588 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800349a:	681b      	ldr	r3, [r3, #0]
 800349c:	4a3a      	ldr	r2, [pc, #232]	; (8003588 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800349e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80034a2:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80034a4:	f7fd fff4 	bl	8001490 <HAL_GetTick>
 80034a8:	60f8      	str	r0, [r7, #12]

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80034aa:	e009      	b.n	80034c0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80034ac:	f7fd fff0 	bl	8001490 <HAL_GetTick>
 80034b0:	4602      	mov	r2, r0
 80034b2:	68fb      	ldr	r3, [r7, #12]
 80034b4:	1ad3      	subs	r3, r2, r3
 80034b6:	2b02      	cmp	r3, #2
 80034b8:	d902      	bls.n	80034c0 <HAL_RCCEx_PeriphCLKConfig+0x19c>
      {
        ret = HAL_TIMEOUT;
 80034ba:	2303      	movs	r3, #3
 80034bc:	74fb      	strb	r3, [r7, #19]
        break;
 80034be:	e005      	b.n	80034cc <HAL_RCCEx_PeriphCLKConfig+0x1a8>
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80034c0:	4b31      	ldr	r3, [pc, #196]	; (8003588 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80034c2:	681b      	ldr	r3, [r3, #0]
 80034c4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80034c8:	2b00      	cmp	r3, #0
 80034ca:	d0ef      	beq.n	80034ac <HAL_RCCEx_PeriphCLKConfig+0x188>
      }
    }

    if(ret == HAL_OK)
 80034cc:	7cfb      	ldrb	r3, [r7, #19]
 80034ce:	2b00      	cmp	r3, #0
 80034d0:	d15c      	bne.n	800358c <HAL_RCCEx_PeriphCLKConfig+0x268>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80034d2:	4b2c      	ldr	r3, [pc, #176]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80034d4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80034d8:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80034dc:	617b      	str	r3, [r7, #20]

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80034de:	697b      	ldr	r3, [r7, #20]
 80034e0:	2b00      	cmp	r3, #0
 80034e2:	d01f      	beq.n	8003524 <HAL_RCCEx_PeriphCLKConfig+0x200>
 80034e4:	687b      	ldr	r3, [r7, #4]
 80034e6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80034ea:	697a      	ldr	r2, [r7, #20]
 80034ec:	429a      	cmp	r2, r3
 80034ee:	d019      	beq.n	8003524 <HAL_RCCEx_PeriphCLKConfig+0x200>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80034f0:	4b24      	ldr	r3, [pc, #144]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80034f2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80034f6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80034fa:	617b      	str	r3, [r7, #20]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80034fc:	4b21      	ldr	r3, [pc, #132]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80034fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003502:	4a20      	ldr	r2, [pc, #128]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003504:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003508:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 800350c:	4b1d      	ldr	r3, [pc, #116]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800350e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003512:	4a1c      	ldr	r2, [pc, #112]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003514:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003518:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 800351c:	4a19      	ldr	r2, [pc, #100]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800351e:	697b      	ldr	r3, [r7, #20]
 8003520:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8003524:	697b      	ldr	r3, [r7, #20]
 8003526:	f003 0301 	and.w	r3, r3, #1
 800352a:	2b00      	cmp	r3, #0
 800352c:	d016      	beq.n	800355c <HAL_RCCEx_PeriphCLKConfig+0x238>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800352e:	f7fd ffaf 	bl	8001490 <HAL_GetTick>
 8003532:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003534:	e00b      	b.n	800354e <HAL_RCCEx_PeriphCLKConfig+0x22a>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003536:	f7fd ffab 	bl	8001490 <HAL_GetTick>
 800353a:	4602      	mov	r2, r0
 800353c:	68fb      	ldr	r3, [r7, #12]
 800353e:	1ad3      	subs	r3, r2, r3
 8003540:	f241 3288 	movw	r2, #5000	; 0x1388
 8003544:	4293      	cmp	r3, r2
 8003546:	d902      	bls.n	800354e <HAL_RCCEx_PeriphCLKConfig+0x22a>
          {
            ret = HAL_TIMEOUT;
 8003548:	2303      	movs	r3, #3
 800354a:	74fb      	strb	r3, [r7, #19]
            break;
 800354c:	e006      	b.n	800355c <HAL_RCCEx_PeriphCLKConfig+0x238>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800354e:	4b0d      	ldr	r3, [pc, #52]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003550:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003554:	f003 0302 	and.w	r3, r3, #2
 8003558:	2b00      	cmp	r3, #0
 800355a:	d0ec      	beq.n	8003536 <HAL_RCCEx_PeriphCLKConfig+0x212>
          }
        }
      }

      if(ret == HAL_OK)
 800355c:	7cfb      	ldrb	r3, [r7, #19]
 800355e:	2b00      	cmp	r3, #0
 8003560:	d10c      	bne.n	800357c <HAL_RCCEx_PeriphCLKConfig+0x258>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003562:	4b08      	ldr	r3, [pc, #32]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003564:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003568:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800356c:	687b      	ldr	r3, [r7, #4]
 800356e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003572:	4904      	ldr	r1, [pc, #16]	; (8003584 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8003574:	4313      	orrs	r3, r2
 8003576:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 800357a:	e009      	b.n	8003590 <HAL_RCCEx_PeriphCLKConfig+0x26c>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800357c:	7cfb      	ldrb	r3, [r7, #19]
 800357e:	74bb      	strb	r3, [r7, #18]
 8003580:	e006      	b.n	8003590 <HAL_RCCEx_PeriphCLKConfig+0x26c>
 8003582:	bf00      	nop
 8003584:	40021000 	.word	0x40021000
 8003588:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 800358c:	7cfb      	ldrb	r3, [r7, #19]
 800358e:	74bb      	strb	r3, [r7, #18]
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8003590:	7c7b      	ldrb	r3, [r7, #17]
 8003592:	2b01      	cmp	r3, #1
 8003594:	d105      	bne.n	80035a2 <HAL_RCCEx_PeriphCLKConfig+0x27e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003596:	4b9e      	ldr	r3, [pc, #632]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003598:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800359a:	4a9d      	ldr	r2, [pc, #628]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800359c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80035a0:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80035a2:	687b      	ldr	r3, [r7, #4]
 80035a4:	681b      	ldr	r3, [r3, #0]
 80035a6:	f003 0301 	and.w	r3, r3, #1
 80035aa:	2b00      	cmp	r3, #0
 80035ac:	d00a      	beq.n	80035c4 <HAL_RCCEx_PeriphCLKConfig+0x2a0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80035ae:	4b98      	ldr	r3, [pc, #608]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80035b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80035b4:	f023 0203 	bic.w	r2, r3, #3
 80035b8:	687b      	ldr	r3, [r7, #4]
 80035ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80035bc:	4994      	ldr	r1, [pc, #592]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80035be:	4313      	orrs	r3, r2
 80035c0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80035c4:	687b      	ldr	r3, [r7, #4]
 80035c6:	681b      	ldr	r3, [r3, #0]
 80035c8:	f003 0302 	and.w	r3, r3, #2
 80035cc:	2b00      	cmp	r3, #0
 80035ce:	d00a      	beq.n	80035e6 <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80035d0:	4b8f      	ldr	r3, [pc, #572]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80035d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80035d6:	f023 020c 	bic.w	r2, r3, #12
 80035da:	687b      	ldr	r3, [r7, #4]
 80035dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80035de:	498c      	ldr	r1, [pc, #560]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80035e0:	4313      	orrs	r3, r2
 80035e2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80035e6:	687b      	ldr	r3, [r7, #4]
 80035e8:	681b      	ldr	r3, [r3, #0]
 80035ea:	f003 0304 	and.w	r3, r3, #4
 80035ee:	2b00      	cmp	r3, #0
 80035f0:	d00a      	beq.n	8003608 <HAL_RCCEx_PeriphCLKConfig+0x2e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80035f2:	4b87      	ldr	r3, [pc, #540]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80035f4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80035f8:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 80035fc:	687b      	ldr	r3, [r7, #4]
 80035fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003600:	4983      	ldr	r1, [pc, #524]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003602:	4313      	orrs	r3, r2
 8003604:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* USART3 */

#if defined(UART4)

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8003608:	687b      	ldr	r3, [r7, #4]
 800360a:	681b      	ldr	r3, [r3, #0]
 800360c:	f003 0308 	and.w	r3, r3, #8
 8003610:	2b00      	cmp	r3, #0
 8003612:	d00a      	beq.n	800362a <HAL_RCCEx_PeriphCLKConfig+0x306>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8003614:	4b7e      	ldr	r3, [pc, #504]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003616:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800361a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800361e:	687b      	ldr	r3, [r7, #4]
 8003620:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003622:	497b      	ldr	r1, [pc, #492]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003624:	4313      	orrs	r3, r2
 8003626:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800362a:	687b      	ldr	r3, [r7, #4]
 800362c:	681b      	ldr	r3, [r3, #0]
 800362e:	f003 0310 	and.w	r3, r3, #16
 8003632:	2b00      	cmp	r3, #0
 8003634:	d00a      	beq.n	800364c <HAL_RCCEx_PeriphCLKConfig+0x328>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8003636:	4b76      	ldr	r3, [pc, #472]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003638:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800363c:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8003640:	687b      	ldr	r3, [r7, #4]
 8003642:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003644:	4972      	ldr	r1, [pc, #456]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003646:	4313      	orrs	r3, r2
 8003648:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800364c:	687b      	ldr	r3, [r7, #4]
 800364e:	681b      	ldr	r3, [r3, #0]
 8003650:	f003 0320 	and.w	r3, r3, #32
 8003654:	2b00      	cmp	r3, #0
 8003656:	d00a      	beq.n	800366e <HAL_RCCEx_PeriphCLKConfig+0x34a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003658:	4b6d      	ldr	r3, [pc, #436]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800365a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800365e:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8003662:	687b      	ldr	r3, [r7, #4]
 8003664:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003666:	496a      	ldr	r1, [pc, #424]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003668:	4313      	orrs	r3, r2
 800366a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800366e:	687b      	ldr	r3, [r7, #4]
 8003670:	681b      	ldr	r3, [r3, #0]
 8003672:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8003676:	2b00      	cmp	r3, #0
 8003678:	d00a      	beq.n	8003690 <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800367a:	4b65      	ldr	r3, [pc, #404]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800367c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003680:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 8003684:	687b      	ldr	r3, [r7, #4]
 8003686:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003688:	4961      	ldr	r1, [pc, #388]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800368a:	4313      	orrs	r3, r2
 800368c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8003690:	687b      	ldr	r3, [r7, #4]
 8003692:	681b      	ldr	r3, [r3, #0]
 8003694:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003698:	2b00      	cmp	r3, #0
 800369a:	d00a      	beq.n	80036b2 <HAL_RCCEx_PeriphCLKConfig+0x38e>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800369c:	4b5c      	ldr	r3, [pc, #368]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800369e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80036a2:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 80036a6:	687b      	ldr	r3, [r7, #4]
 80036a8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80036aa:	4959      	ldr	r1, [pc, #356]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80036ac:	4313      	orrs	r3, r2
 80036ae:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80036b2:	687b      	ldr	r3, [r7, #4]
 80036b4:	681b      	ldr	r3, [r3, #0]
 80036b6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80036ba:	2b00      	cmp	r3, #0
 80036bc:	d00a      	beq.n	80036d4 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80036be:	4b54      	ldr	r3, [pc, #336]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80036c0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80036c4:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 80036c8:	687b      	ldr	r3, [r7, #4]
 80036ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80036cc:	4950      	ldr	r1, [pc, #320]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80036ce:	4313      	orrs	r3, r2
 80036d0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(I2C2)

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80036d4:	687b      	ldr	r3, [r7, #4]
 80036d6:	681b      	ldr	r3, [r3, #0]
 80036d8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80036dc:	2b00      	cmp	r3, #0
 80036de:	d00a      	beq.n	80036f6 <HAL_RCCEx_PeriphCLKConfig+0x3d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80036e0:	4b4b      	ldr	r3, [pc, #300]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80036e2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80036e6:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 80036ea:	687b      	ldr	r3, [r7, #4]
 80036ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80036ee:	4948      	ldr	r1, [pc, #288]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80036f0:	4313      	orrs	r3, r2
 80036f2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80036f6:	687b      	ldr	r3, [r7, #4]
 80036f8:	681b      	ldr	r3, [r3, #0]
 80036fa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80036fe:	2b00      	cmp	r3, #0
 8003700:	d00a      	beq.n	8003718 <HAL_RCCEx_PeriphCLKConfig+0x3f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8003702:	4b43      	ldr	r3, [pc, #268]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003704:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003708:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800370c:	687b      	ldr	r3, [r7, #4]
 800370e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003710:	493f      	ldr	r1, [pc, #252]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003712:	4313      	orrs	r3, r2
 8003714:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8003718:	687b      	ldr	r3, [r7, #4]
 800371a:	681b      	ldr	r3, [r3, #0]
 800371c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003720:	2b00      	cmp	r3, #0
 8003722:	d028      	beq.n	8003776 <HAL_RCCEx_PeriphCLKConfig+0x452>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8003724:	4b3a      	ldr	r3, [pc, #232]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003726:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800372a:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 800372e:	687b      	ldr	r3, [r7, #4]
 8003730:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003732:	4937      	ldr	r1, [pc, #220]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003734:	4313      	orrs	r3, r2
 8003736:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800373a:	687b      	ldr	r3, [r7, #4]
 800373c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800373e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8003742:	d106      	bne.n	8003752 <HAL_RCCEx_PeriphCLKConfig+0x42e>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8003744:	4b32      	ldr	r3, [pc, #200]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003746:	68db      	ldr	r3, [r3, #12]
 8003748:	4a31      	ldr	r2, [pc, #196]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800374a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800374e:	60d3      	str	r3, [r2, #12]
 8003750:	e011      	b.n	8003776 <HAL_RCCEx_PeriphCLKConfig+0x452>
    }
    else
    {
#if defined(RCC_PLLSAI1_SUPPORT)
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8003752:	687b      	ldr	r3, [r7, #4]
 8003754:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003756:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800375a:	d10c      	bne.n	8003776 <HAL_RCCEx_PeriphCLKConfig+0x452>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800375c:	687b      	ldr	r3, [r7, #4]
 800375e:	3304      	adds	r3, #4
 8003760:	2101      	movs	r1, #1
 8003762:	4618      	mov	r0, r3
 8003764:	f000 f8d8 	bl	8003918 <RCCEx_PLLSAI1_Config>
 8003768:	4603      	mov	r3, r0
 800376a:	74fb      	strb	r3, [r7, #19]

        if(ret != HAL_OK)
 800376c:	7cfb      	ldrb	r3, [r7, #19]
 800376e:	2b00      	cmp	r3, #0
 8003770:	d001      	beq.n	8003776 <HAL_RCCEx_PeriphCLKConfig+0x452>
        {
          /* set overall return value */
          status = ret;
 8003772:	7cfb      	ldrb	r3, [r7, #19]
 8003774:	74bb      	strb	r3, [r7, #18]
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8003776:	687b      	ldr	r3, [r7, #4]
 8003778:	681b      	ldr	r3, [r3, #0]
 800377a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800377e:	2b00      	cmp	r3, #0
 8003780:	d028      	beq.n	80037d4 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8003782:	4b23      	ldr	r3, [pc, #140]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003784:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003788:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 800378c:	687b      	ldr	r3, [r7, #4]
 800378e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003790:	491f      	ldr	r1, [pc, #124]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003792:	4313      	orrs	r3, r2
 8003794:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8003798:	687b      	ldr	r3, [r7, #4]
 800379a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800379c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80037a0:	d106      	bne.n	80037b0 <HAL_RCCEx_PeriphCLKConfig+0x48c>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80037a2:	4b1b      	ldr	r3, [pc, #108]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80037a4:	68db      	ldr	r3, [r3, #12]
 80037a6:	4a1a      	ldr	r2, [pc, #104]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80037a8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80037ac:	60d3      	str	r3, [r2, #12]
 80037ae:	e011      	b.n	80037d4 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
    }
#endif
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80037b0:	687b      	ldr	r3, [r7, #4]
 80037b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80037b4:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80037b8:	d10c      	bne.n	80037d4 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80037ba:	687b      	ldr	r3, [r7, #4]
 80037bc:	3304      	adds	r3, #4
 80037be:	2101      	movs	r1, #1
 80037c0:	4618      	mov	r0, r3
 80037c2:	f000 f8a9 	bl	8003918 <RCCEx_PLLSAI1_Config>
 80037c6:	4603      	mov	r3, r0
 80037c8:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 80037ca:	7cfb      	ldrb	r3, [r7, #19]
 80037cc:	2b00      	cmp	r3, #0
 80037ce:	d001      	beq.n	80037d4 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
      {
        /* set overall return value */
        status = ret;
 80037d0:	7cfb      	ldrb	r3, [r7, #19]
 80037d2:	74bb      	strb	r3, [r7, #18]
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80037d4:	687b      	ldr	r3, [r7, #4]
 80037d6:	681b      	ldr	r3, [r3, #0]
 80037d8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80037dc:	2b00      	cmp	r3, #0
 80037de:	d02b      	beq.n	8003838 <HAL_RCCEx_PeriphCLKConfig+0x514>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80037e0:	4b0b      	ldr	r3, [pc, #44]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80037e2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80037e6:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 80037ea:	687b      	ldr	r3, [r7, #4]
 80037ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80037ee:	4908      	ldr	r1, [pc, #32]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 80037f0:	4313      	orrs	r3, r2
 80037f2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80037f6:	687b      	ldr	r3, [r7, #4]
 80037f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80037fa:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80037fe:	d109      	bne.n	8003814 <HAL_RCCEx_PeriphCLKConfig+0x4f0>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8003800:	4b03      	ldr	r3, [pc, #12]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003802:	68db      	ldr	r3, [r3, #12]
 8003804:	4a02      	ldr	r2, [pc, #8]	; (8003810 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8003806:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800380a:	60d3      	str	r3, [r2, #12]
 800380c:	e014      	b.n	8003838 <HAL_RCCEx_PeriphCLKConfig+0x514>
 800380e:	bf00      	nop
 8003810:	40021000 	.word	0x40021000
    }
#if defined(RCC_PLLSAI1_SUPPORT)
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8003818:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800381c:	d10c      	bne.n	8003838 <HAL_RCCEx_PeriphCLKConfig+0x514>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800381e:	687b      	ldr	r3, [r7, #4]
 8003820:	3304      	adds	r3, #4
 8003822:	2101      	movs	r1, #1
 8003824:	4618      	mov	r0, r3
 8003826:	f000 f877 	bl	8003918 <RCCEx_PLLSAI1_Config>
 800382a:	4603      	mov	r3, r0
 800382c:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 800382e:	7cfb      	ldrb	r3, [r7, #19]
 8003830:	2b00      	cmp	r3, #0
 8003832:	d001      	beq.n	8003838 <HAL_RCCEx_PeriphCLKConfig+0x514>
      {
        /* set overall return value */
        status = ret;
 8003834:	7cfb      	ldrb	r3, [r7, #19]
 8003836:	74bb      	strb	r3, [r7, #18]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
#if !defined(STM32L412xx) && !defined(STM32L422xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8003838:	687b      	ldr	r3, [r7, #4]
 800383a:	681b      	ldr	r3, [r3, #0]
 800383c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003840:	2b00      	cmp	r3, #0
 8003842:	d02f      	beq.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x580>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8003844:	4b2b      	ldr	r3, [pc, #172]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8003846:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800384a:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800384e:	687b      	ldr	r3, [r7, #4]
 8003850:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8003852:	4928      	ldr	r1, [pc, #160]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8003854:	4313      	orrs	r3, r2
 8003856:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 800385a:	687b      	ldr	r3, [r7, #4]
 800385c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800385e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003862:	d10d      	bne.n	8003880 <HAL_RCCEx_PeriphCLKConfig+0x55c>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8003864:	687b      	ldr	r3, [r7, #4]
 8003866:	3304      	adds	r3, #4
 8003868:	2102      	movs	r1, #2
 800386a:	4618      	mov	r0, r3
 800386c:	f000 f854 	bl	8003918 <RCCEx_PLLSAI1_Config>
 8003870:	4603      	mov	r3, r0
 8003872:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 8003874:	7cfb      	ldrb	r3, [r7, #19]
 8003876:	2b00      	cmp	r3, #0
 8003878:	d014      	beq.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x580>
      {
        /* set overall return value */
        status = ret;
 800387a:	7cfb      	ldrb	r3, [r7, #19]
 800387c:	74bb      	strb	r3, [r7, #18]
 800387e:	e011      	b.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x580>
    }
#endif /* RCC_PLLSAI1_SUPPORT */

#if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || defined(STM32L496xx) || defined(STM32L4A6xx)

    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8003884:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8003888:	d10c      	bne.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x580>
    {
      /* PLLSAI2 input clock, parameters M, N & R configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 800388a:	687b      	ldr	r3, [r7, #4]
 800388c:	3320      	adds	r3, #32
 800388e:	2102      	movs	r1, #2
 8003890:	4618      	mov	r0, r3
 8003892:	f000 f935 	bl	8003b00 <RCCEx_PLLSAI2_Config>
 8003896:	4603      	mov	r3, r0
 8003898:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 800389a:	7cfb      	ldrb	r3, [r7, #19]
 800389c:	2b00      	cmp	r3, #0
 800389e:	d001      	beq.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x580>
      {
        /* set overall return value */
        status = ret;
 80038a0:	7cfb      	ldrb	r3, [r7, #19]
 80038a2:	74bb      	strb	r3, [r7, #18]
#endif /* !STM32L412xx && !STM32L422xx */

#if defined(SWPMI1)

  /*-------------------------- SWPMI1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 80038a4:	687b      	ldr	r3, [r7, #4]
 80038a6:	681b      	ldr	r3, [r3, #0]
 80038a8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80038ac:	2b00      	cmp	r3, #0
 80038ae:	d00a      	beq.n	80038c6 <HAL_RCCEx_PeriphCLKConfig+0x5a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 80038b0:	4b10      	ldr	r3, [pc, #64]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 80038b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80038b6:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
 80038ba:	687b      	ldr	r3, [r7, #4]
 80038bc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80038be:	490d      	ldr	r1, [pc, #52]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 80038c0:	4313      	orrs	r3, r2
 80038c2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)

  /*-------------------------- DFSDM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 80038c6:	687b      	ldr	r3, [r7, #4]
 80038c8:	681b      	ldr	r3, [r3, #0]
 80038ca:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80038ce:	2b00      	cmp	r3, #0
 80038d0:	d00b      	beq.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x5c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 80038d2:	4b08      	ldr	r3, [pc, #32]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 80038d4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80038d8:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 80038dc:	687b      	ldr	r3, [r7, #4]
 80038de:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80038e2:	4904      	ldr	r1, [pc, #16]	; (80038f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 80038e4:	4313      	orrs	r3, r2
 80038e6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
 80038ea:	7cbb      	ldrb	r3, [r7, #18]
}
 80038ec:	4618      	mov	r0, r3
 80038ee:	3718      	adds	r7, #24
 80038f0:	46bd      	mov	sp, r7
 80038f2:	bd80      	pop	{r7, pc}
 80038f4:	40021000 	.word	0x40021000

080038f8 <HAL_RCCEx_EnableMSIPLLMode>:
  * @note   Prior to enable the PLL-mode of the MSI for automatic hardware
  *         calibration LSE oscillator is to be enabled with HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
 80038f8:	b480      	push	{r7}
 80038fa:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 80038fc:	4b05      	ldr	r3, [pc, #20]	; (8003914 <HAL_RCCEx_EnableMSIPLLMode+0x1c>)
 80038fe:	681b      	ldr	r3, [r3, #0]
 8003900:	4a04      	ldr	r2, [pc, #16]	; (8003914 <HAL_RCCEx_EnableMSIPLLMode+0x1c>)
 8003902:	f043 0304 	orr.w	r3, r3, #4
 8003906:	6013      	str	r3, [r2, #0]
}
 8003908:	bf00      	nop
 800390a:	46bd      	mov	sp, r7
 800390c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003910:	4770      	bx	lr
 8003912:	bf00      	nop
 8003914:	40021000 	.word	0x40021000

08003918 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8003918:	b580      	push	{r7, lr}
 800391a:	b084      	sub	sp, #16
 800391c:	af00      	add	r7, sp, #0
 800391e:	6078      	str	r0, [r7, #4]
 8003920:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8003922:	2300      	movs	r3, #0
 8003924:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003926:	4b75      	ldr	r3, [pc, #468]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003928:	68db      	ldr	r3, [r3, #12]
 800392a:	f003 0303 	and.w	r3, r3, #3
 800392e:	2b00      	cmp	r3, #0
 8003930:	d018      	beq.n	8003964 <RCCEx_PLLSAI1_Config+0x4c>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8003932:	4b72      	ldr	r3, [pc, #456]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003934:	68db      	ldr	r3, [r3, #12]
 8003936:	f003 0203 	and.w	r2, r3, #3
 800393a:	687b      	ldr	r3, [r7, #4]
 800393c:	681b      	ldr	r3, [r3, #0]
 800393e:	429a      	cmp	r2, r3
 8003940:	d10d      	bne.n	800395e <RCCEx_PLLSAI1_Config+0x46>
       ||
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
 8003942:	687b      	ldr	r3, [r7, #4]
 8003944:	681b      	ldr	r3, [r3, #0]
       ||
 8003946:	2b00      	cmp	r3, #0
 8003948:	d009      	beq.n	800395e <RCCEx_PLLSAI1_Config+0x46>
#if !defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 800394a:	4b6c      	ldr	r3, [pc, #432]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 800394c:	68db      	ldr	r3, [r3, #12]
 800394e:	091b      	lsrs	r3, r3, #4
 8003950:	f003 0307 	and.w	r3, r3, #7
 8003954:	1c5a      	adds	r2, r3, #1
 8003956:	687b      	ldr	r3, [r7, #4]
 8003958:	685b      	ldr	r3, [r3, #4]
       ||
 800395a:	429a      	cmp	r2, r3
 800395c:	d047      	beq.n	80039ee <RCCEx_PLLSAI1_Config+0xd6>
#endif
      )
    {
      status = HAL_ERROR;
 800395e:	2301      	movs	r3, #1
 8003960:	73fb      	strb	r3, [r7, #15]
 8003962:	e044      	b.n	80039ee <RCCEx_PLLSAI1_Config+0xd6>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 8003964:	687b      	ldr	r3, [r7, #4]
 8003966:	681b      	ldr	r3, [r3, #0]
 8003968:	2b03      	cmp	r3, #3
 800396a:	d018      	beq.n	800399e <RCCEx_PLLSAI1_Config+0x86>
 800396c:	2b03      	cmp	r3, #3
 800396e:	d825      	bhi.n	80039bc <RCCEx_PLLSAI1_Config+0xa4>
 8003970:	2b01      	cmp	r3, #1
 8003972:	d002      	beq.n	800397a <RCCEx_PLLSAI1_Config+0x62>
 8003974:	2b02      	cmp	r3, #2
 8003976:	d009      	beq.n	800398c <RCCEx_PLLSAI1_Config+0x74>
 8003978:	e020      	b.n	80039bc <RCCEx_PLLSAI1_Config+0xa4>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 800397a:	4b60      	ldr	r3, [pc, #384]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 800397c:	681b      	ldr	r3, [r3, #0]
 800397e:	f003 0302 	and.w	r3, r3, #2
 8003982:	2b00      	cmp	r3, #0
 8003984:	d11d      	bne.n	80039c2 <RCCEx_PLLSAI1_Config+0xaa>
      {
        status = HAL_ERROR;
 8003986:	2301      	movs	r3, #1
 8003988:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800398a:	e01a      	b.n	80039c2 <RCCEx_PLLSAI1_Config+0xaa>
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 800398c:	4b5b      	ldr	r3, [pc, #364]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 800398e:	681b      	ldr	r3, [r3, #0]
 8003990:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003994:	2b00      	cmp	r3, #0
 8003996:	d116      	bne.n	80039c6 <RCCEx_PLLSAI1_Config+0xae>
      {
        status = HAL_ERROR;
 8003998:	2301      	movs	r3, #1
 800399a:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800399c:	e013      	b.n	80039c6 <RCCEx_PLLSAI1_Config+0xae>
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 800399e:	4b57      	ldr	r3, [pc, #348]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039a0:	681b      	ldr	r3, [r3, #0]
 80039a2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80039a6:	2b00      	cmp	r3, #0
 80039a8:	d10f      	bne.n	80039ca <RCCEx_PLLSAI1_Config+0xb2>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80039aa:	4b54      	ldr	r3, [pc, #336]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039ac:	681b      	ldr	r3, [r3, #0]
 80039ae:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80039b2:	2b00      	cmp	r3, #0
 80039b4:	d109      	bne.n	80039ca <RCCEx_PLLSAI1_Config+0xb2>
        {
          status = HAL_ERROR;
 80039b6:	2301      	movs	r3, #1
 80039b8:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 80039ba:	e006      	b.n	80039ca <RCCEx_PLLSAI1_Config+0xb2>
    default:
      status = HAL_ERROR;
 80039bc:	2301      	movs	r3, #1
 80039be:	73fb      	strb	r3, [r7, #15]
      break;
 80039c0:	e004      	b.n	80039cc <RCCEx_PLLSAI1_Config+0xb4>
      break;
 80039c2:	bf00      	nop
 80039c4:	e002      	b.n	80039cc <RCCEx_PLLSAI1_Config+0xb4>
      break;
 80039c6:	bf00      	nop
 80039c8:	e000      	b.n	80039cc <RCCEx_PLLSAI1_Config+0xb4>
      break;
 80039ca:	bf00      	nop
    }

    if(status == HAL_OK)
 80039cc:	7bfb      	ldrb	r3, [r7, #15]
 80039ce:	2b00      	cmp	r3, #0
 80039d0:	d10d      	bne.n	80039ee <RCCEx_PLLSAI1_Config+0xd6>
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
      /* Set PLLSAI1 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
#else
      /* Set PLLSAI1 clock source and divider M */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 80039d2:	4b4a      	ldr	r3, [pc, #296]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039d4:	68db      	ldr	r3, [r3, #12]
 80039d6:	f023 0273 	bic.w	r2, r3, #115	; 0x73
 80039da:	687b      	ldr	r3, [r7, #4]
 80039dc:	6819      	ldr	r1, [r3, #0]
 80039de:	687b      	ldr	r3, [r7, #4]
 80039e0:	685b      	ldr	r3, [r3, #4]
 80039e2:	3b01      	subs	r3, #1
 80039e4:	011b      	lsls	r3, r3, #4
 80039e6:	430b      	orrs	r3, r1
 80039e8:	4944      	ldr	r1, [pc, #272]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039ea:	4313      	orrs	r3, r2
 80039ec:	60cb      	str	r3, [r1, #12]
#endif
    }
  }

  if(status == HAL_OK)
 80039ee:	7bfb      	ldrb	r3, [r7, #15]
 80039f0:	2b00      	cmp	r3, #0
 80039f2:	d17d      	bne.n	8003af0 <RCCEx_PLLSAI1_Config+0x1d8>
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 80039f4:	4b41      	ldr	r3, [pc, #260]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039f6:	681b      	ldr	r3, [r3, #0]
 80039f8:	4a40      	ldr	r2, [pc, #256]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 80039fa:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80039fe:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003a00:	f7fd fd46 	bl	8001490 <HAL_GetTick>
 8003a04:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8003a06:	e009      	b.n	8003a1c <RCCEx_PLLSAI1_Config+0x104>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8003a08:	f7fd fd42 	bl	8001490 <HAL_GetTick>
 8003a0c:	4602      	mov	r2, r0
 8003a0e:	68bb      	ldr	r3, [r7, #8]
 8003a10:	1ad3      	subs	r3, r2, r3
 8003a12:	2b02      	cmp	r3, #2
 8003a14:	d902      	bls.n	8003a1c <RCCEx_PLLSAI1_Config+0x104>
      {
        status = HAL_TIMEOUT;
 8003a16:	2303      	movs	r3, #3
 8003a18:	73fb      	strb	r3, [r7, #15]
        break;
 8003a1a:	e005      	b.n	8003a28 <RCCEx_PLLSAI1_Config+0x110>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8003a1c:	4b37      	ldr	r3, [pc, #220]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a1e:	681b      	ldr	r3, [r3, #0]
 8003a20:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003a24:	2b00      	cmp	r3, #0
 8003a26:	d1ef      	bne.n	8003a08 <RCCEx_PLLSAI1_Config+0xf0>
      }
    }

    if(status == HAL_OK)
 8003a28:	7bfb      	ldrb	r3, [r7, #15]
 8003a2a:	2b00      	cmp	r3, #0
 8003a2c:	d160      	bne.n	8003af0 <RCCEx_PLLSAI1_Config+0x1d8>
    {
      if(Divider == DIVIDER_P_UPDATE)
 8003a2e:	683b      	ldr	r3, [r7, #0]
 8003a30:	2b00      	cmp	r3, #0
 8003a32:	d111      	bne.n	8003a58 <RCCEx_PLLSAI1_Config+0x140>
        MODIFY_REG(RCC->PLLSAI1CFGR,
                   RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV,
                   (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (PllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos));
#else
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003a34:	4b31      	ldr	r3, [pc, #196]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a36:	691b      	ldr	r3, [r3, #16]
 8003a38:	f423 331f 	bic.w	r3, r3, #162816	; 0x27c00
 8003a3c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003a40:	687a      	ldr	r2, [r7, #4]
 8003a42:	6892      	ldr	r2, [r2, #8]
 8003a44:	0211      	lsls	r1, r2, #8
 8003a46:	687a      	ldr	r2, [r7, #4]
 8003a48:	68d2      	ldr	r2, [r2, #12]
 8003a4a:	0912      	lsrs	r2, r2, #4
 8003a4c:	0452      	lsls	r2, r2, #17
 8003a4e:	430a      	orrs	r2, r1
 8003a50:	492a      	ldr	r1, [pc, #168]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a52:	4313      	orrs	r3, r2
 8003a54:	610b      	str	r3, [r1, #16]
 8003a56:	e027      	b.n	8003aa8 <RCCEx_PLLSAI1_Config+0x190>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8003a58:	683b      	ldr	r3, [r7, #0]
 8003a5a:	2b01      	cmp	r3, #1
 8003a5c:	d112      	bne.n	8003a84 <RCCEx_PLLSAI1_Config+0x16c>
                   (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) |
                   ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
#else
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003a5e:	4b27      	ldr	r3, [pc, #156]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a60:	691b      	ldr	r3, [r3, #16]
 8003a62:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8003a66:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8003a6a:	687a      	ldr	r2, [r7, #4]
 8003a6c:	6892      	ldr	r2, [r2, #8]
 8003a6e:	0211      	lsls	r1, r2, #8
 8003a70:	687a      	ldr	r2, [r7, #4]
 8003a72:	6912      	ldr	r2, [r2, #16]
 8003a74:	0852      	lsrs	r2, r2, #1
 8003a76:	3a01      	subs	r2, #1
 8003a78:	0552      	lsls	r2, r2, #21
 8003a7a:	430a      	orrs	r2, r1
 8003a7c:	491f      	ldr	r1, [pc, #124]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a7e:	4313      	orrs	r3, r2
 8003a80:	610b      	str	r3, [r1, #16]
 8003a82:	e011      	b.n	8003aa8 <RCCEx_PLLSAI1_Config+0x190>
                   (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) |
                   ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
#else
        /* Configure the PLLSAI1 Division factor R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003a84:	4b1d      	ldr	r3, [pc, #116]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003a86:	691b      	ldr	r3, [r3, #16]
 8003a88:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8003a8c:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8003a90:	687a      	ldr	r2, [r7, #4]
 8003a92:	6892      	ldr	r2, [r2, #8]
 8003a94:	0211      	lsls	r1, r2, #8
 8003a96:	687a      	ldr	r2, [r7, #4]
 8003a98:	6952      	ldr	r2, [r2, #20]
 8003a9a:	0852      	lsrs	r2, r2, #1
 8003a9c:	3a01      	subs	r2, #1
 8003a9e:	0652      	lsls	r2, r2, #25
 8003aa0:	430a      	orrs	r2, r1
 8003aa2:	4916      	ldr	r1, [pc, #88]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003aa4:	4313      	orrs	r3, r2
 8003aa6:	610b      	str	r3, [r1, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8003aa8:	4b14      	ldr	r3, [pc, #80]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003aaa:	681b      	ldr	r3, [r3, #0]
 8003aac:	4a13      	ldr	r2, [pc, #76]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003aae:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003ab2:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003ab4:	f7fd fcec 	bl	8001490 <HAL_GetTick>
 8003ab8:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8003aba:	e009      	b.n	8003ad0 <RCCEx_PLLSAI1_Config+0x1b8>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8003abc:	f7fd fce8 	bl	8001490 <HAL_GetTick>
 8003ac0:	4602      	mov	r2, r0
 8003ac2:	68bb      	ldr	r3, [r7, #8]
 8003ac4:	1ad3      	subs	r3, r2, r3
 8003ac6:	2b02      	cmp	r3, #2
 8003ac8:	d902      	bls.n	8003ad0 <RCCEx_PLLSAI1_Config+0x1b8>
        {
          status = HAL_TIMEOUT;
 8003aca:	2303      	movs	r3, #3
 8003acc:	73fb      	strb	r3, [r7, #15]
          break;
 8003ace:	e005      	b.n	8003adc <RCCEx_PLLSAI1_Config+0x1c4>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8003ad0:	4b0a      	ldr	r3, [pc, #40]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003ad2:	681b      	ldr	r3, [r3, #0]
 8003ad4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003ad8:	2b00      	cmp	r3, #0
 8003ada:	d0ef      	beq.n	8003abc <RCCEx_PLLSAI1_Config+0x1a4>
        }
      }

      if(status == HAL_OK)
 8003adc:	7bfb      	ldrb	r3, [r7, #15]
 8003ade:	2b00      	cmp	r3, #0
 8003ae0:	d106      	bne.n	8003af0 <RCCEx_PLLSAI1_Config+0x1d8>
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8003ae2:	4b06      	ldr	r3, [pc, #24]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003ae4:	691a      	ldr	r2, [r3, #16]
 8003ae6:	687b      	ldr	r3, [r7, #4]
 8003ae8:	699b      	ldr	r3, [r3, #24]
 8003aea:	4904      	ldr	r1, [pc, #16]	; (8003afc <RCCEx_PLLSAI1_Config+0x1e4>)
 8003aec:	4313      	orrs	r3, r2
 8003aee:	610b      	str	r3, [r1, #16]
      }
    }
  }

  return status;
 8003af0:	7bfb      	ldrb	r3, [r7, #15]
}
 8003af2:	4618      	mov	r0, r3
 8003af4:	3710      	adds	r7, #16
 8003af6:	46bd      	mov	sp, r7
 8003af8:	bd80      	pop	{r7, pc}
 8003afa:	bf00      	nop
 8003afc:	40021000 	.word	0x40021000

08003b00 <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 8003b00:	b580      	push	{r7, lr}
 8003b02:	b084      	sub	sp, #16
 8003b04:	af00      	add	r7, sp, #0
 8003b06:	6078      	str	r0, [r7, #4]
 8003b08:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8003b0a:	2300      	movs	r3, #0
 8003b0c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003b0e:	4b6a      	ldr	r3, [pc, #424]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b10:	68db      	ldr	r3, [r3, #12]
 8003b12:	f003 0303 	and.w	r3, r3, #3
 8003b16:	2b00      	cmp	r3, #0
 8003b18:	d018      	beq.n	8003b4c <RCCEx_PLLSAI2_Config+0x4c>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8003b1a:	4b67      	ldr	r3, [pc, #412]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b1c:	68db      	ldr	r3, [r3, #12]
 8003b1e:	f003 0203 	and.w	r2, r3, #3
 8003b22:	687b      	ldr	r3, [r7, #4]
 8003b24:	681b      	ldr	r3, [r3, #0]
 8003b26:	429a      	cmp	r2, r3
 8003b28:	d10d      	bne.n	8003b46 <RCCEx_PLLSAI2_Config+0x46>
       ||
       (PllSai2->PLLSAI2Source == RCC_PLLSOURCE_NONE)
 8003b2a:	687b      	ldr	r3, [r7, #4]
 8003b2c:	681b      	ldr	r3, [r3, #0]
       ||
 8003b2e:	2b00      	cmp	r3, #0
 8003b30:	d009      	beq.n	8003b46 <RCCEx_PLLSAI2_Config+0x46>
#if !defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 8003b32:	4b61      	ldr	r3, [pc, #388]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b34:	68db      	ldr	r3, [r3, #12]
 8003b36:	091b      	lsrs	r3, r3, #4
 8003b38:	f003 0307 	and.w	r3, r3, #7
 8003b3c:	1c5a      	adds	r2, r3, #1
 8003b3e:	687b      	ldr	r3, [r7, #4]
 8003b40:	685b      	ldr	r3, [r3, #4]
       ||
 8003b42:	429a      	cmp	r2, r3
 8003b44:	d047      	beq.n	8003bd6 <RCCEx_PLLSAI2_Config+0xd6>
#endif
      )
    {
      status = HAL_ERROR;
 8003b46:	2301      	movs	r3, #1
 8003b48:	73fb      	strb	r3, [r7, #15]
 8003b4a:	e044      	b.n	8003bd6 <RCCEx_PLLSAI2_Config+0xd6>
    }
  }
  else
  {
    /* Check PLLSAI2 clock source availability */
    switch(PllSai2->PLLSAI2Source)
 8003b4c:	687b      	ldr	r3, [r7, #4]
 8003b4e:	681b      	ldr	r3, [r3, #0]
 8003b50:	2b03      	cmp	r3, #3
 8003b52:	d018      	beq.n	8003b86 <RCCEx_PLLSAI2_Config+0x86>
 8003b54:	2b03      	cmp	r3, #3
 8003b56:	d825      	bhi.n	8003ba4 <RCCEx_PLLSAI2_Config+0xa4>
 8003b58:	2b01      	cmp	r3, #1
 8003b5a:	d002      	beq.n	8003b62 <RCCEx_PLLSAI2_Config+0x62>
 8003b5c:	2b02      	cmp	r3, #2
 8003b5e:	d009      	beq.n	8003b74 <RCCEx_PLLSAI2_Config+0x74>
 8003b60:	e020      	b.n	8003ba4 <RCCEx_PLLSAI2_Config+0xa4>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8003b62:	4b55      	ldr	r3, [pc, #340]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b64:	681b      	ldr	r3, [r3, #0]
 8003b66:	f003 0302 	and.w	r3, r3, #2
 8003b6a:	2b00      	cmp	r3, #0
 8003b6c:	d11d      	bne.n	8003baa <RCCEx_PLLSAI2_Config+0xaa>
      {
        status = HAL_ERROR;
 8003b6e:	2301      	movs	r3, #1
 8003b70:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8003b72:	e01a      	b.n	8003baa <RCCEx_PLLSAI2_Config+0xaa>
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8003b74:	4b50      	ldr	r3, [pc, #320]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b76:	681b      	ldr	r3, [r3, #0]
 8003b78:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003b7c:	2b00      	cmp	r3, #0
 8003b7e:	d116      	bne.n	8003bae <RCCEx_PLLSAI2_Config+0xae>
      {
        status = HAL_ERROR;
 8003b80:	2301      	movs	r3, #1
 8003b82:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8003b84:	e013      	b.n	8003bae <RCCEx_PLLSAI2_Config+0xae>
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8003b86:	4b4c      	ldr	r3, [pc, #304]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b88:	681b      	ldr	r3, [r3, #0]
 8003b8a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	d10f      	bne.n	8003bb2 <RCCEx_PLLSAI2_Config+0xb2>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003b92:	4b49      	ldr	r3, [pc, #292]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003b94:	681b      	ldr	r3, [r3, #0]
 8003b96:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8003b9a:	2b00      	cmp	r3, #0
 8003b9c:	d109      	bne.n	8003bb2 <RCCEx_PLLSAI2_Config+0xb2>
        {
          status = HAL_ERROR;
 8003b9e:	2301      	movs	r3, #1
 8003ba0:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8003ba2:	e006      	b.n	8003bb2 <RCCEx_PLLSAI2_Config+0xb2>
    default:
      status = HAL_ERROR;
 8003ba4:	2301      	movs	r3, #1
 8003ba6:	73fb      	strb	r3, [r7, #15]
      break;
 8003ba8:	e004      	b.n	8003bb4 <RCCEx_PLLSAI2_Config+0xb4>
      break;
 8003baa:	bf00      	nop
 8003bac:	e002      	b.n	8003bb4 <RCCEx_PLLSAI2_Config+0xb4>
      break;
 8003bae:	bf00      	nop
 8003bb0:	e000      	b.n	8003bb4 <RCCEx_PLLSAI2_Config+0xb4>
      break;
 8003bb2:	bf00      	nop
    }

    if(status == HAL_OK)
 8003bb4:	7bfb      	ldrb	r3, [r7, #15]
 8003bb6:	2b00      	cmp	r3, #0
 8003bb8:	d10d      	bne.n	8003bd6 <RCCEx_PLLSAI2_Config+0xd6>
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
      /* Set PLLSAI2 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
#else
      /* Set PLLSAI2 clock source and divider M */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 8003bba:	4b3f      	ldr	r3, [pc, #252]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003bbc:	68db      	ldr	r3, [r3, #12]
 8003bbe:	f023 0273 	bic.w	r2, r3, #115	; 0x73
 8003bc2:	687b      	ldr	r3, [r7, #4]
 8003bc4:	6819      	ldr	r1, [r3, #0]
 8003bc6:	687b      	ldr	r3, [r7, #4]
 8003bc8:	685b      	ldr	r3, [r3, #4]
 8003bca:	3b01      	subs	r3, #1
 8003bcc:	011b      	lsls	r3, r3, #4
 8003bce:	430b      	orrs	r3, r1
 8003bd0:	4939      	ldr	r1, [pc, #228]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003bd2:	4313      	orrs	r3, r2
 8003bd4:	60cb      	str	r3, [r1, #12]
#endif
    }
  }

  if(status == HAL_OK)
 8003bd6:	7bfb      	ldrb	r3, [r7, #15]
 8003bd8:	2b00      	cmp	r3, #0
 8003bda:	d167      	bne.n	8003cac <RCCEx_PLLSAI2_Config+0x1ac>
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8003bdc:	4b36      	ldr	r3, [pc, #216]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003bde:	681b      	ldr	r3, [r3, #0]
 8003be0:	4a35      	ldr	r2, [pc, #212]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003be2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003be6:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003be8:	f7fd fc52 	bl	8001490 <HAL_GetTick>
 8003bec:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8003bee:	e009      	b.n	8003c04 <RCCEx_PLLSAI2_Config+0x104>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8003bf0:	f7fd fc4e 	bl	8001490 <HAL_GetTick>
 8003bf4:	4602      	mov	r2, r0
 8003bf6:	68bb      	ldr	r3, [r7, #8]
 8003bf8:	1ad3      	subs	r3, r2, r3
 8003bfa:	2b02      	cmp	r3, #2
 8003bfc:	d902      	bls.n	8003c04 <RCCEx_PLLSAI2_Config+0x104>
      {
        status = HAL_TIMEOUT;
 8003bfe:	2303      	movs	r3, #3
 8003c00:	73fb      	strb	r3, [r7, #15]
        break;
 8003c02:	e005      	b.n	8003c10 <RCCEx_PLLSAI2_Config+0x110>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8003c04:	4b2c      	ldr	r3, [pc, #176]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c06:	681b      	ldr	r3, [r3, #0]
 8003c08:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8003c0c:	2b00      	cmp	r3, #0
 8003c0e:	d1ef      	bne.n	8003bf0 <RCCEx_PLLSAI2_Config+0xf0>
      }
    }

    if(status == HAL_OK)
 8003c10:	7bfb      	ldrb	r3, [r7, #15]
 8003c12:	2b00      	cmp	r3, #0
 8003c14:	d14a      	bne.n	8003cac <RCCEx_PLLSAI2_Config+0x1ac>
    {
      if(Divider == DIVIDER_P_UPDATE)
 8003c16:	683b      	ldr	r3, [r7, #0]
 8003c18:	2b00      	cmp	r3, #0
 8003c1a:	d111      	bne.n	8003c40 <RCCEx_PLLSAI2_Config+0x140>
        MODIFY_REG(RCC->PLLSAI2CFGR,
                   RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV,
                   (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
                   (PllSai2->PLLSAI2P << RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos));
#else
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003c1c:	4b26      	ldr	r3, [pc, #152]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c1e:	695b      	ldr	r3, [r3, #20]
 8003c20:	f423 331f 	bic.w	r3, r3, #162816	; 0x27c00
 8003c24:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003c28:	687a      	ldr	r2, [r7, #4]
 8003c2a:	6892      	ldr	r2, [r2, #8]
 8003c2c:	0211      	lsls	r1, r2, #8
 8003c2e:	687a      	ldr	r2, [r7, #4]
 8003c30:	68d2      	ldr	r2, [r2, #12]
 8003c32:	0912      	lsrs	r2, r2, #4
 8003c34:	0452      	lsls	r2, r2, #17
 8003c36:	430a      	orrs	r2, r1
 8003c38:	491f      	ldr	r1, [pc, #124]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c3a:	4313      	orrs	r3, r2
 8003c3c:	614b      	str	r3, [r1, #20]
 8003c3e:	e011      	b.n	8003c64 <RCCEx_PLLSAI2_Config+0x164>
                   (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos) |
                   ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
#else
        /* Configure the PLLSAI2 Division factor R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003c40:	4b1d      	ldr	r3, [pc, #116]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c42:	695b      	ldr	r3, [r3, #20]
 8003c44:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8003c48:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8003c4c:	687a      	ldr	r2, [r7, #4]
 8003c4e:	6892      	ldr	r2, [r2, #8]
 8003c50:	0211      	lsls	r1, r2, #8
 8003c52:	687a      	ldr	r2, [r7, #4]
 8003c54:	6912      	ldr	r2, [r2, #16]
 8003c56:	0852      	lsrs	r2, r2, #1
 8003c58:	3a01      	subs	r2, #1
 8003c5a:	0652      	lsls	r2, r2, #25
 8003c5c:	430a      	orrs	r2, r1
 8003c5e:	4916      	ldr	r1, [pc, #88]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c60:	4313      	orrs	r3, r2
 8003c62:	614b      	str	r3, [r1, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 8003c64:	4b14      	ldr	r3, [pc, #80]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c66:	681b      	ldr	r3, [r3, #0]
 8003c68:	4a13      	ldr	r2, [pc, #76]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c6a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003c6e:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003c70:	f7fd fc0e 	bl	8001490 <HAL_GetTick>
 8003c74:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8003c76:	e009      	b.n	8003c8c <RCCEx_PLLSAI2_Config+0x18c>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8003c78:	f7fd fc0a 	bl	8001490 <HAL_GetTick>
 8003c7c:	4602      	mov	r2, r0
 8003c7e:	68bb      	ldr	r3, [r7, #8]
 8003c80:	1ad3      	subs	r3, r2, r3
 8003c82:	2b02      	cmp	r3, #2
 8003c84:	d902      	bls.n	8003c8c <RCCEx_PLLSAI2_Config+0x18c>
        {
          status = HAL_TIMEOUT;
 8003c86:	2303      	movs	r3, #3
 8003c88:	73fb      	strb	r3, [r7, #15]
          break;
 8003c8a:	e005      	b.n	8003c98 <RCCEx_PLLSAI2_Config+0x198>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8003c8c:	4b0a      	ldr	r3, [pc, #40]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003c8e:	681b      	ldr	r3, [r3, #0]
 8003c90:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8003c94:	2b00      	cmp	r3, #0
 8003c96:	d0ef      	beq.n	8003c78 <RCCEx_PLLSAI2_Config+0x178>
        }
      }

      if(status == HAL_OK)
 8003c98:	7bfb      	ldrb	r3, [r7, #15]
 8003c9a:	2b00      	cmp	r3, #0
 8003c9c:	d106      	bne.n	8003cac <RCCEx_PLLSAI2_Config+0x1ac>
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8003c9e:	4b06      	ldr	r3, [pc, #24]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003ca0:	695a      	ldr	r2, [r3, #20]
 8003ca2:	687b      	ldr	r3, [r7, #4]
 8003ca4:	695b      	ldr	r3, [r3, #20]
 8003ca6:	4904      	ldr	r1, [pc, #16]	; (8003cb8 <RCCEx_PLLSAI2_Config+0x1b8>)
 8003ca8:	4313      	orrs	r3, r2
 8003caa:	614b      	str	r3, [r1, #20]
      }
    }
  }

  return status;
 8003cac:	7bfb      	ldrb	r3, [r7, #15]
}
 8003cae:	4618      	mov	r0, r3
 8003cb0:	3710      	adds	r7, #16
 8003cb2:	46bd      	mov	sp, r7
 8003cb4:	bd80      	pop	{r7, pc}
 8003cb6:	bf00      	nop
 8003cb8:	40021000 	.word	0x40021000

08003cbc <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8003cbc:	b580      	push	{r7, lr}
 8003cbe:	b084      	sub	sp, #16
 8003cc0:	af00      	add	r7, sp, #0
 8003cc2:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8003cc4:	687b      	ldr	r3, [r7, #4]
 8003cc6:	2b00      	cmp	r3, #0
 8003cc8:	d101      	bne.n	8003cce <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8003cca:	2301      	movs	r3, #1
 8003ccc:	e095      	b.n	8003dfa <HAL_SPI_Init+0x13e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8003cce:	687b      	ldr	r3, [r7, #4]
 8003cd0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003cd2:	2b00      	cmp	r3, #0
 8003cd4:	d108      	bne.n	8003ce8 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8003cd6:	687b      	ldr	r3, [r7, #4]
 8003cd8:	685b      	ldr	r3, [r3, #4]
 8003cda:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8003cde:	d009      	beq.n	8003cf4 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	2200      	movs	r2, #0
 8003ce4:	61da      	str	r2, [r3, #28]
 8003ce6:	e005      	b.n	8003cf4 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8003ce8:	687b      	ldr	r3, [r7, #4]
 8003cea:	2200      	movs	r2, #0
 8003cec:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8003cee:	687b      	ldr	r3, [r7, #4]
 8003cf0:	2200      	movs	r2, #0
 8003cf2:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003cf4:	687b      	ldr	r3, [r7, #4]
 8003cf6:	2200      	movs	r2, #0
 8003cf8:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8003cfa:	687b      	ldr	r3, [r7, #4]
 8003cfc:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8003d00:	b2db      	uxtb	r3, r3
 8003d02:	2b00      	cmp	r3, #0
 8003d04:	d106      	bne.n	8003d14 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8003d06:	687b      	ldr	r3, [r7, #4]
 8003d08:	2200      	movs	r2, #0
 8003d0a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8003d0e:	6878      	ldr	r0, [r7, #4]
 8003d10:	f7fd f820 	bl	8000d54 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8003d14:	687b      	ldr	r3, [r7, #4]
 8003d16:	2202      	movs	r2, #2
 8003d18:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8003d1c:	687b      	ldr	r3, [r7, #4]
 8003d1e:	681b      	ldr	r3, [r3, #0]
 8003d20:	681a      	ldr	r2, [r3, #0]
 8003d22:	687b      	ldr	r3, [r7, #4]
 8003d24:	681b      	ldr	r3, [r3, #0]
 8003d26:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003d2a:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003d2c:	687b      	ldr	r3, [r7, #4]
 8003d2e:	68db      	ldr	r3, [r3, #12]
 8003d30:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8003d34:	d902      	bls.n	8003d3c <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8003d36:	2300      	movs	r3, #0
 8003d38:	60fb      	str	r3, [r7, #12]
 8003d3a:	e002      	b.n	8003d42 <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8003d3c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003d40:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8003d42:	687b      	ldr	r3, [r7, #4]
 8003d44:	68db      	ldr	r3, [r3, #12]
 8003d46:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8003d4a:	d007      	beq.n	8003d5c <HAL_SPI_Init+0xa0>
 8003d4c:	687b      	ldr	r3, [r7, #4]
 8003d4e:	68db      	ldr	r3, [r3, #12]
 8003d50:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8003d54:	d002      	beq.n	8003d5c <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003d56:	687b      	ldr	r3, [r7, #4]
 8003d58:	2200      	movs	r2, #0
 8003d5a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003d5c:	687b      	ldr	r3, [r7, #4]
 8003d5e:	685b      	ldr	r3, [r3, #4]
 8003d60:	f403 7282 	and.w	r2, r3, #260	; 0x104
 8003d64:	687b      	ldr	r3, [r7, #4]
 8003d66:	689b      	ldr	r3, [r3, #8]
 8003d68:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 8003d6c:	431a      	orrs	r2, r3
 8003d6e:	687b      	ldr	r3, [r7, #4]
 8003d70:	691b      	ldr	r3, [r3, #16]
 8003d72:	f003 0302 	and.w	r3, r3, #2
 8003d76:	431a      	orrs	r2, r3
 8003d78:	687b      	ldr	r3, [r7, #4]
 8003d7a:	695b      	ldr	r3, [r3, #20]
 8003d7c:	f003 0301 	and.w	r3, r3, #1
 8003d80:	431a      	orrs	r2, r3
 8003d82:	687b      	ldr	r3, [r7, #4]
 8003d84:	699b      	ldr	r3, [r3, #24]
 8003d86:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8003d8a:	431a      	orrs	r2, r3
 8003d8c:	687b      	ldr	r3, [r7, #4]
 8003d8e:	69db      	ldr	r3, [r3, #28]
 8003d90:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8003d94:	431a      	orrs	r2, r3
 8003d96:	687b      	ldr	r3, [r7, #4]
 8003d98:	6a1b      	ldr	r3, [r3, #32]
 8003d9a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003d9e:	ea42 0103 	orr.w	r1, r2, r3
 8003da2:	687b      	ldr	r3, [r7, #4]
 8003da4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003da6:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 8003daa:	687b      	ldr	r3, [r7, #4]
 8003dac:	681b      	ldr	r3, [r3, #0]
 8003dae:	430a      	orrs	r2, r1
 8003db0:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8003db2:	687b      	ldr	r3, [r7, #4]
 8003db4:	699b      	ldr	r3, [r3, #24]
 8003db6:	0c1b      	lsrs	r3, r3, #16
 8003db8:	f003 0204 	and.w	r2, r3, #4
 8003dbc:	687b      	ldr	r3, [r7, #4]
 8003dbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003dc0:	f003 0310 	and.w	r3, r3, #16
 8003dc4:	431a      	orrs	r2, r3
 8003dc6:	687b      	ldr	r3, [r7, #4]
 8003dc8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003dca:	f003 0308 	and.w	r3, r3, #8
 8003dce:	431a      	orrs	r2, r3
 8003dd0:	687b      	ldr	r3, [r7, #4]
 8003dd2:	68db      	ldr	r3, [r3, #12]
 8003dd4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8003dd8:	ea42 0103 	orr.w	r1, r2, r3
 8003ddc:	68fb      	ldr	r3, [r7, #12]
 8003dde:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 8003de2:	687b      	ldr	r3, [r7, #4]
 8003de4:	681b      	ldr	r3, [r3, #0]
 8003de6:	430a      	orrs	r2, r1
 8003de8:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8003dea:	687b      	ldr	r3, [r7, #4]
 8003dec:	2200      	movs	r2, #0
 8003dee:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8003df0:	687b      	ldr	r3, [r7, #4]
 8003df2:	2201      	movs	r2, #1
 8003df4:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 8003df8:	2300      	movs	r3, #0
}
 8003dfa:	4618      	mov	r0, r3
 8003dfc:	3710      	adds	r7, #16
 8003dfe:	46bd      	mov	sp, r7
 8003e00:	bd80      	pop	{r7, pc}

08003e02 <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8003e02:	b580      	push	{r7, lr}
 8003e04:	b088      	sub	sp, #32
 8003e06:	af00      	add	r7, sp, #0
 8003e08:	60f8      	str	r0, [r7, #12]
 8003e0a:	60b9      	str	r1, [r7, #8]
 8003e0c:	603b      	str	r3, [r7, #0]
 8003e0e:	4613      	mov	r3, r2
 8003e10:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 8003e12:	2300      	movs	r3, #0
 8003e14:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8003e16:	68fb      	ldr	r3, [r7, #12]
 8003e18:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8003e1c:	2b01      	cmp	r3, #1
 8003e1e:	d101      	bne.n	8003e24 <HAL_SPI_Transmit+0x22>
 8003e20:	2302      	movs	r3, #2
 8003e22:	e158      	b.n	80040d6 <HAL_SPI_Transmit+0x2d4>
 8003e24:	68fb      	ldr	r3, [r7, #12]
 8003e26:	2201      	movs	r2, #1
 8003e28:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8003e2c:	f7fd fb30 	bl	8001490 <HAL_GetTick>
 8003e30:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 8003e32:	88fb      	ldrh	r3, [r7, #6]
 8003e34:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 8003e36:	68fb      	ldr	r3, [r7, #12]
 8003e38:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8003e3c:	b2db      	uxtb	r3, r3
 8003e3e:	2b01      	cmp	r3, #1
 8003e40:	d002      	beq.n	8003e48 <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 8003e42:	2302      	movs	r3, #2
 8003e44:	77fb      	strb	r3, [r7, #31]
    goto error;
 8003e46:	e13d      	b.n	80040c4 <HAL_SPI_Transmit+0x2c2>
  }

  if ((pData == NULL) || (Size == 0U))
 8003e48:	68bb      	ldr	r3, [r7, #8]
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d002      	beq.n	8003e54 <HAL_SPI_Transmit+0x52>
 8003e4e:	88fb      	ldrh	r3, [r7, #6]
 8003e50:	2b00      	cmp	r3, #0
 8003e52:	d102      	bne.n	8003e5a <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 8003e54:	2301      	movs	r3, #1
 8003e56:	77fb      	strb	r3, [r7, #31]
    goto error;
 8003e58:	e134      	b.n	80040c4 <HAL_SPI_Transmit+0x2c2>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8003e5a:	68fb      	ldr	r3, [r7, #12]
 8003e5c:	2203      	movs	r2, #3
 8003e5e:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003e62:	68fb      	ldr	r3, [r7, #12]
 8003e64:	2200      	movs	r2, #0
 8003e66:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8003e68:	68fb      	ldr	r3, [r7, #12]
 8003e6a:	68ba      	ldr	r2, [r7, #8]
 8003e6c:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8003e6e:	68fb      	ldr	r3, [r7, #12]
 8003e70:	88fa      	ldrh	r2, [r7, #6]
 8003e72:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8003e74:	68fb      	ldr	r3, [r7, #12]
 8003e76:	88fa      	ldrh	r2, [r7, #6]
 8003e78:	87da      	strh	r2, [r3, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8003e7a:	68fb      	ldr	r3, [r7, #12]
 8003e7c:	2200      	movs	r2, #0
 8003e7e:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 8003e80:	68fb      	ldr	r3, [r7, #12]
 8003e82:	2200      	movs	r2, #0
 8003e84:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8003e88:	68fb      	ldr	r3, [r7, #12]
 8003e8a:	2200      	movs	r2, #0
 8003e8c:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->TxISR       = NULL;
 8003e90:	68fb      	ldr	r3, [r7, #12]
 8003e92:	2200      	movs	r2, #0
 8003e94:	651a      	str	r2, [r3, #80]	; 0x50
  hspi->RxISR       = NULL;
 8003e96:	68fb      	ldr	r3, [r7, #12]
 8003e98:	2200      	movs	r2, #0
 8003e9a:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003e9c:	68fb      	ldr	r3, [r7, #12]
 8003e9e:	689b      	ldr	r3, [r3, #8]
 8003ea0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003ea4:	d10f      	bne.n	8003ec6 <HAL_SPI_Transmit+0xc4>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 8003ea6:	68fb      	ldr	r3, [r7, #12]
 8003ea8:	681b      	ldr	r3, [r3, #0]
 8003eaa:	681a      	ldr	r2, [r3, #0]
 8003eac:	68fb      	ldr	r3, [r7, #12]
 8003eae:	681b      	ldr	r3, [r3, #0]
 8003eb0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003eb4:	601a      	str	r2, [r3, #0]
    SPI_1LINE_TX(hspi);
 8003eb6:	68fb      	ldr	r3, [r7, #12]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	681a      	ldr	r2, [r3, #0]
 8003ebc:	68fb      	ldr	r3, [r7, #12]
 8003ebe:	681b      	ldr	r3, [r3, #0]
 8003ec0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003ec4:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8003ec6:	68fb      	ldr	r3, [r7, #12]
 8003ec8:	681b      	ldr	r3, [r3, #0]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003ed0:	2b40      	cmp	r3, #64	; 0x40
 8003ed2:	d007      	beq.n	8003ee4 <HAL_SPI_Transmit+0xe2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8003ed4:	68fb      	ldr	r3, [r7, #12]
 8003ed6:	681b      	ldr	r3, [r3, #0]
 8003ed8:	681a      	ldr	r2, [r3, #0]
 8003eda:	68fb      	ldr	r3, [r7, #12]
 8003edc:	681b      	ldr	r3, [r3, #0]
 8003ede:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003ee2:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003ee4:	68fb      	ldr	r3, [r7, #12]
 8003ee6:	68db      	ldr	r3, [r3, #12]
 8003ee8:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8003eec:	d94b      	bls.n	8003f86 <HAL_SPI_Transmit+0x184>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8003eee:	68fb      	ldr	r3, [r7, #12]
 8003ef0:	685b      	ldr	r3, [r3, #4]
 8003ef2:	2b00      	cmp	r3, #0
 8003ef4:	d002      	beq.n	8003efc <HAL_SPI_Transmit+0xfa>
 8003ef6:	8afb      	ldrh	r3, [r7, #22]
 8003ef8:	2b01      	cmp	r3, #1
 8003efa:	d13e      	bne.n	8003f7a <HAL_SPI_Transmit+0x178>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003efc:	68fb      	ldr	r3, [r7, #12]
 8003efe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f00:	881a      	ldrh	r2, [r3, #0]
 8003f02:	68fb      	ldr	r3, [r7, #12]
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8003f08:	68fb      	ldr	r3, [r7, #12]
 8003f0a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f0c:	1c9a      	adds	r2, r3, #2
 8003f0e:	68fb      	ldr	r3, [r7, #12]
 8003f10:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 8003f12:	68fb      	ldr	r3, [r7, #12]
 8003f14:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003f16:	b29b      	uxth	r3, r3
 8003f18:	3b01      	subs	r3, #1
 8003f1a:	b29a      	uxth	r2, r3
 8003f1c:	68fb      	ldr	r3, [r7, #12]
 8003f1e:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8003f20:	e02b      	b.n	8003f7a <HAL_SPI_Transmit+0x178>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8003f22:	68fb      	ldr	r3, [r7, #12]
 8003f24:	681b      	ldr	r3, [r3, #0]
 8003f26:	689b      	ldr	r3, [r3, #8]
 8003f28:	f003 0302 	and.w	r3, r3, #2
 8003f2c:	2b02      	cmp	r3, #2
 8003f2e:	d112      	bne.n	8003f56 <HAL_SPI_Transmit+0x154>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003f30:	68fb      	ldr	r3, [r7, #12]
 8003f32:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f34:	881a      	ldrh	r2, [r3, #0]
 8003f36:	68fb      	ldr	r3, [r7, #12]
 8003f38:	681b      	ldr	r3, [r3, #0]
 8003f3a:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8003f3c:	68fb      	ldr	r3, [r7, #12]
 8003f3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f40:	1c9a      	adds	r2, r3, #2
 8003f42:	68fb      	ldr	r3, [r7, #12]
 8003f44:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8003f46:	68fb      	ldr	r3, [r7, #12]
 8003f48:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003f4a:	b29b      	uxth	r3, r3
 8003f4c:	3b01      	subs	r3, #1
 8003f4e:	b29a      	uxth	r2, r3
 8003f50:	68fb      	ldr	r3, [r7, #12]
 8003f52:	87da      	strh	r2, [r3, #62]	; 0x3e
 8003f54:	e011      	b.n	8003f7a <HAL_SPI_Transmit+0x178>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8003f56:	f7fd fa9b 	bl	8001490 <HAL_GetTick>
 8003f5a:	4602      	mov	r2, r0
 8003f5c:	69bb      	ldr	r3, [r7, #24]
 8003f5e:	1ad3      	subs	r3, r2, r3
 8003f60:	683a      	ldr	r2, [r7, #0]
 8003f62:	429a      	cmp	r2, r3
 8003f64:	d803      	bhi.n	8003f6e <HAL_SPI_Transmit+0x16c>
 8003f66:	683b      	ldr	r3, [r7, #0]
 8003f68:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003f6c:	d102      	bne.n	8003f74 <HAL_SPI_Transmit+0x172>
 8003f6e:	683b      	ldr	r3, [r7, #0]
 8003f70:	2b00      	cmp	r3, #0
 8003f72:	d102      	bne.n	8003f7a <HAL_SPI_Transmit+0x178>
        {
          errorcode = HAL_TIMEOUT;
 8003f74:	2303      	movs	r3, #3
 8003f76:	77fb      	strb	r3, [r7, #31]
          goto error;
 8003f78:	e0a4      	b.n	80040c4 <HAL_SPI_Transmit+0x2c2>
    while (hspi->TxXferCount > 0U)
 8003f7a:	68fb      	ldr	r3, [r7, #12]
 8003f7c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003f7e:	b29b      	uxth	r3, r3
 8003f80:	2b00      	cmp	r3, #0
 8003f82:	d1ce      	bne.n	8003f22 <HAL_SPI_Transmit+0x120>
 8003f84:	e07c      	b.n	8004080 <HAL_SPI_Transmit+0x27e>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8003f86:	68fb      	ldr	r3, [r7, #12]
 8003f88:	685b      	ldr	r3, [r3, #4]
 8003f8a:	2b00      	cmp	r3, #0
 8003f8c:	d002      	beq.n	8003f94 <HAL_SPI_Transmit+0x192>
 8003f8e:	8afb      	ldrh	r3, [r7, #22]
 8003f90:	2b01      	cmp	r3, #1
 8003f92:	d170      	bne.n	8004076 <HAL_SPI_Transmit+0x274>
    {
      if (hspi->TxXferCount > 1U)
 8003f94:	68fb      	ldr	r3, [r7, #12]
 8003f96:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003f98:	b29b      	uxth	r3, r3
 8003f9a:	2b01      	cmp	r3, #1
 8003f9c:	d912      	bls.n	8003fc4 <HAL_SPI_Transmit+0x1c2>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003f9e:	68fb      	ldr	r3, [r7, #12]
 8003fa0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003fa2:	881a      	ldrh	r2, [r3, #0]
 8003fa4:	68fb      	ldr	r3, [r7, #12]
 8003fa6:	681b      	ldr	r3, [r3, #0]
 8003fa8:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8003faa:	68fb      	ldr	r3, [r7, #12]
 8003fac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003fae:	1c9a      	adds	r2, r3, #2
 8003fb0:	68fb      	ldr	r3, [r7, #12]
 8003fb2:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8003fb4:	68fb      	ldr	r3, [r7, #12]
 8003fb6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003fb8:	b29b      	uxth	r3, r3
 8003fba:	3b02      	subs	r3, #2
 8003fbc:	b29a      	uxth	r2, r3
 8003fbe:	68fb      	ldr	r3, [r7, #12]
 8003fc0:	87da      	strh	r2, [r3, #62]	; 0x3e
 8003fc2:	e058      	b.n	8004076 <HAL_SPI_Transmit+0x274>
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8003fc4:	68fb      	ldr	r3, [r7, #12]
 8003fc6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003fc8:	68fb      	ldr	r3, [r7, #12]
 8003fca:	681b      	ldr	r3, [r3, #0]
 8003fcc:	330c      	adds	r3, #12
 8003fce:	7812      	ldrb	r2, [r2, #0]
 8003fd0:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr ++;
 8003fd2:	68fb      	ldr	r3, [r7, #12]
 8003fd4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003fd6:	1c5a      	adds	r2, r3, #1
 8003fd8:	68fb      	ldr	r3, [r7, #12]
 8003fda:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8003fdc:	68fb      	ldr	r3, [r7, #12]
 8003fde:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003fe0:	b29b      	uxth	r3, r3
 8003fe2:	3b01      	subs	r3, #1
 8003fe4:	b29a      	uxth	r2, r3
 8003fe6:	68fb      	ldr	r3, [r7, #12]
 8003fe8:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while (hspi->TxXferCount > 0U)
 8003fea:	e044      	b.n	8004076 <HAL_SPI_Transmit+0x274>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8003fec:	68fb      	ldr	r3, [r7, #12]
 8003fee:	681b      	ldr	r3, [r3, #0]
 8003ff0:	689b      	ldr	r3, [r3, #8]
 8003ff2:	f003 0302 	and.w	r3, r3, #2
 8003ff6:	2b02      	cmp	r3, #2
 8003ff8:	d12b      	bne.n	8004052 <HAL_SPI_Transmit+0x250>
      {
        if (hspi->TxXferCount > 1U)
 8003ffa:	68fb      	ldr	r3, [r7, #12]
 8003ffc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8003ffe:	b29b      	uxth	r3, r3
 8004000:	2b01      	cmp	r3, #1
 8004002:	d912      	bls.n	800402a <HAL_SPI_Transmit+0x228>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8004004:	68fb      	ldr	r3, [r7, #12]
 8004006:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004008:	881a      	ldrh	r2, [r3, #0]
 800400a:	68fb      	ldr	r3, [r7, #12]
 800400c:	681b      	ldr	r3, [r3, #0]
 800400e:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8004010:	68fb      	ldr	r3, [r7, #12]
 8004012:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004014:	1c9a      	adds	r2, r3, #2
 8004016:	68fb      	ldr	r3, [r7, #12]
 8004018:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 800401a:	68fb      	ldr	r3, [r7, #12]
 800401c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800401e:	b29b      	uxth	r3, r3
 8004020:	3b02      	subs	r3, #2
 8004022:	b29a      	uxth	r2, r3
 8004024:	68fb      	ldr	r3, [r7, #12]
 8004026:	87da      	strh	r2, [r3, #62]	; 0x3e
 8004028:	e025      	b.n	8004076 <HAL_SPI_Transmit+0x274>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 800402a:	68fb      	ldr	r3, [r7, #12]
 800402c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800402e:	68fb      	ldr	r3, [r7, #12]
 8004030:	681b      	ldr	r3, [r3, #0]
 8004032:	330c      	adds	r3, #12
 8004034:	7812      	ldrb	r2, [r2, #0]
 8004036:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 8004038:	68fb      	ldr	r3, [r7, #12]
 800403a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800403c:	1c5a      	adds	r2, r3, #1
 800403e:	68fb      	ldr	r3, [r7, #12]
 8004040:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 8004042:	68fb      	ldr	r3, [r7, #12]
 8004044:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004046:	b29b      	uxth	r3, r3
 8004048:	3b01      	subs	r3, #1
 800404a:	b29a      	uxth	r2, r3
 800404c:	68fb      	ldr	r3, [r7, #12]
 800404e:	87da      	strh	r2, [r3, #62]	; 0x3e
 8004050:	e011      	b.n	8004076 <HAL_SPI_Transmit+0x274>
        }
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8004052:	f7fd fa1d 	bl	8001490 <HAL_GetTick>
 8004056:	4602      	mov	r2, r0
 8004058:	69bb      	ldr	r3, [r7, #24]
 800405a:	1ad3      	subs	r3, r2, r3
 800405c:	683a      	ldr	r2, [r7, #0]
 800405e:	429a      	cmp	r2, r3
 8004060:	d803      	bhi.n	800406a <HAL_SPI_Transmit+0x268>
 8004062:	683b      	ldr	r3, [r7, #0]
 8004064:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004068:	d102      	bne.n	8004070 <HAL_SPI_Transmit+0x26e>
 800406a:	683b      	ldr	r3, [r7, #0]
 800406c:	2b00      	cmp	r3, #0
 800406e:	d102      	bne.n	8004076 <HAL_SPI_Transmit+0x274>
        {
          errorcode = HAL_TIMEOUT;
 8004070:	2303      	movs	r3, #3
 8004072:	77fb      	strb	r3, [r7, #31]
          goto error;
 8004074:	e026      	b.n	80040c4 <HAL_SPI_Transmit+0x2c2>
    while (hspi->TxXferCount > 0U)
 8004076:	68fb      	ldr	r3, [r7, #12]
 8004078:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800407a:	b29b      	uxth	r3, r3
 800407c:	2b00      	cmp	r3, #0
 800407e:	d1b5      	bne.n	8003fec <HAL_SPI_Transmit+0x1ea>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8004080:	69ba      	ldr	r2, [r7, #24]
 8004082:	6839      	ldr	r1, [r7, #0]
 8004084:	68f8      	ldr	r0, [r7, #12]
 8004086:	f000 fb57 	bl	8004738 <SPI_EndRxTxTransaction>
 800408a:	4603      	mov	r3, r0
 800408c:	2b00      	cmp	r3, #0
 800408e:	d002      	beq.n	8004096 <HAL_SPI_Transmit+0x294>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8004090:	68fb      	ldr	r3, [r7, #12]
 8004092:	2220      	movs	r2, #32
 8004094:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8004096:	68fb      	ldr	r3, [r7, #12]
 8004098:	689b      	ldr	r3, [r3, #8]
 800409a:	2b00      	cmp	r3, #0
 800409c:	d10a      	bne.n	80040b4 <HAL_SPI_Transmit+0x2b2>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800409e:	2300      	movs	r3, #0
 80040a0:	613b      	str	r3, [r7, #16]
 80040a2:	68fb      	ldr	r3, [r7, #12]
 80040a4:	681b      	ldr	r3, [r3, #0]
 80040a6:	68db      	ldr	r3, [r3, #12]
 80040a8:	613b      	str	r3, [r7, #16]
 80040aa:	68fb      	ldr	r3, [r7, #12]
 80040ac:	681b      	ldr	r3, [r3, #0]
 80040ae:	689b      	ldr	r3, [r3, #8]
 80040b0:	613b      	str	r3, [r7, #16]
 80040b2:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80040b4:	68fb      	ldr	r3, [r7, #12]
 80040b6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80040b8:	2b00      	cmp	r3, #0
 80040ba:	d002      	beq.n	80040c2 <HAL_SPI_Transmit+0x2c0>
  {
    errorcode = HAL_ERROR;
 80040bc:	2301      	movs	r3, #1
 80040be:	77fb      	strb	r3, [r7, #31]
 80040c0:	e000      	b.n	80040c4 <HAL_SPI_Transmit+0x2c2>
  }

error:
 80040c2:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 80040c4:	68fb      	ldr	r3, [r7, #12]
 80040c6:	2201      	movs	r2, #1
 80040c8:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80040cc:	68fb      	ldr	r3, [r7, #12]
 80040ce:	2200      	movs	r2, #0
 80040d0:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 80040d4:	7ffb      	ldrb	r3, [r7, #31]
}
 80040d6:	4618      	mov	r0, r3
 80040d8:	3720      	adds	r7, #32
 80040da:	46bd      	mov	sp, r7
 80040dc:	bd80      	pop	{r7, pc}

080040de <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 80040de:	b580      	push	{r7, lr}
 80040e0:	b08a      	sub	sp, #40	; 0x28
 80040e2:	af00      	add	r7, sp, #0
 80040e4:	60f8      	str	r0, [r7, #12]
 80040e6:	60b9      	str	r1, [r7, #8]
 80040e8:	607a      	str	r2, [r7, #4]
 80040ea:	807b      	strh	r3, [r7, #2]
  uint32_t             spi_cr1;
  uint32_t             spi_cr2;
#endif /* USE_SPI_CRC */

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 80040ec:	2301      	movs	r3, #1
 80040ee:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_StatusTypeDef    errorcode = HAL_OK;
 80040f0:	2300      	movs	r3, #0
 80040f2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80040f6:	68fb      	ldr	r3, [r7, #12]
 80040f8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80040fc:	2b01      	cmp	r3, #1
 80040fe:	d101      	bne.n	8004104 <HAL_SPI_TransmitReceive+0x26>
 8004100:	2302      	movs	r3, #2
 8004102:	e1fb      	b.n	80044fc <HAL_SPI_TransmitReceive+0x41e>
 8004104:	68fb      	ldr	r3, [r7, #12]
 8004106:	2201      	movs	r2, #1
 8004108:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800410c:	f7fd f9c0 	bl	8001490 <HAL_GetTick>
 8004110:	61f8      	str	r0, [r7, #28]

  /* Init temporary variables */
  tmp_state           = hspi->State;
 8004112:	68fb      	ldr	r3, [r7, #12]
 8004114:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8004118:	76fb      	strb	r3, [r7, #27]
  tmp_mode            = hspi->Init.Mode;
 800411a:	68fb      	ldr	r3, [r7, #12]
 800411c:	685b      	ldr	r3, [r3, #4]
 800411e:	617b      	str	r3, [r7, #20]
  initial_TxXferCount = Size;
 8004120:	887b      	ldrh	r3, [r7, #2]
 8004122:	827b      	strh	r3, [r7, #18]
  initial_RxXferCount = Size;
 8004124:	887b      	ldrh	r3, [r7, #2]
 8004126:	823b      	strh	r3, [r7, #16]
#if (USE_SPI_CRC != 0U)
  spi_cr1             = READ_REG(hspi->Instance->CR1);
  spi_cr2             = READ_REG(hspi->Instance->CR2);
#endif /* USE_SPI_CRC */

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8004128:	7efb      	ldrb	r3, [r7, #27]
 800412a:	2b01      	cmp	r3, #1
 800412c:	d00e      	beq.n	800414c <HAL_SPI_TransmitReceive+0x6e>
 800412e:	697b      	ldr	r3, [r7, #20]
 8004130:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8004134:	d106      	bne.n	8004144 <HAL_SPI_TransmitReceive+0x66>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8004136:	68fb      	ldr	r3, [r7, #12]
 8004138:	689b      	ldr	r3, [r3, #8]
 800413a:	2b00      	cmp	r3, #0
 800413c:	d102      	bne.n	8004144 <HAL_SPI_TransmitReceive+0x66>
 800413e:	7efb      	ldrb	r3, [r7, #27]
 8004140:	2b04      	cmp	r3, #4
 8004142:	d003      	beq.n	800414c <HAL_SPI_TransmitReceive+0x6e>
  {
    errorcode = HAL_BUSY;
 8004144:	2302      	movs	r3, #2
 8004146:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 800414a:	e1cd      	b.n	80044e8 <HAL_SPI_TransmitReceive+0x40a>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800414c:	68bb      	ldr	r3, [r7, #8]
 800414e:	2b00      	cmp	r3, #0
 8004150:	d005      	beq.n	800415e <HAL_SPI_TransmitReceive+0x80>
 8004152:	687b      	ldr	r3, [r7, #4]
 8004154:	2b00      	cmp	r3, #0
 8004156:	d002      	beq.n	800415e <HAL_SPI_TransmitReceive+0x80>
 8004158:	887b      	ldrh	r3, [r7, #2]
 800415a:	2b00      	cmp	r3, #0
 800415c:	d103      	bne.n	8004166 <HAL_SPI_TransmitReceive+0x88>
  {
    errorcode = HAL_ERROR;
 800415e:	2301      	movs	r3, #1
 8004160:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 8004164:	e1c0      	b.n	80044e8 <HAL_SPI_TransmitReceive+0x40a>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8004166:	68fb      	ldr	r3, [r7, #12]
 8004168:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800416c:	b2db      	uxtb	r3, r3
 800416e:	2b04      	cmp	r3, #4
 8004170:	d003      	beq.n	800417a <HAL_SPI_TransmitReceive+0x9c>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8004172:	68fb      	ldr	r3, [r7, #12]
 8004174:	2205      	movs	r2, #5
 8004176:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800417a:	68fb      	ldr	r3, [r7, #12]
 800417c:	2200      	movs	r2, #0
 800417e:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8004180:	68fb      	ldr	r3, [r7, #12]
 8004182:	687a      	ldr	r2, [r7, #4]
 8004184:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferCount = Size;
 8004186:	68fb      	ldr	r3, [r7, #12]
 8004188:	887a      	ldrh	r2, [r7, #2]
 800418a:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->RxXferSize  = Size;
 800418e:	68fb      	ldr	r3, [r7, #12]
 8004190:	887a      	ldrh	r2, [r7, #2]
 8004192:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8004196:	68fb      	ldr	r3, [r7, #12]
 8004198:	68ba      	ldr	r2, [r7, #8]
 800419a:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferCount = Size;
 800419c:	68fb      	ldr	r3, [r7, #12]
 800419e:	887a      	ldrh	r2, [r7, #2]
 80041a0:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 80041a2:	68fb      	ldr	r3, [r7, #12]
 80041a4:	887a      	ldrh	r2, [r7, #2]
 80041a6:	879a      	strh	r2, [r3, #60]	; 0x3c

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 80041a8:	68fb      	ldr	r3, [r7, #12]
 80041aa:	2200      	movs	r2, #0
 80041ac:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80041ae:	68fb      	ldr	r3, [r7, #12]
 80041b0:	2200      	movs	r2, #0
 80041b2:	651a      	str	r2, [r3, #80]	; 0x50
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 80041b4:	68fb      	ldr	r3, [r7, #12]
 80041b6:	68db      	ldr	r3, [r3, #12]
 80041b8:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80041bc:	d802      	bhi.n	80041c4 <HAL_SPI_TransmitReceive+0xe6>
 80041be:	8a3b      	ldrh	r3, [r7, #16]
 80041c0:	2b01      	cmp	r3, #1
 80041c2:	d908      	bls.n	80041d6 <HAL_SPI_TransmitReceive+0xf8>
  {
    /* Set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80041c4:	68fb      	ldr	r3, [r7, #12]
 80041c6:	681b      	ldr	r3, [r3, #0]
 80041c8:	685a      	ldr	r2, [r3, #4]
 80041ca:	68fb      	ldr	r3, [r7, #12]
 80041cc:	681b      	ldr	r3, [r3, #0]
 80041ce:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80041d2:	605a      	str	r2, [r3, #4]
 80041d4:	e007      	b.n	80041e6 <HAL_SPI_TransmitReceive+0x108>
  }
  else
  {
    /* Set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80041d6:	68fb      	ldr	r3, [r7, #12]
 80041d8:	681b      	ldr	r3, [r3, #0]
 80041da:	685a      	ldr	r2, [r3, #4]
 80041dc:	68fb      	ldr	r3, [r7, #12]
 80041de:	681b      	ldr	r3, [r3, #0]
 80041e0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80041e4:	605a      	str	r2, [r3, #4]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80041e6:	68fb      	ldr	r3, [r7, #12]
 80041e8:	681b      	ldr	r3, [r3, #0]
 80041ea:	681b      	ldr	r3, [r3, #0]
 80041ec:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80041f0:	2b40      	cmp	r3, #64	; 0x40
 80041f2:	d007      	beq.n	8004204 <HAL_SPI_TransmitReceive+0x126>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80041f4:	68fb      	ldr	r3, [r7, #12]
 80041f6:	681b      	ldr	r3, [r3, #0]
 80041f8:	681a      	ldr	r2, [r3, #0]
 80041fa:	68fb      	ldr	r3, [r7, #12]
 80041fc:	681b      	ldr	r3, [r3, #0]
 80041fe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004202:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004204:	68fb      	ldr	r3, [r7, #12]
 8004206:	68db      	ldr	r3, [r3, #12]
 8004208:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800420c:	d97c      	bls.n	8004308 <HAL_SPI_TransmitReceive+0x22a>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800420e:	68fb      	ldr	r3, [r7, #12]
 8004210:	685b      	ldr	r3, [r3, #4]
 8004212:	2b00      	cmp	r3, #0
 8004214:	d002      	beq.n	800421c <HAL_SPI_TransmitReceive+0x13e>
 8004216:	8a7b      	ldrh	r3, [r7, #18]
 8004218:	2b01      	cmp	r3, #1
 800421a:	d169      	bne.n	80042f0 <HAL_SPI_TransmitReceive+0x212>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800421c:	68fb      	ldr	r3, [r7, #12]
 800421e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004220:	881a      	ldrh	r2, [r3, #0]
 8004222:	68fb      	ldr	r3, [r7, #12]
 8004224:	681b      	ldr	r3, [r3, #0]
 8004226:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8004228:	68fb      	ldr	r3, [r7, #12]
 800422a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800422c:	1c9a      	adds	r2, r3, #2
 800422e:	68fb      	ldr	r3, [r7, #12]
 8004230:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 8004232:	68fb      	ldr	r3, [r7, #12]
 8004234:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004236:	b29b      	uxth	r3, r3
 8004238:	3b01      	subs	r3, #1
 800423a:	b29a      	uxth	r2, r3
 800423c:	68fb      	ldr	r3, [r7, #12]
 800423e:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8004240:	e056      	b.n	80042f0 <HAL_SPI_TransmitReceive+0x212>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8004242:	68fb      	ldr	r3, [r7, #12]
 8004244:	681b      	ldr	r3, [r3, #0]
 8004246:	689b      	ldr	r3, [r3, #8]
 8004248:	f003 0302 	and.w	r3, r3, #2
 800424c:	2b02      	cmp	r3, #2
 800424e:	d11b      	bne.n	8004288 <HAL_SPI_TransmitReceive+0x1aa>
 8004250:	68fb      	ldr	r3, [r7, #12]
 8004252:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004254:	b29b      	uxth	r3, r3
 8004256:	2b00      	cmp	r3, #0
 8004258:	d016      	beq.n	8004288 <HAL_SPI_TransmitReceive+0x1aa>
 800425a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800425c:	2b01      	cmp	r3, #1
 800425e:	d113      	bne.n	8004288 <HAL_SPI_TransmitReceive+0x1aa>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8004260:	68fb      	ldr	r3, [r7, #12]
 8004262:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004264:	881a      	ldrh	r2, [r3, #0]
 8004266:	68fb      	ldr	r3, [r7, #12]
 8004268:	681b      	ldr	r3, [r3, #0]
 800426a:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800426c:	68fb      	ldr	r3, [r7, #12]
 800426e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004270:	1c9a      	adds	r2, r3, #2
 8004272:	68fb      	ldr	r3, [r7, #12]
 8004274:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8004276:	68fb      	ldr	r3, [r7, #12]
 8004278:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800427a:	b29b      	uxth	r3, r3
 800427c:	3b01      	subs	r3, #1
 800427e:	b29a      	uxth	r2, r3
 8004280:	68fb      	ldr	r3, [r7, #12]
 8004282:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 8004284:	2300      	movs	r3, #0
 8004286:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8004288:	68fb      	ldr	r3, [r7, #12]
 800428a:	681b      	ldr	r3, [r3, #0]
 800428c:	689b      	ldr	r3, [r3, #8]
 800428e:	f003 0301 	and.w	r3, r3, #1
 8004292:	2b01      	cmp	r3, #1
 8004294:	d11c      	bne.n	80042d0 <HAL_SPI_TransmitReceive+0x1f2>
 8004296:	68fb      	ldr	r3, [r7, #12]
 8004298:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800429c:	b29b      	uxth	r3, r3
 800429e:	2b00      	cmp	r3, #0
 80042a0:	d016      	beq.n	80042d0 <HAL_SPI_TransmitReceive+0x1f2>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 80042a2:	68fb      	ldr	r3, [r7, #12]
 80042a4:	681b      	ldr	r3, [r3, #0]
 80042a6:	68da      	ldr	r2, [r3, #12]
 80042a8:	68fb      	ldr	r3, [r7, #12]
 80042aa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042ac:	b292      	uxth	r2, r2
 80042ae:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 80042b0:	68fb      	ldr	r3, [r7, #12]
 80042b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042b4:	1c9a      	adds	r2, r3, #2
 80042b6:	68fb      	ldr	r3, [r7, #12]
 80042b8:	641a      	str	r2, [r3, #64]	; 0x40
        hspi->RxXferCount--;
 80042ba:	68fb      	ldr	r3, [r7, #12]
 80042bc:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80042c0:	b29b      	uxth	r3, r3
 80042c2:	3b01      	subs	r3, #1
 80042c4:	b29a      	uxth	r2, r3
 80042c6:	68fb      	ldr	r3, [r7, #12]
 80042c8:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 80042cc:	2301      	movs	r3, #1
 80042ce:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 80042d0:	f7fd f8de 	bl	8001490 <HAL_GetTick>
 80042d4:	4602      	mov	r2, r0
 80042d6:	69fb      	ldr	r3, [r7, #28]
 80042d8:	1ad3      	subs	r3, r2, r3
 80042da:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80042dc:	429a      	cmp	r2, r3
 80042de:	d807      	bhi.n	80042f0 <HAL_SPI_TransmitReceive+0x212>
 80042e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80042e2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80042e6:	d003      	beq.n	80042f0 <HAL_SPI_TransmitReceive+0x212>
      {
        errorcode = HAL_TIMEOUT;
 80042e8:	2303      	movs	r3, #3
 80042ea:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 80042ee:	e0fb      	b.n	80044e8 <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80042f0:	68fb      	ldr	r3, [r7, #12]
 80042f2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80042f4:	b29b      	uxth	r3, r3
 80042f6:	2b00      	cmp	r3, #0
 80042f8:	d1a3      	bne.n	8004242 <HAL_SPI_TransmitReceive+0x164>
 80042fa:	68fb      	ldr	r3, [r7, #12]
 80042fc:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8004300:	b29b      	uxth	r3, r3
 8004302:	2b00      	cmp	r3, #0
 8004304:	d19d      	bne.n	8004242 <HAL_SPI_TransmitReceive+0x164>
 8004306:	e0df      	b.n	80044c8 <HAL_SPI_TransmitReceive+0x3ea>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8004308:	68fb      	ldr	r3, [r7, #12]
 800430a:	685b      	ldr	r3, [r3, #4]
 800430c:	2b00      	cmp	r3, #0
 800430e:	d003      	beq.n	8004318 <HAL_SPI_TransmitReceive+0x23a>
 8004310:	8a7b      	ldrh	r3, [r7, #18]
 8004312:	2b01      	cmp	r3, #1
 8004314:	f040 80cb 	bne.w	80044ae <HAL_SPI_TransmitReceive+0x3d0>
    {
      if (hspi->TxXferCount > 1U)
 8004318:	68fb      	ldr	r3, [r7, #12]
 800431a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800431c:	b29b      	uxth	r3, r3
 800431e:	2b01      	cmp	r3, #1
 8004320:	d912      	bls.n	8004348 <HAL_SPI_TransmitReceive+0x26a>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8004322:	68fb      	ldr	r3, [r7, #12]
 8004324:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004326:	881a      	ldrh	r2, [r3, #0]
 8004328:	68fb      	ldr	r3, [r7, #12]
 800432a:	681b      	ldr	r3, [r3, #0]
 800432c:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800432e:	68fb      	ldr	r3, [r7, #12]
 8004330:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004332:	1c9a      	adds	r2, r3, #2
 8004334:	68fb      	ldr	r3, [r7, #12]
 8004336:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8004338:	68fb      	ldr	r3, [r7, #12]
 800433a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800433c:	b29b      	uxth	r3, r3
 800433e:	3b02      	subs	r3, #2
 8004340:	b29a      	uxth	r2, r3
 8004342:	68fb      	ldr	r3, [r7, #12]
 8004344:	87da      	strh	r2, [r3, #62]	; 0x3e
 8004346:	e0b2      	b.n	80044ae <HAL_SPI_TransmitReceive+0x3d0>
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8004348:	68fb      	ldr	r3, [r7, #12]
 800434a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800434c:	68fb      	ldr	r3, [r7, #12]
 800434e:	681b      	ldr	r3, [r3, #0]
 8004350:	330c      	adds	r3, #12
 8004352:	7812      	ldrb	r2, [r2, #0]
 8004354:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 8004356:	68fb      	ldr	r3, [r7, #12]
 8004358:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800435a:	1c5a      	adds	r2, r3, #1
 800435c:	68fb      	ldr	r3, [r7, #12]
 800435e:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8004360:	68fb      	ldr	r3, [r7, #12]
 8004362:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004364:	b29b      	uxth	r3, r3
 8004366:	3b01      	subs	r3, #1
 8004368:	b29a      	uxth	r2, r3
 800436a:	68fb      	ldr	r3, [r7, #12]
 800436c:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800436e:	e09e      	b.n	80044ae <HAL_SPI_TransmitReceive+0x3d0>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8004370:	68fb      	ldr	r3, [r7, #12]
 8004372:	681b      	ldr	r3, [r3, #0]
 8004374:	689b      	ldr	r3, [r3, #8]
 8004376:	f003 0302 	and.w	r3, r3, #2
 800437a:	2b02      	cmp	r3, #2
 800437c:	d134      	bne.n	80043e8 <HAL_SPI_TransmitReceive+0x30a>
 800437e:	68fb      	ldr	r3, [r7, #12]
 8004380:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004382:	b29b      	uxth	r3, r3
 8004384:	2b00      	cmp	r3, #0
 8004386:	d02f      	beq.n	80043e8 <HAL_SPI_TransmitReceive+0x30a>
 8004388:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800438a:	2b01      	cmp	r3, #1
 800438c:	d12c      	bne.n	80043e8 <HAL_SPI_TransmitReceive+0x30a>
      {
        if (hspi->TxXferCount > 1U)
 800438e:	68fb      	ldr	r3, [r7, #12]
 8004390:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8004392:	b29b      	uxth	r3, r3
 8004394:	2b01      	cmp	r3, #1
 8004396:	d912      	bls.n	80043be <HAL_SPI_TransmitReceive+0x2e0>
        {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8004398:	68fb      	ldr	r3, [r7, #12]
 800439a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800439c:	881a      	ldrh	r2, [r3, #0]
 800439e:	68fb      	ldr	r3, [r7, #12]
 80043a0:	681b      	ldr	r3, [r3, #0]
 80043a2:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 80043a4:	68fb      	ldr	r3, [r7, #12]
 80043a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80043a8:	1c9a      	adds	r2, r3, #2
 80043aa:	68fb      	ldr	r3, [r7, #12]
 80043ac:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 80043ae:	68fb      	ldr	r3, [r7, #12]
 80043b0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80043b2:	b29b      	uxth	r3, r3
 80043b4:	3b02      	subs	r3, #2
 80043b6:	b29a      	uxth	r2, r3
 80043b8:	68fb      	ldr	r3, [r7, #12]
 80043ba:	87da      	strh	r2, [r3, #62]	; 0x3e
 80043bc:	e012      	b.n	80043e4 <HAL_SPI_TransmitReceive+0x306>
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 80043be:	68fb      	ldr	r3, [r7, #12]
 80043c0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80043c2:	68fb      	ldr	r3, [r7, #12]
 80043c4:	681b      	ldr	r3, [r3, #0]
 80043c6:	330c      	adds	r3, #12
 80043c8:	7812      	ldrb	r2, [r2, #0]
 80043ca:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 80043cc:	68fb      	ldr	r3, [r7, #12]
 80043ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80043d0:	1c5a      	adds	r2, r3, #1
 80043d2:	68fb      	ldr	r3, [r7, #12]
 80043d4:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 80043d6:	68fb      	ldr	r3, [r7, #12]
 80043d8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80043da:	b29b      	uxth	r3, r3
 80043dc:	3b01      	subs	r3, #1
 80043de:	b29a      	uxth	r2, r3
 80043e0:	68fb      	ldr	r3, [r7, #12]
 80043e2:	87da      	strh	r2, [r3, #62]	; 0x3e
        }
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 80043e4:	2300      	movs	r3, #0
 80043e6:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80043e8:	68fb      	ldr	r3, [r7, #12]
 80043ea:	681b      	ldr	r3, [r3, #0]
 80043ec:	689b      	ldr	r3, [r3, #8]
 80043ee:	f003 0301 	and.w	r3, r3, #1
 80043f2:	2b01      	cmp	r3, #1
 80043f4:	d148      	bne.n	8004488 <HAL_SPI_TransmitReceive+0x3aa>
 80043f6:	68fb      	ldr	r3, [r7, #12]
 80043f8:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80043fc:	b29b      	uxth	r3, r3
 80043fe:	2b00      	cmp	r3, #0
 8004400:	d042      	beq.n	8004488 <HAL_SPI_TransmitReceive+0x3aa>
      {
        if (hspi->RxXferCount > 1U)
 8004402:	68fb      	ldr	r3, [r7, #12]
 8004404:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8004408:	b29b      	uxth	r3, r3
 800440a:	2b01      	cmp	r3, #1
 800440c:	d923      	bls.n	8004456 <HAL_SPI_TransmitReceive+0x378>
        {
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800440e:	68fb      	ldr	r3, [r7, #12]
 8004410:	681b      	ldr	r3, [r3, #0]
 8004412:	68da      	ldr	r2, [r3, #12]
 8004414:	68fb      	ldr	r3, [r7, #12]
 8004416:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004418:	b292      	uxth	r2, r2
 800441a:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint16_t);
 800441c:	68fb      	ldr	r3, [r7, #12]
 800441e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004420:	1c9a      	adds	r2, r3, #2
 8004422:	68fb      	ldr	r3, [r7, #12]
 8004424:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 8004426:	68fb      	ldr	r3, [r7, #12]
 8004428:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800442c:	b29b      	uxth	r3, r3
 800442e:	3b02      	subs	r3, #2
 8004430:	b29a      	uxth	r2, r3
 8004432:	68fb      	ldr	r3, [r7, #12]
 8004434:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8004438:	68fb      	ldr	r3, [r7, #12]
 800443a:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800443e:	b29b      	uxth	r3, r3
 8004440:	2b01      	cmp	r3, #1
 8004442:	d81f      	bhi.n	8004484 <HAL_SPI_TransmitReceive+0x3a6>
          {
            /* Set RX Fifo threshold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8004444:	68fb      	ldr	r3, [r7, #12]
 8004446:	681b      	ldr	r3, [r3, #0]
 8004448:	685a      	ldr	r2, [r3, #4]
 800444a:	68fb      	ldr	r3, [r7, #12]
 800444c:	681b      	ldr	r3, [r3, #0]
 800444e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8004452:	605a      	str	r2, [r3, #4]
 8004454:	e016      	b.n	8004484 <HAL_SPI_TransmitReceive+0x3a6>
          }
        }
        else
        {
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8004456:	68fb      	ldr	r3, [r7, #12]
 8004458:	681b      	ldr	r3, [r3, #0]
 800445a:	f103 020c 	add.w	r2, r3, #12
 800445e:	68fb      	ldr	r3, [r7, #12]
 8004460:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004462:	7812      	ldrb	r2, [r2, #0]
 8004464:	b2d2      	uxtb	r2, r2
 8004466:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr++;
 8004468:	68fb      	ldr	r3, [r7, #12]
 800446a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800446c:	1c5a      	adds	r2, r3, #1
 800446e:	68fb      	ldr	r3, [r7, #12]
 8004470:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount--;
 8004472:	68fb      	ldr	r3, [r7, #12]
 8004474:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8004478:	b29b      	uxth	r3, r3
 800447a:	3b01      	subs	r3, #1
 800447c:	b29a      	uxth	r2, r3
 800447e:	68fb      	ldr	r3, [r7, #12]
 8004480:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8004484:	2301      	movs	r3, #1
 8004486:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8004488:	f7fd f802 	bl	8001490 <HAL_GetTick>
 800448c:	4602      	mov	r2, r0
 800448e:	69fb      	ldr	r3, [r7, #28]
 8004490:	1ad3      	subs	r3, r2, r3
 8004492:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8004494:	429a      	cmp	r2, r3
 8004496:	d803      	bhi.n	80044a0 <HAL_SPI_TransmitReceive+0x3c2>
 8004498:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800449a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800449e:	d102      	bne.n	80044a6 <HAL_SPI_TransmitReceive+0x3c8>
 80044a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80044a2:	2b00      	cmp	r3, #0
 80044a4:	d103      	bne.n	80044ae <HAL_SPI_TransmitReceive+0x3d0>
      {
        errorcode = HAL_TIMEOUT;
 80044a6:	2303      	movs	r3, #3
 80044a8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 80044ac:	e01c      	b.n	80044e8 <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80044ae:	68fb      	ldr	r3, [r7, #12]
 80044b0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80044b2:	b29b      	uxth	r3, r3
 80044b4:	2b00      	cmp	r3, #0
 80044b6:	f47f af5b 	bne.w	8004370 <HAL_SPI_TransmitReceive+0x292>
 80044ba:	68fb      	ldr	r3, [r7, #12]
 80044bc:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80044c0:	b29b      	uxth	r3, r3
 80044c2:	2b00      	cmp	r3, #0
 80044c4:	f47f af54 	bne.w	8004370 <HAL_SPI_TransmitReceive+0x292>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80044c8:	69fa      	ldr	r2, [r7, #28]
 80044ca:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80044cc:	68f8      	ldr	r0, [r7, #12]
 80044ce:	f000 f933 	bl	8004738 <SPI_EndRxTxTransaction>
 80044d2:	4603      	mov	r3, r0
 80044d4:	2b00      	cmp	r3, #0
 80044d6:	d006      	beq.n	80044e6 <HAL_SPI_TransmitReceive+0x408>
  {
    errorcode = HAL_ERROR;
 80044d8:	2301      	movs	r3, #1
 80044da:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80044de:	68fb      	ldr	r3, [r7, #12]
 80044e0:	2220      	movs	r2, #32
 80044e2:	661a      	str	r2, [r3, #96]	; 0x60
 80044e4:	e000      	b.n	80044e8 <HAL_SPI_TransmitReceive+0x40a>
  }

error :
 80044e6:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 80044e8:	68fb      	ldr	r3, [r7, #12]
 80044ea:	2201      	movs	r2, #1
 80044ec:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 80044f0:	68fb      	ldr	r3, [r7, #12]
 80044f2:	2200      	movs	r2, #0
 80044f4:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 80044f8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
}
 80044fc:	4618      	mov	r0, r3
 80044fe:	3728      	adds	r7, #40	; 0x28
 8004500:	46bd      	mov	sp, r7
 8004502:	bd80      	pop	{r7, pc}

08004504 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8004504:	b580      	push	{r7, lr}
 8004506:	b088      	sub	sp, #32
 8004508:	af00      	add	r7, sp, #0
 800450a:	60f8      	str	r0, [r7, #12]
 800450c:	60b9      	str	r1, [r7, #8]
 800450e:	603b      	str	r3, [r7, #0]
 8004510:	4613      	mov	r3, r2
 8004512:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8004514:	f7fc ffbc 	bl	8001490 <HAL_GetTick>
 8004518:	4602      	mov	r2, r0
 800451a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800451c:	1a9b      	subs	r3, r3, r2
 800451e:	683a      	ldr	r2, [r7, #0]
 8004520:	4413      	add	r3, r2
 8004522:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 8004524:	f7fc ffb4 	bl	8001490 <HAL_GetTick>
 8004528:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 800452a:	4b39      	ldr	r3, [pc, #228]	; (8004610 <SPI_WaitFlagStateUntilTimeout+0x10c>)
 800452c:	681b      	ldr	r3, [r3, #0]
 800452e:	015b      	lsls	r3, r3, #5
 8004530:	0d1b      	lsrs	r3, r3, #20
 8004532:	69fa      	ldr	r2, [r7, #28]
 8004534:	fb02 f303 	mul.w	r3, r2, r3
 8004538:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800453a:	e054      	b.n	80045e6 <SPI_WaitFlagStateUntilTimeout+0xe2>
  {
    if (Timeout != HAL_MAX_DELAY)
 800453c:	683b      	ldr	r3, [r7, #0]
 800453e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004542:	d050      	beq.n	80045e6 <SPI_WaitFlagStateUntilTimeout+0xe2>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8004544:	f7fc ffa4 	bl	8001490 <HAL_GetTick>
 8004548:	4602      	mov	r2, r0
 800454a:	69bb      	ldr	r3, [r7, #24]
 800454c:	1ad3      	subs	r3, r2, r3
 800454e:	69fa      	ldr	r2, [r7, #28]
 8004550:	429a      	cmp	r2, r3
 8004552:	d902      	bls.n	800455a <SPI_WaitFlagStateUntilTimeout+0x56>
 8004554:	69fb      	ldr	r3, [r7, #28]
 8004556:	2b00      	cmp	r3, #0
 8004558:	d13d      	bne.n	80045d6 <SPI_WaitFlagStateUntilTimeout+0xd2>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800455a:	68fb      	ldr	r3, [r7, #12]
 800455c:	681b      	ldr	r3, [r3, #0]
 800455e:	685a      	ldr	r2, [r3, #4]
 8004560:	68fb      	ldr	r3, [r7, #12]
 8004562:	681b      	ldr	r3, [r3, #0]
 8004564:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8004568:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800456a:	68fb      	ldr	r3, [r7, #12]
 800456c:	685b      	ldr	r3, [r3, #4]
 800456e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8004572:	d111      	bne.n	8004598 <SPI_WaitFlagStateUntilTimeout+0x94>
 8004574:	68fb      	ldr	r3, [r7, #12]
 8004576:	689b      	ldr	r3, [r3, #8]
 8004578:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800457c:	d004      	beq.n	8004588 <SPI_WaitFlagStateUntilTimeout+0x84>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800457e:	68fb      	ldr	r3, [r7, #12]
 8004580:	689b      	ldr	r3, [r3, #8]
 8004582:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004586:	d107      	bne.n	8004598 <SPI_WaitFlagStateUntilTimeout+0x94>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8004588:	68fb      	ldr	r3, [r7, #12]
 800458a:	681b      	ldr	r3, [r3, #0]
 800458c:	681a      	ldr	r2, [r3, #0]
 800458e:	68fb      	ldr	r3, [r7, #12]
 8004590:	681b      	ldr	r3, [r3, #0]
 8004592:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8004596:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8004598:	68fb      	ldr	r3, [r7, #12]
 800459a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800459c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80045a0:	d10f      	bne.n	80045c2 <SPI_WaitFlagStateUntilTimeout+0xbe>
        {
          SPI_RESET_CRC(hspi);
 80045a2:	68fb      	ldr	r3, [r7, #12]
 80045a4:	681b      	ldr	r3, [r3, #0]
 80045a6:	681a      	ldr	r2, [r3, #0]
 80045a8:	68fb      	ldr	r3, [r7, #12]
 80045aa:	681b      	ldr	r3, [r3, #0]
 80045ac:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80045b0:	601a      	str	r2, [r3, #0]
 80045b2:	68fb      	ldr	r3, [r7, #12]
 80045b4:	681b      	ldr	r3, [r3, #0]
 80045b6:	681a      	ldr	r2, [r3, #0]
 80045b8:	68fb      	ldr	r3, [r7, #12]
 80045ba:	681b      	ldr	r3, [r3, #0]
 80045bc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80045c0:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 80045c2:	68fb      	ldr	r3, [r7, #12]
 80045c4:	2201      	movs	r2, #1
 80045c6:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80045ca:	68fb      	ldr	r3, [r7, #12]
 80045cc:	2200      	movs	r2, #0
 80045ce:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 80045d2:	2303      	movs	r3, #3
 80045d4:	e017      	b.n	8004606 <SPI_WaitFlagStateUntilTimeout+0x102>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if(count == 0U)
 80045d6:	697b      	ldr	r3, [r7, #20]
 80045d8:	2b00      	cmp	r3, #0
 80045da:	d101      	bne.n	80045e0 <SPI_WaitFlagStateUntilTimeout+0xdc>
      {
        tmp_timeout = 0U;
 80045dc:	2300      	movs	r3, #0
 80045de:	61fb      	str	r3, [r7, #28]
      }
      count--;
 80045e0:	697b      	ldr	r3, [r7, #20]
 80045e2:	3b01      	subs	r3, #1
 80045e4:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80045e6:	68fb      	ldr	r3, [r7, #12]
 80045e8:	681b      	ldr	r3, [r3, #0]
 80045ea:	689a      	ldr	r2, [r3, #8]
 80045ec:	68bb      	ldr	r3, [r7, #8]
 80045ee:	4013      	ands	r3, r2
 80045f0:	68ba      	ldr	r2, [r7, #8]
 80045f2:	429a      	cmp	r2, r3
 80045f4:	bf0c      	ite	eq
 80045f6:	2301      	moveq	r3, #1
 80045f8:	2300      	movne	r3, #0
 80045fa:	b2db      	uxtb	r3, r3
 80045fc:	461a      	mov	r2, r3
 80045fe:	79fb      	ldrb	r3, [r7, #7]
 8004600:	429a      	cmp	r2, r3
 8004602:	d19b      	bne.n	800453c <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 8004604:	2300      	movs	r3, #0
}
 8004606:	4618      	mov	r0, r3
 8004608:	3720      	adds	r7, #32
 800460a:	46bd      	mov	sp, r7
 800460c:	bd80      	pop	{r7, pc}
 800460e:	bf00      	nop
 8004610:	20000000 	.word	0x20000000

08004614 <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8004614:	b580      	push	{r7, lr}
 8004616:	b088      	sub	sp, #32
 8004618:	af00      	add	r7, sp, #0
 800461a:	60f8      	str	r0, [r7, #12]
 800461c:	60b9      	str	r1, [r7, #8]
 800461e:	607a      	str	r2, [r7, #4]
 8004620:	603b      	str	r3, [r7, #0]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 8004622:	f7fc ff35 	bl	8001490 <HAL_GetTick>
 8004626:	4602      	mov	r2, r0
 8004628:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800462a:	1a9b      	subs	r3, r3, r2
 800462c:	683a      	ldr	r2, [r7, #0]
 800462e:	4413      	add	r3, r2
 8004630:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 8004632:	f7fc ff2d 	bl	8001490 <HAL_GetTick>
 8004636:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8004638:	4b3e      	ldr	r3, [pc, #248]	; (8004734 <SPI_WaitFifoStateUntilTimeout+0x120>)
 800463a:	681a      	ldr	r2, [r3, #0]
 800463c:	4613      	mov	r3, r2
 800463e:	009b      	lsls	r3, r3, #2
 8004640:	4413      	add	r3, r2
 8004642:	00da      	lsls	r2, r3, #3
 8004644:	1ad3      	subs	r3, r2, r3
 8004646:	0d1b      	lsrs	r3, r3, #20
 8004648:	69fa      	ldr	r2, [r7, #28]
 800464a:	fb02 f303 	mul.w	r3, r2, r3
 800464e:	613b      	str	r3, [r7, #16]

  while ((hspi->Instance->SR & Fifo) != State)
 8004650:	e062      	b.n	8004718 <SPI_WaitFifoStateUntilTimeout+0x104>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8004652:	68bb      	ldr	r3, [r7, #8]
 8004654:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8004658:	d109      	bne.n	800466e <SPI_WaitFifoStateUntilTimeout+0x5a>
 800465a:	687b      	ldr	r3, [r7, #4]
 800465c:	2b00      	cmp	r3, #0
 800465e:	d106      	bne.n	800466e <SPI_WaitFifoStateUntilTimeout+0x5a>
    {
      /* Flush Data Register by a blank read */
      tmpreg = READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8004660:	68fb      	ldr	r3, [r7, #12]
 8004662:	681b      	ldr	r3, [r3, #0]
 8004664:	330c      	adds	r3, #12
 8004666:	781b      	ldrb	r3, [r3, #0]
 8004668:	b2db      	uxtb	r3, r3
 800466a:	617b      	str	r3, [r7, #20]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 800466c:	697b      	ldr	r3, [r7, #20]
    }

    if (Timeout != HAL_MAX_DELAY)
 800466e:	683b      	ldr	r3, [r7, #0]
 8004670:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004674:	d050      	beq.n	8004718 <SPI_WaitFifoStateUntilTimeout+0x104>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8004676:	f7fc ff0b 	bl	8001490 <HAL_GetTick>
 800467a:	4602      	mov	r2, r0
 800467c:	69bb      	ldr	r3, [r7, #24]
 800467e:	1ad3      	subs	r3, r2, r3
 8004680:	69fa      	ldr	r2, [r7, #28]
 8004682:	429a      	cmp	r2, r3
 8004684:	d902      	bls.n	800468c <SPI_WaitFifoStateUntilTimeout+0x78>
 8004686:	69fb      	ldr	r3, [r7, #28]
 8004688:	2b00      	cmp	r3, #0
 800468a:	d13d      	bne.n	8004708 <SPI_WaitFifoStateUntilTimeout+0xf4>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800468c:	68fb      	ldr	r3, [r7, #12]
 800468e:	681b      	ldr	r3, [r3, #0]
 8004690:	685a      	ldr	r2, [r3, #4]
 8004692:	68fb      	ldr	r3, [r7, #12]
 8004694:	681b      	ldr	r3, [r3, #0]
 8004696:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800469a:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800469c:	68fb      	ldr	r3, [r7, #12]
 800469e:	685b      	ldr	r3, [r3, #4]
 80046a0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80046a4:	d111      	bne.n	80046ca <SPI_WaitFifoStateUntilTimeout+0xb6>
 80046a6:	68fb      	ldr	r3, [r7, #12]
 80046a8:	689b      	ldr	r3, [r3, #8]
 80046aa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80046ae:	d004      	beq.n	80046ba <SPI_WaitFifoStateUntilTimeout+0xa6>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80046b0:	68fb      	ldr	r3, [r7, #12]
 80046b2:	689b      	ldr	r3, [r3, #8]
 80046b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80046b8:	d107      	bne.n	80046ca <SPI_WaitFifoStateUntilTimeout+0xb6>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 80046ba:	68fb      	ldr	r3, [r7, #12]
 80046bc:	681b      	ldr	r3, [r3, #0]
 80046be:	681a      	ldr	r2, [r3, #0]
 80046c0:	68fb      	ldr	r3, [r7, #12]
 80046c2:	681b      	ldr	r3, [r3, #0]
 80046c4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80046c8:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80046ca:	68fb      	ldr	r3, [r7, #12]
 80046cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80046ce:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80046d2:	d10f      	bne.n	80046f4 <SPI_WaitFifoStateUntilTimeout+0xe0>
        {
          SPI_RESET_CRC(hspi);
 80046d4:	68fb      	ldr	r3, [r7, #12]
 80046d6:	681b      	ldr	r3, [r3, #0]
 80046d8:	681a      	ldr	r2, [r3, #0]
 80046da:	68fb      	ldr	r3, [r7, #12]
 80046dc:	681b      	ldr	r3, [r3, #0]
 80046de:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80046e2:	601a      	str	r2, [r3, #0]
 80046e4:	68fb      	ldr	r3, [r7, #12]
 80046e6:	681b      	ldr	r3, [r3, #0]
 80046e8:	681a      	ldr	r2, [r3, #0]
 80046ea:	68fb      	ldr	r3, [r7, #12]
 80046ec:	681b      	ldr	r3, [r3, #0]
 80046ee:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80046f2:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 80046f4:	68fb      	ldr	r3, [r7, #12]
 80046f6:	2201      	movs	r2, #1
 80046f8:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80046fc:	68fb      	ldr	r3, [r7, #12]
 80046fe:	2200      	movs	r2, #0
 8004700:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 8004704:	2303      	movs	r3, #3
 8004706:	e010      	b.n	800472a <SPI_WaitFifoStateUntilTimeout+0x116>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if(count == 0U)
 8004708:	693b      	ldr	r3, [r7, #16]
 800470a:	2b00      	cmp	r3, #0
 800470c:	d101      	bne.n	8004712 <SPI_WaitFifoStateUntilTimeout+0xfe>
      {
        tmp_timeout = 0U;
 800470e:	2300      	movs	r3, #0
 8004710:	61fb      	str	r3, [r7, #28]
      }      
      count--;
 8004712:	693b      	ldr	r3, [r7, #16]
 8004714:	3b01      	subs	r3, #1
 8004716:	613b      	str	r3, [r7, #16]
  while ((hspi->Instance->SR & Fifo) != State)
 8004718:	68fb      	ldr	r3, [r7, #12]
 800471a:	681b      	ldr	r3, [r3, #0]
 800471c:	689a      	ldr	r2, [r3, #8]
 800471e:	68bb      	ldr	r3, [r7, #8]
 8004720:	4013      	ands	r3, r2
 8004722:	687a      	ldr	r2, [r7, #4]
 8004724:	429a      	cmp	r2, r3
 8004726:	d194      	bne.n	8004652 <SPI_WaitFifoStateUntilTimeout+0x3e>
    }
  }

  return HAL_OK;
 8004728:	2300      	movs	r3, #0
}
 800472a:	4618      	mov	r0, r3
 800472c:	3720      	adds	r7, #32
 800472e:	46bd      	mov	sp, r7
 8004730:	bd80      	pop	{r7, pc}
 8004732:	bf00      	nop
 8004734:	20000000 	.word	0x20000000

08004738 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8004738:	b580      	push	{r7, lr}
 800473a:	b086      	sub	sp, #24
 800473c:	af02      	add	r7, sp, #8
 800473e:	60f8      	str	r0, [r7, #12]
 8004740:	60b9      	str	r1, [r7, #8]
 8004742:	607a      	str	r2, [r7, #4]
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8004744:	687b      	ldr	r3, [r7, #4]
 8004746:	9300      	str	r3, [sp, #0]
 8004748:	68bb      	ldr	r3, [r7, #8]
 800474a:	2200      	movs	r2, #0
 800474c:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 8004750:	68f8      	ldr	r0, [r7, #12]
 8004752:	f7ff ff5f 	bl	8004614 <SPI_WaitFifoStateUntilTimeout>
 8004756:	4603      	mov	r3, r0
 8004758:	2b00      	cmp	r3, #0
 800475a:	d007      	beq.n	800476c <SPI_EndRxTxTransaction+0x34>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800475c:	68fb      	ldr	r3, [r7, #12]
 800475e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004760:	f043 0220 	orr.w	r2, r3, #32
 8004764:	68fb      	ldr	r3, [r7, #12]
 8004766:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 8004768:	2303      	movs	r3, #3
 800476a:	e027      	b.n	80047bc <SPI_EndRxTxTransaction+0x84>
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	9300      	str	r3, [sp, #0]
 8004770:	68bb      	ldr	r3, [r7, #8]
 8004772:	2200      	movs	r2, #0
 8004774:	2180      	movs	r1, #128	; 0x80
 8004776:	68f8      	ldr	r0, [r7, #12]
 8004778:	f7ff fec4 	bl	8004504 <SPI_WaitFlagStateUntilTimeout>
 800477c:	4603      	mov	r3, r0
 800477e:	2b00      	cmp	r3, #0
 8004780:	d007      	beq.n	8004792 <SPI_EndRxTxTransaction+0x5a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8004782:	68fb      	ldr	r3, [r7, #12]
 8004784:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004786:	f043 0220 	orr.w	r2, r3, #32
 800478a:	68fb      	ldr	r3, [r7, #12]
 800478c:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 800478e:	2303      	movs	r3, #3
 8004790:	e014      	b.n	80047bc <SPI_EndRxTxTransaction+0x84>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8004792:	687b      	ldr	r3, [r7, #4]
 8004794:	9300      	str	r3, [sp, #0]
 8004796:	68bb      	ldr	r3, [r7, #8]
 8004798:	2200      	movs	r2, #0
 800479a:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 800479e:	68f8      	ldr	r0, [r7, #12]
 80047a0:	f7ff ff38 	bl	8004614 <SPI_WaitFifoStateUntilTimeout>
 80047a4:	4603      	mov	r3, r0
 80047a6:	2b00      	cmp	r3, #0
 80047a8:	d007      	beq.n	80047ba <SPI_EndRxTxTransaction+0x82>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80047aa:	68fb      	ldr	r3, [r7, #12]
 80047ac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80047ae:	f043 0220 	orr.w	r2, r3, #32
 80047b2:	68fb      	ldr	r3, [r7, #12]
 80047b4:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 80047b6:	2303      	movs	r3, #3
 80047b8:	e000      	b.n	80047bc <SPI_EndRxTxTransaction+0x84>
  }

  return HAL_OK;
 80047ba:	2300      	movs	r3, #0
}
 80047bc:	4618      	mov	r0, r3
 80047be:	3710      	adds	r7, #16
 80047c0:	46bd      	mov	sp, r7
 80047c2:	bd80      	pop	{r7, pc}

080047c4 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 80047c4:	b580      	push	{r7, lr}
 80047c6:	b082      	sub	sp, #8
 80047c8:	af00      	add	r7, sp, #0
 80047ca:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80047cc:	687b      	ldr	r3, [r7, #4]
 80047ce:	2b00      	cmp	r3, #0
 80047d0:	d101      	bne.n	80047d6 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 80047d2:	2301      	movs	r3, #1
 80047d4:	e049      	b.n	800486a <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80047d6:	687b      	ldr	r3, [r7, #4]
 80047d8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80047dc:	b2db      	uxtb	r3, r3
 80047de:	2b00      	cmp	r3, #0
 80047e0:	d106      	bne.n	80047f0 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80047e2:	687b      	ldr	r3, [r7, #4]
 80047e4:	2200      	movs	r2, #0
 80047e6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80047ea:	6878      	ldr	r0, [r7, #4]
 80047ec:	f7fc fb2a 	bl	8000e44 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80047f0:	687b      	ldr	r3, [r7, #4]
 80047f2:	2202      	movs	r2, #2
 80047f4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	681a      	ldr	r2, [r3, #0]
 80047fc:	687b      	ldr	r3, [r7, #4]
 80047fe:	3304      	adds	r3, #4
 8004800:	4619      	mov	r1, r3
 8004802:	4610      	mov	r0, r2
 8004804:	f000 fd9e 	bl	8005344 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8004808:	687b      	ldr	r3, [r7, #4]
 800480a:	2201      	movs	r2, #1
 800480c:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004810:	687b      	ldr	r3, [r7, #4]
 8004812:	2201      	movs	r2, #1
 8004814:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8004818:	687b      	ldr	r3, [r7, #4]
 800481a:	2201      	movs	r2, #1
 800481c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8004820:	687b      	ldr	r3, [r7, #4]
 8004822:	2201      	movs	r2, #1
 8004824:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8004828:	687b      	ldr	r3, [r7, #4]
 800482a:	2201      	movs	r2, #1
 800482c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8004830:	687b      	ldr	r3, [r7, #4]
 8004832:	2201      	movs	r2, #1
 8004834:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8004838:	687b      	ldr	r3, [r7, #4]
 800483a:	2201      	movs	r2, #1
 800483c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004840:	687b      	ldr	r3, [r7, #4]
 8004842:	2201      	movs	r2, #1
 8004844:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8004848:	687b      	ldr	r3, [r7, #4]
 800484a:	2201      	movs	r2, #1
 800484c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8004850:	687b      	ldr	r3, [r7, #4]
 8004852:	2201      	movs	r2, #1
 8004854:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8004858:	687b      	ldr	r3, [r7, #4]
 800485a:	2201      	movs	r2, #1
 800485c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8004860:	687b      	ldr	r3, [r7, #4]
 8004862:	2201      	movs	r2, #1
 8004864:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8004868:	2300      	movs	r3, #0
}
 800486a:	4618      	mov	r0, r3
 800486c:	3708      	adds	r7, #8
 800486e:	46bd      	mov	sp, r7
 8004870:	bd80      	pop	{r7, pc}

08004872 <HAL_TIM_Base_DeInit>:
  * @brief  DeInitializes the TIM Base peripheral
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
{
 8004872:	b580      	push	{r7, lr}
 8004874:	b082      	sub	sp, #8
 8004876:	af00      	add	r7, sp, #0
 8004878:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 800487a:	687b      	ldr	r3, [r7, #4]
 800487c:	2202      	movs	r2, #2
 800487e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 8004882:	687b      	ldr	r3, [r7, #4]
 8004884:	681b      	ldr	r3, [r3, #0]
 8004886:	6a1a      	ldr	r2, [r3, #32]
 8004888:	f241 1311 	movw	r3, #4369	; 0x1111
 800488c:	4013      	ands	r3, r2
 800488e:	2b00      	cmp	r3, #0
 8004890:	d10f      	bne.n	80048b2 <HAL_TIM_Base_DeInit+0x40>
 8004892:	687b      	ldr	r3, [r7, #4]
 8004894:	681b      	ldr	r3, [r3, #0]
 8004896:	6a1a      	ldr	r2, [r3, #32]
 8004898:	f240 4344 	movw	r3, #1092	; 0x444
 800489c:	4013      	ands	r3, r2
 800489e:	2b00      	cmp	r3, #0
 80048a0:	d107      	bne.n	80048b2 <HAL_TIM_Base_DeInit+0x40>
 80048a2:	687b      	ldr	r3, [r7, #4]
 80048a4:	681b      	ldr	r3, [r3, #0]
 80048a6:	681a      	ldr	r2, [r3, #0]
 80048a8:	687b      	ldr	r3, [r7, #4]
 80048aa:	681b      	ldr	r3, [r3, #0]
 80048ac:	f022 0201 	bic.w	r2, r2, #1
 80048b0:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->Base_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Base_MspDeInit(htim);
 80048b2:	6878      	ldr	r0, [r7, #4]
 80048b4:	f7fc faea 	bl	8000e8c <HAL_TIM_Base_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 80048b8:	687b      	ldr	r3, [r7, #4]
 80048ba:	2200      	movs	r2, #0
 80048bc:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 80048c0:	687b      	ldr	r3, [r7, #4]
 80048c2:	2200      	movs	r2, #0
 80048c4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 80048c8:	687b      	ldr	r3, [r7, #4]
 80048ca:	2200      	movs	r2, #0
 80048cc:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 80048d0:	687b      	ldr	r3, [r7, #4]
 80048d2:	2200      	movs	r2, #0
 80048d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	2200      	movs	r2, #0
 80048dc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 80048e0:	687b      	ldr	r3, [r7, #4]
 80048e2:	2200      	movs	r2, #0
 80048e4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80048e8:	687b      	ldr	r3, [r7, #4]
 80048ea:	2200      	movs	r2, #0
 80048ec:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	2200      	movs	r2, #0
 80048f4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	2200      	movs	r2, #0
 80048fc:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8004900:	687b      	ldr	r3, [r7, #4]
 8004902:	2200      	movs	r2, #0
 8004904:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8004908:	687b      	ldr	r3, [r7, #4]
 800490a:	2200      	movs	r2, #0
 800490c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
 8004910:	687b      	ldr	r3, [r7, #4]
 8004912:	2200      	movs	r2, #0
 8004914:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
 8004918:	687b      	ldr	r3, [r7, #4]
 800491a:	2200      	movs	r2, #0
 800491c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 8004920:	2300      	movs	r3, #0
}
 8004922:	4618      	mov	r0, r3
 8004924:	3708      	adds	r7, #8
 8004926:	46bd      	mov	sp, r7
 8004928:	bd80      	pop	{r7, pc}

0800492a <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 800492a:	b580      	push	{r7, lr}
 800492c:	b082      	sub	sp, #8
 800492e:	af00      	add	r7, sp, #0
 8004930:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	2b00      	cmp	r3, #0
 8004936:	d101      	bne.n	800493c <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 8004938:	2301      	movs	r3, #1
 800493a:	e049      	b.n	80049d0 <HAL_TIM_OC_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800493c:	687b      	ldr	r3, [r7, #4]
 800493e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004942:	b2db      	uxtb	r3, r3
 8004944:	2b00      	cmp	r3, #0
 8004946:	d106      	bne.n	8004956 <HAL_TIM_OC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8004948:	687b      	ldr	r3, [r7, #4]
 800494a:	2200      	movs	r2, #0
 800494c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 8004950:	6878      	ldr	r0, [r7, #4]
 8004952:	f000 f841 	bl	80049d8 <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8004956:	687b      	ldr	r3, [r7, #4]
 8004958:	2202      	movs	r2, #2
 800495a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 800495e:	687b      	ldr	r3, [r7, #4]
 8004960:	681a      	ldr	r2, [r3, #0]
 8004962:	687b      	ldr	r3, [r7, #4]
 8004964:	3304      	adds	r3, #4
 8004966:	4619      	mov	r1, r3
 8004968:	4610      	mov	r0, r2
 800496a:	f000 fceb 	bl	8005344 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800496e:	687b      	ldr	r3, [r7, #4]
 8004970:	2201      	movs	r2, #1
 8004972:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004976:	687b      	ldr	r3, [r7, #4]
 8004978:	2201      	movs	r2, #1
 800497a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 800497e:	687b      	ldr	r3, [r7, #4]
 8004980:	2201      	movs	r2, #1
 8004982:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8004986:	687b      	ldr	r3, [r7, #4]
 8004988:	2201      	movs	r2, #1
 800498a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800498e:	687b      	ldr	r3, [r7, #4]
 8004990:	2201      	movs	r2, #1
 8004992:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8004996:	687b      	ldr	r3, [r7, #4]
 8004998:	2201      	movs	r2, #1
 800499a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800499e:	687b      	ldr	r3, [r7, #4]
 80049a0:	2201      	movs	r2, #1
 80049a2:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80049a6:	687b      	ldr	r3, [r7, #4]
 80049a8:	2201      	movs	r2, #1
 80049aa:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80049ae:	687b      	ldr	r3, [r7, #4]
 80049b0:	2201      	movs	r2, #1
 80049b2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	2201      	movs	r2, #1
 80049ba:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 80049be:	687b      	ldr	r3, [r7, #4]
 80049c0:	2201      	movs	r2, #1
 80049c2:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	2201      	movs	r2, #1
 80049ca:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 80049ce:	2300      	movs	r3, #0
}
 80049d0:	4618      	mov	r0, r3
 80049d2:	3708      	adds	r7, #8
 80049d4:	46bd      	mov	sp, r7
 80049d6:	bd80      	pop	{r7, pc}

080049d8 <HAL_TIM_OC_MspInit>:
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
 80049d8:	b480      	push	{r7}
 80049da:	b083      	sub	sp, #12
 80049dc:	af00      	add	r7, sp, #0
 80049de:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */
}
 80049e0:	bf00      	nop
 80049e2:	370c      	adds	r7, #12
 80049e4:	46bd      	mov	sp, r7
 80049e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049ea:	4770      	bx	lr

080049ec <HAL_TIM_OC_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80049ec:	b580      	push	{r7, lr}
 80049ee:	b084      	sub	sp, #16
 80049f0:	af00      	add	r7, sp, #0
 80049f2:	6078      	str	r0, [r7, #4]
 80049f4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80049f6:	683b      	ldr	r3, [r7, #0]
 80049f8:	2b00      	cmp	r3, #0
 80049fa:	d109      	bne.n	8004a10 <HAL_TIM_OC_Start_IT+0x24>
 80049fc:	687b      	ldr	r3, [r7, #4]
 80049fe:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8004a02:	b2db      	uxtb	r3, r3
 8004a04:	2b01      	cmp	r3, #1
 8004a06:	bf14      	ite	ne
 8004a08:	2301      	movne	r3, #1
 8004a0a:	2300      	moveq	r3, #0
 8004a0c:	b2db      	uxtb	r3, r3
 8004a0e:	e03c      	b.n	8004a8a <HAL_TIM_OC_Start_IT+0x9e>
 8004a10:	683b      	ldr	r3, [r7, #0]
 8004a12:	2b04      	cmp	r3, #4
 8004a14:	d109      	bne.n	8004a2a <HAL_TIM_OC_Start_IT+0x3e>
 8004a16:	687b      	ldr	r3, [r7, #4]
 8004a18:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 8004a1c:	b2db      	uxtb	r3, r3
 8004a1e:	2b01      	cmp	r3, #1
 8004a20:	bf14      	ite	ne
 8004a22:	2301      	movne	r3, #1
 8004a24:	2300      	moveq	r3, #0
 8004a26:	b2db      	uxtb	r3, r3
 8004a28:	e02f      	b.n	8004a8a <HAL_TIM_OC_Start_IT+0x9e>
 8004a2a:	683b      	ldr	r3, [r7, #0]
 8004a2c:	2b08      	cmp	r3, #8
 8004a2e:	d109      	bne.n	8004a44 <HAL_TIM_OC_Start_IT+0x58>
 8004a30:	687b      	ldr	r3, [r7, #4]
 8004a32:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8004a36:	b2db      	uxtb	r3, r3
 8004a38:	2b01      	cmp	r3, #1
 8004a3a:	bf14      	ite	ne
 8004a3c:	2301      	movne	r3, #1
 8004a3e:	2300      	moveq	r3, #0
 8004a40:	b2db      	uxtb	r3, r3
 8004a42:	e022      	b.n	8004a8a <HAL_TIM_OC_Start_IT+0x9e>
 8004a44:	683b      	ldr	r3, [r7, #0]
 8004a46:	2b0c      	cmp	r3, #12
 8004a48:	d109      	bne.n	8004a5e <HAL_TIM_OC_Start_IT+0x72>
 8004a4a:	687b      	ldr	r3, [r7, #4]
 8004a4c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8004a50:	b2db      	uxtb	r3, r3
 8004a52:	2b01      	cmp	r3, #1
 8004a54:	bf14      	ite	ne
 8004a56:	2301      	movne	r3, #1
 8004a58:	2300      	moveq	r3, #0
 8004a5a:	b2db      	uxtb	r3, r3
 8004a5c:	e015      	b.n	8004a8a <HAL_TIM_OC_Start_IT+0x9e>
 8004a5e:	683b      	ldr	r3, [r7, #0]
 8004a60:	2b10      	cmp	r3, #16
 8004a62:	d109      	bne.n	8004a78 <HAL_TIM_OC_Start_IT+0x8c>
 8004a64:	687b      	ldr	r3, [r7, #4]
 8004a66:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8004a6a:	b2db      	uxtb	r3, r3
 8004a6c:	2b01      	cmp	r3, #1
 8004a6e:	bf14      	ite	ne
 8004a70:	2301      	movne	r3, #1
 8004a72:	2300      	moveq	r3, #0
 8004a74:	b2db      	uxtb	r3, r3
 8004a76:	e008      	b.n	8004a8a <HAL_TIM_OC_Start_IT+0x9e>
 8004a78:	687b      	ldr	r3, [r7, #4]
 8004a7a:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8004a7e:	b2db      	uxtb	r3, r3
 8004a80:	2b01      	cmp	r3, #1
 8004a82:	bf14      	ite	ne
 8004a84:	2301      	movne	r3, #1
 8004a86:	2300      	moveq	r3, #0
 8004a88:	b2db      	uxtb	r3, r3
 8004a8a:	2b00      	cmp	r3, #0
 8004a8c:	d001      	beq.n	8004a92 <HAL_TIM_OC_Start_IT+0xa6>
  {
    return HAL_ERROR;
 8004a8e:	2301      	movs	r3, #1
 8004a90:	e0e2      	b.n	8004c58 <HAL_TIM_OC_Start_IT+0x26c>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8004a92:	683b      	ldr	r3, [r7, #0]
 8004a94:	2b00      	cmp	r3, #0
 8004a96:	d104      	bne.n	8004aa2 <HAL_TIM_OC_Start_IT+0xb6>
 8004a98:	687b      	ldr	r3, [r7, #4]
 8004a9a:	2202      	movs	r2, #2
 8004a9c:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8004aa0:	e023      	b.n	8004aea <HAL_TIM_OC_Start_IT+0xfe>
 8004aa2:	683b      	ldr	r3, [r7, #0]
 8004aa4:	2b04      	cmp	r3, #4
 8004aa6:	d104      	bne.n	8004ab2 <HAL_TIM_OC_Start_IT+0xc6>
 8004aa8:	687b      	ldr	r3, [r7, #4]
 8004aaa:	2202      	movs	r2, #2
 8004aac:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8004ab0:	e01b      	b.n	8004aea <HAL_TIM_OC_Start_IT+0xfe>
 8004ab2:	683b      	ldr	r3, [r7, #0]
 8004ab4:	2b08      	cmp	r3, #8
 8004ab6:	d104      	bne.n	8004ac2 <HAL_TIM_OC_Start_IT+0xd6>
 8004ab8:	687b      	ldr	r3, [r7, #4]
 8004aba:	2202      	movs	r2, #2
 8004abc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8004ac0:	e013      	b.n	8004aea <HAL_TIM_OC_Start_IT+0xfe>
 8004ac2:	683b      	ldr	r3, [r7, #0]
 8004ac4:	2b0c      	cmp	r3, #12
 8004ac6:	d104      	bne.n	8004ad2 <HAL_TIM_OC_Start_IT+0xe6>
 8004ac8:	687b      	ldr	r3, [r7, #4]
 8004aca:	2202      	movs	r2, #2
 8004acc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8004ad0:	e00b      	b.n	8004aea <HAL_TIM_OC_Start_IT+0xfe>
 8004ad2:	683b      	ldr	r3, [r7, #0]
 8004ad4:	2b10      	cmp	r3, #16
 8004ad6:	d104      	bne.n	8004ae2 <HAL_TIM_OC_Start_IT+0xf6>
 8004ad8:	687b      	ldr	r3, [r7, #4]
 8004ada:	2202      	movs	r2, #2
 8004adc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8004ae0:	e003      	b.n	8004aea <HAL_TIM_OC_Start_IT+0xfe>
 8004ae2:	687b      	ldr	r3, [r7, #4]
 8004ae4:	2202      	movs	r2, #2
 8004ae6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  switch (Channel)
 8004aea:	683b      	ldr	r3, [r7, #0]
 8004aec:	2b0c      	cmp	r3, #12
 8004aee:	d841      	bhi.n	8004b74 <HAL_TIM_OC_Start_IT+0x188>
 8004af0:	a201      	add	r2, pc, #4	; (adr r2, 8004af8 <HAL_TIM_OC_Start_IT+0x10c>)
 8004af2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004af6:	bf00      	nop
 8004af8:	08004b2d 	.word	0x08004b2d
 8004afc:	08004b75 	.word	0x08004b75
 8004b00:	08004b75 	.word	0x08004b75
 8004b04:	08004b75 	.word	0x08004b75
 8004b08:	08004b3f 	.word	0x08004b3f
 8004b0c:	08004b75 	.word	0x08004b75
 8004b10:	08004b75 	.word	0x08004b75
 8004b14:	08004b75 	.word	0x08004b75
 8004b18:	08004b51 	.word	0x08004b51
 8004b1c:	08004b75 	.word	0x08004b75
 8004b20:	08004b75 	.word	0x08004b75
 8004b24:	08004b75 	.word	0x08004b75
 8004b28:	08004b63 	.word	0x08004b63
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8004b2c:	687b      	ldr	r3, [r7, #4]
 8004b2e:	681b      	ldr	r3, [r3, #0]
 8004b30:	68da      	ldr	r2, [r3, #12]
 8004b32:	687b      	ldr	r3, [r7, #4]
 8004b34:	681b      	ldr	r3, [r3, #0]
 8004b36:	f042 0202 	orr.w	r2, r2, #2
 8004b3a:	60da      	str	r2, [r3, #12]
      break;
 8004b3c:	e01b      	b.n	8004b76 <HAL_TIM_OC_Start_IT+0x18a>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8004b3e:	687b      	ldr	r3, [r7, #4]
 8004b40:	681b      	ldr	r3, [r3, #0]
 8004b42:	68da      	ldr	r2, [r3, #12]
 8004b44:	687b      	ldr	r3, [r7, #4]
 8004b46:	681b      	ldr	r3, [r3, #0]
 8004b48:	f042 0204 	orr.w	r2, r2, #4
 8004b4c:	60da      	str	r2, [r3, #12]
      break;
 8004b4e:	e012      	b.n	8004b76 <HAL_TIM_OC_Start_IT+0x18a>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8004b50:	687b      	ldr	r3, [r7, #4]
 8004b52:	681b      	ldr	r3, [r3, #0]
 8004b54:	68da      	ldr	r2, [r3, #12]
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	681b      	ldr	r3, [r3, #0]
 8004b5a:	f042 0208 	orr.w	r2, r2, #8
 8004b5e:	60da      	str	r2, [r3, #12]
      break;
 8004b60:	e009      	b.n	8004b76 <HAL_TIM_OC_Start_IT+0x18a>
    }

    case TIM_CHANNEL_4:
    {
      /* Enable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8004b62:	687b      	ldr	r3, [r7, #4]
 8004b64:	681b      	ldr	r3, [r3, #0]
 8004b66:	68da      	ldr	r2, [r3, #12]
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	681b      	ldr	r3, [r3, #0]
 8004b6c:	f042 0210 	orr.w	r2, r2, #16
 8004b70:	60da      	str	r2, [r3, #12]
      break;
 8004b72:	e000      	b.n	8004b76 <HAL_TIM_OC_Start_IT+0x18a>
    }

    default:
      break;
 8004b74:	bf00      	nop
  }

  /* Enable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8004b76:	687b      	ldr	r3, [r7, #4]
 8004b78:	681b      	ldr	r3, [r3, #0]
 8004b7a:	2201      	movs	r2, #1
 8004b7c:	6839      	ldr	r1, [r7, #0]
 8004b7e:	4618      	mov	r0, r3
 8004b80:	f000 ffea 	bl	8005b58 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8004b84:	687b      	ldr	r3, [r7, #4]
 8004b86:	681b      	ldr	r3, [r3, #0]
 8004b88:	4a35      	ldr	r2, [pc, #212]	; (8004c60 <HAL_TIM_OC_Start_IT+0x274>)
 8004b8a:	4293      	cmp	r3, r2
 8004b8c:	d013      	beq.n	8004bb6 <HAL_TIM_OC_Start_IT+0x1ca>
 8004b8e:	687b      	ldr	r3, [r7, #4]
 8004b90:	681b      	ldr	r3, [r3, #0]
 8004b92:	4a34      	ldr	r2, [pc, #208]	; (8004c64 <HAL_TIM_OC_Start_IT+0x278>)
 8004b94:	4293      	cmp	r3, r2
 8004b96:	d00e      	beq.n	8004bb6 <HAL_TIM_OC_Start_IT+0x1ca>
 8004b98:	687b      	ldr	r3, [r7, #4]
 8004b9a:	681b      	ldr	r3, [r3, #0]
 8004b9c:	4a32      	ldr	r2, [pc, #200]	; (8004c68 <HAL_TIM_OC_Start_IT+0x27c>)
 8004b9e:	4293      	cmp	r3, r2
 8004ba0:	d009      	beq.n	8004bb6 <HAL_TIM_OC_Start_IT+0x1ca>
 8004ba2:	687b      	ldr	r3, [r7, #4]
 8004ba4:	681b      	ldr	r3, [r3, #0]
 8004ba6:	4a31      	ldr	r2, [pc, #196]	; (8004c6c <HAL_TIM_OC_Start_IT+0x280>)
 8004ba8:	4293      	cmp	r3, r2
 8004baa:	d004      	beq.n	8004bb6 <HAL_TIM_OC_Start_IT+0x1ca>
 8004bac:	687b      	ldr	r3, [r7, #4]
 8004bae:	681b      	ldr	r3, [r3, #0]
 8004bb0:	4a2f      	ldr	r2, [pc, #188]	; (8004c70 <HAL_TIM_OC_Start_IT+0x284>)
 8004bb2:	4293      	cmp	r3, r2
 8004bb4:	d101      	bne.n	8004bba <HAL_TIM_OC_Start_IT+0x1ce>
 8004bb6:	2301      	movs	r3, #1
 8004bb8:	e000      	b.n	8004bbc <HAL_TIM_OC_Start_IT+0x1d0>
 8004bba:	2300      	movs	r3, #0
 8004bbc:	2b00      	cmp	r3, #0
 8004bbe:	d007      	beq.n	8004bd0 <HAL_TIM_OC_Start_IT+0x1e4>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 8004bc0:	687b      	ldr	r3, [r7, #4]
 8004bc2:	681b      	ldr	r3, [r3, #0]
 8004bc4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004bc6:	687b      	ldr	r3, [r7, #4]
 8004bc8:	681b      	ldr	r3, [r3, #0]
 8004bca:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8004bce:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004bd0:	687b      	ldr	r3, [r7, #4]
 8004bd2:	681b      	ldr	r3, [r3, #0]
 8004bd4:	4a22      	ldr	r2, [pc, #136]	; (8004c60 <HAL_TIM_OC_Start_IT+0x274>)
 8004bd6:	4293      	cmp	r3, r2
 8004bd8:	d01d      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004bda:	687b      	ldr	r3, [r7, #4]
 8004bdc:	681b      	ldr	r3, [r3, #0]
 8004bde:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004be2:	d018      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004be4:	687b      	ldr	r3, [r7, #4]
 8004be6:	681b      	ldr	r3, [r3, #0]
 8004be8:	4a22      	ldr	r2, [pc, #136]	; (8004c74 <HAL_TIM_OC_Start_IT+0x288>)
 8004bea:	4293      	cmp	r3, r2
 8004bec:	d013      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004bee:	687b      	ldr	r3, [r7, #4]
 8004bf0:	681b      	ldr	r3, [r3, #0]
 8004bf2:	4a21      	ldr	r2, [pc, #132]	; (8004c78 <HAL_TIM_OC_Start_IT+0x28c>)
 8004bf4:	4293      	cmp	r3, r2
 8004bf6:	d00e      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004bf8:	687b      	ldr	r3, [r7, #4]
 8004bfa:	681b      	ldr	r3, [r3, #0]
 8004bfc:	4a1f      	ldr	r2, [pc, #124]	; (8004c7c <HAL_TIM_OC_Start_IT+0x290>)
 8004bfe:	4293      	cmp	r3, r2
 8004c00:	d009      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004c02:	687b      	ldr	r3, [r7, #4]
 8004c04:	681b      	ldr	r3, [r3, #0]
 8004c06:	4a17      	ldr	r2, [pc, #92]	; (8004c64 <HAL_TIM_OC_Start_IT+0x278>)
 8004c08:	4293      	cmp	r3, r2
 8004c0a:	d004      	beq.n	8004c16 <HAL_TIM_OC_Start_IT+0x22a>
 8004c0c:	687b      	ldr	r3, [r7, #4]
 8004c0e:	681b      	ldr	r3, [r3, #0]
 8004c10:	4a15      	ldr	r2, [pc, #84]	; (8004c68 <HAL_TIM_OC_Start_IT+0x27c>)
 8004c12:	4293      	cmp	r3, r2
 8004c14:	d115      	bne.n	8004c42 <HAL_TIM_OC_Start_IT+0x256>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004c16:	687b      	ldr	r3, [r7, #4]
 8004c18:	681b      	ldr	r3, [r3, #0]
 8004c1a:	689a      	ldr	r2, [r3, #8]
 8004c1c:	4b18      	ldr	r3, [pc, #96]	; (8004c80 <HAL_TIM_OC_Start_IT+0x294>)
 8004c1e:	4013      	ands	r3, r2
 8004c20:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004c22:	68fb      	ldr	r3, [r7, #12]
 8004c24:	2b06      	cmp	r3, #6
 8004c26:	d015      	beq.n	8004c54 <HAL_TIM_OC_Start_IT+0x268>
 8004c28:	68fb      	ldr	r3, [r7, #12]
 8004c2a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004c2e:	d011      	beq.n	8004c54 <HAL_TIM_OC_Start_IT+0x268>
    {
      __HAL_TIM_ENABLE(htim);
 8004c30:	687b      	ldr	r3, [r7, #4]
 8004c32:	681b      	ldr	r3, [r3, #0]
 8004c34:	681a      	ldr	r2, [r3, #0]
 8004c36:	687b      	ldr	r3, [r7, #4]
 8004c38:	681b      	ldr	r3, [r3, #0]
 8004c3a:	f042 0201 	orr.w	r2, r2, #1
 8004c3e:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004c40:	e008      	b.n	8004c54 <HAL_TIM_OC_Start_IT+0x268>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8004c42:	687b      	ldr	r3, [r7, #4]
 8004c44:	681b      	ldr	r3, [r3, #0]
 8004c46:	681a      	ldr	r2, [r3, #0]
 8004c48:	687b      	ldr	r3, [r7, #4]
 8004c4a:	681b      	ldr	r3, [r3, #0]
 8004c4c:	f042 0201 	orr.w	r2, r2, #1
 8004c50:	601a      	str	r2, [r3, #0]
 8004c52:	e000      	b.n	8004c56 <HAL_TIM_OC_Start_IT+0x26a>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004c54:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8004c56:	2300      	movs	r3, #0
}
 8004c58:	4618      	mov	r0, r3
 8004c5a:	3710      	adds	r7, #16
 8004c5c:	46bd      	mov	sp, r7
 8004c5e:	bd80      	pop	{r7, pc}
 8004c60:	40012c00 	.word	0x40012c00
 8004c64:	40013400 	.word	0x40013400
 8004c68:	40014000 	.word	0x40014000
 8004c6c:	40014400 	.word	0x40014400
 8004c70:	40014800 	.word	0x40014800
 8004c74:	40000400 	.word	0x40000400
 8004c78:	40000800 	.word	0x40000800
 8004c7c:	40000c00 	.word	0x40000c00
 8004c80:	00010007 	.word	0x00010007

08004c84 <HAL_TIM_OC_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8004c84:	b580      	push	{r7, lr}
 8004c86:	b082      	sub	sp, #8
 8004c88:	af00      	add	r7, sp, #0
 8004c8a:	6078      	str	r0, [r7, #4]
 8004c8c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
 8004c8e:	683b      	ldr	r3, [r7, #0]
 8004c90:	2b0c      	cmp	r3, #12
 8004c92:	d841      	bhi.n	8004d18 <HAL_TIM_OC_Stop_IT+0x94>
 8004c94:	a201      	add	r2, pc, #4	; (adr r2, 8004c9c <HAL_TIM_OC_Stop_IT+0x18>)
 8004c96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004c9a:	bf00      	nop
 8004c9c:	08004cd1 	.word	0x08004cd1
 8004ca0:	08004d19 	.word	0x08004d19
 8004ca4:	08004d19 	.word	0x08004d19
 8004ca8:	08004d19 	.word	0x08004d19
 8004cac:	08004ce3 	.word	0x08004ce3
 8004cb0:	08004d19 	.word	0x08004d19
 8004cb4:	08004d19 	.word	0x08004d19
 8004cb8:	08004d19 	.word	0x08004d19
 8004cbc:	08004cf5 	.word	0x08004cf5
 8004cc0:	08004d19 	.word	0x08004d19
 8004cc4:	08004d19 	.word	0x08004d19
 8004cc8:	08004d19 	.word	0x08004d19
 8004ccc:	08004d07 	.word	0x08004d07
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8004cd0:	687b      	ldr	r3, [r7, #4]
 8004cd2:	681b      	ldr	r3, [r3, #0]
 8004cd4:	68da      	ldr	r2, [r3, #12]
 8004cd6:	687b      	ldr	r3, [r7, #4]
 8004cd8:	681b      	ldr	r3, [r3, #0]
 8004cda:	f022 0202 	bic.w	r2, r2, #2
 8004cde:	60da      	str	r2, [r3, #12]
      break;
 8004ce0:	e01b      	b.n	8004d1a <HAL_TIM_OC_Stop_IT+0x96>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8004ce2:	687b      	ldr	r3, [r7, #4]
 8004ce4:	681b      	ldr	r3, [r3, #0]
 8004ce6:	68da      	ldr	r2, [r3, #12]
 8004ce8:	687b      	ldr	r3, [r7, #4]
 8004cea:	681b      	ldr	r3, [r3, #0]
 8004cec:	f022 0204 	bic.w	r2, r2, #4
 8004cf0:	60da      	str	r2, [r3, #12]
      break;
 8004cf2:	e012      	b.n	8004d1a <HAL_TIM_OC_Stop_IT+0x96>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8004cf4:	687b      	ldr	r3, [r7, #4]
 8004cf6:	681b      	ldr	r3, [r3, #0]
 8004cf8:	68da      	ldr	r2, [r3, #12]
 8004cfa:	687b      	ldr	r3, [r7, #4]
 8004cfc:	681b      	ldr	r3, [r3, #0]
 8004cfe:	f022 0208 	bic.w	r2, r2, #8
 8004d02:	60da      	str	r2, [r3, #12]
      break;
 8004d04:	e009      	b.n	8004d1a <HAL_TIM_OC_Stop_IT+0x96>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8004d06:	687b      	ldr	r3, [r7, #4]
 8004d08:	681b      	ldr	r3, [r3, #0]
 8004d0a:	68da      	ldr	r2, [r3, #12]
 8004d0c:	687b      	ldr	r3, [r7, #4]
 8004d0e:	681b      	ldr	r3, [r3, #0]
 8004d10:	f022 0210 	bic.w	r2, r2, #16
 8004d14:	60da      	str	r2, [r3, #12]
      break;
 8004d16:	e000      	b.n	8004d1a <HAL_TIM_OC_Stop_IT+0x96>
    }

    default:
      break;
 8004d18:	bf00      	nop
  }

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8004d1a:	687b      	ldr	r3, [r7, #4]
 8004d1c:	681b      	ldr	r3, [r3, #0]
 8004d1e:	2200      	movs	r2, #0
 8004d20:	6839      	ldr	r1, [r7, #0]
 8004d22:	4618      	mov	r0, r3
 8004d24:	f000 ff18 	bl	8005b58 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8004d28:	687b      	ldr	r3, [r7, #4]
 8004d2a:	681b      	ldr	r3, [r3, #0]
 8004d2c:	4a3e      	ldr	r2, [pc, #248]	; (8004e28 <HAL_TIM_OC_Stop_IT+0x1a4>)
 8004d2e:	4293      	cmp	r3, r2
 8004d30:	d013      	beq.n	8004d5a <HAL_TIM_OC_Stop_IT+0xd6>
 8004d32:	687b      	ldr	r3, [r7, #4]
 8004d34:	681b      	ldr	r3, [r3, #0]
 8004d36:	4a3d      	ldr	r2, [pc, #244]	; (8004e2c <HAL_TIM_OC_Stop_IT+0x1a8>)
 8004d38:	4293      	cmp	r3, r2
 8004d3a:	d00e      	beq.n	8004d5a <HAL_TIM_OC_Stop_IT+0xd6>
 8004d3c:	687b      	ldr	r3, [r7, #4]
 8004d3e:	681b      	ldr	r3, [r3, #0]
 8004d40:	4a3b      	ldr	r2, [pc, #236]	; (8004e30 <HAL_TIM_OC_Stop_IT+0x1ac>)
 8004d42:	4293      	cmp	r3, r2
 8004d44:	d009      	beq.n	8004d5a <HAL_TIM_OC_Stop_IT+0xd6>
 8004d46:	687b      	ldr	r3, [r7, #4]
 8004d48:	681b      	ldr	r3, [r3, #0]
 8004d4a:	4a3a      	ldr	r2, [pc, #232]	; (8004e34 <HAL_TIM_OC_Stop_IT+0x1b0>)
 8004d4c:	4293      	cmp	r3, r2
 8004d4e:	d004      	beq.n	8004d5a <HAL_TIM_OC_Stop_IT+0xd6>
 8004d50:	687b      	ldr	r3, [r7, #4]
 8004d52:	681b      	ldr	r3, [r3, #0]
 8004d54:	4a38      	ldr	r2, [pc, #224]	; (8004e38 <HAL_TIM_OC_Stop_IT+0x1b4>)
 8004d56:	4293      	cmp	r3, r2
 8004d58:	d101      	bne.n	8004d5e <HAL_TIM_OC_Stop_IT+0xda>
 8004d5a:	2301      	movs	r3, #1
 8004d5c:	e000      	b.n	8004d60 <HAL_TIM_OC_Stop_IT+0xdc>
 8004d5e:	2300      	movs	r3, #0
 8004d60:	2b00      	cmp	r3, #0
 8004d62:	d017      	beq.n	8004d94 <HAL_TIM_OC_Stop_IT+0x110>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
 8004d64:	687b      	ldr	r3, [r7, #4]
 8004d66:	681b      	ldr	r3, [r3, #0]
 8004d68:	6a1a      	ldr	r2, [r3, #32]
 8004d6a:	f241 1311 	movw	r3, #4369	; 0x1111
 8004d6e:	4013      	ands	r3, r2
 8004d70:	2b00      	cmp	r3, #0
 8004d72:	d10f      	bne.n	8004d94 <HAL_TIM_OC_Stop_IT+0x110>
 8004d74:	687b      	ldr	r3, [r7, #4]
 8004d76:	681b      	ldr	r3, [r3, #0]
 8004d78:	6a1a      	ldr	r2, [r3, #32]
 8004d7a:	f240 4344 	movw	r3, #1092	; 0x444
 8004d7e:	4013      	ands	r3, r2
 8004d80:	2b00      	cmp	r3, #0
 8004d82:	d107      	bne.n	8004d94 <HAL_TIM_OC_Stop_IT+0x110>
 8004d84:	687b      	ldr	r3, [r7, #4]
 8004d86:	681b      	ldr	r3, [r3, #0]
 8004d88:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004d8a:	687b      	ldr	r3, [r7, #4]
 8004d8c:	681b      	ldr	r3, [r3, #0]
 8004d8e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004d92:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 8004d94:	687b      	ldr	r3, [r7, #4]
 8004d96:	681b      	ldr	r3, [r3, #0]
 8004d98:	6a1a      	ldr	r2, [r3, #32]
 8004d9a:	f241 1311 	movw	r3, #4369	; 0x1111
 8004d9e:	4013      	ands	r3, r2
 8004da0:	2b00      	cmp	r3, #0
 8004da2:	d10f      	bne.n	8004dc4 <HAL_TIM_OC_Stop_IT+0x140>
 8004da4:	687b      	ldr	r3, [r7, #4]
 8004da6:	681b      	ldr	r3, [r3, #0]
 8004da8:	6a1a      	ldr	r2, [r3, #32]
 8004daa:	f240 4344 	movw	r3, #1092	; 0x444
 8004dae:	4013      	ands	r3, r2
 8004db0:	2b00      	cmp	r3, #0
 8004db2:	d107      	bne.n	8004dc4 <HAL_TIM_OC_Stop_IT+0x140>
 8004db4:	687b      	ldr	r3, [r7, #4]
 8004db6:	681b      	ldr	r3, [r3, #0]
 8004db8:	681a      	ldr	r2, [r3, #0]
 8004dba:	687b      	ldr	r3, [r7, #4]
 8004dbc:	681b      	ldr	r3, [r3, #0]
 8004dbe:	f022 0201 	bic.w	r2, r2, #1
 8004dc2:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8004dc4:	683b      	ldr	r3, [r7, #0]
 8004dc6:	2b00      	cmp	r3, #0
 8004dc8:	d104      	bne.n	8004dd4 <HAL_TIM_OC_Stop_IT+0x150>
 8004dca:	687b      	ldr	r3, [r7, #4]
 8004dcc:	2201      	movs	r2, #1
 8004dce:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8004dd2:	e023      	b.n	8004e1c <HAL_TIM_OC_Stop_IT+0x198>
 8004dd4:	683b      	ldr	r3, [r7, #0]
 8004dd6:	2b04      	cmp	r3, #4
 8004dd8:	d104      	bne.n	8004de4 <HAL_TIM_OC_Stop_IT+0x160>
 8004dda:	687b      	ldr	r3, [r7, #4]
 8004ddc:	2201      	movs	r2, #1
 8004dde:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8004de2:	e01b      	b.n	8004e1c <HAL_TIM_OC_Stop_IT+0x198>
 8004de4:	683b      	ldr	r3, [r7, #0]
 8004de6:	2b08      	cmp	r3, #8
 8004de8:	d104      	bne.n	8004df4 <HAL_TIM_OC_Stop_IT+0x170>
 8004dea:	687b      	ldr	r3, [r7, #4]
 8004dec:	2201      	movs	r2, #1
 8004dee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8004df2:	e013      	b.n	8004e1c <HAL_TIM_OC_Stop_IT+0x198>
 8004df4:	683b      	ldr	r3, [r7, #0]
 8004df6:	2b0c      	cmp	r3, #12
 8004df8:	d104      	bne.n	8004e04 <HAL_TIM_OC_Stop_IT+0x180>
 8004dfa:	687b      	ldr	r3, [r7, #4]
 8004dfc:	2201      	movs	r2, #1
 8004dfe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8004e02:	e00b      	b.n	8004e1c <HAL_TIM_OC_Stop_IT+0x198>
 8004e04:	683b      	ldr	r3, [r7, #0]
 8004e06:	2b10      	cmp	r3, #16
 8004e08:	d104      	bne.n	8004e14 <HAL_TIM_OC_Stop_IT+0x190>
 8004e0a:	687b      	ldr	r3, [r7, #4]
 8004e0c:	2201      	movs	r2, #1
 8004e0e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8004e12:	e003      	b.n	8004e1c <HAL_TIM_OC_Stop_IT+0x198>
 8004e14:	687b      	ldr	r3, [r7, #4]
 8004e16:	2201      	movs	r2, #1
 8004e18:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Return function status */
  return HAL_OK;
 8004e1c:	2300      	movs	r3, #0
}
 8004e1e:	4618      	mov	r0, r3
 8004e20:	3708      	adds	r7, #8
 8004e22:	46bd      	mov	sp, r7
 8004e24:	bd80      	pop	{r7, pc}
 8004e26:	bf00      	nop
 8004e28:	40012c00 	.word	0x40012c00
 8004e2c:	40013400 	.word	0x40013400
 8004e30:	40014000 	.word	0x40014000
 8004e34:	40014400 	.word	0x40014400
 8004e38:	40014800 	.word	0x40014800

08004e3c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8004e3c:	b580      	push	{r7, lr}
 8004e3e:	b082      	sub	sp, #8
 8004e40:	af00      	add	r7, sp, #0
 8004e42:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8004e44:	687b      	ldr	r3, [r7, #4]
 8004e46:	681b      	ldr	r3, [r3, #0]
 8004e48:	691b      	ldr	r3, [r3, #16]
 8004e4a:	f003 0302 	and.w	r3, r3, #2
 8004e4e:	2b02      	cmp	r3, #2
 8004e50:	d122      	bne.n	8004e98 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8004e52:	687b      	ldr	r3, [r7, #4]
 8004e54:	681b      	ldr	r3, [r3, #0]
 8004e56:	68db      	ldr	r3, [r3, #12]
 8004e58:	f003 0302 	and.w	r3, r3, #2
 8004e5c:	2b02      	cmp	r3, #2
 8004e5e:	d11b      	bne.n	8004e98 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8004e60:	687b      	ldr	r3, [r7, #4]
 8004e62:	681b      	ldr	r3, [r3, #0]
 8004e64:	f06f 0202 	mvn.w	r2, #2
 8004e68:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8004e6a:	687b      	ldr	r3, [r7, #4]
 8004e6c:	2201      	movs	r2, #1
 8004e6e:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8004e70:	687b      	ldr	r3, [r7, #4]
 8004e72:	681b      	ldr	r3, [r3, #0]
 8004e74:	699b      	ldr	r3, [r3, #24]
 8004e76:	f003 0303 	and.w	r3, r3, #3
 8004e7a:	2b00      	cmp	r3, #0
 8004e7c:	d003      	beq.n	8004e86 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8004e7e:	6878      	ldr	r0, [r7, #4]
 8004e80:	f000 fa42 	bl	8005308 <HAL_TIM_IC_CaptureCallback>
 8004e84:	e005      	b.n	8004e92 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8004e86:	6878      	ldr	r0, [r7, #4]
 8004e88:	f00e ff02 	bl	8013c90 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004e8c:	6878      	ldr	r0, [r7, #4]
 8004e8e:	f000 fa45 	bl	800531c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004e92:	687b      	ldr	r3, [r7, #4]
 8004e94:	2200      	movs	r2, #0
 8004e96:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8004e98:	687b      	ldr	r3, [r7, #4]
 8004e9a:	681b      	ldr	r3, [r3, #0]
 8004e9c:	691b      	ldr	r3, [r3, #16]
 8004e9e:	f003 0304 	and.w	r3, r3, #4
 8004ea2:	2b04      	cmp	r3, #4
 8004ea4:	d122      	bne.n	8004eec <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8004ea6:	687b      	ldr	r3, [r7, #4]
 8004ea8:	681b      	ldr	r3, [r3, #0]
 8004eaa:	68db      	ldr	r3, [r3, #12]
 8004eac:	f003 0304 	and.w	r3, r3, #4
 8004eb0:	2b04      	cmp	r3, #4
 8004eb2:	d11b      	bne.n	8004eec <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8004eb4:	687b      	ldr	r3, [r7, #4]
 8004eb6:	681b      	ldr	r3, [r3, #0]
 8004eb8:	f06f 0204 	mvn.w	r2, #4
 8004ebc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8004ebe:	687b      	ldr	r3, [r7, #4]
 8004ec0:	2202      	movs	r2, #2
 8004ec2:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8004ec4:	687b      	ldr	r3, [r7, #4]
 8004ec6:	681b      	ldr	r3, [r3, #0]
 8004ec8:	699b      	ldr	r3, [r3, #24]
 8004eca:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004ece:	2b00      	cmp	r3, #0
 8004ed0:	d003      	beq.n	8004eda <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8004ed2:	6878      	ldr	r0, [r7, #4]
 8004ed4:	f000 fa18 	bl	8005308 <HAL_TIM_IC_CaptureCallback>
 8004ed8:	e005      	b.n	8004ee6 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8004eda:	6878      	ldr	r0, [r7, #4]
 8004edc:	f00e fed8 	bl	8013c90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004ee0:	6878      	ldr	r0, [r7, #4]
 8004ee2:	f000 fa1b 	bl	800531c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004ee6:	687b      	ldr	r3, [r7, #4]
 8004ee8:	2200      	movs	r2, #0
 8004eea:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8004eec:	687b      	ldr	r3, [r7, #4]
 8004eee:	681b      	ldr	r3, [r3, #0]
 8004ef0:	691b      	ldr	r3, [r3, #16]
 8004ef2:	f003 0308 	and.w	r3, r3, #8
 8004ef6:	2b08      	cmp	r3, #8
 8004ef8:	d122      	bne.n	8004f40 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8004efa:	687b      	ldr	r3, [r7, #4]
 8004efc:	681b      	ldr	r3, [r3, #0]
 8004efe:	68db      	ldr	r3, [r3, #12]
 8004f00:	f003 0308 	and.w	r3, r3, #8
 8004f04:	2b08      	cmp	r3, #8
 8004f06:	d11b      	bne.n	8004f40 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8004f08:	687b      	ldr	r3, [r7, #4]
 8004f0a:	681b      	ldr	r3, [r3, #0]
 8004f0c:	f06f 0208 	mvn.w	r2, #8
 8004f10:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8004f12:	687b      	ldr	r3, [r7, #4]
 8004f14:	2204      	movs	r2, #4
 8004f16:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8004f18:	687b      	ldr	r3, [r7, #4]
 8004f1a:	681b      	ldr	r3, [r3, #0]
 8004f1c:	69db      	ldr	r3, [r3, #28]
 8004f1e:	f003 0303 	and.w	r3, r3, #3
 8004f22:	2b00      	cmp	r3, #0
 8004f24:	d003      	beq.n	8004f2e <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8004f26:	6878      	ldr	r0, [r7, #4]
 8004f28:	f000 f9ee 	bl	8005308 <HAL_TIM_IC_CaptureCallback>
 8004f2c:	e005      	b.n	8004f3a <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8004f2e:	6878      	ldr	r0, [r7, #4]
 8004f30:	f00e feae 	bl	8013c90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004f34:	6878      	ldr	r0, [r7, #4]
 8004f36:	f000 f9f1 	bl	800531c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f3a:	687b      	ldr	r3, [r7, #4]
 8004f3c:	2200      	movs	r2, #0
 8004f3e:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8004f40:	687b      	ldr	r3, [r7, #4]
 8004f42:	681b      	ldr	r3, [r3, #0]
 8004f44:	691b      	ldr	r3, [r3, #16]
 8004f46:	f003 0310 	and.w	r3, r3, #16
 8004f4a:	2b10      	cmp	r3, #16
 8004f4c:	d122      	bne.n	8004f94 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8004f4e:	687b      	ldr	r3, [r7, #4]
 8004f50:	681b      	ldr	r3, [r3, #0]
 8004f52:	68db      	ldr	r3, [r3, #12]
 8004f54:	f003 0310 	and.w	r3, r3, #16
 8004f58:	2b10      	cmp	r3, #16
 8004f5a:	d11b      	bne.n	8004f94 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8004f5c:	687b      	ldr	r3, [r7, #4]
 8004f5e:	681b      	ldr	r3, [r3, #0]
 8004f60:	f06f 0210 	mvn.w	r2, #16
 8004f64:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8004f66:	687b      	ldr	r3, [r7, #4]
 8004f68:	2208      	movs	r2, #8
 8004f6a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004f6c:	687b      	ldr	r3, [r7, #4]
 8004f6e:	681b      	ldr	r3, [r3, #0]
 8004f70:	69db      	ldr	r3, [r3, #28]
 8004f72:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004f76:	2b00      	cmp	r3, #0
 8004f78:	d003      	beq.n	8004f82 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8004f7a:	6878      	ldr	r0, [r7, #4]
 8004f7c:	f000 f9c4 	bl	8005308 <HAL_TIM_IC_CaptureCallback>
 8004f80:	e005      	b.n	8004f8e <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8004f82:	6878      	ldr	r0, [r7, #4]
 8004f84:	f00e fe84 	bl	8013c90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004f88:	6878      	ldr	r0, [r7, #4]
 8004f8a:	f000 f9c7 	bl	800531c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f8e:	687b      	ldr	r3, [r7, #4]
 8004f90:	2200      	movs	r2, #0
 8004f92:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8004f94:	687b      	ldr	r3, [r7, #4]
 8004f96:	681b      	ldr	r3, [r3, #0]
 8004f98:	691b      	ldr	r3, [r3, #16]
 8004f9a:	f003 0301 	and.w	r3, r3, #1
 8004f9e:	2b01      	cmp	r3, #1
 8004fa0:	d10e      	bne.n	8004fc0 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8004fa2:	687b      	ldr	r3, [r7, #4]
 8004fa4:	681b      	ldr	r3, [r3, #0]
 8004fa6:	68db      	ldr	r3, [r3, #12]
 8004fa8:	f003 0301 	and.w	r3, r3, #1
 8004fac:	2b01      	cmp	r3, #1
 8004fae:	d107      	bne.n	8004fc0 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8004fb0:	687b      	ldr	r3, [r7, #4]
 8004fb2:	681b      	ldr	r3, [r3, #0]
 8004fb4:	f06f 0201 	mvn.w	r2, #1
 8004fb8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8004fba:	6878      	ldr	r0, [r7, #4]
 8004fbc:	f000 f99a 	bl	80052f4 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8004fc0:	687b      	ldr	r3, [r7, #4]
 8004fc2:	681b      	ldr	r3, [r3, #0]
 8004fc4:	691b      	ldr	r3, [r3, #16]
 8004fc6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004fca:	2b80      	cmp	r3, #128	; 0x80
 8004fcc:	d10e      	bne.n	8004fec <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8004fce:	687b      	ldr	r3, [r7, #4]
 8004fd0:	681b      	ldr	r3, [r3, #0]
 8004fd2:	68db      	ldr	r3, [r3, #12]
 8004fd4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004fd8:	2b80      	cmp	r3, #128	; 0x80
 8004fda:	d107      	bne.n	8004fec <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8004fdc:	687b      	ldr	r3, [r7, #4]
 8004fde:	681b      	ldr	r3, [r3, #0]
 8004fe0:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8004fe4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8004fe6:	6878      	ldr	r0, [r7, #4]
 8004fe8:	f000 fe6e 	bl	8005cc8 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8004fec:	687b      	ldr	r3, [r7, #4]
 8004fee:	681b      	ldr	r3, [r3, #0]
 8004ff0:	691b      	ldr	r3, [r3, #16]
 8004ff2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004ff6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004ffa:	d10e      	bne.n	800501a <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8004ffc:	687b      	ldr	r3, [r7, #4]
 8004ffe:	681b      	ldr	r3, [r3, #0]
 8005000:	68db      	ldr	r3, [r3, #12]
 8005002:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005006:	2b80      	cmp	r3, #128	; 0x80
 8005008:	d107      	bne.n	800501a <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800500a:	687b      	ldr	r3, [r7, #4]
 800500c:	681b      	ldr	r3, [r3, #0]
 800500e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8005012:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8005014:	6878      	ldr	r0, [r7, #4]
 8005016:	f000 fe61 	bl	8005cdc <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800501a:	687b      	ldr	r3, [r7, #4]
 800501c:	681b      	ldr	r3, [r3, #0]
 800501e:	691b      	ldr	r3, [r3, #16]
 8005020:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005024:	2b40      	cmp	r3, #64	; 0x40
 8005026:	d10e      	bne.n	8005046 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8005028:	687b      	ldr	r3, [r7, #4]
 800502a:	681b      	ldr	r3, [r3, #0]
 800502c:	68db      	ldr	r3, [r3, #12]
 800502e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005032:	2b40      	cmp	r3, #64	; 0x40
 8005034:	d107      	bne.n	8005046 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8005036:	687b      	ldr	r3, [r7, #4]
 8005038:	681b      	ldr	r3, [r3, #0]
 800503a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800503e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8005040:	6878      	ldr	r0, [r7, #4]
 8005042:	f000 f975 	bl	8005330 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8005046:	687b      	ldr	r3, [r7, #4]
 8005048:	681b      	ldr	r3, [r3, #0]
 800504a:	691b      	ldr	r3, [r3, #16]
 800504c:	f003 0320 	and.w	r3, r3, #32
 8005050:	2b20      	cmp	r3, #32
 8005052:	d10e      	bne.n	8005072 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8005054:	687b      	ldr	r3, [r7, #4]
 8005056:	681b      	ldr	r3, [r3, #0]
 8005058:	68db      	ldr	r3, [r3, #12]
 800505a:	f003 0320 	and.w	r3, r3, #32
 800505e:	2b20      	cmp	r3, #32
 8005060:	d107      	bne.n	8005072 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8005062:	687b      	ldr	r3, [r7, #4]
 8005064:	681b      	ldr	r3, [r3, #0]
 8005066:	f06f 0220 	mvn.w	r2, #32
 800506a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800506c:	6878      	ldr	r0, [r7, #4]
 800506e:	f000 fe21 	bl	8005cb4 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8005072:	bf00      	nop
 8005074:	3708      	adds	r7, #8
 8005076:	46bd      	mov	sp, r7
 8005078:	bd80      	pop	{r7, pc}
	...

0800507c <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 800507c:	b580      	push	{r7, lr}
 800507e:	b084      	sub	sp, #16
 8005080:	af00      	add	r7, sp, #0
 8005082:	60f8      	str	r0, [r7, #12]
 8005084:	60b9      	str	r1, [r7, #8]
 8005086:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
 8005088:	68fb      	ldr	r3, [r7, #12]
 800508a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800508e:	2b01      	cmp	r3, #1
 8005090:	d101      	bne.n	8005096 <HAL_TIM_OC_ConfigChannel+0x1a>
 8005092:	2302      	movs	r3, #2
 8005094:	e064      	b.n	8005160 <HAL_TIM_OC_ConfigChannel+0xe4>
 8005096:	68fb      	ldr	r3, [r7, #12]
 8005098:	2201      	movs	r2, #1
 800509a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (Channel)
 800509e:	687b      	ldr	r3, [r7, #4]
 80050a0:	2b14      	cmp	r3, #20
 80050a2:	d857      	bhi.n	8005154 <HAL_TIM_OC_ConfigChannel+0xd8>
 80050a4:	a201      	add	r2, pc, #4	; (adr r2, 80050ac <HAL_TIM_OC_ConfigChannel+0x30>)
 80050a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80050aa:	bf00      	nop
 80050ac:	08005101 	.word	0x08005101
 80050b0:	08005155 	.word	0x08005155
 80050b4:	08005155 	.word	0x08005155
 80050b8:	08005155 	.word	0x08005155
 80050bc:	0800510f 	.word	0x0800510f
 80050c0:	08005155 	.word	0x08005155
 80050c4:	08005155 	.word	0x08005155
 80050c8:	08005155 	.word	0x08005155
 80050cc:	0800511d 	.word	0x0800511d
 80050d0:	08005155 	.word	0x08005155
 80050d4:	08005155 	.word	0x08005155
 80050d8:	08005155 	.word	0x08005155
 80050dc:	0800512b 	.word	0x0800512b
 80050e0:	08005155 	.word	0x08005155
 80050e4:	08005155 	.word	0x08005155
 80050e8:	08005155 	.word	0x08005155
 80050ec:	08005139 	.word	0x08005139
 80050f0:	08005155 	.word	0x08005155
 80050f4:	08005155 	.word	0x08005155
 80050f8:	08005155 	.word	0x08005155
 80050fc:	08005147 	.word	0x08005147
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 1 in Output Compare */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8005100:	68fb      	ldr	r3, [r7, #12]
 8005102:	681b      	ldr	r3, [r3, #0]
 8005104:	68b9      	ldr	r1, [r7, #8]
 8005106:	4618      	mov	r0, r3
 8005108:	f000 f9b6 	bl	8005478 <TIM_OC1_SetConfig>
      break;
 800510c:	e023      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 2 in Output Compare */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800510e:	68fb      	ldr	r3, [r7, #12]
 8005110:	681b      	ldr	r3, [r3, #0]
 8005112:	68b9      	ldr	r1, [r7, #8]
 8005114:	4618      	mov	r0, r3
 8005116:	f000 fa3f 	bl	8005598 <TIM_OC2_SetConfig>
      break;
 800511a:	e01c      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 3 in Output Compare */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800511c:	68fb      	ldr	r3, [r7, #12]
 800511e:	681b      	ldr	r3, [r3, #0]
 8005120:	68b9      	ldr	r1, [r7, #8]
 8005122:	4618      	mov	r0, r3
 8005124:	f000 fac2 	bl	80056ac <TIM_OC3_SetConfig>
      break;
 8005128:	e015      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 4 in Output Compare */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800512a:	68fb      	ldr	r3, [r7, #12]
 800512c:	681b      	ldr	r3, [r3, #0]
 800512e:	68b9      	ldr	r1, [r7, #8]
 8005130:	4618      	mov	r0, r3
 8005132:	f000 fb43 	bl	80057bc <TIM_OC4_SetConfig>
      break;
 8005136:	e00e      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 5 in Output Compare */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8005138:	68fb      	ldr	r3, [r7, #12]
 800513a:	681b      	ldr	r3, [r3, #0]
 800513c:	68b9      	ldr	r1, [r7, #8]
 800513e:	4618      	mov	r0, r3
 8005140:	f000 fba6 	bl	8005890 <TIM_OC5_SetConfig>
      break;
 8005144:	e007      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 6 in Output Compare */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8005146:	68fb      	ldr	r3, [r7, #12]
 8005148:	681b      	ldr	r3, [r3, #0]
 800514a:	68b9      	ldr	r1, [r7, #8]
 800514c:	4618      	mov	r0, r3
 800514e:	f000 fc03 	bl	8005958 <TIM_OC6_SetConfig>
      break;
 8005152:	e000      	b.n	8005156 <HAL_TIM_OC_ConfigChannel+0xda>
    }

    default:
      break;
 8005154:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 8005156:	68fb      	ldr	r3, [r7, #12]
 8005158:	2200      	movs	r2, #0
 800515a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800515e:	2300      	movs	r3, #0
}
 8005160:	4618      	mov	r0, r3
 8005162:	3710      	adds	r7, #16
 8005164:	46bd      	mov	sp, r7
 8005166:	bd80      	pop	{r7, pc}

08005168 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 8005168:	b580      	push	{r7, lr}
 800516a:	b084      	sub	sp, #16
 800516c:	af00      	add	r7, sp, #0
 800516e:	6078      	str	r0, [r7, #4]
 8005170:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 8005172:	687b      	ldr	r3, [r7, #4]
 8005174:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005178:	2b01      	cmp	r3, #1
 800517a:	d101      	bne.n	8005180 <HAL_TIM_ConfigClockSource+0x18>
 800517c:	2302      	movs	r3, #2
 800517e:	e0b5      	b.n	80052ec <HAL_TIM_ConfigClockSource+0x184>
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	2201      	movs	r2, #1
 8005184:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 8005188:	687b      	ldr	r3, [r7, #4]
 800518a:	2202      	movs	r2, #2
 800518c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8005190:	687b      	ldr	r3, [r7, #4]
 8005192:	681b      	ldr	r3, [r3, #0]
 8005194:	689b      	ldr	r3, [r3, #8]
 8005196:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8005198:	68fb      	ldr	r3, [r7, #12]
 800519a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800519e:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 80051a2:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80051a4:	68fb      	ldr	r3, [r7, #12]
 80051a6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80051aa:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	681b      	ldr	r3, [r3, #0]
 80051b0:	68fa      	ldr	r2, [r7, #12]
 80051b2:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 80051b4:	683b      	ldr	r3, [r7, #0]
 80051b6:	681b      	ldr	r3, [r3, #0]
 80051b8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80051bc:	d03e      	beq.n	800523c <HAL_TIM_ConfigClockSource+0xd4>
 80051be:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80051c2:	f200 8087 	bhi.w	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051c6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80051ca:	f000 8085 	beq.w	80052d8 <HAL_TIM_ConfigClockSource+0x170>
 80051ce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80051d2:	d87f      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051d4:	2b70      	cmp	r3, #112	; 0x70
 80051d6:	d01a      	beq.n	800520e <HAL_TIM_ConfigClockSource+0xa6>
 80051d8:	2b70      	cmp	r3, #112	; 0x70
 80051da:	d87b      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051dc:	2b60      	cmp	r3, #96	; 0x60
 80051de:	d050      	beq.n	8005282 <HAL_TIM_ConfigClockSource+0x11a>
 80051e0:	2b60      	cmp	r3, #96	; 0x60
 80051e2:	d877      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051e4:	2b50      	cmp	r3, #80	; 0x50
 80051e6:	d03c      	beq.n	8005262 <HAL_TIM_ConfigClockSource+0xfa>
 80051e8:	2b50      	cmp	r3, #80	; 0x50
 80051ea:	d873      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051ec:	2b40      	cmp	r3, #64	; 0x40
 80051ee:	d058      	beq.n	80052a2 <HAL_TIM_ConfigClockSource+0x13a>
 80051f0:	2b40      	cmp	r3, #64	; 0x40
 80051f2:	d86f      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051f4:	2b30      	cmp	r3, #48	; 0x30
 80051f6:	d064      	beq.n	80052c2 <HAL_TIM_ConfigClockSource+0x15a>
 80051f8:	2b30      	cmp	r3, #48	; 0x30
 80051fa:	d86b      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 80051fc:	2b20      	cmp	r3, #32
 80051fe:	d060      	beq.n	80052c2 <HAL_TIM_ConfigClockSource+0x15a>
 8005200:	2b20      	cmp	r3, #32
 8005202:	d867      	bhi.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
 8005204:	2b00      	cmp	r3, #0
 8005206:	d05c      	beq.n	80052c2 <HAL_TIM_ConfigClockSource+0x15a>
 8005208:	2b10      	cmp	r3, #16
 800520a:	d05a      	beq.n	80052c2 <HAL_TIM_ConfigClockSource+0x15a>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
        break;
      }

    default:
      break;
 800520c:	e062      	b.n	80052d4 <HAL_TIM_ConfigClockSource+0x16c>
      TIM_ETR_SetConfig(htim->Instance,
 800520e:	687b      	ldr	r3, [r7, #4]
 8005210:	6818      	ldr	r0, [r3, #0]
 8005212:	683b      	ldr	r3, [r7, #0]
 8005214:	6899      	ldr	r1, [r3, #8]
 8005216:	683b      	ldr	r3, [r7, #0]
 8005218:	685a      	ldr	r2, [r3, #4]
 800521a:	683b      	ldr	r3, [r7, #0]
 800521c:	68db      	ldr	r3, [r3, #12]
 800521e:	f000 fc7b 	bl	8005b18 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 8005222:	687b      	ldr	r3, [r7, #4]
 8005224:	681b      	ldr	r3, [r3, #0]
 8005226:	689b      	ldr	r3, [r3, #8]
 8005228:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800522a:	68fb      	ldr	r3, [r7, #12]
 800522c:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 8005230:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
 8005232:	687b      	ldr	r3, [r7, #4]
 8005234:	681b      	ldr	r3, [r3, #0]
 8005236:	68fa      	ldr	r2, [r7, #12]
 8005238:	609a      	str	r2, [r3, #8]
      break;
 800523a:	e04e      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      TIM_ETR_SetConfig(htim->Instance,
 800523c:	687b      	ldr	r3, [r7, #4]
 800523e:	6818      	ldr	r0, [r3, #0]
 8005240:	683b      	ldr	r3, [r7, #0]
 8005242:	6899      	ldr	r1, [r3, #8]
 8005244:	683b      	ldr	r3, [r7, #0]
 8005246:	685a      	ldr	r2, [r3, #4]
 8005248:	683b      	ldr	r3, [r7, #0]
 800524a:	68db      	ldr	r3, [r3, #12]
 800524c:	f000 fc64 	bl	8005b18 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8005250:	687b      	ldr	r3, [r7, #4]
 8005252:	681b      	ldr	r3, [r3, #0]
 8005254:	689a      	ldr	r2, [r3, #8]
 8005256:	687b      	ldr	r3, [r7, #4]
 8005258:	681b      	ldr	r3, [r3, #0]
 800525a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800525e:	609a      	str	r2, [r3, #8]
      break;
 8005260:	e03b      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8005262:	687b      	ldr	r3, [r7, #4]
 8005264:	6818      	ldr	r0, [r3, #0]
 8005266:	683b      	ldr	r3, [r7, #0]
 8005268:	6859      	ldr	r1, [r3, #4]
 800526a:	683b      	ldr	r3, [r7, #0]
 800526c:	68db      	ldr	r3, [r3, #12]
 800526e:	461a      	mov	r2, r3
 8005270:	f000 fbd8 	bl	8005a24 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 8005274:	687b      	ldr	r3, [r7, #4]
 8005276:	681b      	ldr	r3, [r3, #0]
 8005278:	2150      	movs	r1, #80	; 0x50
 800527a:	4618      	mov	r0, r3
 800527c:	f000 fc31 	bl	8005ae2 <TIM_ITRx_SetConfig>
      break;
 8005280:	e02b      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      TIM_TI2_ConfigInputStage(htim->Instance,
 8005282:	687b      	ldr	r3, [r7, #4]
 8005284:	6818      	ldr	r0, [r3, #0]
 8005286:	683b      	ldr	r3, [r7, #0]
 8005288:	6859      	ldr	r1, [r3, #4]
 800528a:	683b      	ldr	r3, [r7, #0]
 800528c:	68db      	ldr	r3, [r3, #12]
 800528e:	461a      	mov	r2, r3
 8005290:	f000 fbf7 	bl	8005a82 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 8005294:	687b      	ldr	r3, [r7, #4]
 8005296:	681b      	ldr	r3, [r3, #0]
 8005298:	2160      	movs	r1, #96	; 0x60
 800529a:	4618      	mov	r0, r3
 800529c:	f000 fc21 	bl	8005ae2 <TIM_ITRx_SetConfig>
      break;
 80052a0:	e01b      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80052a2:	687b      	ldr	r3, [r7, #4]
 80052a4:	6818      	ldr	r0, [r3, #0]
 80052a6:	683b      	ldr	r3, [r7, #0]
 80052a8:	6859      	ldr	r1, [r3, #4]
 80052aa:	683b      	ldr	r3, [r7, #0]
 80052ac:	68db      	ldr	r3, [r3, #12]
 80052ae:	461a      	mov	r2, r3
 80052b0:	f000 fbb8 	bl	8005a24 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 80052b4:	687b      	ldr	r3, [r7, #4]
 80052b6:	681b      	ldr	r3, [r3, #0]
 80052b8:	2140      	movs	r1, #64	; 0x40
 80052ba:	4618      	mov	r0, r3
 80052bc:	f000 fc11 	bl	8005ae2 <TIM_ITRx_SetConfig>
      break;
 80052c0:	e00b      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 80052c2:	687b      	ldr	r3, [r7, #4]
 80052c4:	681a      	ldr	r2, [r3, #0]
 80052c6:	683b      	ldr	r3, [r7, #0]
 80052c8:	681b      	ldr	r3, [r3, #0]
 80052ca:	4619      	mov	r1, r3
 80052cc:	4610      	mov	r0, r2
 80052ce:	f000 fc08 	bl	8005ae2 <TIM_ITRx_SetConfig>
        break;
 80052d2:	e002      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      break;
 80052d4:	bf00      	nop
 80052d6:	e000      	b.n	80052da <HAL_TIM_ConfigClockSource+0x172>
      break;
 80052d8:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 80052da:	687b      	ldr	r3, [r7, #4]
 80052dc:	2201      	movs	r2, #1
 80052de:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80052e2:	687b      	ldr	r3, [r7, #4]
 80052e4:	2200      	movs	r2, #0
 80052e6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 80052ea:	2300      	movs	r3, #0
}
 80052ec:	4618      	mov	r0, r3
 80052ee:	3710      	adds	r7, #16
 80052f0:	46bd      	mov	sp, r7
 80052f2:	bd80      	pop	{r7, pc}

080052f4 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80052f4:	b480      	push	{r7}
 80052f6:	b083      	sub	sp, #12
 80052f8:	af00      	add	r7, sp, #0
 80052fa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 80052fc:	bf00      	nop
 80052fe:	370c      	adds	r7, #12
 8005300:	46bd      	mov	sp, r7
 8005302:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005306:	4770      	bx	lr

08005308 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8005308:	b480      	push	{r7}
 800530a:	b083      	sub	sp, #12
 800530c:	af00      	add	r7, sp, #0
 800530e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8005310:	bf00      	nop
 8005312:	370c      	adds	r7, #12
 8005314:	46bd      	mov	sp, r7
 8005316:	f85d 7b04 	ldr.w	r7, [sp], #4
 800531a:	4770      	bx	lr

0800531c <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800531c:	b480      	push	{r7}
 800531e:	b083      	sub	sp, #12
 8005320:	af00      	add	r7, sp, #0
 8005322:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8005324:	bf00      	nop
 8005326:	370c      	adds	r7, #12
 8005328:	46bd      	mov	sp, r7
 800532a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800532e:	4770      	bx	lr

08005330 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8005330:	b480      	push	{r7}
 8005332:	b083      	sub	sp, #12
 8005334:	af00      	add	r7, sp, #0
 8005336:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8005338:	bf00      	nop
 800533a:	370c      	adds	r7, #12
 800533c:	46bd      	mov	sp, r7
 800533e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005342:	4770      	bx	lr

08005344 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8005344:	b480      	push	{r7}
 8005346:	b085      	sub	sp, #20
 8005348:	af00      	add	r7, sp, #0
 800534a:	6078      	str	r0, [r7, #4]
 800534c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800534e:	687b      	ldr	r3, [r7, #4]
 8005350:	681b      	ldr	r3, [r3, #0]
 8005352:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005354:	687b      	ldr	r3, [r7, #4]
 8005356:	4a40      	ldr	r2, [pc, #256]	; (8005458 <TIM_Base_SetConfig+0x114>)
 8005358:	4293      	cmp	r3, r2
 800535a:	d013      	beq.n	8005384 <TIM_Base_SetConfig+0x40>
 800535c:	687b      	ldr	r3, [r7, #4]
 800535e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005362:	d00f      	beq.n	8005384 <TIM_Base_SetConfig+0x40>
 8005364:	687b      	ldr	r3, [r7, #4]
 8005366:	4a3d      	ldr	r2, [pc, #244]	; (800545c <TIM_Base_SetConfig+0x118>)
 8005368:	4293      	cmp	r3, r2
 800536a:	d00b      	beq.n	8005384 <TIM_Base_SetConfig+0x40>
 800536c:	687b      	ldr	r3, [r7, #4]
 800536e:	4a3c      	ldr	r2, [pc, #240]	; (8005460 <TIM_Base_SetConfig+0x11c>)
 8005370:	4293      	cmp	r3, r2
 8005372:	d007      	beq.n	8005384 <TIM_Base_SetConfig+0x40>
 8005374:	687b      	ldr	r3, [r7, #4]
 8005376:	4a3b      	ldr	r2, [pc, #236]	; (8005464 <TIM_Base_SetConfig+0x120>)
 8005378:	4293      	cmp	r3, r2
 800537a:	d003      	beq.n	8005384 <TIM_Base_SetConfig+0x40>
 800537c:	687b      	ldr	r3, [r7, #4]
 800537e:	4a3a      	ldr	r2, [pc, #232]	; (8005468 <TIM_Base_SetConfig+0x124>)
 8005380:	4293      	cmp	r3, r2
 8005382:	d108      	bne.n	8005396 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005384:	68fb      	ldr	r3, [r7, #12]
 8005386:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800538a:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800538c:	683b      	ldr	r3, [r7, #0]
 800538e:	685b      	ldr	r3, [r3, #4]
 8005390:	68fa      	ldr	r2, [r7, #12]
 8005392:	4313      	orrs	r3, r2
 8005394:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005396:	687b      	ldr	r3, [r7, #4]
 8005398:	4a2f      	ldr	r2, [pc, #188]	; (8005458 <TIM_Base_SetConfig+0x114>)
 800539a:	4293      	cmp	r3, r2
 800539c:	d01f      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 800539e:	687b      	ldr	r3, [r7, #4]
 80053a0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80053a4:	d01b      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053a6:	687b      	ldr	r3, [r7, #4]
 80053a8:	4a2c      	ldr	r2, [pc, #176]	; (800545c <TIM_Base_SetConfig+0x118>)
 80053aa:	4293      	cmp	r3, r2
 80053ac:	d017      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053ae:	687b      	ldr	r3, [r7, #4]
 80053b0:	4a2b      	ldr	r2, [pc, #172]	; (8005460 <TIM_Base_SetConfig+0x11c>)
 80053b2:	4293      	cmp	r3, r2
 80053b4:	d013      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053b6:	687b      	ldr	r3, [r7, #4]
 80053b8:	4a2a      	ldr	r2, [pc, #168]	; (8005464 <TIM_Base_SetConfig+0x120>)
 80053ba:	4293      	cmp	r3, r2
 80053bc:	d00f      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053be:	687b      	ldr	r3, [r7, #4]
 80053c0:	4a29      	ldr	r2, [pc, #164]	; (8005468 <TIM_Base_SetConfig+0x124>)
 80053c2:	4293      	cmp	r3, r2
 80053c4:	d00b      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053c6:	687b      	ldr	r3, [r7, #4]
 80053c8:	4a28      	ldr	r2, [pc, #160]	; (800546c <TIM_Base_SetConfig+0x128>)
 80053ca:	4293      	cmp	r3, r2
 80053cc:	d007      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053ce:	687b      	ldr	r3, [r7, #4]
 80053d0:	4a27      	ldr	r2, [pc, #156]	; (8005470 <TIM_Base_SetConfig+0x12c>)
 80053d2:	4293      	cmp	r3, r2
 80053d4:	d003      	beq.n	80053de <TIM_Base_SetConfig+0x9a>
 80053d6:	687b      	ldr	r3, [r7, #4]
 80053d8:	4a26      	ldr	r2, [pc, #152]	; (8005474 <TIM_Base_SetConfig+0x130>)
 80053da:	4293      	cmp	r3, r2
 80053dc:	d108      	bne.n	80053f0 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80053de:	68fb      	ldr	r3, [r7, #12]
 80053e0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80053e4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80053e6:	683b      	ldr	r3, [r7, #0]
 80053e8:	68db      	ldr	r3, [r3, #12]
 80053ea:	68fa      	ldr	r2, [r7, #12]
 80053ec:	4313      	orrs	r3, r2
 80053ee:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80053f0:	68fb      	ldr	r3, [r7, #12]
 80053f2:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 80053f6:	683b      	ldr	r3, [r7, #0]
 80053f8:	695b      	ldr	r3, [r3, #20]
 80053fa:	4313      	orrs	r3, r2
 80053fc:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 80053fe:	687b      	ldr	r3, [r7, #4]
 8005400:	68fa      	ldr	r2, [r7, #12]
 8005402:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005404:	683b      	ldr	r3, [r7, #0]
 8005406:	689a      	ldr	r2, [r3, #8]
 8005408:	687b      	ldr	r3, [r7, #4]
 800540a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800540c:	683b      	ldr	r3, [r7, #0]
 800540e:	681a      	ldr	r2, [r3, #0]
 8005410:	687b      	ldr	r3, [r7, #4]
 8005412:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005414:	687b      	ldr	r3, [r7, #4]
 8005416:	4a10      	ldr	r2, [pc, #64]	; (8005458 <TIM_Base_SetConfig+0x114>)
 8005418:	4293      	cmp	r3, r2
 800541a:	d00f      	beq.n	800543c <TIM_Base_SetConfig+0xf8>
 800541c:	687b      	ldr	r3, [r7, #4]
 800541e:	4a12      	ldr	r2, [pc, #72]	; (8005468 <TIM_Base_SetConfig+0x124>)
 8005420:	4293      	cmp	r3, r2
 8005422:	d00b      	beq.n	800543c <TIM_Base_SetConfig+0xf8>
 8005424:	687b      	ldr	r3, [r7, #4]
 8005426:	4a11      	ldr	r2, [pc, #68]	; (800546c <TIM_Base_SetConfig+0x128>)
 8005428:	4293      	cmp	r3, r2
 800542a:	d007      	beq.n	800543c <TIM_Base_SetConfig+0xf8>
 800542c:	687b      	ldr	r3, [r7, #4]
 800542e:	4a10      	ldr	r2, [pc, #64]	; (8005470 <TIM_Base_SetConfig+0x12c>)
 8005430:	4293      	cmp	r3, r2
 8005432:	d003      	beq.n	800543c <TIM_Base_SetConfig+0xf8>
 8005434:	687b      	ldr	r3, [r7, #4]
 8005436:	4a0f      	ldr	r2, [pc, #60]	; (8005474 <TIM_Base_SetConfig+0x130>)
 8005438:	4293      	cmp	r3, r2
 800543a:	d103      	bne.n	8005444 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800543c:	683b      	ldr	r3, [r7, #0]
 800543e:	691a      	ldr	r2, [r3, #16]
 8005440:	687b      	ldr	r3, [r7, #4]
 8005442:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8005444:	687b      	ldr	r3, [r7, #4]
 8005446:	2201      	movs	r2, #1
 8005448:	615a      	str	r2, [r3, #20]
}
 800544a:	bf00      	nop
 800544c:	3714      	adds	r7, #20
 800544e:	46bd      	mov	sp, r7
 8005450:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005454:	4770      	bx	lr
 8005456:	bf00      	nop
 8005458:	40012c00 	.word	0x40012c00
 800545c:	40000400 	.word	0x40000400
 8005460:	40000800 	.word	0x40000800
 8005464:	40000c00 	.word	0x40000c00
 8005468:	40013400 	.word	0x40013400
 800546c:	40014000 	.word	0x40014000
 8005470:	40014400 	.word	0x40014400
 8005474:	40014800 	.word	0x40014800

08005478 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8005478:	b480      	push	{r7}
 800547a:	b087      	sub	sp, #28
 800547c:	af00      	add	r7, sp, #0
 800547e:	6078      	str	r0, [r7, #4]
 8005480:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005482:	687b      	ldr	r3, [r7, #4]
 8005484:	6a1b      	ldr	r3, [r3, #32]
 8005486:	f023 0201 	bic.w	r2, r3, #1
 800548a:	687b      	ldr	r3, [r7, #4]
 800548c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800548e:	687b      	ldr	r3, [r7, #4]
 8005490:	6a1b      	ldr	r3, [r3, #32]
 8005492:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005494:	687b      	ldr	r3, [r7, #4]
 8005496:	685b      	ldr	r3, [r3, #4]
 8005498:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800549a:	687b      	ldr	r3, [r7, #4]
 800549c:	699b      	ldr	r3, [r3, #24]
 800549e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 80054a0:	68fb      	ldr	r3, [r7, #12]
 80054a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80054a6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80054aa:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80054ac:	68fb      	ldr	r3, [r7, #12]
 80054ae:	f023 0303 	bic.w	r3, r3, #3
 80054b2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80054b4:	683b      	ldr	r3, [r7, #0]
 80054b6:	681b      	ldr	r3, [r3, #0]
 80054b8:	68fa      	ldr	r2, [r7, #12]
 80054ba:	4313      	orrs	r3, r2
 80054bc:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80054be:	697b      	ldr	r3, [r7, #20]
 80054c0:	f023 0302 	bic.w	r3, r3, #2
 80054c4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80054c6:	683b      	ldr	r3, [r7, #0]
 80054c8:	689b      	ldr	r3, [r3, #8]
 80054ca:	697a      	ldr	r2, [r7, #20]
 80054cc:	4313      	orrs	r3, r2
 80054ce:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	4a2c      	ldr	r2, [pc, #176]	; (8005584 <TIM_OC1_SetConfig+0x10c>)
 80054d4:	4293      	cmp	r3, r2
 80054d6:	d00f      	beq.n	80054f8 <TIM_OC1_SetConfig+0x80>
 80054d8:	687b      	ldr	r3, [r7, #4]
 80054da:	4a2b      	ldr	r2, [pc, #172]	; (8005588 <TIM_OC1_SetConfig+0x110>)
 80054dc:	4293      	cmp	r3, r2
 80054de:	d00b      	beq.n	80054f8 <TIM_OC1_SetConfig+0x80>
 80054e0:	687b      	ldr	r3, [r7, #4]
 80054e2:	4a2a      	ldr	r2, [pc, #168]	; (800558c <TIM_OC1_SetConfig+0x114>)
 80054e4:	4293      	cmp	r3, r2
 80054e6:	d007      	beq.n	80054f8 <TIM_OC1_SetConfig+0x80>
 80054e8:	687b      	ldr	r3, [r7, #4]
 80054ea:	4a29      	ldr	r2, [pc, #164]	; (8005590 <TIM_OC1_SetConfig+0x118>)
 80054ec:	4293      	cmp	r3, r2
 80054ee:	d003      	beq.n	80054f8 <TIM_OC1_SetConfig+0x80>
 80054f0:	687b      	ldr	r3, [r7, #4]
 80054f2:	4a28      	ldr	r2, [pc, #160]	; (8005594 <TIM_OC1_SetConfig+0x11c>)
 80054f4:	4293      	cmp	r3, r2
 80054f6:	d10c      	bne.n	8005512 <TIM_OC1_SetConfig+0x9a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80054f8:	697b      	ldr	r3, [r7, #20]
 80054fa:	f023 0308 	bic.w	r3, r3, #8
 80054fe:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8005500:	683b      	ldr	r3, [r7, #0]
 8005502:	68db      	ldr	r3, [r3, #12]
 8005504:	697a      	ldr	r2, [r7, #20]
 8005506:	4313      	orrs	r3, r2
 8005508:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800550a:	697b      	ldr	r3, [r7, #20]
 800550c:	f023 0304 	bic.w	r3, r3, #4
 8005510:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8005512:	687b      	ldr	r3, [r7, #4]
 8005514:	4a1b      	ldr	r2, [pc, #108]	; (8005584 <TIM_OC1_SetConfig+0x10c>)
 8005516:	4293      	cmp	r3, r2
 8005518:	d00f      	beq.n	800553a <TIM_OC1_SetConfig+0xc2>
 800551a:	687b      	ldr	r3, [r7, #4]
 800551c:	4a1a      	ldr	r2, [pc, #104]	; (8005588 <TIM_OC1_SetConfig+0x110>)
 800551e:	4293      	cmp	r3, r2
 8005520:	d00b      	beq.n	800553a <TIM_OC1_SetConfig+0xc2>
 8005522:	687b      	ldr	r3, [r7, #4]
 8005524:	4a19      	ldr	r2, [pc, #100]	; (800558c <TIM_OC1_SetConfig+0x114>)
 8005526:	4293      	cmp	r3, r2
 8005528:	d007      	beq.n	800553a <TIM_OC1_SetConfig+0xc2>
 800552a:	687b      	ldr	r3, [r7, #4]
 800552c:	4a18      	ldr	r2, [pc, #96]	; (8005590 <TIM_OC1_SetConfig+0x118>)
 800552e:	4293      	cmp	r3, r2
 8005530:	d003      	beq.n	800553a <TIM_OC1_SetConfig+0xc2>
 8005532:	687b      	ldr	r3, [r7, #4]
 8005534:	4a17      	ldr	r2, [pc, #92]	; (8005594 <TIM_OC1_SetConfig+0x11c>)
 8005536:	4293      	cmp	r3, r2
 8005538:	d111      	bne.n	800555e <TIM_OC1_SetConfig+0xe6>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 800553a:	693b      	ldr	r3, [r7, #16]
 800553c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005540:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8005542:	693b      	ldr	r3, [r7, #16]
 8005544:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8005548:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 800554a:	683b      	ldr	r3, [r7, #0]
 800554c:	695b      	ldr	r3, [r3, #20]
 800554e:	693a      	ldr	r2, [r7, #16]
 8005550:	4313      	orrs	r3, r2
 8005552:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8005554:	683b      	ldr	r3, [r7, #0]
 8005556:	699b      	ldr	r3, [r3, #24]
 8005558:	693a      	ldr	r2, [r7, #16]
 800555a:	4313      	orrs	r3, r2
 800555c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800555e:	687b      	ldr	r3, [r7, #4]
 8005560:	693a      	ldr	r2, [r7, #16]
 8005562:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8005564:	687b      	ldr	r3, [r7, #4]
 8005566:	68fa      	ldr	r2, [r7, #12]
 8005568:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800556a:	683b      	ldr	r3, [r7, #0]
 800556c:	685a      	ldr	r2, [r3, #4]
 800556e:	687b      	ldr	r3, [r7, #4]
 8005570:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005572:	687b      	ldr	r3, [r7, #4]
 8005574:	697a      	ldr	r2, [r7, #20]
 8005576:	621a      	str	r2, [r3, #32]
}
 8005578:	bf00      	nop
 800557a:	371c      	adds	r7, #28
 800557c:	46bd      	mov	sp, r7
 800557e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005582:	4770      	bx	lr
 8005584:	40012c00 	.word	0x40012c00
 8005588:	40013400 	.word	0x40013400
 800558c:	40014000 	.word	0x40014000
 8005590:	40014400 	.word	0x40014400
 8005594:	40014800 	.word	0x40014800

08005598 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8005598:	b480      	push	{r7}
 800559a:	b087      	sub	sp, #28
 800559c:	af00      	add	r7, sp, #0
 800559e:	6078      	str	r0, [r7, #4]
 80055a0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80055a2:	687b      	ldr	r3, [r7, #4]
 80055a4:	6a1b      	ldr	r3, [r3, #32]
 80055a6:	f023 0210 	bic.w	r2, r3, #16
 80055aa:	687b      	ldr	r3, [r7, #4]
 80055ac:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80055ae:	687b      	ldr	r3, [r7, #4]
 80055b0:	6a1b      	ldr	r3, [r3, #32]
 80055b2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80055b4:	687b      	ldr	r3, [r7, #4]
 80055b6:	685b      	ldr	r3, [r3, #4]
 80055b8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	699b      	ldr	r3, [r3, #24]
 80055be:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 80055c0:	68fb      	ldr	r3, [r7, #12]
 80055c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80055c6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80055ca:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80055cc:	68fb      	ldr	r3, [r7, #12]
 80055ce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80055d2:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80055d4:	683b      	ldr	r3, [r7, #0]
 80055d6:	681b      	ldr	r3, [r3, #0]
 80055d8:	021b      	lsls	r3, r3, #8
 80055da:	68fa      	ldr	r2, [r7, #12]
 80055dc:	4313      	orrs	r3, r2
 80055de:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 80055e0:	697b      	ldr	r3, [r7, #20]
 80055e2:	f023 0320 	bic.w	r3, r3, #32
 80055e6:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80055e8:	683b      	ldr	r3, [r7, #0]
 80055ea:	689b      	ldr	r3, [r3, #8]
 80055ec:	011b      	lsls	r3, r3, #4
 80055ee:	697a      	ldr	r2, [r7, #20]
 80055f0:	4313      	orrs	r3, r2
 80055f2:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80055f4:	687b      	ldr	r3, [r7, #4]
 80055f6:	4a28      	ldr	r2, [pc, #160]	; (8005698 <TIM_OC2_SetConfig+0x100>)
 80055f8:	4293      	cmp	r3, r2
 80055fa:	d003      	beq.n	8005604 <TIM_OC2_SetConfig+0x6c>
 80055fc:	687b      	ldr	r3, [r7, #4]
 80055fe:	4a27      	ldr	r2, [pc, #156]	; (800569c <TIM_OC2_SetConfig+0x104>)
 8005600:	4293      	cmp	r3, r2
 8005602:	d10d      	bne.n	8005620 <TIM_OC2_SetConfig+0x88>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8005604:	697b      	ldr	r3, [r7, #20]
 8005606:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800560a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800560c:	683b      	ldr	r3, [r7, #0]
 800560e:	68db      	ldr	r3, [r3, #12]
 8005610:	011b      	lsls	r3, r3, #4
 8005612:	697a      	ldr	r2, [r7, #20]
 8005614:	4313      	orrs	r3, r2
 8005616:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8005618:	697b      	ldr	r3, [r7, #20]
 800561a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800561e:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8005620:	687b      	ldr	r3, [r7, #4]
 8005622:	4a1d      	ldr	r2, [pc, #116]	; (8005698 <TIM_OC2_SetConfig+0x100>)
 8005624:	4293      	cmp	r3, r2
 8005626:	d00f      	beq.n	8005648 <TIM_OC2_SetConfig+0xb0>
 8005628:	687b      	ldr	r3, [r7, #4]
 800562a:	4a1c      	ldr	r2, [pc, #112]	; (800569c <TIM_OC2_SetConfig+0x104>)
 800562c:	4293      	cmp	r3, r2
 800562e:	d00b      	beq.n	8005648 <TIM_OC2_SetConfig+0xb0>
 8005630:	687b      	ldr	r3, [r7, #4]
 8005632:	4a1b      	ldr	r2, [pc, #108]	; (80056a0 <TIM_OC2_SetConfig+0x108>)
 8005634:	4293      	cmp	r3, r2
 8005636:	d007      	beq.n	8005648 <TIM_OC2_SetConfig+0xb0>
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	4a1a      	ldr	r2, [pc, #104]	; (80056a4 <TIM_OC2_SetConfig+0x10c>)
 800563c:	4293      	cmp	r3, r2
 800563e:	d003      	beq.n	8005648 <TIM_OC2_SetConfig+0xb0>
 8005640:	687b      	ldr	r3, [r7, #4]
 8005642:	4a19      	ldr	r2, [pc, #100]	; (80056a8 <TIM_OC2_SetConfig+0x110>)
 8005644:	4293      	cmp	r3, r2
 8005646:	d113      	bne.n	8005670 <TIM_OC2_SetConfig+0xd8>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8005648:	693b      	ldr	r3, [r7, #16]
 800564a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800564e:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8005650:	693b      	ldr	r3, [r7, #16]
 8005652:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005656:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8005658:	683b      	ldr	r3, [r7, #0]
 800565a:	695b      	ldr	r3, [r3, #20]
 800565c:	009b      	lsls	r3, r3, #2
 800565e:	693a      	ldr	r2, [r7, #16]
 8005660:	4313      	orrs	r3, r2
 8005662:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8005664:	683b      	ldr	r3, [r7, #0]
 8005666:	699b      	ldr	r3, [r3, #24]
 8005668:	009b      	lsls	r3, r3, #2
 800566a:	693a      	ldr	r2, [r7, #16]
 800566c:	4313      	orrs	r3, r2
 800566e:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005670:	687b      	ldr	r3, [r7, #4]
 8005672:	693a      	ldr	r2, [r7, #16]
 8005674:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8005676:	687b      	ldr	r3, [r7, #4]
 8005678:	68fa      	ldr	r2, [r7, #12]
 800567a:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800567c:	683b      	ldr	r3, [r7, #0]
 800567e:	685a      	ldr	r2, [r3, #4]
 8005680:	687b      	ldr	r3, [r7, #4]
 8005682:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005684:	687b      	ldr	r3, [r7, #4]
 8005686:	697a      	ldr	r2, [r7, #20]
 8005688:	621a      	str	r2, [r3, #32]
}
 800568a:	bf00      	nop
 800568c:	371c      	adds	r7, #28
 800568e:	46bd      	mov	sp, r7
 8005690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005694:	4770      	bx	lr
 8005696:	bf00      	nop
 8005698:	40012c00 	.word	0x40012c00
 800569c:	40013400 	.word	0x40013400
 80056a0:	40014000 	.word	0x40014000
 80056a4:	40014400 	.word	0x40014400
 80056a8:	40014800 	.word	0x40014800

080056ac <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80056ac:	b480      	push	{r7}
 80056ae:	b087      	sub	sp, #28
 80056b0:	af00      	add	r7, sp, #0
 80056b2:	6078      	str	r0, [r7, #4]
 80056b4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80056b6:	687b      	ldr	r3, [r7, #4]
 80056b8:	6a1b      	ldr	r3, [r3, #32]
 80056ba:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 80056be:	687b      	ldr	r3, [r7, #4]
 80056c0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80056c2:	687b      	ldr	r3, [r7, #4]
 80056c4:	6a1b      	ldr	r3, [r3, #32]
 80056c6:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80056c8:	687b      	ldr	r3, [r7, #4]
 80056ca:	685b      	ldr	r3, [r3, #4]
 80056cc:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80056ce:	687b      	ldr	r3, [r7, #4]
 80056d0:	69db      	ldr	r3, [r3, #28]
 80056d2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 80056d4:	68fb      	ldr	r3, [r7, #12]
 80056d6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80056da:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80056de:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 80056e0:	68fb      	ldr	r3, [r7, #12]
 80056e2:	f023 0303 	bic.w	r3, r3, #3
 80056e6:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80056e8:	683b      	ldr	r3, [r7, #0]
 80056ea:	681b      	ldr	r3, [r3, #0]
 80056ec:	68fa      	ldr	r2, [r7, #12]
 80056ee:	4313      	orrs	r3, r2
 80056f0:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 80056f2:	697b      	ldr	r3, [r7, #20]
 80056f4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80056f8:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80056fa:	683b      	ldr	r3, [r7, #0]
 80056fc:	689b      	ldr	r3, [r3, #8]
 80056fe:	021b      	lsls	r3, r3, #8
 8005700:	697a      	ldr	r2, [r7, #20]
 8005702:	4313      	orrs	r3, r2
 8005704:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8005706:	687b      	ldr	r3, [r7, #4]
 8005708:	4a27      	ldr	r2, [pc, #156]	; (80057a8 <TIM_OC3_SetConfig+0xfc>)
 800570a:	4293      	cmp	r3, r2
 800570c:	d003      	beq.n	8005716 <TIM_OC3_SetConfig+0x6a>
 800570e:	687b      	ldr	r3, [r7, #4]
 8005710:	4a26      	ldr	r2, [pc, #152]	; (80057ac <TIM_OC3_SetConfig+0x100>)
 8005712:	4293      	cmp	r3, r2
 8005714:	d10d      	bne.n	8005732 <TIM_OC3_SetConfig+0x86>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8005716:	697b      	ldr	r3, [r7, #20]
 8005718:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800571c:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800571e:	683b      	ldr	r3, [r7, #0]
 8005720:	68db      	ldr	r3, [r3, #12]
 8005722:	021b      	lsls	r3, r3, #8
 8005724:	697a      	ldr	r2, [r7, #20]
 8005726:	4313      	orrs	r3, r2
 8005728:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800572a:	697b      	ldr	r3, [r7, #20]
 800572c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005730:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8005732:	687b      	ldr	r3, [r7, #4]
 8005734:	4a1c      	ldr	r2, [pc, #112]	; (80057a8 <TIM_OC3_SetConfig+0xfc>)
 8005736:	4293      	cmp	r3, r2
 8005738:	d00f      	beq.n	800575a <TIM_OC3_SetConfig+0xae>
 800573a:	687b      	ldr	r3, [r7, #4]
 800573c:	4a1b      	ldr	r2, [pc, #108]	; (80057ac <TIM_OC3_SetConfig+0x100>)
 800573e:	4293      	cmp	r3, r2
 8005740:	d00b      	beq.n	800575a <TIM_OC3_SetConfig+0xae>
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	4a1a      	ldr	r2, [pc, #104]	; (80057b0 <TIM_OC3_SetConfig+0x104>)
 8005746:	4293      	cmp	r3, r2
 8005748:	d007      	beq.n	800575a <TIM_OC3_SetConfig+0xae>
 800574a:	687b      	ldr	r3, [r7, #4]
 800574c:	4a19      	ldr	r2, [pc, #100]	; (80057b4 <TIM_OC3_SetConfig+0x108>)
 800574e:	4293      	cmp	r3, r2
 8005750:	d003      	beq.n	800575a <TIM_OC3_SetConfig+0xae>
 8005752:	687b      	ldr	r3, [r7, #4]
 8005754:	4a18      	ldr	r2, [pc, #96]	; (80057b8 <TIM_OC3_SetConfig+0x10c>)
 8005756:	4293      	cmp	r3, r2
 8005758:	d113      	bne.n	8005782 <TIM_OC3_SetConfig+0xd6>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 800575a:	693b      	ldr	r3, [r7, #16]
 800575c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005760:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8005762:	693b      	ldr	r3, [r7, #16]
 8005764:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005768:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 800576a:	683b      	ldr	r3, [r7, #0]
 800576c:	695b      	ldr	r3, [r3, #20]
 800576e:	011b      	lsls	r3, r3, #4
 8005770:	693a      	ldr	r2, [r7, #16]
 8005772:	4313      	orrs	r3, r2
 8005774:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8005776:	683b      	ldr	r3, [r7, #0]
 8005778:	699b      	ldr	r3, [r3, #24]
 800577a:	011b      	lsls	r3, r3, #4
 800577c:	693a      	ldr	r2, [r7, #16]
 800577e:	4313      	orrs	r3, r2
 8005780:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005782:	687b      	ldr	r3, [r7, #4]
 8005784:	693a      	ldr	r2, [r7, #16]
 8005786:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8005788:	687b      	ldr	r3, [r7, #4]
 800578a:	68fa      	ldr	r2, [r7, #12]
 800578c:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800578e:	683b      	ldr	r3, [r7, #0]
 8005790:	685a      	ldr	r2, [r3, #4]
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005796:	687b      	ldr	r3, [r7, #4]
 8005798:	697a      	ldr	r2, [r7, #20]
 800579a:	621a      	str	r2, [r3, #32]
}
 800579c:	bf00      	nop
 800579e:	371c      	adds	r7, #28
 80057a0:	46bd      	mov	sp, r7
 80057a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057a6:	4770      	bx	lr
 80057a8:	40012c00 	.word	0x40012c00
 80057ac:	40013400 	.word	0x40013400
 80057b0:	40014000 	.word	0x40014000
 80057b4:	40014400 	.word	0x40014400
 80057b8:	40014800 	.word	0x40014800

080057bc <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80057bc:	b480      	push	{r7}
 80057be:	b087      	sub	sp, #28
 80057c0:	af00      	add	r7, sp, #0
 80057c2:	6078      	str	r0, [r7, #4]
 80057c4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80057c6:	687b      	ldr	r3, [r7, #4]
 80057c8:	6a1b      	ldr	r3, [r3, #32]
 80057ca:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80057ce:	687b      	ldr	r3, [r7, #4]
 80057d0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80057d2:	687b      	ldr	r3, [r7, #4]
 80057d4:	6a1b      	ldr	r3, [r3, #32]
 80057d6:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80057d8:	687b      	ldr	r3, [r7, #4]
 80057da:	685b      	ldr	r3, [r3, #4]
 80057dc:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80057de:	687b      	ldr	r3, [r7, #4]
 80057e0:	69db      	ldr	r3, [r3, #28]
 80057e2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 80057e4:	68fb      	ldr	r3, [r7, #12]
 80057e6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80057ea:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80057ee:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80057f0:	68fb      	ldr	r3, [r7, #12]
 80057f2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80057f6:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80057f8:	683b      	ldr	r3, [r7, #0]
 80057fa:	681b      	ldr	r3, [r3, #0]
 80057fc:	021b      	lsls	r3, r3, #8
 80057fe:	68fa      	ldr	r2, [r7, #12]
 8005800:	4313      	orrs	r3, r2
 8005802:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8005804:	693b      	ldr	r3, [r7, #16]
 8005806:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800580a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800580c:	683b      	ldr	r3, [r7, #0]
 800580e:	689b      	ldr	r3, [r3, #8]
 8005810:	031b      	lsls	r3, r3, #12
 8005812:	693a      	ldr	r2, [r7, #16]
 8005814:	4313      	orrs	r3, r2
 8005816:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8005818:	687b      	ldr	r3, [r7, #4]
 800581a:	4a18      	ldr	r2, [pc, #96]	; (800587c <TIM_OC4_SetConfig+0xc0>)
 800581c:	4293      	cmp	r3, r2
 800581e:	d00f      	beq.n	8005840 <TIM_OC4_SetConfig+0x84>
 8005820:	687b      	ldr	r3, [r7, #4]
 8005822:	4a17      	ldr	r2, [pc, #92]	; (8005880 <TIM_OC4_SetConfig+0xc4>)
 8005824:	4293      	cmp	r3, r2
 8005826:	d00b      	beq.n	8005840 <TIM_OC4_SetConfig+0x84>
 8005828:	687b      	ldr	r3, [r7, #4]
 800582a:	4a16      	ldr	r2, [pc, #88]	; (8005884 <TIM_OC4_SetConfig+0xc8>)
 800582c:	4293      	cmp	r3, r2
 800582e:	d007      	beq.n	8005840 <TIM_OC4_SetConfig+0x84>
 8005830:	687b      	ldr	r3, [r7, #4]
 8005832:	4a15      	ldr	r2, [pc, #84]	; (8005888 <TIM_OC4_SetConfig+0xcc>)
 8005834:	4293      	cmp	r3, r2
 8005836:	d003      	beq.n	8005840 <TIM_OC4_SetConfig+0x84>
 8005838:	687b      	ldr	r3, [r7, #4]
 800583a:	4a14      	ldr	r2, [pc, #80]	; (800588c <TIM_OC4_SetConfig+0xd0>)
 800583c:	4293      	cmp	r3, r2
 800583e:	d109      	bne.n	8005854 <TIM_OC4_SetConfig+0x98>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8005840:	697b      	ldr	r3, [r7, #20]
 8005842:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005846:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8005848:	683b      	ldr	r3, [r7, #0]
 800584a:	695b      	ldr	r3, [r3, #20]
 800584c:	019b      	lsls	r3, r3, #6
 800584e:	697a      	ldr	r2, [r7, #20]
 8005850:	4313      	orrs	r3, r2
 8005852:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005854:	687b      	ldr	r3, [r7, #4]
 8005856:	697a      	ldr	r2, [r7, #20]
 8005858:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800585a:	687b      	ldr	r3, [r7, #4]
 800585c:	68fa      	ldr	r2, [r7, #12]
 800585e:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8005860:	683b      	ldr	r3, [r7, #0]
 8005862:	685a      	ldr	r2, [r3, #4]
 8005864:	687b      	ldr	r3, [r7, #4]
 8005866:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005868:	687b      	ldr	r3, [r7, #4]
 800586a:	693a      	ldr	r2, [r7, #16]
 800586c:	621a      	str	r2, [r3, #32]
}
 800586e:	bf00      	nop
 8005870:	371c      	adds	r7, #28
 8005872:	46bd      	mov	sp, r7
 8005874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005878:	4770      	bx	lr
 800587a:	bf00      	nop
 800587c:	40012c00 	.word	0x40012c00
 8005880:	40013400 	.word	0x40013400
 8005884:	40014000 	.word	0x40014000
 8005888:	40014400 	.word	0x40014400
 800588c:	40014800 	.word	0x40014800

08005890 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8005890:	b480      	push	{r7}
 8005892:	b087      	sub	sp, #28
 8005894:	af00      	add	r7, sp, #0
 8005896:	6078      	str	r0, [r7, #4]
 8005898:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800589a:	687b      	ldr	r3, [r7, #4]
 800589c:	6a1b      	ldr	r3, [r3, #32]
 800589e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 80058a2:	687b      	ldr	r3, [r7, #4]
 80058a4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80058a6:	687b      	ldr	r3, [r7, #4]
 80058a8:	6a1b      	ldr	r3, [r3, #32]
 80058aa:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80058ac:	687b      	ldr	r3, [r7, #4]
 80058ae:	685b      	ldr	r3, [r3, #4]
 80058b0:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 80058b2:	687b      	ldr	r3, [r7, #4]
 80058b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80058b6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80058b8:	68fb      	ldr	r3, [r7, #12]
 80058ba:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80058be:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80058c2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80058c4:	683b      	ldr	r3, [r7, #0]
 80058c6:	681b      	ldr	r3, [r3, #0]
 80058c8:	68fa      	ldr	r2, [r7, #12]
 80058ca:	4313      	orrs	r3, r2
 80058cc:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 80058ce:	693b      	ldr	r3, [r7, #16]
 80058d0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80058d4:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80058d6:	683b      	ldr	r3, [r7, #0]
 80058d8:	689b      	ldr	r3, [r3, #8]
 80058da:	041b      	lsls	r3, r3, #16
 80058dc:	693a      	ldr	r2, [r7, #16]
 80058de:	4313      	orrs	r3, r2
 80058e0:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80058e2:	687b      	ldr	r3, [r7, #4]
 80058e4:	4a17      	ldr	r2, [pc, #92]	; (8005944 <TIM_OC5_SetConfig+0xb4>)
 80058e6:	4293      	cmp	r3, r2
 80058e8:	d00f      	beq.n	800590a <TIM_OC5_SetConfig+0x7a>
 80058ea:	687b      	ldr	r3, [r7, #4]
 80058ec:	4a16      	ldr	r2, [pc, #88]	; (8005948 <TIM_OC5_SetConfig+0xb8>)
 80058ee:	4293      	cmp	r3, r2
 80058f0:	d00b      	beq.n	800590a <TIM_OC5_SetConfig+0x7a>
 80058f2:	687b      	ldr	r3, [r7, #4]
 80058f4:	4a15      	ldr	r2, [pc, #84]	; (800594c <TIM_OC5_SetConfig+0xbc>)
 80058f6:	4293      	cmp	r3, r2
 80058f8:	d007      	beq.n	800590a <TIM_OC5_SetConfig+0x7a>
 80058fa:	687b      	ldr	r3, [r7, #4]
 80058fc:	4a14      	ldr	r2, [pc, #80]	; (8005950 <TIM_OC5_SetConfig+0xc0>)
 80058fe:	4293      	cmp	r3, r2
 8005900:	d003      	beq.n	800590a <TIM_OC5_SetConfig+0x7a>
 8005902:	687b      	ldr	r3, [r7, #4]
 8005904:	4a13      	ldr	r2, [pc, #76]	; (8005954 <TIM_OC5_SetConfig+0xc4>)
 8005906:	4293      	cmp	r3, r2
 8005908:	d109      	bne.n	800591e <TIM_OC5_SetConfig+0x8e>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800590a:	697b      	ldr	r3, [r7, #20]
 800590c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005910:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8005912:	683b      	ldr	r3, [r7, #0]
 8005914:	695b      	ldr	r3, [r3, #20]
 8005916:	021b      	lsls	r3, r3, #8
 8005918:	697a      	ldr	r2, [r7, #20]
 800591a:	4313      	orrs	r3, r2
 800591c:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800591e:	687b      	ldr	r3, [r7, #4]
 8005920:	697a      	ldr	r2, [r7, #20]
 8005922:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8005924:	687b      	ldr	r3, [r7, #4]
 8005926:	68fa      	ldr	r2, [r7, #12]
 8005928:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800592a:	683b      	ldr	r3, [r7, #0]
 800592c:	685a      	ldr	r2, [r3, #4]
 800592e:	687b      	ldr	r3, [r7, #4]
 8005930:	659a      	str	r2, [r3, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005932:	687b      	ldr	r3, [r7, #4]
 8005934:	693a      	ldr	r2, [r7, #16]
 8005936:	621a      	str	r2, [r3, #32]
}
 8005938:	bf00      	nop
 800593a:	371c      	adds	r7, #28
 800593c:	46bd      	mov	sp, r7
 800593e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005942:	4770      	bx	lr
 8005944:	40012c00 	.word	0x40012c00
 8005948:	40013400 	.word	0x40013400
 800594c:	40014000 	.word	0x40014000
 8005950:	40014400 	.word	0x40014400
 8005954:	40014800 	.word	0x40014800

08005958 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8005958:	b480      	push	{r7}
 800595a:	b087      	sub	sp, #28
 800595c:	af00      	add	r7, sp, #0
 800595e:	6078      	str	r0, [r7, #4]
 8005960:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8005962:	687b      	ldr	r3, [r7, #4]
 8005964:	6a1b      	ldr	r3, [r3, #32]
 8005966:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800596a:	687b      	ldr	r3, [r7, #4]
 800596c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800596e:	687b      	ldr	r3, [r7, #4]
 8005970:	6a1b      	ldr	r3, [r3, #32]
 8005972:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005974:	687b      	ldr	r3, [r7, #4]
 8005976:	685b      	ldr	r3, [r3, #4]
 8005978:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800597a:	687b      	ldr	r3, [r7, #4]
 800597c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800597e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8005980:	68fb      	ldr	r3, [r7, #12]
 8005982:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8005986:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800598a:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800598c:	683b      	ldr	r3, [r7, #0]
 800598e:	681b      	ldr	r3, [r3, #0]
 8005990:	021b      	lsls	r3, r3, #8
 8005992:	68fa      	ldr	r2, [r7, #12]
 8005994:	4313      	orrs	r3, r2
 8005996:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8005998:	693b      	ldr	r3, [r7, #16]
 800599a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800599e:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80059a0:	683b      	ldr	r3, [r7, #0]
 80059a2:	689b      	ldr	r3, [r3, #8]
 80059a4:	051b      	lsls	r3, r3, #20
 80059a6:	693a      	ldr	r2, [r7, #16]
 80059a8:	4313      	orrs	r3, r2
 80059aa:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80059ac:	687b      	ldr	r3, [r7, #4]
 80059ae:	4a18      	ldr	r2, [pc, #96]	; (8005a10 <TIM_OC6_SetConfig+0xb8>)
 80059b0:	4293      	cmp	r3, r2
 80059b2:	d00f      	beq.n	80059d4 <TIM_OC6_SetConfig+0x7c>
 80059b4:	687b      	ldr	r3, [r7, #4]
 80059b6:	4a17      	ldr	r2, [pc, #92]	; (8005a14 <TIM_OC6_SetConfig+0xbc>)
 80059b8:	4293      	cmp	r3, r2
 80059ba:	d00b      	beq.n	80059d4 <TIM_OC6_SetConfig+0x7c>
 80059bc:	687b      	ldr	r3, [r7, #4]
 80059be:	4a16      	ldr	r2, [pc, #88]	; (8005a18 <TIM_OC6_SetConfig+0xc0>)
 80059c0:	4293      	cmp	r3, r2
 80059c2:	d007      	beq.n	80059d4 <TIM_OC6_SetConfig+0x7c>
 80059c4:	687b      	ldr	r3, [r7, #4]
 80059c6:	4a15      	ldr	r2, [pc, #84]	; (8005a1c <TIM_OC6_SetConfig+0xc4>)
 80059c8:	4293      	cmp	r3, r2
 80059ca:	d003      	beq.n	80059d4 <TIM_OC6_SetConfig+0x7c>
 80059cc:	687b      	ldr	r3, [r7, #4]
 80059ce:	4a14      	ldr	r2, [pc, #80]	; (8005a20 <TIM_OC6_SetConfig+0xc8>)
 80059d0:	4293      	cmp	r3, r2
 80059d2:	d109      	bne.n	80059e8 <TIM_OC6_SetConfig+0x90>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 80059d4:	697b      	ldr	r3, [r7, #20]
 80059d6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80059da:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80059dc:	683b      	ldr	r3, [r7, #0]
 80059de:	695b      	ldr	r3, [r3, #20]
 80059e0:	029b      	lsls	r3, r3, #10
 80059e2:	697a      	ldr	r2, [r7, #20]
 80059e4:	4313      	orrs	r3, r2
 80059e6:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80059e8:	687b      	ldr	r3, [r7, #4]
 80059ea:	697a      	ldr	r2, [r7, #20]
 80059ec:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 80059ee:	687b      	ldr	r3, [r7, #4]
 80059f0:	68fa      	ldr	r2, [r7, #12]
 80059f2:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 80059f4:	683b      	ldr	r3, [r7, #0]
 80059f6:	685a      	ldr	r2, [r3, #4]
 80059f8:	687b      	ldr	r3, [r7, #4]
 80059fa:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80059fc:	687b      	ldr	r3, [r7, #4]
 80059fe:	693a      	ldr	r2, [r7, #16]
 8005a00:	621a      	str	r2, [r3, #32]
}
 8005a02:	bf00      	nop
 8005a04:	371c      	adds	r7, #28
 8005a06:	46bd      	mov	sp, r7
 8005a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a0c:	4770      	bx	lr
 8005a0e:	bf00      	nop
 8005a10:	40012c00 	.word	0x40012c00
 8005a14:	40013400 	.word	0x40013400
 8005a18:	40014000 	.word	0x40014000
 8005a1c:	40014400 	.word	0x40014400
 8005a20:	40014800 	.word	0x40014800

08005a24 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8005a24:	b480      	push	{r7}
 8005a26:	b087      	sub	sp, #28
 8005a28:	af00      	add	r7, sp, #0
 8005a2a:	60f8      	str	r0, [r7, #12]
 8005a2c:	60b9      	str	r1, [r7, #8]
 8005a2e:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8005a30:	68fb      	ldr	r3, [r7, #12]
 8005a32:	6a1b      	ldr	r3, [r3, #32]
 8005a34:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005a36:	68fb      	ldr	r3, [r7, #12]
 8005a38:	6a1b      	ldr	r3, [r3, #32]
 8005a3a:	f023 0201 	bic.w	r2, r3, #1
 8005a3e:	68fb      	ldr	r3, [r7, #12]
 8005a40:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	699b      	ldr	r3, [r3, #24]
 8005a46:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8005a48:	693b      	ldr	r3, [r7, #16]
 8005a4a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8005a4e:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8005a50:	687b      	ldr	r3, [r7, #4]
 8005a52:	011b      	lsls	r3, r3, #4
 8005a54:	693a      	ldr	r2, [r7, #16]
 8005a56:	4313      	orrs	r3, r2
 8005a58:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005a5a:	697b      	ldr	r3, [r7, #20]
 8005a5c:	f023 030a 	bic.w	r3, r3, #10
 8005a60:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 8005a62:	697a      	ldr	r2, [r7, #20]
 8005a64:	68bb      	ldr	r3, [r7, #8]
 8005a66:	4313      	orrs	r3, r2
 8005a68:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8005a6a:	68fb      	ldr	r3, [r7, #12]
 8005a6c:	693a      	ldr	r2, [r7, #16]
 8005a6e:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8005a70:	68fb      	ldr	r3, [r7, #12]
 8005a72:	697a      	ldr	r2, [r7, #20]
 8005a74:	621a      	str	r2, [r3, #32]
}
 8005a76:	bf00      	nop
 8005a78:	371c      	adds	r7, #28
 8005a7a:	46bd      	mov	sp, r7
 8005a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a80:	4770      	bx	lr

08005a82 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8005a82:	b480      	push	{r7}
 8005a84:	b087      	sub	sp, #28
 8005a86:	af00      	add	r7, sp, #0
 8005a88:	60f8      	str	r0, [r7, #12]
 8005a8a:	60b9      	str	r1, [r7, #8]
 8005a8c:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8005a8e:	68fb      	ldr	r3, [r7, #12]
 8005a90:	6a1b      	ldr	r3, [r3, #32]
 8005a92:	f023 0210 	bic.w	r2, r3, #16
 8005a96:	68fb      	ldr	r3, [r7, #12]
 8005a98:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	699b      	ldr	r3, [r3, #24]
 8005a9e:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 8005aa0:	68fb      	ldr	r3, [r7, #12]
 8005aa2:	6a1b      	ldr	r3, [r3, #32]
 8005aa4:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8005aa6:	697b      	ldr	r3, [r7, #20]
 8005aa8:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 8005aac:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8005aae:	687b      	ldr	r3, [r7, #4]
 8005ab0:	031b      	lsls	r3, r3, #12
 8005ab2:	697a      	ldr	r2, [r7, #20]
 8005ab4:	4313      	orrs	r3, r2
 8005ab6:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8005ab8:	693b      	ldr	r3, [r7, #16]
 8005aba:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8005abe:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 8005ac0:	68bb      	ldr	r3, [r7, #8]
 8005ac2:	011b      	lsls	r3, r3, #4
 8005ac4:	693a      	ldr	r2, [r7, #16]
 8005ac6:	4313      	orrs	r3, r2
 8005ac8:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8005aca:	68fb      	ldr	r3, [r7, #12]
 8005acc:	697a      	ldr	r2, [r7, #20]
 8005ace:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8005ad0:	68fb      	ldr	r3, [r7, #12]
 8005ad2:	693a      	ldr	r2, [r7, #16]
 8005ad4:	621a      	str	r2, [r3, #32]
}
 8005ad6:	bf00      	nop
 8005ad8:	371c      	adds	r7, #28
 8005ada:	46bd      	mov	sp, r7
 8005adc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ae0:	4770      	bx	lr

08005ae2 <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8005ae2:	b480      	push	{r7}
 8005ae4:	b085      	sub	sp, #20
 8005ae6:	af00      	add	r7, sp, #0
 8005ae8:	6078      	str	r0, [r7, #4]
 8005aea:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005aec:	687b      	ldr	r3, [r7, #4]
 8005aee:	689b      	ldr	r3, [r3, #8]
 8005af0:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8005af2:	68fb      	ldr	r3, [r7, #12]
 8005af4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005af8:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8005afa:	683a      	ldr	r2, [r7, #0]
 8005afc:	68fb      	ldr	r3, [r7, #12]
 8005afe:	4313      	orrs	r3, r2
 8005b00:	f043 0307 	orr.w	r3, r3, #7
 8005b04:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005b06:	687b      	ldr	r3, [r7, #4]
 8005b08:	68fa      	ldr	r2, [r7, #12]
 8005b0a:	609a      	str	r2, [r3, #8]
}
 8005b0c:	bf00      	nop
 8005b0e:	3714      	adds	r7, #20
 8005b10:	46bd      	mov	sp, r7
 8005b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b16:	4770      	bx	lr

08005b18 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8005b18:	b480      	push	{r7}
 8005b1a:	b087      	sub	sp, #28
 8005b1c:	af00      	add	r7, sp, #0
 8005b1e:	60f8      	str	r0, [r7, #12]
 8005b20:	60b9      	str	r1, [r7, #8]
 8005b22:	607a      	str	r2, [r7, #4]
 8005b24:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8005b26:	68fb      	ldr	r3, [r7, #12]
 8005b28:	689b      	ldr	r3, [r3, #8]
 8005b2a:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8005b2c:	697b      	ldr	r3, [r7, #20]
 8005b2e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8005b32:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8005b34:	683b      	ldr	r3, [r7, #0]
 8005b36:	021a      	lsls	r2, r3, #8
 8005b38:	687b      	ldr	r3, [r7, #4]
 8005b3a:	431a      	orrs	r2, r3
 8005b3c:	68bb      	ldr	r3, [r7, #8]
 8005b3e:	4313      	orrs	r3, r2
 8005b40:	697a      	ldr	r2, [r7, #20]
 8005b42:	4313      	orrs	r3, r2
 8005b44:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005b46:	68fb      	ldr	r3, [r7, #12]
 8005b48:	697a      	ldr	r2, [r7, #20]
 8005b4a:	609a      	str	r2, [r3, #8]
}
 8005b4c:	bf00      	nop
 8005b4e:	371c      	adds	r7, #28
 8005b50:	46bd      	mov	sp, r7
 8005b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b56:	4770      	bx	lr

08005b58 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8005b58:	b480      	push	{r7}
 8005b5a:	b087      	sub	sp, #28
 8005b5c:	af00      	add	r7, sp, #0
 8005b5e:	60f8      	str	r0, [r7, #12]
 8005b60:	60b9      	str	r1, [r7, #8]
 8005b62:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8005b64:	68bb      	ldr	r3, [r7, #8]
 8005b66:	f003 031f 	and.w	r3, r3, #31
 8005b6a:	2201      	movs	r2, #1
 8005b6c:	fa02 f303 	lsl.w	r3, r2, r3
 8005b70:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8005b72:	68fb      	ldr	r3, [r7, #12]
 8005b74:	6a1a      	ldr	r2, [r3, #32]
 8005b76:	697b      	ldr	r3, [r7, #20]
 8005b78:	43db      	mvns	r3, r3
 8005b7a:	401a      	ands	r2, r3
 8005b7c:	68fb      	ldr	r3, [r7, #12]
 8005b7e:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8005b80:	68fb      	ldr	r3, [r7, #12]
 8005b82:	6a1a      	ldr	r2, [r3, #32]
 8005b84:	68bb      	ldr	r3, [r7, #8]
 8005b86:	f003 031f 	and.w	r3, r3, #31
 8005b8a:	6879      	ldr	r1, [r7, #4]
 8005b8c:	fa01 f303 	lsl.w	r3, r1, r3
 8005b90:	431a      	orrs	r2, r3
 8005b92:	68fb      	ldr	r3, [r7, #12]
 8005b94:	621a      	str	r2, [r3, #32]
}
 8005b96:	bf00      	nop
 8005b98:	371c      	adds	r7, #28
 8005b9a:	46bd      	mov	sp, r7
 8005b9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ba0:	4770      	bx	lr
	...

08005ba4 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 8005ba4:	b480      	push	{r7}
 8005ba6:	b085      	sub	sp, #20
 8005ba8:	af00      	add	r7, sp, #0
 8005baa:	6078      	str	r0, [r7, #4]
 8005bac:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8005bae:	687b      	ldr	r3, [r7, #4]
 8005bb0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005bb4:	2b01      	cmp	r3, #1
 8005bb6:	d101      	bne.n	8005bbc <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8005bb8:	2302      	movs	r3, #2
 8005bba:	e068      	b.n	8005c8e <HAL_TIMEx_MasterConfigSynchronization+0xea>
 8005bbc:	687b      	ldr	r3, [r7, #4]
 8005bbe:	2201      	movs	r2, #1
 8005bc0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005bc4:	687b      	ldr	r3, [r7, #4]
 8005bc6:	2202      	movs	r2, #2
 8005bc8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8005bcc:	687b      	ldr	r3, [r7, #4]
 8005bce:	681b      	ldr	r3, [r3, #0]
 8005bd0:	685b      	ldr	r3, [r3, #4]
 8005bd2:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8005bd4:	687b      	ldr	r3, [r7, #4]
 8005bd6:	681b      	ldr	r3, [r3, #0]
 8005bd8:	689b      	ldr	r3, [r3, #8]
 8005bda:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8005bdc:	687b      	ldr	r3, [r7, #4]
 8005bde:	681b      	ldr	r3, [r3, #0]
 8005be0:	4a2e      	ldr	r2, [pc, #184]	; (8005c9c <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 8005be2:	4293      	cmp	r3, r2
 8005be4:	d004      	beq.n	8005bf0 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8005be6:	687b      	ldr	r3, [r7, #4]
 8005be8:	681b      	ldr	r3, [r3, #0]
 8005bea:	4a2d      	ldr	r2, [pc, #180]	; (8005ca0 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 8005bec:	4293      	cmp	r3, r2
 8005bee:	d108      	bne.n	8005c02 <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8005bf0:	68fb      	ldr	r3, [r7, #12]
 8005bf2:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8005bf6:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8005bf8:	683b      	ldr	r3, [r7, #0]
 8005bfa:	685b      	ldr	r3, [r3, #4]
 8005bfc:	68fa      	ldr	r2, [r7, #12]
 8005bfe:	4313      	orrs	r3, r2
 8005c00:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8005c02:	68fb      	ldr	r3, [r7, #12]
 8005c04:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005c08:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8005c0a:	683b      	ldr	r3, [r7, #0]
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	68fa      	ldr	r2, [r7, #12]
 8005c10:	4313      	orrs	r3, r2
 8005c12:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8005c14:	687b      	ldr	r3, [r7, #4]
 8005c16:	681b      	ldr	r3, [r3, #0]
 8005c18:	68fa      	ldr	r2, [r7, #12]
 8005c1a:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005c1c:	687b      	ldr	r3, [r7, #4]
 8005c1e:	681b      	ldr	r3, [r3, #0]
 8005c20:	4a1e      	ldr	r2, [pc, #120]	; (8005c9c <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 8005c22:	4293      	cmp	r3, r2
 8005c24:	d01d      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c26:	687b      	ldr	r3, [r7, #4]
 8005c28:	681b      	ldr	r3, [r3, #0]
 8005c2a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005c2e:	d018      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c30:	687b      	ldr	r3, [r7, #4]
 8005c32:	681b      	ldr	r3, [r3, #0]
 8005c34:	4a1b      	ldr	r2, [pc, #108]	; (8005ca4 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 8005c36:	4293      	cmp	r3, r2
 8005c38:	d013      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c3a:	687b      	ldr	r3, [r7, #4]
 8005c3c:	681b      	ldr	r3, [r3, #0]
 8005c3e:	4a1a      	ldr	r2, [pc, #104]	; (8005ca8 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8005c40:	4293      	cmp	r3, r2
 8005c42:	d00e      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c44:	687b      	ldr	r3, [r7, #4]
 8005c46:	681b      	ldr	r3, [r3, #0]
 8005c48:	4a18      	ldr	r2, [pc, #96]	; (8005cac <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 8005c4a:	4293      	cmp	r3, r2
 8005c4c:	d009      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c4e:	687b      	ldr	r3, [r7, #4]
 8005c50:	681b      	ldr	r3, [r3, #0]
 8005c52:	4a13      	ldr	r2, [pc, #76]	; (8005ca0 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 8005c54:	4293      	cmp	r3, r2
 8005c56:	d004      	beq.n	8005c62 <HAL_TIMEx_MasterConfigSynchronization+0xbe>
 8005c58:	687b      	ldr	r3, [r7, #4]
 8005c5a:	681b      	ldr	r3, [r3, #0]
 8005c5c:	4a14      	ldr	r2, [pc, #80]	; (8005cb0 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 8005c5e:	4293      	cmp	r3, r2
 8005c60:	d10c      	bne.n	8005c7c <HAL_TIMEx_MasterConfigSynchronization+0xd8>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8005c62:	68bb      	ldr	r3, [r7, #8]
 8005c64:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005c68:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8005c6a:	683b      	ldr	r3, [r7, #0]
 8005c6c:	689b      	ldr	r3, [r3, #8]
 8005c6e:	68ba      	ldr	r2, [r7, #8]
 8005c70:	4313      	orrs	r3, r2
 8005c72:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8005c74:	687b      	ldr	r3, [r7, #4]
 8005c76:	681b      	ldr	r3, [r3, #0]
 8005c78:	68ba      	ldr	r2, [r7, #8]
 8005c7a:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8005c7c:	687b      	ldr	r3, [r7, #4]
 8005c7e:	2201      	movs	r2, #1
 8005c80:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8005c84:	687b      	ldr	r3, [r7, #4]
 8005c86:	2200      	movs	r2, #0
 8005c88:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 8005c8c:	2300      	movs	r3, #0
}
 8005c8e:	4618      	mov	r0, r3
 8005c90:	3714      	adds	r7, #20
 8005c92:	46bd      	mov	sp, r7
 8005c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c98:	4770      	bx	lr
 8005c9a:	bf00      	nop
 8005c9c:	40012c00 	.word	0x40012c00
 8005ca0:	40013400 	.word	0x40013400
 8005ca4:	40000400 	.word	0x40000400
 8005ca8:	40000800 	.word	0x40000800
 8005cac:	40000c00 	.word	0x40000c00
 8005cb0:	40014000 	.word	0x40014000

08005cb4 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8005cb4:	b480      	push	{r7}
 8005cb6:	b083      	sub	sp, #12
 8005cb8:	af00      	add	r7, sp, #0
 8005cba:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8005cbc:	bf00      	nop
 8005cbe:	370c      	adds	r7, #12
 8005cc0:	46bd      	mov	sp, r7
 8005cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cc6:	4770      	bx	lr

08005cc8 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8005cc8:	b480      	push	{r7}
 8005cca:	b083      	sub	sp, #12
 8005ccc:	af00      	add	r7, sp, #0
 8005cce:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8005cd0:	bf00      	nop
 8005cd2:	370c      	adds	r7, #12
 8005cd4:	46bd      	mov	sp, r7
 8005cd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cda:	4770      	bx	lr

08005cdc <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8005cdc:	b480      	push	{r7}
 8005cde:	b083      	sub	sp, #12
 8005ce0:	af00      	add	r7, sp, #0
 8005ce2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8005ce4:	bf00      	nop
 8005ce6:	370c      	adds	r7, #12
 8005ce8:	46bd      	mov	sp, r7
 8005cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cee:	4770      	bx	lr

08005cf0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8005cf0:	b580      	push	{r7, lr}
 8005cf2:	b082      	sub	sp, #8
 8005cf4:	af00      	add	r7, sp, #0
 8005cf6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8005cf8:	687b      	ldr	r3, [r7, #4]
 8005cfa:	2b00      	cmp	r3, #0
 8005cfc:	d101      	bne.n	8005d02 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8005cfe:	2301      	movs	r3, #1
 8005d00:	e040      	b.n	8005d84 <HAL_UART_Init+0x94>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8005d02:	687b      	ldr	r3, [r7, #4]
 8005d04:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005d06:	2b00      	cmp	r3, #0
 8005d08:	d106      	bne.n	8005d18 <HAL_UART_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8005d0a:	687b      	ldr	r3, [r7, #4]
 8005d0c:	2200      	movs	r2, #0
 8005d0e:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8005d12:	6878      	ldr	r0, [r7, #4]
 8005d14:	f7fb f8d2 	bl	8000ebc <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8005d18:	687b      	ldr	r3, [r7, #4]
 8005d1a:	2224      	movs	r2, #36	; 0x24
 8005d1c:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 8005d1e:	687b      	ldr	r3, [r7, #4]
 8005d20:	681b      	ldr	r3, [r3, #0]
 8005d22:	681a      	ldr	r2, [r3, #0]
 8005d24:	687b      	ldr	r3, [r7, #4]
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	f022 0201 	bic.w	r2, r2, #1
 8005d2c:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8005d2e:	6878      	ldr	r0, [r7, #4]
 8005d30:	f000 f95c 	bl	8005fec <UART_SetConfig>
 8005d34:	4603      	mov	r3, r0
 8005d36:	2b01      	cmp	r3, #1
 8005d38:	d101      	bne.n	8005d3e <HAL_UART_Init+0x4e>
  {
    return HAL_ERROR;
 8005d3a:	2301      	movs	r3, #1
 8005d3c:	e022      	b.n	8005d84 <HAL_UART_Init+0x94>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8005d3e:	687b      	ldr	r3, [r7, #4]
 8005d40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005d42:	2b00      	cmp	r3, #0
 8005d44:	d002      	beq.n	8005d4c <HAL_UART_Init+0x5c>
  {
    UART_AdvFeatureConfig(huart);
 8005d46:	6878      	ldr	r0, [r7, #4]
 8005d48:	f000 fc0a 	bl	8006560 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	681b      	ldr	r3, [r3, #0]
 8005d50:	685a      	ldr	r2, [r3, #4]
 8005d52:	687b      	ldr	r3, [r7, #4]
 8005d54:	681b      	ldr	r3, [r3, #0]
 8005d56:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005d5a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8005d5c:	687b      	ldr	r3, [r7, #4]
 8005d5e:	681b      	ldr	r3, [r3, #0]
 8005d60:	689a      	ldr	r2, [r3, #8]
 8005d62:	687b      	ldr	r3, [r7, #4]
 8005d64:	681b      	ldr	r3, [r3, #0]
 8005d66:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005d6a:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8005d6c:	687b      	ldr	r3, [r7, #4]
 8005d6e:	681b      	ldr	r3, [r3, #0]
 8005d70:	681a      	ldr	r2, [r3, #0]
 8005d72:	687b      	ldr	r3, [r7, #4]
 8005d74:	681b      	ldr	r3, [r3, #0]
 8005d76:	f042 0201 	orr.w	r2, r2, #1
 8005d7a:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8005d7c:	6878      	ldr	r0, [r7, #4]
 8005d7e:	f000 fc91 	bl	80066a4 <UART_CheckIdleState>
 8005d82:	4603      	mov	r3, r0
}
 8005d84:	4618      	mov	r0, r3
 8005d86:	3708      	adds	r7, #8
 8005d88:	46bd      	mov	sp, r7
 8005d8a:	bd80      	pop	{r7, pc}

08005d8c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8005d8c:	b580      	push	{r7, lr}
 8005d8e:	b08a      	sub	sp, #40	; 0x28
 8005d90:	af02      	add	r7, sp, #8
 8005d92:	60f8      	str	r0, [r7, #12]
 8005d94:	60b9      	str	r1, [r7, #8]
 8005d96:	603b      	str	r3, [r7, #0]
 8005d98:	4613      	mov	r3, r2
 8005d9a:	80fb      	strh	r3, [r7, #6]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005da0:	2b20      	cmp	r3, #32
 8005da2:	f040 8082 	bne.w	8005eaa <HAL_UART_Transmit+0x11e>
  {
    if ((pData == NULL) || (Size == 0U))
 8005da6:	68bb      	ldr	r3, [r7, #8]
 8005da8:	2b00      	cmp	r3, #0
 8005daa:	d002      	beq.n	8005db2 <HAL_UART_Transmit+0x26>
 8005dac:	88fb      	ldrh	r3, [r7, #6]
 8005dae:	2b00      	cmp	r3, #0
 8005db0:	d101      	bne.n	8005db6 <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
 8005db2:	2301      	movs	r3, #1
 8005db4:	e07a      	b.n	8005eac <HAL_UART_Transmit+0x120>
    }

    __HAL_LOCK(huart);
 8005db6:	68fb      	ldr	r3, [r7, #12]
 8005db8:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8005dbc:	2b01      	cmp	r3, #1
 8005dbe:	d101      	bne.n	8005dc4 <HAL_UART_Transmit+0x38>
 8005dc0:	2302      	movs	r3, #2
 8005dc2:	e073      	b.n	8005eac <HAL_UART_Transmit+0x120>
 8005dc4:	68fb      	ldr	r3, [r7, #12]
 8005dc6:	2201      	movs	r2, #1
 8005dc8:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005dcc:	68fb      	ldr	r3, [r7, #12]
 8005dce:	2200      	movs	r2, #0
 8005dd0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005dd4:	68fb      	ldr	r3, [r7, #12]
 8005dd6:	2221      	movs	r2, #33	; 0x21
 8005dd8:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8005dda:	f7fb fb59 	bl	8001490 <HAL_GetTick>
 8005dde:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 8005de0:	68fb      	ldr	r3, [r7, #12]
 8005de2:	88fa      	ldrh	r2, [r7, #6]
 8005de4:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    huart->TxXferCount = Size;
 8005de8:	68fb      	ldr	r3, [r7, #12]
 8005dea:	88fa      	ldrh	r2, [r7, #6]
 8005dec:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8005df0:	68fb      	ldr	r3, [r7, #12]
 8005df2:	689b      	ldr	r3, [r3, #8]
 8005df4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005df8:	d108      	bne.n	8005e0c <HAL_UART_Transmit+0x80>
 8005dfa:	68fb      	ldr	r3, [r7, #12]
 8005dfc:	691b      	ldr	r3, [r3, #16]
 8005dfe:	2b00      	cmp	r3, #0
 8005e00:	d104      	bne.n	8005e0c <HAL_UART_Transmit+0x80>
    {
      pdata8bits  = NULL;
 8005e02:	2300      	movs	r3, #0
 8005e04:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 8005e06:	68bb      	ldr	r3, [r7, #8]
 8005e08:	61bb      	str	r3, [r7, #24]
 8005e0a:	e003      	b.n	8005e14 <HAL_UART_Transmit+0x88>
    }
    else
    {
      pdata8bits  = pData;
 8005e0c:	68bb      	ldr	r3, [r7, #8]
 8005e0e:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8005e10:	2300      	movs	r3, #0
 8005e12:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 8005e14:	68fb      	ldr	r3, [r7, #12]
 8005e16:	2200      	movs	r2, #0
 8005e18:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    while (huart->TxXferCount > 0U)
 8005e1c:	e02d      	b.n	8005e7a <HAL_UART_Transmit+0xee>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8005e1e:	683b      	ldr	r3, [r7, #0]
 8005e20:	9300      	str	r3, [sp, #0]
 8005e22:	697b      	ldr	r3, [r7, #20]
 8005e24:	2200      	movs	r2, #0
 8005e26:	2180      	movs	r1, #128	; 0x80
 8005e28:	68f8      	ldr	r0, [r7, #12]
 8005e2a:	f000 fc84 	bl	8006736 <UART_WaitOnFlagUntilTimeout>
 8005e2e:	4603      	mov	r3, r0
 8005e30:	2b00      	cmp	r3, #0
 8005e32:	d001      	beq.n	8005e38 <HAL_UART_Transmit+0xac>
      {
        return HAL_TIMEOUT;
 8005e34:	2303      	movs	r3, #3
 8005e36:	e039      	b.n	8005eac <HAL_UART_Transmit+0x120>
      }
      if (pdata8bits == NULL)
 8005e38:	69fb      	ldr	r3, [r7, #28]
 8005e3a:	2b00      	cmp	r3, #0
 8005e3c:	d10b      	bne.n	8005e56 <HAL_UART_Transmit+0xca>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8005e3e:	69bb      	ldr	r3, [r7, #24]
 8005e40:	881a      	ldrh	r2, [r3, #0]
 8005e42:	68fb      	ldr	r3, [r7, #12]
 8005e44:	681b      	ldr	r3, [r3, #0]
 8005e46:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8005e4a:	b292      	uxth	r2, r2
 8005e4c:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8005e4e:	69bb      	ldr	r3, [r7, #24]
 8005e50:	3302      	adds	r3, #2
 8005e52:	61bb      	str	r3, [r7, #24]
 8005e54:	e008      	b.n	8005e68 <HAL_UART_Transmit+0xdc>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8005e56:	69fb      	ldr	r3, [r7, #28]
 8005e58:	781a      	ldrb	r2, [r3, #0]
 8005e5a:	68fb      	ldr	r3, [r7, #12]
 8005e5c:	681b      	ldr	r3, [r3, #0]
 8005e5e:	b292      	uxth	r2, r2
 8005e60:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8005e62:	69fb      	ldr	r3, [r7, #28]
 8005e64:	3301      	adds	r3, #1
 8005e66:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8005e68:	68fb      	ldr	r3, [r7, #12]
 8005e6a:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8005e6e:	b29b      	uxth	r3, r3
 8005e70:	3b01      	subs	r3, #1
 8005e72:	b29a      	uxth	r2, r3
 8005e74:	68fb      	ldr	r3, [r7, #12]
 8005e76:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 8005e7a:	68fb      	ldr	r3, [r7, #12]
 8005e7c:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8005e80:	b29b      	uxth	r3, r3
 8005e82:	2b00      	cmp	r3, #0
 8005e84:	d1cb      	bne.n	8005e1e <HAL_UART_Transmit+0x92>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8005e86:	683b      	ldr	r3, [r7, #0]
 8005e88:	9300      	str	r3, [sp, #0]
 8005e8a:	697b      	ldr	r3, [r7, #20]
 8005e8c:	2200      	movs	r2, #0
 8005e8e:	2140      	movs	r1, #64	; 0x40
 8005e90:	68f8      	ldr	r0, [r7, #12]
 8005e92:	f000 fc50 	bl	8006736 <UART_WaitOnFlagUntilTimeout>
 8005e96:	4603      	mov	r3, r0
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d001      	beq.n	8005ea0 <HAL_UART_Transmit+0x114>
    {
      return HAL_TIMEOUT;
 8005e9c:	2303      	movs	r3, #3
 8005e9e:	e005      	b.n	8005eac <HAL_UART_Transmit+0x120>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8005ea0:	68fb      	ldr	r3, [r7, #12]
 8005ea2:	2220      	movs	r2, #32
 8005ea4:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 8005ea6:	2300      	movs	r3, #0
 8005ea8:	e000      	b.n	8005eac <HAL_UART_Transmit+0x120>
  }
  else
  {
    return HAL_BUSY;
 8005eaa:	2302      	movs	r3, #2
  }
}
 8005eac:	4618      	mov	r0, r3
 8005eae:	3720      	adds	r7, #32
 8005eb0:	46bd      	mov	sp, r7
 8005eb2:	bd80      	pop	{r7, pc}

08005eb4 <HAL_UART_Transmit_DMA>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8005eb4:	b580      	push	{r7, lr}
 8005eb6:	b084      	sub	sp, #16
 8005eb8:	af00      	add	r7, sp, #0
 8005eba:	60f8      	str	r0, [r7, #12]
 8005ebc:	60b9      	str	r1, [r7, #8]
 8005ebe:	4613      	mov	r3, r2
 8005ec0:	80fb      	strh	r3, [r7, #6]
  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8005ec2:	68fb      	ldr	r3, [r7, #12]
 8005ec4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005ec6:	2b20      	cmp	r3, #32
 8005ec8:	d166      	bne.n	8005f98 <HAL_UART_Transmit_DMA+0xe4>
  {
    if ((pData == NULL) || (Size == 0U))
 8005eca:	68bb      	ldr	r3, [r7, #8]
 8005ecc:	2b00      	cmp	r3, #0
 8005ece:	d002      	beq.n	8005ed6 <HAL_UART_Transmit_DMA+0x22>
 8005ed0:	88fb      	ldrh	r3, [r7, #6]
 8005ed2:	2b00      	cmp	r3, #0
 8005ed4:	d101      	bne.n	8005eda <HAL_UART_Transmit_DMA+0x26>
    {
      return HAL_ERROR;
 8005ed6:	2301      	movs	r3, #1
 8005ed8:	e05f      	b.n	8005f9a <HAL_UART_Transmit_DMA+0xe6>
    }

    __HAL_LOCK(huart);
 8005eda:	68fb      	ldr	r3, [r7, #12]
 8005edc:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8005ee0:	2b01      	cmp	r3, #1
 8005ee2:	d101      	bne.n	8005ee8 <HAL_UART_Transmit_DMA+0x34>
 8005ee4:	2302      	movs	r3, #2
 8005ee6:	e058      	b.n	8005f9a <HAL_UART_Transmit_DMA+0xe6>
 8005ee8:	68fb      	ldr	r3, [r7, #12]
 8005eea:	2201      	movs	r2, #1
 8005eec:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    huart->pTxBuffPtr  = pData;
 8005ef0:	68fb      	ldr	r3, [r7, #12]
 8005ef2:	68ba      	ldr	r2, [r7, #8]
 8005ef4:	64da      	str	r2, [r3, #76]	; 0x4c
    huart->TxXferSize  = Size;
 8005ef6:	68fb      	ldr	r3, [r7, #12]
 8005ef8:	88fa      	ldrh	r2, [r7, #6]
 8005efa:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    huart->TxXferCount = Size;
 8005efe:	68fb      	ldr	r3, [r7, #12]
 8005f00:	88fa      	ldrh	r2, [r7, #6]
 8005f02:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005f06:	68fb      	ldr	r3, [r7, #12]
 8005f08:	2200      	movs	r2, #0
 8005f0a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005f0e:	68fb      	ldr	r3, [r7, #12]
 8005f10:	2221      	movs	r2, #33	; 0x21
 8005f12:	679a      	str	r2, [r3, #120]	; 0x78

    if (huart->hdmatx != NULL)
 8005f14:	68fb      	ldr	r3, [r7, #12]
 8005f16:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005f18:	2b00      	cmp	r3, #0
 8005f1a:	d02b      	beq.n	8005f74 <HAL_UART_Transmit_DMA+0xc0>
    {
      /* Set the UART DMA transfer complete callback */
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005f1c:	68fb      	ldr	r3, [r7, #12]
 8005f1e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005f20:	4a20      	ldr	r2, [pc, #128]	; (8005fa4 <HAL_UART_Transmit_DMA+0xf0>)
 8005f22:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Set the UART DMA Half transfer complete callback */
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8005f24:	68fb      	ldr	r3, [r7, #12]
 8005f26:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005f28:	4a1f      	ldr	r2, [pc, #124]	; (8005fa8 <HAL_UART_Transmit_DMA+0xf4>)
 8005f2a:	631a      	str	r2, [r3, #48]	; 0x30

      /* Set the DMA error callback */
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 8005f2c:	68fb      	ldr	r3, [r7, #12]
 8005f2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005f30:	4a1e      	ldr	r2, [pc, #120]	; (8005fac <HAL_UART_Transmit_DMA+0xf8>)
 8005f32:	635a      	str	r2, [r3, #52]	; 0x34

      /* Set the DMA abort callback */
      huart->hdmatx->XferAbortCallback = NULL;
 8005f34:	68fb      	ldr	r3, [r7, #12]
 8005f36:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005f38:	2200      	movs	r2, #0
 8005f3a:	639a      	str	r2, [r3, #56]	; 0x38

      /* Enable the UART transmit DMA channel */
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8005f3c:	68fb      	ldr	r3, [r7, #12]
 8005f3e:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8005f40:	68fb      	ldr	r3, [r7, #12]
 8005f42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005f44:	4619      	mov	r1, r3
 8005f46:	68fb      	ldr	r3, [r7, #12]
 8005f48:	681b      	ldr	r3, [r3, #0]
 8005f4a:	3328      	adds	r3, #40	; 0x28
 8005f4c:	461a      	mov	r2, r3
 8005f4e:	88fb      	ldrh	r3, [r7, #6]
 8005f50:	f7fb fc11 	bl	8001776 <HAL_DMA_Start_IT>
 8005f54:	4603      	mov	r3, r0
 8005f56:	2b00      	cmp	r3, #0
 8005f58:	d00c      	beq.n	8005f74 <HAL_UART_Transmit_DMA+0xc0>
      {
        /* Set error code to DMA */
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 8005f5a:	68fb      	ldr	r3, [r7, #12]
 8005f5c:	2210      	movs	r2, #16
 8005f5e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

        __HAL_UNLOCK(huart);
 8005f62:	68fb      	ldr	r3, [r7, #12]
 8005f64:	2200      	movs	r2, #0
 8005f66:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

        /* Restore huart->gState to ready */
        huart->gState = HAL_UART_STATE_READY;
 8005f6a:	68fb      	ldr	r3, [r7, #12]
 8005f6c:	2220      	movs	r2, #32
 8005f6e:	679a      	str	r2, [r3, #120]	; 0x78

        return HAL_ERROR;
 8005f70:	2301      	movs	r3, #1
 8005f72:	e012      	b.n	8005f9a <HAL_UART_Transmit_DMA+0xe6>
      }
    }
    /* Clear the TC flag in the ICR register */
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 8005f74:	68fb      	ldr	r3, [r7, #12]
 8005f76:	681b      	ldr	r3, [r3, #0]
 8005f78:	2240      	movs	r2, #64	; 0x40
 8005f7a:	621a      	str	r2, [r3, #32]

    __HAL_UNLOCK(huart);
 8005f7c:	68fb      	ldr	r3, [r7, #12]
 8005f7e:	2200      	movs	r2, #0
 8005f80:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
    in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005f84:	68fb      	ldr	r3, [r7, #12]
 8005f86:	681b      	ldr	r3, [r3, #0]
 8005f88:	689a      	ldr	r2, [r3, #8]
 8005f8a:	68fb      	ldr	r3, [r7, #12]
 8005f8c:	681b      	ldr	r3, [r3, #0]
 8005f8e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005f92:	609a      	str	r2, [r3, #8]

    return HAL_OK;
 8005f94:	2300      	movs	r3, #0
 8005f96:	e000      	b.n	8005f9a <HAL_UART_Transmit_DMA+0xe6>
  }
  else
  {
    return HAL_BUSY;
 8005f98:	2302      	movs	r3, #2
  }
}
 8005f9a:	4618      	mov	r0, r3
 8005f9c:	3710      	adds	r7, #16
 8005f9e:	46bd      	mov	sp, r7
 8005fa0:	bd80      	pop	{r7, pc}
 8005fa2:	bf00      	nop
 8005fa4:	080068b7 	.word	0x080068b7
 8005fa8:	0800690b 	.word	0x0800690b
 8005fac:	08006927 	.word	0x08006927

08005fb0 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8005fb0:	b480      	push	{r7}
 8005fb2:	b083      	sub	sp, #12
 8005fb4:	af00      	add	r7, sp, #0
 8005fb6:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 8005fb8:	bf00      	nop
 8005fba:	370c      	adds	r7, #12
 8005fbc:	46bd      	mov	sp, r7
 8005fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fc2:	4770      	bx	lr

08005fc4 <HAL_UART_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8005fc4:	b480      	push	{r7}
 8005fc6:	b083      	sub	sp, #12
 8005fc8:	af00      	add	r7, sp, #0
 8005fca:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
   */
}
 8005fcc:	bf00      	nop
 8005fce:	370c      	adds	r7, #12
 8005fd0:	46bd      	mov	sp, r7
 8005fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fd6:	4770      	bx	lr

08005fd8 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8005fd8:	b480      	push	{r7}
 8005fda:	b083      	sub	sp, #12
 8005fdc:	af00      	add	r7, sp, #0
 8005fde:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8005fe0:	bf00      	nop
 8005fe2:	370c      	adds	r7, #12
 8005fe4:	46bd      	mov	sp, r7
 8005fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fea:	4770      	bx	lr

08005fec <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8005fec:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005ff0:	b08a      	sub	sp, #40	; 0x28
 8005ff2:	af00      	add	r7, sp, #0
 8005ff4:	60f8      	str	r0, [r7, #12]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8005ff6:	2300      	movs	r3, #0
 8005ff8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005ffc:	68fb      	ldr	r3, [r7, #12]
 8005ffe:	689a      	ldr	r2, [r3, #8]
 8006000:	68fb      	ldr	r3, [r7, #12]
 8006002:	691b      	ldr	r3, [r3, #16]
 8006004:	431a      	orrs	r2, r3
 8006006:	68fb      	ldr	r3, [r7, #12]
 8006008:	695b      	ldr	r3, [r3, #20]
 800600a:	431a      	orrs	r2, r3
 800600c:	68fb      	ldr	r3, [r7, #12]
 800600e:	69db      	ldr	r3, [r3, #28]
 8006010:	4313      	orrs	r3, r2
 8006012:	627b      	str	r3, [r7, #36]	; 0x24
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006014:	68fb      	ldr	r3, [r7, #12]
 8006016:	681b      	ldr	r3, [r3, #0]
 8006018:	681a      	ldr	r2, [r3, #0]
 800601a:	4ba4      	ldr	r3, [pc, #656]	; (80062ac <UART_SetConfig+0x2c0>)
 800601c:	4013      	ands	r3, r2
 800601e:	68fa      	ldr	r2, [r7, #12]
 8006020:	6812      	ldr	r2, [r2, #0]
 8006022:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8006024:	430b      	orrs	r3, r1
 8006026:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006028:	68fb      	ldr	r3, [r7, #12]
 800602a:	681b      	ldr	r3, [r3, #0]
 800602c:	685b      	ldr	r3, [r3, #4]
 800602e:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8006032:	68fb      	ldr	r3, [r7, #12]
 8006034:	68da      	ldr	r2, [r3, #12]
 8006036:	68fb      	ldr	r3, [r7, #12]
 8006038:	681b      	ldr	r3, [r3, #0]
 800603a:	430a      	orrs	r2, r1
 800603c:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800603e:	68fb      	ldr	r3, [r7, #12]
 8006040:	699b      	ldr	r3, [r3, #24]
 8006042:	627b      	str	r3, [r7, #36]	; 0x24

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8006044:	68fb      	ldr	r3, [r7, #12]
 8006046:	681b      	ldr	r3, [r3, #0]
 8006048:	4a99      	ldr	r2, [pc, #612]	; (80062b0 <UART_SetConfig+0x2c4>)
 800604a:	4293      	cmp	r3, r2
 800604c:	d004      	beq.n	8006058 <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 800604e:	68fb      	ldr	r3, [r7, #12]
 8006050:	6a1b      	ldr	r3, [r3, #32]
 8006052:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006054:	4313      	orrs	r3, r2
 8006056:	627b      	str	r3, [r7, #36]	; 0x24
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006058:	68fb      	ldr	r3, [r7, #12]
 800605a:	681b      	ldr	r3, [r3, #0]
 800605c:	689b      	ldr	r3, [r3, #8]
 800605e:	f423 6130 	bic.w	r1, r3, #2816	; 0xb00
 8006062:	68fb      	ldr	r3, [r7, #12]
 8006064:	681b      	ldr	r3, [r3, #0]
 8006066:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006068:	430a      	orrs	r2, r1
 800606a:	609a      	str	r2, [r3, #8]
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800606c:	68fb      	ldr	r3, [r7, #12]
 800606e:	681b      	ldr	r3, [r3, #0]
 8006070:	4a90      	ldr	r2, [pc, #576]	; (80062b4 <UART_SetConfig+0x2c8>)
 8006072:	4293      	cmp	r3, r2
 8006074:	d126      	bne.n	80060c4 <UART_SetConfig+0xd8>
 8006076:	4b90      	ldr	r3, [pc, #576]	; (80062b8 <UART_SetConfig+0x2cc>)
 8006078:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800607c:	f003 0303 	and.w	r3, r3, #3
 8006080:	2b03      	cmp	r3, #3
 8006082:	d81b      	bhi.n	80060bc <UART_SetConfig+0xd0>
 8006084:	a201      	add	r2, pc, #4	; (adr r2, 800608c <UART_SetConfig+0xa0>)
 8006086:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800608a:	bf00      	nop
 800608c:	0800609d 	.word	0x0800609d
 8006090:	080060ad 	.word	0x080060ad
 8006094:	080060a5 	.word	0x080060a5
 8006098:	080060b5 	.word	0x080060b5
 800609c:	2301      	movs	r3, #1
 800609e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80060a2:	e116      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80060a4:	2302      	movs	r3, #2
 80060a6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80060aa:	e112      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80060ac:	2304      	movs	r3, #4
 80060ae:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80060b2:	e10e      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80060b4:	2308      	movs	r3, #8
 80060b6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80060ba:	e10a      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80060bc:	2310      	movs	r3, #16
 80060be:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80060c2:	e106      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80060c4:	68fb      	ldr	r3, [r7, #12]
 80060c6:	681b      	ldr	r3, [r3, #0]
 80060c8:	4a7c      	ldr	r2, [pc, #496]	; (80062bc <UART_SetConfig+0x2d0>)
 80060ca:	4293      	cmp	r3, r2
 80060cc:	d138      	bne.n	8006140 <UART_SetConfig+0x154>
 80060ce:	4b7a      	ldr	r3, [pc, #488]	; (80062b8 <UART_SetConfig+0x2cc>)
 80060d0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80060d4:	f003 030c 	and.w	r3, r3, #12
 80060d8:	2b0c      	cmp	r3, #12
 80060da:	d82d      	bhi.n	8006138 <UART_SetConfig+0x14c>
 80060dc:	a201      	add	r2, pc, #4	; (adr r2, 80060e4 <UART_SetConfig+0xf8>)
 80060de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80060e2:	bf00      	nop
 80060e4:	08006119 	.word	0x08006119
 80060e8:	08006139 	.word	0x08006139
 80060ec:	08006139 	.word	0x08006139
 80060f0:	08006139 	.word	0x08006139
 80060f4:	08006129 	.word	0x08006129
 80060f8:	08006139 	.word	0x08006139
 80060fc:	08006139 	.word	0x08006139
 8006100:	08006139 	.word	0x08006139
 8006104:	08006121 	.word	0x08006121
 8006108:	08006139 	.word	0x08006139
 800610c:	08006139 	.word	0x08006139
 8006110:	08006139 	.word	0x08006139
 8006114:	08006131 	.word	0x08006131
 8006118:	2300      	movs	r3, #0
 800611a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800611e:	e0d8      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006120:	2302      	movs	r3, #2
 8006122:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006126:	e0d4      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006128:	2304      	movs	r3, #4
 800612a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800612e:	e0d0      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006130:	2308      	movs	r3, #8
 8006132:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006136:	e0cc      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006138:	2310      	movs	r3, #16
 800613a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800613e:	e0c8      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006140:	68fb      	ldr	r3, [r7, #12]
 8006142:	681b      	ldr	r3, [r3, #0]
 8006144:	4a5e      	ldr	r2, [pc, #376]	; (80062c0 <UART_SetConfig+0x2d4>)
 8006146:	4293      	cmp	r3, r2
 8006148:	d125      	bne.n	8006196 <UART_SetConfig+0x1aa>
 800614a:	4b5b      	ldr	r3, [pc, #364]	; (80062b8 <UART_SetConfig+0x2cc>)
 800614c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8006150:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8006154:	2b30      	cmp	r3, #48	; 0x30
 8006156:	d016      	beq.n	8006186 <UART_SetConfig+0x19a>
 8006158:	2b30      	cmp	r3, #48	; 0x30
 800615a:	d818      	bhi.n	800618e <UART_SetConfig+0x1a2>
 800615c:	2b20      	cmp	r3, #32
 800615e:	d00a      	beq.n	8006176 <UART_SetConfig+0x18a>
 8006160:	2b20      	cmp	r3, #32
 8006162:	d814      	bhi.n	800618e <UART_SetConfig+0x1a2>
 8006164:	2b00      	cmp	r3, #0
 8006166:	d002      	beq.n	800616e <UART_SetConfig+0x182>
 8006168:	2b10      	cmp	r3, #16
 800616a:	d008      	beq.n	800617e <UART_SetConfig+0x192>
 800616c:	e00f      	b.n	800618e <UART_SetConfig+0x1a2>
 800616e:	2300      	movs	r3, #0
 8006170:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006174:	e0ad      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006176:	2302      	movs	r3, #2
 8006178:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800617c:	e0a9      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800617e:	2304      	movs	r3, #4
 8006180:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006184:	e0a5      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006186:	2308      	movs	r3, #8
 8006188:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800618c:	e0a1      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800618e:	2310      	movs	r3, #16
 8006190:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006194:	e09d      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006196:	68fb      	ldr	r3, [r7, #12]
 8006198:	681b      	ldr	r3, [r3, #0]
 800619a:	4a4a      	ldr	r2, [pc, #296]	; (80062c4 <UART_SetConfig+0x2d8>)
 800619c:	4293      	cmp	r3, r2
 800619e:	d125      	bne.n	80061ec <UART_SetConfig+0x200>
 80061a0:	4b45      	ldr	r3, [pc, #276]	; (80062b8 <UART_SetConfig+0x2cc>)
 80061a2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80061a6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80061aa:	2bc0      	cmp	r3, #192	; 0xc0
 80061ac:	d016      	beq.n	80061dc <UART_SetConfig+0x1f0>
 80061ae:	2bc0      	cmp	r3, #192	; 0xc0
 80061b0:	d818      	bhi.n	80061e4 <UART_SetConfig+0x1f8>
 80061b2:	2b80      	cmp	r3, #128	; 0x80
 80061b4:	d00a      	beq.n	80061cc <UART_SetConfig+0x1e0>
 80061b6:	2b80      	cmp	r3, #128	; 0x80
 80061b8:	d814      	bhi.n	80061e4 <UART_SetConfig+0x1f8>
 80061ba:	2b00      	cmp	r3, #0
 80061bc:	d002      	beq.n	80061c4 <UART_SetConfig+0x1d8>
 80061be:	2b40      	cmp	r3, #64	; 0x40
 80061c0:	d008      	beq.n	80061d4 <UART_SetConfig+0x1e8>
 80061c2:	e00f      	b.n	80061e4 <UART_SetConfig+0x1f8>
 80061c4:	2300      	movs	r3, #0
 80061c6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80061ca:	e082      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80061cc:	2302      	movs	r3, #2
 80061ce:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80061d2:	e07e      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80061d4:	2304      	movs	r3, #4
 80061d6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80061da:	e07a      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80061dc:	2308      	movs	r3, #8
 80061de:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80061e2:	e076      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80061e4:	2310      	movs	r3, #16
 80061e6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80061ea:	e072      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80061ec:	68fb      	ldr	r3, [r7, #12]
 80061ee:	681b      	ldr	r3, [r3, #0]
 80061f0:	4a35      	ldr	r2, [pc, #212]	; (80062c8 <UART_SetConfig+0x2dc>)
 80061f2:	4293      	cmp	r3, r2
 80061f4:	d12a      	bne.n	800624c <UART_SetConfig+0x260>
 80061f6:	4b30      	ldr	r3, [pc, #192]	; (80062b8 <UART_SetConfig+0x2cc>)
 80061f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80061fc:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006200:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006204:	d01a      	beq.n	800623c <UART_SetConfig+0x250>
 8006206:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800620a:	d81b      	bhi.n	8006244 <UART_SetConfig+0x258>
 800620c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006210:	d00c      	beq.n	800622c <UART_SetConfig+0x240>
 8006212:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006216:	d815      	bhi.n	8006244 <UART_SetConfig+0x258>
 8006218:	2b00      	cmp	r3, #0
 800621a:	d003      	beq.n	8006224 <UART_SetConfig+0x238>
 800621c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006220:	d008      	beq.n	8006234 <UART_SetConfig+0x248>
 8006222:	e00f      	b.n	8006244 <UART_SetConfig+0x258>
 8006224:	2300      	movs	r3, #0
 8006226:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800622a:	e052      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800622c:	2302      	movs	r3, #2
 800622e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006232:	e04e      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006234:	2304      	movs	r3, #4
 8006236:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800623a:	e04a      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800623c:	2308      	movs	r3, #8
 800623e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006242:	e046      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006244:	2310      	movs	r3, #16
 8006246:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800624a:	e042      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800624c:	68fb      	ldr	r3, [r7, #12]
 800624e:	681b      	ldr	r3, [r3, #0]
 8006250:	4a17      	ldr	r2, [pc, #92]	; (80062b0 <UART_SetConfig+0x2c4>)
 8006252:	4293      	cmp	r3, r2
 8006254:	d13a      	bne.n	80062cc <UART_SetConfig+0x2e0>
 8006256:	4b18      	ldr	r3, [pc, #96]	; (80062b8 <UART_SetConfig+0x2cc>)
 8006258:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800625c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8006260:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8006264:	d01a      	beq.n	800629c <UART_SetConfig+0x2b0>
 8006266:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800626a:	d81b      	bhi.n	80062a4 <UART_SetConfig+0x2b8>
 800626c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006270:	d00c      	beq.n	800628c <UART_SetConfig+0x2a0>
 8006272:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006276:	d815      	bhi.n	80062a4 <UART_SetConfig+0x2b8>
 8006278:	2b00      	cmp	r3, #0
 800627a:	d003      	beq.n	8006284 <UART_SetConfig+0x298>
 800627c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006280:	d008      	beq.n	8006294 <UART_SetConfig+0x2a8>
 8006282:	e00f      	b.n	80062a4 <UART_SetConfig+0x2b8>
 8006284:	2300      	movs	r3, #0
 8006286:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800628a:	e022      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800628c:	2302      	movs	r3, #2
 800628e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8006292:	e01e      	b.n	80062d2 <UART_SetConfig+0x2e6>
 8006294:	2304      	movs	r3, #4
 8006296:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800629a:	e01a      	b.n	80062d2 <UART_SetConfig+0x2e6>
 800629c:	2308      	movs	r3, #8
 800629e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80062a2:	e016      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80062a4:	2310      	movs	r3, #16
 80062a6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80062aa:	e012      	b.n	80062d2 <UART_SetConfig+0x2e6>
 80062ac:	efff69f3 	.word	0xefff69f3
 80062b0:	40008000 	.word	0x40008000
 80062b4:	40013800 	.word	0x40013800
 80062b8:	40021000 	.word	0x40021000
 80062bc:	40004400 	.word	0x40004400
 80062c0:	40004800 	.word	0x40004800
 80062c4:	40004c00 	.word	0x40004c00
 80062c8:	40005000 	.word	0x40005000
 80062cc:	2310      	movs	r3, #16
 80062ce:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 80062d2:	68fb      	ldr	r3, [r7, #12]
 80062d4:	681b      	ldr	r3, [r3, #0]
 80062d6:	4aa0      	ldr	r2, [pc, #640]	; (8006558 <UART_SetConfig+0x56c>)
 80062d8:	4293      	cmp	r3, r2
 80062da:	d17a      	bne.n	80063d2 <UART_SetConfig+0x3e6>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 80062dc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80062e0:	2b08      	cmp	r3, #8
 80062e2:	d824      	bhi.n	800632e <UART_SetConfig+0x342>
 80062e4:	a201      	add	r2, pc, #4	; (adr r2, 80062ec <UART_SetConfig+0x300>)
 80062e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80062ea:	bf00      	nop
 80062ec:	08006311 	.word	0x08006311
 80062f0:	0800632f 	.word	0x0800632f
 80062f4:	08006319 	.word	0x08006319
 80062f8:	0800632f 	.word	0x0800632f
 80062fc:	0800631f 	.word	0x0800631f
 8006300:	0800632f 	.word	0x0800632f
 8006304:	0800632f 	.word	0x0800632f
 8006308:	0800632f 	.word	0x0800632f
 800630c:	08006327 	.word	0x08006327
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8006310:	f7fc ff7c 	bl	800320c <HAL_RCC_GetPCLK1Freq>
 8006314:	61f8      	str	r0, [r7, #28]
        break;
 8006316:	e010      	b.n	800633a <UART_SetConfig+0x34e>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8006318:	4b90      	ldr	r3, [pc, #576]	; (800655c <UART_SetConfig+0x570>)
 800631a:	61fb      	str	r3, [r7, #28]
        break;
 800631c:	e00d      	b.n	800633a <UART_SetConfig+0x34e>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800631e:	f7fc fedd 	bl	80030dc <HAL_RCC_GetSysClockFreq>
 8006322:	61f8      	str	r0, [r7, #28]
        break;
 8006324:	e009      	b.n	800633a <UART_SetConfig+0x34e>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8006326:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800632a:	61fb      	str	r3, [r7, #28]
        break;
 800632c:	e005      	b.n	800633a <UART_SetConfig+0x34e>
      default:
        pclk = 0U;
 800632e:	2300      	movs	r3, #0
 8006330:	61fb      	str	r3, [r7, #28]
        ret = HAL_ERROR;
 8006332:	2301      	movs	r3, #1
 8006334:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        break;
 8006338:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800633a:	69fb      	ldr	r3, [r7, #28]
 800633c:	2b00      	cmp	r3, #0
 800633e:	f000 80fd 	beq.w	800653c <UART_SetConfig+0x550>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
#else
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8006342:	68fb      	ldr	r3, [r7, #12]
 8006344:	685a      	ldr	r2, [r3, #4]
 8006346:	4613      	mov	r3, r2
 8006348:	005b      	lsls	r3, r3, #1
 800634a:	4413      	add	r3, r2
 800634c:	69fa      	ldr	r2, [r7, #28]
 800634e:	429a      	cmp	r2, r3
 8006350:	d305      	bcc.n	800635e <UART_SetConfig+0x372>
          (pclk > (4096U * huart->Init.BaudRate)))
 8006352:	68fb      	ldr	r3, [r7, #12]
 8006354:	685b      	ldr	r3, [r3, #4]
 8006356:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8006358:	69fa      	ldr	r2, [r7, #28]
 800635a:	429a      	cmp	r2, r3
 800635c:	d903      	bls.n	8006366 <UART_SetConfig+0x37a>
      {
        ret = HAL_ERROR;
 800635e:	2301      	movs	r3, #1
 8006360:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 8006364:	e0ea      	b.n	800653c <UART_SetConfig+0x550>
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 8006366:	69fb      	ldr	r3, [r7, #28]
 8006368:	2200      	movs	r2, #0
 800636a:	461c      	mov	r4, r3
 800636c:	4615      	mov	r5, r2
 800636e:	f04f 0200 	mov.w	r2, #0
 8006372:	f04f 0300 	mov.w	r3, #0
 8006376:	022b      	lsls	r3, r5, #8
 8006378:	ea43 6314 	orr.w	r3, r3, r4, lsr #24
 800637c:	0222      	lsls	r2, r4, #8
 800637e:	68f9      	ldr	r1, [r7, #12]
 8006380:	6849      	ldr	r1, [r1, #4]
 8006382:	0849      	lsrs	r1, r1, #1
 8006384:	2000      	movs	r0, #0
 8006386:	4688      	mov	r8, r1
 8006388:	4681      	mov	r9, r0
 800638a:	eb12 0a08 	adds.w	sl, r2, r8
 800638e:	eb43 0b09 	adc.w	fp, r3, r9
 8006392:	68fb      	ldr	r3, [r7, #12]
 8006394:	685b      	ldr	r3, [r3, #4]
 8006396:	2200      	movs	r2, #0
 8006398:	603b      	str	r3, [r7, #0]
 800639a:	607a      	str	r2, [r7, #4]
 800639c:	e9d7 2300 	ldrd	r2, r3, [r7]
 80063a0:	4650      	mov	r0, sl
 80063a2:	4659      	mov	r1, fp
 80063a4:	f7f9 ff6c 	bl	8000280 <__aeabi_uldivmod>
 80063a8:	4602      	mov	r2, r0
 80063aa:	460b      	mov	r3, r1
 80063ac:	4613      	mov	r3, r2
 80063ae:	61bb      	str	r3, [r7, #24]
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80063b0:	69bb      	ldr	r3, [r7, #24]
 80063b2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80063b6:	d308      	bcc.n	80063ca <UART_SetConfig+0x3de>
 80063b8:	69bb      	ldr	r3, [r7, #24]
 80063ba:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80063be:	d204      	bcs.n	80063ca <UART_SetConfig+0x3de>
        {
          huart->Instance->BRR = usartdiv;
 80063c0:	68fb      	ldr	r3, [r7, #12]
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	69ba      	ldr	r2, [r7, #24]
 80063c6:	60da      	str	r2, [r3, #12]
 80063c8:	e0b8      	b.n	800653c <UART_SetConfig+0x550>
        }
        else
        {
          ret = HAL_ERROR;
 80063ca:	2301      	movs	r3, #1
 80063cc:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 80063d0:	e0b4      	b.n	800653c <UART_SetConfig+0x550>
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
#endif /* USART_PRESC_PRESCALER */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80063d2:	68fb      	ldr	r3, [r7, #12]
 80063d4:	69db      	ldr	r3, [r3, #28]
 80063d6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80063da:	d15f      	bne.n	800649c <UART_SetConfig+0x4b0>
  {
    switch (clocksource)
 80063dc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80063e0:	2b08      	cmp	r3, #8
 80063e2:	d828      	bhi.n	8006436 <UART_SetConfig+0x44a>
 80063e4:	a201      	add	r2, pc, #4	; (adr r2, 80063ec <UART_SetConfig+0x400>)
 80063e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80063ea:	bf00      	nop
 80063ec:	08006411 	.word	0x08006411
 80063f0:	08006419 	.word	0x08006419
 80063f4:	08006421 	.word	0x08006421
 80063f8:	08006437 	.word	0x08006437
 80063fc:	08006427 	.word	0x08006427
 8006400:	08006437 	.word	0x08006437
 8006404:	08006437 	.word	0x08006437
 8006408:	08006437 	.word	0x08006437
 800640c:	0800642f 	.word	0x0800642f
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8006410:	f7fc fefc 	bl	800320c <HAL_RCC_GetPCLK1Freq>
 8006414:	61f8      	str	r0, [r7, #28]
        break;
 8006416:	e014      	b.n	8006442 <UART_SetConfig+0x456>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8006418:	f7fc ff0e 	bl	8003238 <HAL_RCC_GetPCLK2Freq>
 800641c:	61f8      	str	r0, [r7, #28]
        break;
 800641e:	e010      	b.n	8006442 <UART_SetConfig+0x456>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8006420:	4b4e      	ldr	r3, [pc, #312]	; (800655c <UART_SetConfig+0x570>)
 8006422:	61fb      	str	r3, [r7, #28]
        break;
 8006424:	e00d      	b.n	8006442 <UART_SetConfig+0x456>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8006426:	f7fc fe59 	bl	80030dc <HAL_RCC_GetSysClockFreq>
 800642a:	61f8      	str	r0, [r7, #28]
        break;
 800642c:	e009      	b.n	8006442 <UART_SetConfig+0x456>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800642e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006432:	61fb      	str	r3, [r7, #28]
        break;
 8006434:	e005      	b.n	8006442 <UART_SetConfig+0x456>
      default:
        pclk = 0U;
 8006436:	2300      	movs	r3, #0
 8006438:	61fb      	str	r3, [r7, #28]
        ret = HAL_ERROR;
 800643a:	2301      	movs	r3, #1
 800643c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        break;
 8006440:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8006442:	69fb      	ldr	r3, [r7, #28]
 8006444:	2b00      	cmp	r3, #0
 8006446:	d079      	beq.n	800653c <UART_SetConfig+0x550>
    {
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
#else
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8006448:	69fb      	ldr	r3, [r7, #28]
 800644a:	005a      	lsls	r2, r3, #1
 800644c:	68fb      	ldr	r3, [r7, #12]
 800644e:	685b      	ldr	r3, [r3, #4]
 8006450:	085b      	lsrs	r3, r3, #1
 8006452:	441a      	add	r2, r3
 8006454:	68fb      	ldr	r3, [r7, #12]
 8006456:	685b      	ldr	r3, [r3, #4]
 8006458:	fbb2 f3f3 	udiv	r3, r2, r3
 800645c:	b29b      	uxth	r3, r3
 800645e:	61bb      	str	r3, [r7, #24]
#endif /* USART_PRESC_PRESCALER */
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006460:	69bb      	ldr	r3, [r7, #24]
 8006462:	2b0f      	cmp	r3, #15
 8006464:	d916      	bls.n	8006494 <UART_SetConfig+0x4a8>
 8006466:	69bb      	ldr	r3, [r7, #24]
 8006468:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800646c:	d212      	bcs.n	8006494 <UART_SetConfig+0x4a8>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800646e:	69bb      	ldr	r3, [r7, #24]
 8006470:	b29b      	uxth	r3, r3
 8006472:	f023 030f 	bic.w	r3, r3, #15
 8006476:	82fb      	strh	r3, [r7, #22]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8006478:	69bb      	ldr	r3, [r7, #24]
 800647a:	085b      	lsrs	r3, r3, #1
 800647c:	b29b      	uxth	r3, r3
 800647e:	f003 0307 	and.w	r3, r3, #7
 8006482:	b29a      	uxth	r2, r3
 8006484:	8afb      	ldrh	r3, [r7, #22]
 8006486:	4313      	orrs	r3, r2
 8006488:	82fb      	strh	r3, [r7, #22]
        huart->Instance->BRR = brrtemp;
 800648a:	68fb      	ldr	r3, [r7, #12]
 800648c:	681b      	ldr	r3, [r3, #0]
 800648e:	8afa      	ldrh	r2, [r7, #22]
 8006490:	60da      	str	r2, [r3, #12]
 8006492:	e053      	b.n	800653c <UART_SetConfig+0x550>
      }
      else
      {
        ret = HAL_ERROR;
 8006494:	2301      	movs	r3, #1
 8006496:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 800649a:	e04f      	b.n	800653c <UART_SetConfig+0x550>
      }
    }
  }
  else
  {
    switch (clocksource)
 800649c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80064a0:	2b08      	cmp	r3, #8
 80064a2:	d828      	bhi.n	80064f6 <UART_SetConfig+0x50a>
 80064a4:	a201      	add	r2, pc, #4	; (adr r2, 80064ac <UART_SetConfig+0x4c0>)
 80064a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80064aa:	bf00      	nop
 80064ac:	080064d1 	.word	0x080064d1
 80064b0:	080064d9 	.word	0x080064d9
 80064b4:	080064e1 	.word	0x080064e1
 80064b8:	080064f7 	.word	0x080064f7
 80064bc:	080064e7 	.word	0x080064e7
 80064c0:	080064f7 	.word	0x080064f7
 80064c4:	080064f7 	.word	0x080064f7
 80064c8:	080064f7 	.word	0x080064f7
 80064cc:	080064ef 	.word	0x080064ef
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 80064d0:	f7fc fe9c 	bl	800320c <HAL_RCC_GetPCLK1Freq>
 80064d4:	61f8      	str	r0, [r7, #28]
        break;
 80064d6:	e014      	b.n	8006502 <UART_SetConfig+0x516>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 80064d8:	f7fc feae 	bl	8003238 <HAL_RCC_GetPCLK2Freq>
 80064dc:	61f8      	str	r0, [r7, #28]
        break;
 80064de:	e010      	b.n	8006502 <UART_SetConfig+0x516>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 80064e0:	4b1e      	ldr	r3, [pc, #120]	; (800655c <UART_SetConfig+0x570>)
 80064e2:	61fb      	str	r3, [r7, #28]
        break;
 80064e4:	e00d      	b.n	8006502 <UART_SetConfig+0x516>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 80064e6:	f7fc fdf9 	bl	80030dc <HAL_RCC_GetSysClockFreq>
 80064ea:	61f8      	str	r0, [r7, #28]
        break;
 80064ec:	e009      	b.n	8006502 <UART_SetConfig+0x516>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 80064ee:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80064f2:	61fb      	str	r3, [r7, #28]
        break;
 80064f4:	e005      	b.n	8006502 <UART_SetConfig+0x516>
      default:
        pclk = 0U;
 80064f6:	2300      	movs	r3, #0
 80064f8:	61fb      	str	r3, [r7, #28]
        ret = HAL_ERROR;
 80064fa:	2301      	movs	r3, #1
 80064fc:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        break;
 8006500:	bf00      	nop
    }

    if (pclk != 0U)
 8006502:	69fb      	ldr	r3, [r7, #28]
 8006504:	2b00      	cmp	r3, #0
 8006506:	d019      	beq.n	800653c <UART_SetConfig+0x550>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
#else
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8006508:	68fb      	ldr	r3, [r7, #12]
 800650a:	685b      	ldr	r3, [r3, #4]
 800650c:	085a      	lsrs	r2, r3, #1
 800650e:	69fb      	ldr	r3, [r7, #28]
 8006510:	441a      	add	r2, r3
 8006512:	68fb      	ldr	r3, [r7, #12]
 8006514:	685b      	ldr	r3, [r3, #4]
 8006516:	fbb2 f3f3 	udiv	r3, r2, r3
 800651a:	b29b      	uxth	r3, r3
 800651c:	61bb      	str	r3, [r7, #24]
#endif /* USART_PRESC_PRESCALER */
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800651e:	69bb      	ldr	r3, [r7, #24]
 8006520:	2b0f      	cmp	r3, #15
 8006522:	d908      	bls.n	8006536 <UART_SetConfig+0x54a>
 8006524:	69bb      	ldr	r3, [r7, #24]
 8006526:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800652a:	d204      	bcs.n	8006536 <UART_SetConfig+0x54a>
      {
        huart->Instance->BRR = usartdiv;
 800652c:	68fb      	ldr	r3, [r7, #12]
 800652e:	681b      	ldr	r3, [r3, #0]
 8006530:	69ba      	ldr	r2, [r7, #24]
 8006532:	60da      	str	r2, [r3, #12]
 8006534:	e002      	b.n	800653c <UART_SetConfig+0x550>
      }
      else
      {
        ret = HAL_ERROR;
 8006536:	2301      	movs	r3, #1
 8006538:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800653c:	68fb      	ldr	r3, [r7, #12]
 800653e:	2200      	movs	r2, #0
 8006540:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 8006542:	68fb      	ldr	r3, [r7, #12]
 8006544:	2200      	movs	r2, #0
 8006546:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 8006548:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
}
 800654c:	4618      	mov	r0, r3
 800654e:	3728      	adds	r7, #40	; 0x28
 8006550:	46bd      	mov	sp, r7
 8006552:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006556:	bf00      	nop
 8006558:	40008000 	.word	0x40008000
 800655c:	00f42400 	.word	0x00f42400

08006560 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8006560:	b480      	push	{r7}
 8006562:	b083      	sub	sp, #12
 8006564:	af00      	add	r7, sp, #0
 8006566:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006568:	687b      	ldr	r3, [r7, #4]
 800656a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800656c:	f003 0301 	and.w	r3, r3, #1
 8006570:	2b00      	cmp	r3, #0
 8006572:	d00a      	beq.n	800658a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006574:	687b      	ldr	r3, [r7, #4]
 8006576:	681b      	ldr	r3, [r3, #0]
 8006578:	685b      	ldr	r3, [r3, #4]
 800657a:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 800657e:	687b      	ldr	r3, [r7, #4]
 8006580:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006582:	687b      	ldr	r3, [r7, #4]
 8006584:	681b      	ldr	r3, [r3, #0]
 8006586:	430a      	orrs	r2, r1
 8006588:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800658a:	687b      	ldr	r3, [r7, #4]
 800658c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800658e:	f003 0302 	and.w	r3, r3, #2
 8006592:	2b00      	cmp	r3, #0
 8006594:	d00a      	beq.n	80065ac <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	681b      	ldr	r3, [r3, #0]
 800659a:	685b      	ldr	r3, [r3, #4]
 800659c:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 80065a0:	687b      	ldr	r3, [r7, #4]
 80065a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80065a4:	687b      	ldr	r3, [r7, #4]
 80065a6:	681b      	ldr	r3, [r3, #0]
 80065a8:	430a      	orrs	r2, r1
 80065aa:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80065ac:	687b      	ldr	r3, [r7, #4]
 80065ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80065b0:	f003 0304 	and.w	r3, r3, #4
 80065b4:	2b00      	cmp	r3, #0
 80065b6:	d00a      	beq.n	80065ce <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80065b8:	687b      	ldr	r3, [r7, #4]
 80065ba:	681b      	ldr	r3, [r3, #0]
 80065bc:	685b      	ldr	r3, [r3, #4]
 80065be:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 80065c2:	687b      	ldr	r3, [r7, #4]
 80065c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80065c6:	687b      	ldr	r3, [r7, #4]
 80065c8:	681b      	ldr	r3, [r3, #0]
 80065ca:	430a      	orrs	r2, r1
 80065cc:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80065ce:	687b      	ldr	r3, [r7, #4]
 80065d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80065d2:	f003 0308 	and.w	r3, r3, #8
 80065d6:	2b00      	cmp	r3, #0
 80065d8:	d00a      	beq.n	80065f0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80065da:	687b      	ldr	r3, [r7, #4]
 80065dc:	681b      	ldr	r3, [r3, #0]
 80065de:	685b      	ldr	r3, [r3, #4]
 80065e0:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 80065e4:	687b      	ldr	r3, [r7, #4]
 80065e6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80065e8:	687b      	ldr	r3, [r7, #4]
 80065ea:	681b      	ldr	r3, [r3, #0]
 80065ec:	430a      	orrs	r2, r1
 80065ee:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80065f0:	687b      	ldr	r3, [r7, #4]
 80065f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80065f4:	f003 0310 	and.w	r3, r3, #16
 80065f8:	2b00      	cmp	r3, #0
 80065fa:	d00a      	beq.n	8006612 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80065fc:	687b      	ldr	r3, [r7, #4]
 80065fe:	681b      	ldr	r3, [r3, #0]
 8006600:	689b      	ldr	r3, [r3, #8]
 8006602:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8006606:	687b      	ldr	r3, [r7, #4]
 8006608:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800660a:	687b      	ldr	r3, [r7, #4]
 800660c:	681b      	ldr	r3, [r3, #0]
 800660e:	430a      	orrs	r2, r1
 8006610:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006612:	687b      	ldr	r3, [r7, #4]
 8006614:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006616:	f003 0320 	and.w	r3, r3, #32
 800661a:	2b00      	cmp	r3, #0
 800661c:	d00a      	beq.n	8006634 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	689b      	ldr	r3, [r3, #8]
 8006624:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 8006628:	687b      	ldr	r3, [r7, #4]
 800662a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800662c:	687b      	ldr	r3, [r7, #4]
 800662e:	681b      	ldr	r3, [r3, #0]
 8006630:	430a      	orrs	r2, r1
 8006632:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006634:	687b      	ldr	r3, [r7, #4]
 8006636:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006638:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800663c:	2b00      	cmp	r3, #0
 800663e:	d01a      	beq.n	8006676 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006640:	687b      	ldr	r3, [r7, #4]
 8006642:	681b      	ldr	r3, [r3, #0]
 8006644:	685b      	ldr	r3, [r3, #4]
 8006646:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 800664a:	687b      	ldr	r3, [r7, #4]
 800664c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800664e:	687b      	ldr	r3, [r7, #4]
 8006650:	681b      	ldr	r3, [r3, #0]
 8006652:	430a      	orrs	r2, r1
 8006654:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006656:	687b      	ldr	r3, [r7, #4]
 8006658:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800665a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800665e:	d10a      	bne.n	8006676 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8006660:	687b      	ldr	r3, [r7, #4]
 8006662:	681b      	ldr	r3, [r3, #0]
 8006664:	685b      	ldr	r3, [r3, #4]
 8006666:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 800666a:	687b      	ldr	r3, [r7, #4]
 800666c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	681b      	ldr	r3, [r3, #0]
 8006672:	430a      	orrs	r2, r1
 8006674:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8006676:	687b      	ldr	r3, [r7, #4]
 8006678:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800667a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800667e:	2b00      	cmp	r3, #0
 8006680:	d00a      	beq.n	8006698 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006682:	687b      	ldr	r3, [r7, #4]
 8006684:	681b      	ldr	r3, [r3, #0]
 8006686:	685b      	ldr	r3, [r3, #4]
 8006688:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 800668c:	687b      	ldr	r3, [r7, #4]
 800668e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8006690:	687b      	ldr	r3, [r7, #4]
 8006692:	681b      	ldr	r3, [r3, #0]
 8006694:	430a      	orrs	r2, r1
 8006696:	605a      	str	r2, [r3, #4]
  }
}
 8006698:	bf00      	nop
 800669a:	370c      	adds	r7, #12
 800669c:	46bd      	mov	sp, r7
 800669e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a2:	4770      	bx	lr

080066a4 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 80066a4:	b580      	push	{r7, lr}
 80066a6:	b086      	sub	sp, #24
 80066a8:	af02      	add	r7, sp, #8
 80066aa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	2200      	movs	r2, #0
 80066b0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 80066b4:	f7fa feec 	bl	8001490 <HAL_GetTick>
 80066b8:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80066ba:	687b      	ldr	r3, [r7, #4]
 80066bc:	681b      	ldr	r3, [r3, #0]
 80066be:	681b      	ldr	r3, [r3, #0]
 80066c0:	f003 0308 	and.w	r3, r3, #8
 80066c4:	2b08      	cmp	r3, #8
 80066c6:	d10e      	bne.n	80066e6 <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80066c8:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80066cc:	9300      	str	r3, [sp, #0]
 80066ce:	68fb      	ldr	r3, [r7, #12]
 80066d0:	2200      	movs	r2, #0
 80066d2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80066d6:	6878      	ldr	r0, [r7, #4]
 80066d8:	f000 f82d 	bl	8006736 <UART_WaitOnFlagUntilTimeout>
 80066dc:	4603      	mov	r3, r0
 80066de:	2b00      	cmp	r3, #0
 80066e0:	d001      	beq.n	80066e6 <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80066e2:	2303      	movs	r3, #3
 80066e4:	e023      	b.n	800672e <UART_CheckIdleState+0x8a>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80066e6:	687b      	ldr	r3, [r7, #4]
 80066e8:	681b      	ldr	r3, [r3, #0]
 80066ea:	681b      	ldr	r3, [r3, #0]
 80066ec:	f003 0304 	and.w	r3, r3, #4
 80066f0:	2b04      	cmp	r3, #4
 80066f2:	d10e      	bne.n	8006712 <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80066f4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80066f8:	9300      	str	r3, [sp, #0]
 80066fa:	68fb      	ldr	r3, [r7, #12]
 80066fc:	2200      	movs	r2, #0
 80066fe:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8006702:	6878      	ldr	r0, [r7, #4]
 8006704:	f000 f817 	bl	8006736 <UART_WaitOnFlagUntilTimeout>
 8006708:	4603      	mov	r3, r0
 800670a:	2b00      	cmp	r3, #0
 800670c:	d001      	beq.n	8006712 <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800670e:	2303      	movs	r3, #3
 8006710:	e00d      	b.n	800672e <UART_CheckIdleState+0x8a>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8006712:	687b      	ldr	r3, [r7, #4]
 8006714:	2220      	movs	r2, #32
 8006716:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 8006718:	687b      	ldr	r3, [r7, #4]
 800671a:	2220      	movs	r2, #32
 800671c:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800671e:	687b      	ldr	r3, [r7, #4]
 8006720:	2200      	movs	r2, #0
 8006722:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 8006724:	687b      	ldr	r3, [r7, #4]
 8006726:	2200      	movs	r2, #0
 8006728:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

  return HAL_OK;
 800672c:	2300      	movs	r3, #0
}
 800672e:	4618      	mov	r0, r3
 8006730:	3710      	adds	r7, #16
 8006732:	46bd      	mov	sp, r7
 8006734:	bd80      	pop	{r7, pc}

08006736 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8006736:	b580      	push	{r7, lr}
 8006738:	b084      	sub	sp, #16
 800673a:	af00      	add	r7, sp, #0
 800673c:	60f8      	str	r0, [r7, #12]
 800673e:	60b9      	str	r1, [r7, #8]
 8006740:	603b      	str	r3, [r7, #0]
 8006742:	4613      	mov	r3, r2
 8006744:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006746:	e05e      	b.n	8006806 <UART_WaitOnFlagUntilTimeout+0xd0>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006748:	69bb      	ldr	r3, [r7, #24]
 800674a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800674e:	d05a      	beq.n	8006806 <UART_WaitOnFlagUntilTimeout+0xd0>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006750:	f7fa fe9e 	bl	8001490 <HAL_GetTick>
 8006754:	4602      	mov	r2, r0
 8006756:	683b      	ldr	r3, [r7, #0]
 8006758:	1ad3      	subs	r3, r2, r3
 800675a:	69ba      	ldr	r2, [r7, #24]
 800675c:	429a      	cmp	r2, r3
 800675e:	d302      	bcc.n	8006766 <UART_WaitOnFlagUntilTimeout+0x30>
 8006760:	69bb      	ldr	r3, [r7, #24]
 8006762:	2b00      	cmp	r3, #0
 8006764:	d11b      	bne.n	800679e <UART_WaitOnFlagUntilTimeout+0x68>
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
#else
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8006766:	68fb      	ldr	r3, [r7, #12]
 8006768:	681b      	ldr	r3, [r3, #0]
 800676a:	681a      	ldr	r2, [r3, #0]
 800676c:	68fb      	ldr	r3, [r7, #12]
 800676e:	681b      	ldr	r3, [r3, #0]
 8006770:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8006774:	601a      	str	r2, [r3, #0]
#endif /* USART_CR1_FIFOEN */
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006776:	68fb      	ldr	r3, [r7, #12]
 8006778:	681b      	ldr	r3, [r3, #0]
 800677a:	689a      	ldr	r2, [r3, #8]
 800677c:	68fb      	ldr	r3, [r7, #12]
 800677e:	681b      	ldr	r3, [r3, #0]
 8006780:	f022 0201 	bic.w	r2, r2, #1
 8006784:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 8006786:	68fb      	ldr	r3, [r7, #12]
 8006788:	2220      	movs	r2, #32
 800678a:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800678c:	68fb      	ldr	r3, [r7, #12]
 800678e:	2220      	movs	r2, #32
 8006790:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 8006792:	68fb      	ldr	r3, [r7, #12]
 8006794:	2200      	movs	r2, #0
 8006796:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

        return HAL_TIMEOUT;
 800679a:	2303      	movs	r3, #3
 800679c:	e043      	b.n	8006826 <UART_WaitOnFlagUntilTimeout+0xf0>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800679e:	68fb      	ldr	r3, [r7, #12]
 80067a0:	681b      	ldr	r3, [r3, #0]
 80067a2:	681b      	ldr	r3, [r3, #0]
 80067a4:	f003 0304 	and.w	r3, r3, #4
 80067a8:	2b00      	cmp	r3, #0
 80067aa:	d02c      	beq.n	8006806 <UART_WaitOnFlagUntilTimeout+0xd0>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80067ac:	68fb      	ldr	r3, [r7, #12]
 80067ae:	681b      	ldr	r3, [r3, #0]
 80067b0:	69db      	ldr	r3, [r3, #28]
 80067b2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80067b6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80067ba:	d124      	bne.n	8006806 <UART_WaitOnFlagUntilTimeout+0xd0>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80067bc:	68fb      	ldr	r3, [r7, #12]
 80067be:	681b      	ldr	r3, [r3, #0]
 80067c0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80067c4:	621a      	str	r2, [r3, #32]
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
#else
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80067c6:	68fb      	ldr	r3, [r7, #12]
 80067c8:	681b      	ldr	r3, [r3, #0]
 80067ca:	681a      	ldr	r2, [r3, #0]
 80067cc:	68fb      	ldr	r3, [r7, #12]
 80067ce:	681b      	ldr	r3, [r3, #0]
 80067d0:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 80067d4:	601a      	str	r2, [r3, #0]
#endif
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80067d6:	68fb      	ldr	r3, [r7, #12]
 80067d8:	681b      	ldr	r3, [r3, #0]
 80067da:	689a      	ldr	r2, [r3, #8]
 80067dc:	68fb      	ldr	r3, [r7, #12]
 80067de:	681b      	ldr	r3, [r3, #0]
 80067e0:	f022 0201 	bic.w	r2, r2, #1
 80067e4:	609a      	str	r2, [r3, #8]

          huart->gState = HAL_UART_STATE_READY;
 80067e6:	68fb      	ldr	r3, [r7, #12]
 80067e8:	2220      	movs	r2, #32
 80067ea:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 80067ec:	68fb      	ldr	r3, [r7, #12]
 80067ee:	2220      	movs	r2, #32
 80067f0:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80067f2:	68fb      	ldr	r3, [r7, #12]
 80067f4:	2220      	movs	r2, #32
 80067f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 80067fa:	68fb      	ldr	r3, [r7, #12]
 80067fc:	2200      	movs	r2, #0
 80067fe:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

          return HAL_TIMEOUT;
 8006802:	2303      	movs	r3, #3
 8006804:	e00f      	b.n	8006826 <UART_WaitOnFlagUntilTimeout+0xf0>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006806:	68fb      	ldr	r3, [r7, #12]
 8006808:	681b      	ldr	r3, [r3, #0]
 800680a:	69da      	ldr	r2, [r3, #28]
 800680c:	68bb      	ldr	r3, [r7, #8]
 800680e:	4013      	ands	r3, r2
 8006810:	68ba      	ldr	r2, [r7, #8]
 8006812:	429a      	cmp	r2, r3
 8006814:	bf0c      	ite	eq
 8006816:	2301      	moveq	r3, #1
 8006818:	2300      	movne	r3, #0
 800681a:	b2db      	uxtb	r3, r3
 800681c:	461a      	mov	r2, r3
 800681e:	79fb      	ldrb	r3, [r7, #7]
 8006820:	429a      	cmp	r2, r3
 8006822:	d091      	beq.n	8006748 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8006824:	2300      	movs	r3, #0
}
 8006826:	4618      	mov	r0, r3
 8006828:	3710      	adds	r7, #16
 800682a:	46bd      	mov	sp, r7
 800682c:	bd80      	pop	{r7, pc}

0800682e <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 800682e:	b480      	push	{r7}
 8006830:	b083      	sub	sp, #12
 8006832:	af00      	add	r7, sp, #0
 8006834:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE, TCIE, TXFT interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
#else
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8006836:	687b      	ldr	r3, [r7, #4]
 8006838:	681b      	ldr	r3, [r3, #0]
 800683a:	681a      	ldr	r2, [r3, #0]
 800683c:	687b      	ldr	r3, [r7, #4]
 800683e:	681b      	ldr	r3, [r3, #0]
 8006840:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8006844:	601a      	str	r2, [r3, #0]
#endif /* USART_CR1_FIFOEN */

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8006846:	687b      	ldr	r3, [r7, #4]
 8006848:	2220      	movs	r2, #32
 800684a:	679a      	str	r2, [r3, #120]	; 0x78
}
 800684c:	bf00      	nop
 800684e:	370c      	adds	r7, #12
 8006850:	46bd      	mov	sp, r7
 8006852:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006856:	4770      	bx	lr

08006858 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8006858:	b480      	push	{r7}
 800685a:	b083      	sub	sp, #12
 800685c:	af00      	add	r7, sp, #0
 800685e:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
#if defined(USART_CR1_FIFOEN)
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
#else
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8006860:	687b      	ldr	r3, [r7, #4]
 8006862:	681b      	ldr	r3, [r3, #0]
 8006864:	681a      	ldr	r2, [r3, #0]
 8006866:	687b      	ldr	r3, [r7, #4]
 8006868:	681b      	ldr	r3, [r3, #0]
 800686a:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 800686e:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	681b      	ldr	r3, [r3, #0]
 8006874:	689a      	ldr	r2, [r3, #8]
 8006876:	687b      	ldr	r3, [r7, #4]
 8006878:	681b      	ldr	r3, [r3, #0]
 800687a:	f022 0201 	bic.w	r2, r2, #1
 800687e:	609a      	str	r2, [r3, #8]
#endif /* USART_CR1_FIFOEN */

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006880:	687b      	ldr	r3, [r7, #4]
 8006882:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006884:	2b01      	cmp	r3, #1
 8006886:	d107      	bne.n	8006898 <UART_EndRxTransfer+0x40>
  {
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006888:	687b      	ldr	r3, [r7, #4]
 800688a:	681b      	ldr	r3, [r3, #0]
 800688c:	681a      	ldr	r2, [r3, #0]
 800688e:	687b      	ldr	r3, [r7, #4]
 8006890:	681b      	ldr	r3, [r3, #0]
 8006892:	f022 0210 	bic.w	r2, r2, #16
 8006896:	601a      	str	r2, [r3, #0]
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8006898:	687b      	ldr	r3, [r7, #4]
 800689a:	2220      	movs	r2, #32
 800689c:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800689e:	687b      	ldr	r3, [r7, #4]
 80068a0:	2200      	movs	r2, #0
 80068a2:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 80068a4:	687b      	ldr	r3, [r7, #4]
 80068a6:	2200      	movs	r2, #0
 80068a8:	665a      	str	r2, [r3, #100]	; 0x64
}
 80068aa:	bf00      	nop
 80068ac:	370c      	adds	r7, #12
 80068ae:	46bd      	mov	sp, r7
 80068b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068b4:	4770      	bx	lr

080068b6 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 80068b6:	b580      	push	{r7, lr}
 80068b8:	b084      	sub	sp, #16
 80068ba:	af00      	add	r7, sp, #0
 80068bc:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80068be:	687b      	ldr	r3, [r7, #4]
 80068c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80068c2:	60fb      	str	r3, [r7, #12]

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 80068c4:	687b      	ldr	r3, [r7, #4]
 80068c6:	681b      	ldr	r3, [r3, #0]
 80068c8:	681b      	ldr	r3, [r3, #0]
 80068ca:	f003 0320 	and.w	r3, r3, #32
 80068ce:	2b00      	cmp	r3, #0
 80068d0:	d114      	bne.n	80068fc <UART_DMATransmitCplt+0x46>
  {
    huart->TxXferCount = 0U;
 80068d2:	68fb      	ldr	r3, [r7, #12]
 80068d4:	2200      	movs	r2, #0
 80068d6:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80068da:	68fb      	ldr	r3, [r7, #12]
 80068dc:	681b      	ldr	r3, [r3, #0]
 80068de:	689a      	ldr	r2, [r3, #8]
 80068e0:	68fb      	ldr	r3, [r7, #12]
 80068e2:	681b      	ldr	r3, [r3, #0]
 80068e4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80068e8:	609a      	str	r2, [r3, #8]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80068ea:	68fb      	ldr	r3, [r7, #12]
 80068ec:	681b      	ldr	r3, [r3, #0]
 80068ee:	681a      	ldr	r2, [r3, #0]
 80068f0:	68fb      	ldr	r3, [r7, #12]
 80068f2:	681b      	ldr	r3, [r3, #0]
 80068f4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80068f8:	601a      	str	r2, [r3, #0]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 80068fa:	e002      	b.n	8006902 <UART_DMATransmitCplt+0x4c>
    HAL_UART_TxCpltCallback(huart);
 80068fc:	68f8      	ldr	r0, [r7, #12]
 80068fe:	f7ff fb57 	bl	8005fb0 <HAL_UART_TxCpltCallback>
}
 8006902:	bf00      	nop
 8006904:	3710      	adds	r7, #16
 8006906:	46bd      	mov	sp, r7
 8006908:	bd80      	pop	{r7, pc}

0800690a <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800690a:	b580      	push	{r7, lr}
 800690c:	b084      	sub	sp, #16
 800690e:	af00      	add	r7, sp, #0
 8006910:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8006912:	687b      	ldr	r3, [r7, #4]
 8006914:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006916:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 8006918:	68f8      	ldr	r0, [r7, #12]
 800691a:	f7ff fb53 	bl	8005fc4 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800691e:	bf00      	nop
 8006920:	3710      	adds	r7, #16
 8006922:	46bd      	mov	sp, r7
 8006924:	bd80      	pop	{r7, pc}

08006926 <UART_DMAError>:
  * @brief DMA UART communication error callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 8006926:	b580      	push	{r7, lr}
 8006928:	b086      	sub	sp, #24
 800692a:	af00      	add	r7, sp, #0
 800692c:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800692e:	687b      	ldr	r3, [r7, #4]
 8006930:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006932:	617b      	str	r3, [r7, #20]

  const HAL_UART_StateTypeDef gstate = huart->gState;
 8006934:	697b      	ldr	r3, [r7, #20]
 8006936:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006938:	613b      	str	r3, [r7, #16]
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800693a:	697b      	ldr	r3, [r7, #20]
 800693c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800693e:	60fb      	str	r3, [r7, #12]

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8006940:	697b      	ldr	r3, [r7, #20]
 8006942:	681b      	ldr	r3, [r3, #0]
 8006944:	689b      	ldr	r3, [r3, #8]
 8006946:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800694a:	2b80      	cmp	r3, #128	; 0x80
 800694c:	d109      	bne.n	8006962 <UART_DMAError+0x3c>
 800694e:	693b      	ldr	r3, [r7, #16]
 8006950:	2b21      	cmp	r3, #33	; 0x21
 8006952:	d106      	bne.n	8006962 <UART_DMAError+0x3c>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 8006954:	697b      	ldr	r3, [r7, #20]
 8006956:	2200      	movs	r2, #0
 8006958:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    UART_EndTxTransfer(huart);
 800695c:	6978      	ldr	r0, [r7, #20]
 800695e:	f7ff ff66 	bl	800682e <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 8006962:	697b      	ldr	r3, [r7, #20]
 8006964:	681b      	ldr	r3, [r3, #0]
 8006966:	689b      	ldr	r3, [r3, #8]
 8006968:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800696c:	2b40      	cmp	r3, #64	; 0x40
 800696e:	d109      	bne.n	8006984 <UART_DMAError+0x5e>
 8006970:	68fb      	ldr	r3, [r7, #12]
 8006972:	2b22      	cmp	r3, #34	; 0x22
 8006974:	d106      	bne.n	8006984 <UART_DMAError+0x5e>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 8006976:	697b      	ldr	r3, [r7, #20]
 8006978:	2200      	movs	r2, #0
 800697a:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    UART_EndRxTransfer(huart);
 800697e:	6978      	ldr	r0, [r7, #20]
 8006980:	f7ff ff6a 	bl	8006858 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8006984:	697b      	ldr	r3, [r7, #20]
 8006986:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800698a:	f043 0210 	orr.w	r2, r3, #16
 800698e:	697b      	ldr	r3, [r7, #20]
 8006990:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8006994:	6978      	ldr	r0, [r7, #20]
 8006996:	f7ff fb1f 	bl	8005fd8 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800699a:	bf00      	nop
 800699c:	3718      	adds	r7, #24
 800699e:	46bd      	mov	sp, r7
 80069a0:	bd80      	pop	{r7, pc}

080069a2 <_ZNK8IXFEvent12getEventTypeEv>:

    /** \brief Returns the type of the event.
     *
     * Can be used to distinguish between an event or a timeout.
     */
    inline eEventType getEventType() const { return _eventType; }
 80069a2:	b480      	push	{r7}
 80069a4:	b083      	sub	sp, #12
 80069a6:	af00      	add	r7, sp, #0
 80069a8:	6078      	str	r0, [r7, #4]
 80069aa:	687b      	ldr	r3, [r7, #4]
 80069ac:	f993 3004 	ldrsb.w	r3, [r3, #4]
 80069b0:	4618      	mov	r0, r3
 80069b2:	370c      	adds	r7, #12
 80069b4:	46bd      	mov	sp, r7
 80069b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069ba:	4770      	bx	lr

080069bc <_ZNK8IXFEvent5getIdEv>:
    /** \brief Sets pointer to behavioral class (see #_pBehavior).
     * Sets the behavior in which the event should be executed.
     */
    inline void setBehavior(IXFReactive * pBehavior) { _pBehavior = pBehavior; }

    inline int getId() const { return _id; }		///< Returns #_id identifying the event in the behaviors context.
 80069bc:	b480      	push	{r7}
 80069be:	b083      	sub	sp, #12
 80069c0:	af00      	add	r7, sp, #0
 80069c2:	6078      	str	r0, [r7, #4]
 80069c4:	687b      	ldr	r3, [r7, #4]
 80069c6:	689b      	ldr	r3, [r3, #8]
 80069c8:	4618      	mov	r0, r3
 80069ca:	370c      	adds	r7, #12
 80069cc:	46bd      	mov	sp, r7
 80069ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069d2:	4770      	bx	lr

080069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>:
    /**
     * Constructor
     *
     * \param eventStatus Initial value of the event status.
     */
    EventStatus(eEventStatus eventStatus = Unknown) : _status(eventStatus) {}
 80069d4:	b480      	push	{r7}
 80069d6:	b083      	sub	sp, #12
 80069d8:	af00      	add	r7, sp, #0
 80069da:	6078      	str	r0, [r7, #4]
 80069dc:	460b      	mov	r3, r1
 80069de:	70fb      	strb	r3, [r7, #3]
 80069e0:	687b      	ldr	r3, [r7, #4]
 80069e2:	78fa      	ldrb	r2, [r7, #3]
 80069e4:	701a      	strb	r2, [r3, #0]
 80069e6:	687b      	ldr	r3, [r7, #4]
 80069e8:	4618      	mov	r0, r3
 80069ea:	370c      	adds	r7, #12
 80069ec:	46bd      	mov	sp, r7
 80069ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069f2:	4770      	bx	lr

080069f4 <_ZNKSt16initializer_listIhE4sizeEv>:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }

      // Number of elements.
      constexpr size_type
      size() const noexcept { return _M_len; }
 80069f4:	b480      	push	{r7}
 80069f6:	b083      	sub	sp, #12
 80069f8:	af00      	add	r7, sp, #0
 80069fa:	6078      	str	r0, [r7, #4]
 80069fc:	687b      	ldr	r3, [r7, #4]
 80069fe:	685b      	ldr	r3, [r3, #4]
 8006a00:	4618      	mov	r0, r3
 8006a02:	370c      	adds	r7, #12
 8006a04:	46bd      	mov	sp, r7
 8006a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a0a:	4770      	bx	lr

08006a0c <_ZNKSt16initializer_listIhE5beginEv>:

      // First element.
      constexpr const_iterator
      begin() const noexcept { return _M_array; }
 8006a0c:	b480      	push	{r7}
 8006a0e:	b083      	sub	sp, #12
 8006a10:	af00      	add	r7, sp, #0
 8006a12:	6078      	str	r0, [r7, #4]
 8006a14:	687b      	ldr	r3, [r7, #4]
 8006a16:	681b      	ldr	r3, [r3, #0]
 8006a18:	4618      	mov	r0, r3
 8006a1a:	370c      	adds	r7, #12
 8006a1c:	46bd      	mov	sp, r7
 8006a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a22:	4770      	bx	lr

08006a24 <_ZN7desenet6sensor19AbstractApplicationC1Ev>:
     */
    class AbstractApplication
    {
        friend class NetworkEntity;
    public:
        AbstractApplication() {}				///< @brief Default constructor.
 8006a24:	b480      	push	{r7}
 8006a26:	b083      	sub	sp, #12
 8006a28:	af00      	add	r7, sp, #0
 8006a2a:	6078      	str	r0, [r7, #4]
 8006a2c:	4a04      	ldr	r2, [pc, #16]	; (8006a40 <_ZN7desenet6sensor19AbstractApplicationC1Ev+0x1c>)
 8006a2e:	687b      	ldr	r3, [r7, #4]
 8006a30:	601a      	str	r2, [r3, #0]
 8006a32:	687b      	ldr	r3, [r7, #4]
 8006a34:	4618      	mov	r0, r3
 8006a36:	370c      	adds	r7, #12
 8006a38:	46bd      	mov	sp, r7
 8006a3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a3e:	4770      	bx	lr
 8006a40:	0801ba08 	.word	0x0801ba08

08006a44 <_ZN7desenet6sensor19AbstractApplicationD1Ev>:
        virtual ~AbstractApplication() {}		///< @brief Destructor.
 8006a44:	b480      	push	{r7}
 8006a46:	b083      	sub	sp, #12
 8006a48:	af00      	add	r7, sp, #0
 8006a4a:	6078      	str	r0, [r7, #4]
 8006a4c:	4a04      	ldr	r2, [pc, #16]	; (8006a60 <_ZN7desenet6sensor19AbstractApplicationD1Ev+0x1c>)
 8006a4e:	687b      	ldr	r3, [r7, #4]
 8006a50:	601a      	str	r2, [r3, #0]
 8006a52:	687b      	ldr	r3, [r7, #4]
 8006a54:	4618      	mov	r0, r3
 8006a56:	370c      	adds	r7, #12
 8006a58:	46bd      	mov	sp, r7
 8006a5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a5e:	4770      	bx	lr
 8006a60:	0801ba08 	.word	0x0801ba08

08006a64 <_ZN7desenet6sensor19AbstractApplicationD0Ev>:
 8006a64:	b580      	push	{r7, lr}
 8006a66:	b082      	sub	sp, #8
 8006a68:	af00      	add	r7, sp, #0
 8006a6a:	6078      	str	r0, [r7, #4]
 8006a6c:	6878      	ldr	r0, [r7, #4]
 8006a6e:	f7ff ffe9 	bl	8006a44 <_ZN7desenet6sensor19AbstractApplicationD1Ev>
 8006a72:	2104      	movs	r1, #4
 8006a74:	6878      	ldr	r0, [r7, #4]
 8006a76:	f00f fb99 	bl	80161ac <_ZdlPvj>
 8006a7a:	687b      	ldr	r3, [r7, #4]
 8006a7c:	4618      	mov	r0, r3
 8006a7e:	3708      	adds	r7, #8
 8006a80:	46bd      	mov	sp, r7
 8006a82:	bd80      	pop	{r7, pc}

08006a84 <_ZN3app7Factory8instanceEv>:
public:
    Factory(int argc, char ** argv);

    void buildApplication();

    static Factory & instance() { assert(_pInstance); return *_pInstance; }
 8006a84:	b580      	push	{r7, lr}
 8006a86:	af00      	add	r7, sp, #0
 8006a88:	4b06      	ldr	r3, [pc, #24]	; (8006aa4 <_ZN3app7Factory8instanceEv+0x20>)
 8006a8a:	681b      	ldr	r3, [r3, #0]
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	d105      	bne.n	8006a9c <_ZN3app7Factory8instanceEv+0x18>
 8006a90:	4b05      	ldr	r3, [pc, #20]	; (8006aa8 <_ZN3app7Factory8instanceEv+0x24>)
 8006a92:	4a06      	ldr	r2, [pc, #24]	; (8006aac <_ZN3app7Factory8instanceEv+0x28>)
 8006a94:	212e      	movs	r1, #46	; 0x2e
 8006a96:	4806      	ldr	r0, [pc, #24]	; (8006ab0 <_ZN3app7Factory8instanceEv+0x2c>)
 8006a98:	f00f fc7c 	bl	8016394 <__assert_func>
 8006a9c:	4b01      	ldr	r3, [pc, #4]	; (8006aa4 <_ZN3app7Factory8instanceEv+0x20>)
 8006a9e:	681b      	ldr	r3, [r3, #0]
 8006aa0:	4618      	mov	r0, r3
 8006aa2:	bd80      	pop	{r7, pc}
 8006aa4:	2000032c 	.word	0x2000032c
 8006aa8:	08017930 	.word	0x08017930
 8006aac:	0801793c 	.word	0x0801793c
 8006ab0:	0801796c 	.word	0x0801796c

08006ab4 <_ZN3app24AccelerometerApplicationC1Ev>:
#include "xf/xfevent.h"
#include "accelerometerapplication.h"

using app::AccelerometerApplication;

AccelerometerApplication::AccelerometerApplication()
 8006ab4:	b580      	push	{r7, lr}
 8006ab6:	b082      	sub	sp, #8
 8006ab8:	af00      	add	r7, sp, #0
 8006aba:	6078      	str	r0, [r7, #4]
: _currentState(STATE_UNKOWN)
 8006abc:	687b      	ldr	r3, [r7, #4]
 8006abe:	2100      	movs	r1, #0
 8006ac0:	4618      	mov	r0, r3
 8006ac2:	f00d fb2f 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 8006ac6:	687b      	ldr	r3, [r7, #4]
 8006ac8:	330c      	adds	r3, #12
 8006aca:	4618      	mov	r0, r3
 8006acc:	f7ff ffaa 	bl	8006a24 <_ZN7desenet6sensor19AbstractApplicationC1Ev>
 8006ad0:	4a0b      	ldr	r2, [pc, #44]	; (8006b00 <_ZN3app24AccelerometerApplicationC1Ev+0x4c>)
 8006ad2:	687b      	ldr	r3, [r7, #4]
 8006ad4:	601a      	str	r2, [r3, #0]
 8006ad6:	4a0b      	ldr	r2, [pc, #44]	; (8006b04 <_ZN3app24AccelerometerApplicationC1Ev+0x50>)
 8006ad8:	687b      	ldr	r3, [r7, #4]
 8006ada:	60da      	str	r2, [r3, #12]
 8006adc:	687b      	ldr	r3, [r7, #4]
 8006ade:	2200      	movs	r2, #0
 8006ae0:	741a      	strb	r2, [r3, #16]
 8006ae2:	687b      	ldr	r3, [r7, #4]
 8006ae4:	2202      	movs	r2, #2
 8006ae6:	745a      	strb	r2, [r3, #17]
{
	memset(_accelValuesSyncArray, 0, sizeof(_accelValuesSyncArray));
 8006ae8:	687b      	ldr	r3, [r7, #4]
 8006aea:	3312      	adds	r3, #18
 8006aec:	2206      	movs	r2, #6
 8006aee:	2100      	movs	r1, #0
 8006af0:	4618      	mov	r0, r3
 8006af2:	f00f fce7 	bl	80164c4 <memset>
}
 8006af6:	687b      	ldr	r3, [r7, #4]
 8006af8:	4618      	mov	r0, r3
 8006afa:	3708      	adds	r7, #8
 8006afc:	46bd      	mov	sp, r7
 8006afe:	bd80      	pop	{r7, pc}
 8006b00:	0801b890 	.word	0x0801b890
 8006b04:	0801b8bc 	.word	0x0801b8bc

08006b08 <_ZN3app24AccelerometerApplicationD1Ev>:

AccelerometerApplication::~AccelerometerApplication()
 8006b08:	b580      	push	{r7, lr}
 8006b0a:	b082      	sub	sp, #8
 8006b0c:	af00      	add	r7, sp, #0
 8006b0e:	6078      	str	r0, [r7, #4]
 8006b10:	4a09      	ldr	r2, [pc, #36]	; (8006b38 <_ZN3app24AccelerometerApplicationD1Ev+0x30>)
 8006b12:	687b      	ldr	r3, [r7, #4]
 8006b14:	601a      	str	r2, [r3, #0]
 8006b16:	4a09      	ldr	r2, [pc, #36]	; (8006b3c <_ZN3app24AccelerometerApplicationD1Ev+0x34>)
 8006b18:	687b      	ldr	r3, [r7, #4]
 8006b1a:	60da      	str	r2, [r3, #12]
 8006b1c:	687b      	ldr	r3, [r7, #4]
 8006b1e:	330c      	adds	r3, #12
 8006b20:	4618      	mov	r0, r3
 8006b22:	f7ff ff8f 	bl	8006a44 <_ZN7desenet6sensor19AbstractApplicationD1Ev>
 8006b26:	687b      	ldr	r3, [r7, #4]
 8006b28:	4618      	mov	r0, r3
 8006b2a:	f00d fb1d 	bl	8014168 <_ZN10XFReactiveD1Ev>
{
}
 8006b2e:	687b      	ldr	r3, [r7, #4]
 8006b30:	4618      	mov	r0, r3
 8006b32:	3708      	adds	r7, #8
 8006b34:	46bd      	mov	sp, r7
 8006b36:	bd80      	pop	{r7, pc}
 8006b38:	0801b890 	.word	0x0801b890
 8006b3c:	0801b8bc 	.word	0x0801b8bc

08006b40 <_ZThn12_N3app24AccelerometerApplicationD1Ev>:
class AccelerometerApplication : public XFReactive,
								 public desenet::sensor::AbstractApplication
{
public:
	AccelerometerApplication();
	virtual ~AccelerometerApplication();
 8006b40:	f1a0 000c 	sub.w	r0, r0, #12
 8006b44:	f7ff bfe0 	b.w	8006b08 <_ZN3app24AccelerometerApplicationD1Ev>

08006b48 <_ZN3app24AccelerometerApplicationD0Ev>:
AccelerometerApplication::~AccelerometerApplication()
 8006b48:	b580      	push	{r7, lr}
 8006b4a:	b082      	sub	sp, #8
 8006b4c:	af00      	add	r7, sp, #0
 8006b4e:	6078      	str	r0, [r7, #4]
}
 8006b50:	6878      	ldr	r0, [r7, #4]
 8006b52:	f7ff ffd9 	bl	8006b08 <_ZN3app24AccelerometerApplicationD1Ev>
 8006b56:	2118      	movs	r1, #24
 8006b58:	6878      	ldr	r0, [r7, #4]
 8006b5a:	f00f fb27 	bl	80161ac <_ZdlPvj>
 8006b5e:	687b      	ldr	r3, [r7, #4]
 8006b60:	4618      	mov	r0, r3
 8006b62:	3708      	adds	r7, #8
 8006b64:	46bd      	mov	sp, r7
 8006b66:	bd80      	pop	{r7, pc}

08006b68 <_ZThn12_N3app24AccelerometerApplicationD0Ev>:
 8006b68:	f1a0 000c 	sub.w	r0, r0, #12
 8006b6c:	f7ff bfec 	b.w	8006b48 <_ZN3app24AccelerometerApplicationD0Ev>

08006b70 <_ZN3app24AccelerometerApplication10initializeEv>:

void AccelerometerApplication::initialize()
{
 8006b70:	b580      	push	{r7, lr}
 8006b72:	b082      	sub	sp, #8
 8006b74:	af00      	add	r7, sp, #0
 8006b76:	6078      	str	r0, [r7, #4]
	// Register application to get informed about arrival of beacons.
	svSyncRequest();
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	330c      	adds	r3, #12
 8006b7c:	4618      	mov	r0, r3
 8006b7e:	f004 f830 	bl	800abe2 <_ZN7desenet6sensor19AbstractApplication13svSyncRequestEv>
	// Register to publish sampled values for a specific group.
	svPublishRequest(MY_GROUP);
 8006b82:	687b      	ldr	r3, [r7, #4]
 8006b84:	f103 020c 	add.w	r2, r3, #12
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	7c5b      	ldrb	r3, [r3, #17]
 8006b8c:	4619      	mov	r1, r3
 8006b8e:	4610      	mov	r0, r2
 8006b90:	f004 f836 	bl	800ac00 <_ZN7desenet6sensor19AbstractApplication16svPublishRequestEh>
}
 8006b94:	bf00      	nop
 8006b96:	3708      	adds	r7, #8
 8006b98:	46bd      	mov	sp, r7
 8006b9a:	bd80      	pop	{r7, pc}

08006b9c <_ZN3app24AccelerometerApplication5startEv>:

void AccelerometerApplication::start()
{
 8006b9c:	b580      	push	{r7, lr}
 8006b9e:	b082      	sub	sp, #8
 8006ba0:	af00      	add	r7, sp, #0
 8006ba2:	6078      	str	r0, [r7, #4]
	startBehavior();	// Start state machine
 8006ba4:	687a      	ldr	r2, [r7, #4]
 8006ba6:	687b      	ldr	r3, [r7, #4]
 8006ba8:	681b      	ldr	r3, [r3, #0]
 8006baa:	3308      	adds	r3, #8
 8006bac:	681b      	ldr	r3, [r3, #0]
 8006bae:	4610      	mov	r0, r2
 8006bb0:	4798      	blx	r3
}
 8006bb2:	bf00      	nop
 8006bb4:	3708      	adds	r7, #8
 8006bb6:	46bd      	mov	sp, r7
 8006bb8:	bd80      	pop	{r7, pc}

08006bba <_ZN3app24AccelerometerApplication16svSyncIndicationEm>:

/**
 * Called by the network after reception of a beacon frame from gateway node.
 */
void AccelerometerApplication::svSyncIndication(NetworkTime time)
{
 8006bba:	b580      	push	{r7, lr}
 8006bbc:	b082      	sub	sp, #8
 8006bbe:	af00      	add	r7, sp, #0
 8006bc0:	6078      	str	r0, [r7, #4]
 8006bc2:	6039      	str	r1, [r7, #0]
// Using the state machine to read accelerometer values does not work for the moment. To
// let it work with it, NetworkEntity must also implement a state machine and call
// svPublishIndication()'s asynchronously!

	// For the moment, read accelerator values directly here
	_readAccelerometerValues();
 8006bc4:	6878      	ldr	r0, [r7, #4]
 8006bc6:	f000 f89f 	bl	8006d08 <_ZN3app24AccelerometerApplication24_readAccelerometerValuesEv>
}
 8006bca:	bf00      	nop
 8006bcc:	3708      	adds	r7, #8
 8006bce:	46bd      	mov	sp, r7
 8006bd0:	bd80      	pop	{r7, pc}

08006bd2 <_ZThn12_N3app24AccelerometerApplication16svSyncIndicationEm>:
	void initialize();
	void start();

	// desenet::AbstractApplication callback implementation
protected:
	virtual void svSyncIndication(NetworkTime time);
 8006bd2:	f1a0 000c 	sub.w	r0, r0, #12
 8006bd6:	f7ff bff0 	b.w	8006bba <_ZN3app24AccelerometerApplication16svSyncIndicationEm>

08006bda <_ZN3app24AccelerometerApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE>:

desenet::SharedByteBuffer::sizeType AccelerometerApplication::svPublishIndication(desenet::SvGroup group, desenet::SharedByteBuffer & svData)
{
 8006bda:	b580      	push	{r7, lr}
 8006bdc:	b084      	sub	sp, #16
 8006bde:	af00      	add	r7, sp, #0
 8006be0:	60f8      	str	r0, [r7, #12]
 8006be2:	460b      	mov	r3, r1
 8006be4:	607a      	str	r2, [r7, #4]
 8006be6:	72fb      	strb	r3, [r7, #11]
	if (group == MY_GROUP)
 8006be8:	68fb      	ldr	r3, [r7, #12]
 8006bea:	7c5b      	ldrb	r3, [r3, #17]
 8006bec:	7afa      	ldrb	r2, [r7, #11]
 8006bee:	429a      	cmp	r2, r3
 8006bf0:	d11f      	bne.n	8006c32 <_ZN3app24AccelerometerApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE+0x58>
	{
		memcpy(&svData[0], &_accelValuesSyncArray[0], 2);
 8006bf2:	2100      	movs	r1, #0
 8006bf4:	6878      	ldr	r0, [r7, #4]
 8006bf6:	f000 f8d1 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8006bfa:	4602      	mov	r2, r0
 8006bfc:	68fb      	ldr	r3, [r7, #12]
 8006bfe:	3312      	adds	r3, #18
 8006c00:	881b      	ldrh	r3, [r3, #0]
 8006c02:	b29b      	uxth	r3, r3
 8006c04:	8013      	strh	r3, [r2, #0]
		memcpy(&svData[2], &_accelValuesSyncArray[1], 2);
 8006c06:	2102      	movs	r1, #2
 8006c08:	6878      	ldr	r0, [r7, #4]
 8006c0a:	f000 f8c7 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8006c0e:	4602      	mov	r2, r0
 8006c10:	68fb      	ldr	r3, [r7, #12]
 8006c12:	3314      	adds	r3, #20
 8006c14:	881b      	ldrh	r3, [r3, #0]
 8006c16:	b29b      	uxth	r3, r3
 8006c18:	8013      	strh	r3, [r2, #0]
		memcpy(&svData[4], &_accelValuesSyncArray[2], 2);
 8006c1a:	2104      	movs	r1, #4
 8006c1c:	6878      	ldr	r0, [r7, #4]
 8006c1e:	f000 f8bd 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8006c22:	4602      	mov	r2, r0
 8006c24:	68fb      	ldr	r3, [r7, #12]
 8006c26:	3316      	adds	r3, #22
 8006c28:	881b      	ldrh	r3, [r3, #0]
 8006c2a:	b29b      	uxth	r3, r3
 8006c2c:	8013      	strh	r3, [r2, #0]

		return sizeof(_accelValuesSyncArray);
 8006c2e:	2306      	movs	r3, #6
 8006c30:	e000      	b.n	8006c34 <_ZN3app24AccelerometerApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE+0x5a>
	}
	return 0;
 8006c32:	2300      	movs	r3, #0
}
 8006c34:	4618      	mov	r0, r3
 8006c36:	3710      	adds	r7, #16
 8006c38:	46bd      	mov	sp, r7
 8006c3a:	bd80      	pop	{r7, pc}

08006c3c <_ZThn12_N3app24AccelerometerApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE>:
	virtual desenet::SharedByteBuffer::sizeType svPublishIndication(desenet::SvGroup group, desenet::SharedByteBuffer & svData);
 8006c3c:	f1a0 000c 	sub.w	r0, r0, #12
 8006c40:	f7ff bfcb 	b.w	8006bda <_ZN3app24AccelerometerApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE>

08006c44 <_ZN3app24AccelerometerApplication12processEventEv>:

EventStatus AccelerometerApplication::processEvent()
{
 8006c44:	b580      	push	{r7, lr}
 8006c46:	b084      	sub	sp, #16
 8006c48:	af00      	add	r7, sp, #0
 8006c4a:	6078      	str	r0, [r7, #4]
	eMainState newState = _currentState;
 8006c4c:	687b      	ldr	r3, [r7, #4]
 8006c4e:	7c1b      	ldrb	r3, [r3, #16]
 8006c50:	73fb      	strb	r3, [r7, #15]

	switch (_currentState)
 8006c52:	687b      	ldr	r3, [r7, #4]
 8006c54:	7c1b      	ldrb	r3, [r3, #16]
 8006c56:	2b01      	cmp	r3, #1
 8006c58:	dc02      	bgt.n	8006c60 <_ZN3app24AccelerometerApplication12processEventEv+0x1c>
 8006c5a:	2b00      	cmp	r3, #0
 8006c5c:	da03      	bge.n	8006c66 <_ZN3app24AccelerometerApplication12processEventEv+0x22>
 8006c5e:	e036      	b.n	8006cce <_ZN3app24AccelerometerApplication12processEventEv+0x8a>
 8006c60:	2b02      	cmp	r3, #2
 8006c62:	d013      	beq.n	8006c8c <_ZN3app24AccelerometerApplication12processEventEv+0x48>
 8006c64:	e033      	b.n	8006cce <_ZN3app24AccelerometerApplication12processEventEv+0x8a>
	{
	case STATE_UNKOWN:
	case STATE_INITIAL:
		if (getCurrentEvent()->getEventType() == IXFEvent::Initial)
 8006c66:	687b      	ldr	r3, [r7, #4]
 8006c68:	4618      	mov	r0, r3
 8006c6a:	f00d fb39 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8006c6e:	4603      	mov	r3, r0
 8006c70:	4618      	mov	r0, r3
 8006c72:	f7ff fe96 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 8006c76:	4603      	mov	r3, r0
 8006c78:	2b01      	cmp	r3, #1
 8006c7a:	bf0c      	ite	eq
 8006c7c:	2301      	moveq	r3, #1
 8006c7e:	2300      	movne	r3, #0
 8006c80:	b2db      	uxtb	r3, r3
 8006c82:	2b00      	cmp	r3, #0
 8006c84:	d020      	beq.n	8006cc8 <_ZN3app24AccelerometerApplication12processEventEv+0x84>
		{
			newState = STATE_ROOT;	// Move to state ROOT
 8006c86:	2302      	movs	r3, #2
 8006c88:	73fb      	strb	r3, [r7, #15]
		}
		break;
 8006c8a:	e01d      	b.n	8006cc8 <_ZN3app24AccelerometerApplication12processEventEv+0x84>
	case STATE_ROOT:
		if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 8006c8c:	687b      	ldr	r3, [r7, #4]
 8006c8e:	4618      	mov	r0, r3
 8006c90:	f00d fb26 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8006c94:	4603      	mov	r3, r0
 8006c96:	4618      	mov	r0, r3
 8006c98:	f7ff fe83 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 8006c9c:	4603      	mov	r3, r0
 8006c9e:	2b03      	cmp	r3, #3
 8006ca0:	d10c      	bne.n	8006cbc <_ZN3app24AccelerometerApplication12processEventEv+0x78>
			getCurrentEvent()->getId() == EV_SV_SYNC_id)
 8006ca2:	687b      	ldr	r3, [r7, #4]
 8006ca4:	4618      	mov	r0, r3
 8006ca6:	f00d fb1b 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8006caa:	4603      	mov	r3, r0
 8006cac:	4618      	mov	r0, r3
 8006cae:	f7ff fe85 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 8006cb2:	4603      	mov	r3, r0
		if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 8006cb4:	2b01      	cmp	r3, #1
 8006cb6:	d101      	bne.n	8006cbc <_ZN3app24AccelerometerApplication12processEventEv+0x78>
 8006cb8:	2301      	movs	r3, #1
 8006cba:	e000      	b.n	8006cbe <_ZN3app24AccelerometerApplication12processEventEv+0x7a>
 8006cbc:	2300      	movs	r3, #0
 8006cbe:	2b00      	cmp	r3, #0
 8006cc0:	d004      	beq.n	8006ccc <_ZN3app24AccelerometerApplication12processEventEv+0x88>
		{
			newState = STATE_ROOT;	// Stay in state
 8006cc2:	2302      	movs	r3, #2
 8006cc4:	73fb      	strb	r3, [r7, #15]
#if (ACCELEROMETER_APP_VERBOSE != 0)
			// Show actual accelerometer values
			Trace::outln("App: acc (%5d, %5d, %5d)", _accelValuesSyncArray[0], _accelValuesSyncArray[1], _accelValuesSyncArray[2]);
#endif
		}
		break;
 8006cc6:	e001      	b.n	8006ccc <_ZN3app24AccelerometerApplication12processEventEv+0x88>
		break;
 8006cc8:	bf00      	nop
 8006cca:	e000      	b.n	8006cce <_ZN3app24AccelerometerApplication12processEventEv+0x8a>
		break;
 8006ccc:	bf00      	nop
	}

	_currentState = newState;		// Save new state to actual
 8006cce:	687b      	ldr	r3, [r7, #4]
 8006cd0:	7bfa      	ldrb	r2, [r7, #15]
 8006cd2:	741a      	strb	r2, [r3, #16]

	return EventStatus::Consumed;	// We consume all given events/timeouts
 8006cd4:	f107 030c 	add.w	r3, r7, #12
 8006cd8:	2101      	movs	r1, #1
 8006cda:	4618      	mov	r0, r3
 8006cdc:	f7ff fe7a 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 8006ce0:	7b3b      	ldrb	r3, [r7, #12]
}
 8006ce2:	4618      	mov	r0, r3
 8006ce4:	3710      	adds	r7, #16
 8006ce6:	46bd      	mov	sp, r7
 8006ce8:	bd80      	pop	{r7, pc}

08006cea <_ZN3app24AccelerometerApplication13accelerometerEv>:

board::Accelerometer & AccelerometerApplication::accelerometer()
{
 8006cea:	b580      	push	{r7, lr}
 8006cec:	b082      	sub	sp, #8
 8006cee:	af00      	add	r7, sp, #0
 8006cf0:	6078      	str	r0, [r7, #4]
	return Factory::instance().accelerometer();
 8006cf2:	f7ff fec7 	bl	8006a84 <_ZN3app7Factory8instanceEv>
 8006cf6:	4603      	mov	r3, r0
 8006cf8:	4618      	mov	r0, r3
 8006cfa:	f000 fb45 	bl	8007388 <_ZNK3app7Factory13accelerometerEv>
 8006cfe:	4603      	mov	r3, r0
}
 8006d00:	4618      	mov	r0, r3
 8006d02:	3708      	adds	r7, #8
 8006d04:	46bd      	mov	sp, r7
 8006d06:	bd80      	pop	{r7, pc}

08006d08 <_ZN3app24AccelerometerApplication24_readAccelerometerValuesEv>:

void AccelerometerApplication::_readAccelerometerValues()
{
 8006d08:	b580      	push	{r7, lr}
 8006d0a:	b082      	sub	sp, #8
 8006d0c:	af00      	add	r7, sp, #0
 8006d0e:	6078      	str	r0, [r7, #4]
	accelerometer().getAccelerationValues(_accelValuesSyncArray[0],	/* x */
 8006d10:	6878      	ldr	r0, [r7, #4]
 8006d12:	f7ff ffea 	bl	8006cea <_ZN3app24AccelerometerApplication13accelerometerEv>
 8006d16:	687b      	ldr	r3, [r7, #4]
 8006d18:	f103 0012 	add.w	r0, r3, #18
										  _accelValuesSyncArray[1],	/* x */
 8006d1c:	687b      	ldr	r3, [r7, #4]
 8006d1e:	f103 0114 	add.w	r1, r3, #20
										  _accelValuesSyncArray[2]	/* z */);
 8006d22:	687b      	ldr	r3, [r7, #4]
 8006d24:	3316      	adds	r3, #22
 8006d26:	461a      	mov	r2, r3
 8006d28:	f007 fdde 	bl	800e8e8 <_ZN5board13Accelerometer21getAccelerationValuesERsS1_S1_>
}
 8006d2c:	bf00      	nop
 8006d2e:	3708      	adds	r7, #8
 8006d30:	46bd      	mov	sp, r7
 8006d32:	bd80      	pop	{r7, pc}

08006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>:
	/**
	 * @brief Initializer-list constructor
	 *
	 * Allows to initializes an address with an array initializer.
	 */
	Address(std::initializer_list<uint8_t> from)
 8006d34:	b590      	push	{r4, r7, lr}
 8006d36:	b085      	sub	sp, #20
 8006d38:	af00      	add	r7, sp, #0
 8006d3a:	60f8      	str	r0, [r7, #12]
 8006d3c:	1d3b      	adds	r3, r7, #4
 8006d3e:	e883 0006 	stmia.w	r3, {r1, r2}
	{
 8006d42:	4a12      	ldr	r2, [pc, #72]	; (8006d8c <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE+0x58>)
 8006d44:	68fb      	ldr	r3, [r7, #12]
 8006d46:	601a      	str	r2, [r3, #0]
		assert(from.size() == size);
 8006d48:	1d3b      	adds	r3, r7, #4
 8006d4a:	4618      	mov	r0, r3
 8006d4c:	f7ff fe52 	bl	80069f4 <_ZNKSt16initializer_listIhE4sizeEv>
 8006d50:	4603      	mov	r3, r0
 8006d52:	2b04      	cmp	r3, #4
 8006d54:	d005      	beq.n	8006d62 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE+0x2e>
 8006d56:	4b0e      	ldr	r3, [pc, #56]	; (8006d90 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE+0x5c>)
 8006d58:	4a0e      	ldr	r2, [pc, #56]	; (8006d94 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE+0x60>)
 8006d5a:	2131      	movs	r1, #49	; 0x31
 8006d5c:	480e      	ldr	r0, [pc, #56]	; (8006d98 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE+0x64>)
 8006d5e:	f00f fb19 	bl	8016394 <__assert_func>
		std::copy(from.begin(), from.end(), _address);
 8006d62:	1d3b      	adds	r3, r7, #4
 8006d64:	4618      	mov	r0, r3
 8006d66:	f7ff fe51 	bl	8006a0c <_ZNKSt16initializer_listIhE5beginEv>
 8006d6a:	4604      	mov	r4, r0
 8006d6c:	1d3b      	adds	r3, r7, #4
 8006d6e:	4618      	mov	r0, r3
 8006d70:	f000 f824 	bl	8006dbc <_ZNKSt16initializer_listIhE3endEv>
 8006d74:	4601      	mov	r1, r0
 8006d76:	68fb      	ldr	r3, [r7, #12]
 8006d78:	3304      	adds	r3, #4
 8006d7a:	461a      	mov	r2, r3
 8006d7c:	4620      	mov	r0, r4
 8006d7e:	f000 f82e 	bl	8006dde <_ZSt4copyIPKhPhET0_T_S4_S3_>
	}
 8006d82:	68fb      	ldr	r3, [r7, #12]
 8006d84:	4618      	mov	r0, r3
 8006d86:	3714      	adds	r7, #20
 8006d88:	46bd      	mov	sp, r7
 8006d8a:	bd90      	pop	{r4, r7, pc}
 8006d8c:	0801b8d4 	.word	0x0801b8d4
 8006d90:	080179d0 	.word	0x080179d0
 8006d94:	080179e4 	.word	0x080179e4
 8006d98:	08017a44 	.word	0x08017a44

08006d9c <_ZN3hei12SharedBufferIhEixEj>:
         * @brief Returns a reference to the element at specified location pos. No bounds checking is performed.
         *
         * @param pos   Position of the element to return.
         * @return      Reference to the requested element.
         */
        reference operator [](sizeType pos) {
 8006d9c:	b580      	push	{r7, lr}
 8006d9e:	b082      	sub	sp, #8
 8006da0:	af00      	add	r7, sp, #0
 8006da2:	6078      	str	r0, [r7, #4]
 8006da4:	6039      	str	r1, [r7, #0]
            return data_.get()[pos];
 8006da6:	687b      	ldr	r3, [r7, #4]
 8006da8:	4618      	mov	r0, r3
 8006daa:	f000 f830 	bl	8006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>
 8006dae:	4602      	mov	r2, r0
 8006db0:	683b      	ldr	r3, [r7, #0]
 8006db2:	4413      	add	r3, r2
        }
 8006db4:	4618      	mov	r0, r3
 8006db6:	3708      	adds	r7, #8
 8006db8:	46bd      	mov	sp, r7
 8006dba:	bd80      	pop	{r7, pc}

08006dbc <_ZNKSt16initializer_listIhE3endEv>:

      // One past the last element.
      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
 8006dbc:	b590      	push	{r4, r7, lr}
 8006dbe:	b083      	sub	sp, #12
 8006dc0:	af00      	add	r7, sp, #0
 8006dc2:	6078      	str	r0, [r7, #4]
 8006dc4:	6878      	ldr	r0, [r7, #4]
 8006dc6:	f7ff fe21 	bl	8006a0c <_ZNKSt16initializer_listIhE5beginEv>
 8006dca:	4604      	mov	r4, r0
 8006dcc:	6878      	ldr	r0, [r7, #4]
 8006dce:	f7ff fe11 	bl	80069f4 <_ZNKSt16initializer_listIhE4sizeEv>
 8006dd2:	4603      	mov	r3, r0
 8006dd4:	4423      	add	r3, r4
 8006dd6:	4618      	mov	r0, r3
 8006dd8:	370c      	adds	r7, #12
 8006dda:	46bd      	mov	sp, r7
 8006ddc:	bd90      	pop	{r4, r7, pc}

08006dde <_ZSt4copyIPKhPhET0_T_S4_S3_>:
   *  within [first,last).
  */
  template<typename _II, typename _OI>
    _GLIBCXX20_CONSTEXPR
    inline _OI
    copy(_II __first, _II __last, _OI __result)
 8006dde:	b590      	push	{r4, r7, lr}
 8006de0:	b085      	sub	sp, #20
 8006de2:	af00      	add	r7, sp, #0
 8006de4:	60f8      	str	r0, [r7, #12]
 8006de6:	60b9      	str	r1, [r7, #8]
 8006de8:	607a      	str	r2, [r7, #4]
      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
	    typename iterator_traits<_II>::value_type>)
      __glibcxx_requires_can_increment_range(__first, __last, __result);

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 8006dea:	68f8      	ldr	r0, [r7, #12]
 8006dec:	f000 f81b 	bl	8006e26 <_ZSt12__miter_baseIPKhET_S2_>
 8006df0:	4604      	mov	r4, r0
 8006df2:	68b8      	ldr	r0, [r7, #8]
 8006df4:	f000 f817 	bl	8006e26 <_ZSt12__miter_baseIPKhET_S2_>
 8006df8:	4603      	mov	r3, r0
 8006dfa:	687a      	ldr	r2, [r7, #4]
 8006dfc:	4619      	mov	r1, r3
 8006dfe:	4620      	mov	r0, r4
 8006e00:	f000 f81c 	bl	8006e3c <_ZSt13__copy_move_aILb0EPKhPhET1_T0_S4_S3_>
 8006e04:	4603      	mov	r3, r0
    }
 8006e06:	4618      	mov	r0, r3
 8006e08:	3714      	adds	r7, #20
 8006e0a:	46bd      	mov	sp, r7
 8006e0c:	bd90      	pop	{r4, r7, pc}

08006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>:
	reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      /// Return the stored pointer.
      element_type*
      get() const noexcept
 8006e0e:	b480      	push	{r7}
 8006e10:	b083      	sub	sp, #12
 8006e12:	af00      	add	r7, sp, #0
 8006e14:	6078      	str	r0, [r7, #4]
      { return _M_ptr; }
 8006e16:	687b      	ldr	r3, [r7, #4]
 8006e18:	681b      	ldr	r3, [r3, #0]
 8006e1a:	4618      	mov	r0, r3
 8006e1c:	370c      	adds	r7, #12
 8006e1e:	46bd      	mov	sp, r7
 8006e20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e24:	4770      	bx	lr

08006e26 <_ZSt12__miter_baseIPKhET_S2_>:
  // Fallback implementation of the function in bits/stl_iterator.h used to
  // remove the move_iterator wrapper.
  template<typename _Iterator>
    _GLIBCXX20_CONSTEXPR
    inline _Iterator
    __miter_base(_Iterator __it)
 8006e26:	b480      	push	{r7}
 8006e28:	b083      	sub	sp, #12
 8006e2a:	af00      	add	r7, sp, #0
 8006e2c:	6078      	str	r0, [r7, #4]
    { return __it; }
 8006e2e:	687b      	ldr	r3, [r7, #4]
 8006e30:	4618      	mov	r0, r3
 8006e32:	370c      	adds	r7, #12
 8006e34:	46bd      	mov	sp, r7
 8006e36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e3a:	4770      	bx	lr

08006e3c <_ZSt13__copy_move_aILb0EPKhPhET1_T0_S4_S3_>:
    __copy_move_a(_II __first, _II __last, _OI __result)
 8006e3c:	b5b0      	push	{r4, r5, r7, lr}
 8006e3e:	b084      	sub	sp, #16
 8006e40:	af00      	add	r7, sp, #0
 8006e42:	60f8      	str	r0, [r7, #12]
 8006e44:	60b9      	str	r1, [r7, #8]
 8006e46:	607a      	str	r2, [r7, #4]
      return std::__niter_wrap(__result,
 8006e48:	68f8      	ldr	r0, [r7, #12]
 8006e4a:	f000 f81a 	bl	8006e82 <_ZSt12__niter_baseIPKhET_S2_>
 8006e4e:	4604      	mov	r4, r0
 8006e50:	68b8      	ldr	r0, [r7, #8]
 8006e52:	f000 f816 	bl	8006e82 <_ZSt12__niter_baseIPKhET_S2_>
 8006e56:	4605      	mov	r5, r0
 8006e58:	687b      	ldr	r3, [r7, #4]
 8006e5a:	4618      	mov	r0, r3
 8006e5c:	f000 f81c 	bl	8006e98 <_ZSt12__niter_baseIPhET_S1_>
 8006e60:	4603      	mov	r3, r0
 8006e62:	461a      	mov	r2, r3
 8006e64:	4629      	mov	r1, r5
 8006e66:	4620      	mov	r0, r4
 8006e68:	f000 f821 	bl	8006eae <_ZSt14__copy_move_a1ILb0EPKhPhET1_T0_S4_S3_>
 8006e6c:	4602      	mov	r2, r0
 8006e6e:	1d3b      	adds	r3, r7, #4
 8006e70:	4611      	mov	r1, r2
 8006e72:	4618      	mov	r0, r3
 8006e74:	f000 f82b 	bl	8006ece <_ZSt12__niter_wrapIPhET_RKS1_S1_>
 8006e78:	4603      	mov	r3, r0
    }
 8006e7a:	4618      	mov	r0, r3
 8006e7c:	3710      	adds	r7, #16
 8006e7e:	46bd      	mov	sp, r7
 8006e80:	bdb0      	pop	{r4, r5, r7, pc}

08006e82 <_ZSt12__niter_baseIPKhET_S2_>:
    __niter_base(_Iterator __it)
 8006e82:	b480      	push	{r7}
 8006e84:	b083      	sub	sp, #12
 8006e86:	af00      	add	r7, sp, #0
 8006e88:	6078      	str	r0, [r7, #4]
    { return __it; }
 8006e8a:	687b      	ldr	r3, [r7, #4]
 8006e8c:	4618      	mov	r0, r3
 8006e8e:	370c      	adds	r7, #12
 8006e90:	46bd      	mov	sp, r7
 8006e92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e96:	4770      	bx	lr

08006e98 <_ZSt12__niter_baseIPhET_S1_>:
    __niter_base(_Iterator __it)
 8006e98:	b480      	push	{r7}
 8006e9a:	b083      	sub	sp, #12
 8006e9c:	af00      	add	r7, sp, #0
 8006e9e:	6078      	str	r0, [r7, #4]
    { return __it; }
 8006ea0:	687b      	ldr	r3, [r7, #4]
 8006ea2:	4618      	mov	r0, r3
 8006ea4:	370c      	adds	r7, #12
 8006ea6:	46bd      	mov	sp, r7
 8006ea8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006eac:	4770      	bx	lr

08006eae <_ZSt14__copy_move_a1ILb0EPKhPhET1_T0_S4_S3_>:
    __copy_move_a1(_II __first, _II __last, _OI __result)
 8006eae:	b580      	push	{r7, lr}
 8006eb0:	b084      	sub	sp, #16
 8006eb2:	af00      	add	r7, sp, #0
 8006eb4:	60f8      	str	r0, [r7, #12]
 8006eb6:	60b9      	str	r1, [r7, #8]
 8006eb8:	607a      	str	r2, [r7, #4]
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
 8006eba:	687a      	ldr	r2, [r7, #4]
 8006ebc:	68b9      	ldr	r1, [r7, #8]
 8006ebe:	68f8      	ldr	r0, [r7, #12]
 8006ec0:	f000 f811 	bl	8006ee6 <_ZSt14__copy_move_a2ILb0EPKhPhET1_T0_S4_S3_>
 8006ec4:	4603      	mov	r3, r0
 8006ec6:	4618      	mov	r0, r3
 8006ec8:	3710      	adds	r7, #16
 8006eca:	46bd      	mov	sp, r7
 8006ecc:	bd80      	pop	{r7, pc}

08006ece <_ZSt12__niter_wrapIPhET_RKS1_S1_>:
    __niter_wrap(const _Iterator&, _Iterator __res)
 8006ece:	b480      	push	{r7}
 8006ed0:	b083      	sub	sp, #12
 8006ed2:	af00      	add	r7, sp, #0
 8006ed4:	6078      	str	r0, [r7, #4]
 8006ed6:	6039      	str	r1, [r7, #0]
    { return __res; }
 8006ed8:	683b      	ldr	r3, [r7, #0]
 8006eda:	4618      	mov	r0, r3
 8006edc:	370c      	adds	r7, #12
 8006ede:	46bd      	mov	sp, r7
 8006ee0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ee4:	4770      	bx	lr

08006ee6 <_ZSt14__copy_move_a2ILb0EPKhPhET1_T0_S4_S3_>:
    __copy_move_a2(_II __first, _II __last, _OI __result)
 8006ee6:	b580      	push	{r7, lr}
 8006ee8:	b084      	sub	sp, #16
 8006eea:	af00      	add	r7, sp, #0
 8006eec:	60f8      	str	r0, [r7, #12]
 8006eee:	60b9      	str	r1, [r7, #8]
 8006ef0:	607a      	str	r2, [r7, #4]
			      _Category>::__copy_m(__first, __last, __result);
 8006ef2:	687a      	ldr	r2, [r7, #4]
 8006ef4:	68b9      	ldr	r1, [r7, #8]
 8006ef6:	68f8      	ldr	r0, [r7, #12]
 8006ef8:	f000 f805 	bl	8006f06 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIhEEPT_PKS3_S6_S4_>
 8006efc:	4603      	mov	r3, r0
    }
 8006efe:	4618      	mov	r0, r3
 8006f00:	3710      	adds	r7, #16
 8006f02:	46bd      	mov	sp, r7
 8006f04:	bd80      	pop	{r7, pc}

08006f06 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIhEEPT_PKS3_S6_S4_>:
	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 8006f06:	b580      	push	{r7, lr}
 8006f08:	b086      	sub	sp, #24
 8006f0a:	af00      	add	r7, sp, #0
 8006f0c:	60f8      	str	r0, [r7, #12]
 8006f0e:	60b9      	str	r1, [r7, #8]
 8006f10:	607a      	str	r2, [r7, #4]
	  const ptrdiff_t _Num = __last - __first;
 8006f12:	68ba      	ldr	r2, [r7, #8]
 8006f14:	68fb      	ldr	r3, [r7, #12]
 8006f16:	1ad3      	subs	r3, r2, r3
 8006f18:	617b      	str	r3, [r7, #20]
	  if (_Num)
 8006f1a:	697b      	ldr	r3, [r7, #20]
 8006f1c:	2b00      	cmp	r3, #0
 8006f1e:	d005      	beq.n	8006f2c <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIhEEPT_PKS3_S6_S4_+0x26>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
 8006f20:	697b      	ldr	r3, [r7, #20]
 8006f22:	461a      	mov	r2, r3
 8006f24:	68f9      	ldr	r1, [r7, #12]
 8006f26:	6878      	ldr	r0, [r7, #4]
 8006f28:	f00f fab2 	bl	8016490 <memmove>
	  return __result + _Num;
 8006f2c:	697b      	ldr	r3, [r7, #20]
 8006f2e:	687a      	ldr	r2, [r7, #4]
 8006f30:	4413      	add	r3, r2
	}
 8006f32:	4618      	mov	r0, r3
 8006f34:	3718      	adds	r7, #24
 8006f36:	46bd      	mov	sp, r7
 8006f38:	bd80      	pop	{r7, pc}
	...

08006f3c <_Z41__static_initialization_and_destruction_0ii>:
 8006f3c:	b580      	push	{r7, lr}
 8006f3e:	b088      	sub	sp, #32
 8006f40:	af00      	add	r7, sp, #0
 8006f42:	6078      	str	r0, [r7, #4]
 8006f44:	6039      	str	r1, [r7, #0]
 8006f46:	687b      	ldr	r3, [r7, #4]
 8006f48:	2b01      	cmp	r3, #1
 8006f4a:	d122      	bne.n	8006f92 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8006f4c:	683b      	ldr	r3, [r7, #0]
 8006f4e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006f52:	4293      	cmp	r3, r2
 8006f54:	d11d      	bne.n	8006f92 <_Z41__static_initialization_and_destruction_0ii+0x56>
#define NRFTRANSCEIVER_TRACE_VERBOSE 	1

#define DESNET_NODE_NAME				"SENSOR"

#ifdef __cplusplus
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8006f56:	4b18      	ldr	r3, [pc, #96]	; (8006fb8 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8006f58:	681b      	ldr	r3, [r3, #0]
 8006f5a:	613b      	str	r3, [r7, #16]
 8006f5c:	f107 0310 	add.w	r3, r7, #16
 8006f60:	60bb      	str	r3, [r7, #8]
 8006f62:	2304      	movs	r3, #4
 8006f64:	60fb      	str	r3, [r7, #12]
 8006f66:	f107 0308 	add.w	r3, r7, #8
 8006f6a:	e893 0006 	ldmia.w	r3, {r1, r2}
 8006f6e:	4813      	ldr	r0, [pc, #76]	; (8006fbc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8006f70:	f7ff fee0 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8006f74:	4b12      	ldr	r3, [pc, #72]	; (8006fc0 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8006f76:	681b      	ldr	r3, [r3, #0]
 8006f78:	61fb      	str	r3, [r7, #28]
 8006f7a:	f107 031c 	add.w	r3, r7, #28
 8006f7e:	617b      	str	r3, [r7, #20]
 8006f80:	2304      	movs	r3, #4
 8006f82:	61bb      	str	r3, [r7, #24]
 8006f84:	f107 0314 	add.w	r3, r7, #20
 8006f88:	e893 0006 	ldmia.w	r3, {r1, r2}
 8006f8c:	480d      	ldr	r0, [pc, #52]	; (8006fc4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8006f8e:	f7ff fed1 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8006f92:	687b      	ldr	r3, [r7, #4]
 8006f94:	2b00      	cmp	r3, #0
 8006f96:	d10a      	bne.n	8006fae <_Z41__static_initialization_and_destruction_0ii+0x72>
 8006f98:	683b      	ldr	r3, [r7, #0]
 8006f9a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006f9e:	4293      	cmp	r3, r2
 8006fa0:	d105      	bne.n	8006fae <_Z41__static_initialization_and_destruction_0ii+0x72>
 8006fa2:	4808      	ldr	r0, [pc, #32]	; (8006fc4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8006fa4:	f000 f810 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8006fa8:	4804      	ldr	r0, [pc, #16]	; (8006fbc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8006faa:	f000 f80d 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8006fae:	bf00      	nop
 8006fb0:	3720      	adds	r7, #32
 8006fb2:	46bd      	mov	sp, r7
 8006fb4:	bd80      	pop	{r7, pc}
 8006fb6:	bf00      	nop
 8006fb8:	08017ab8 	.word	0x08017ab8
 8006fbc:	2000030c 	.word	0x2000030c
 8006fc0:	08017abc 	.word	0x08017abc
 8006fc4:	20000314 	.word	0x20000314

08006fc8 <_ZN3phy7AddressILj4EED1Ev>:

	/**
	 * @brief Destructor, actually it does nothing @ all.
	 */
	virtual ~Address()
 8006fc8:	b480      	push	{r7}
 8006fca:	b083      	sub	sp, #12
 8006fcc:	af00      	add	r7, sp, #0
 8006fce:	6078      	str	r0, [r7, #4]
	{}
 8006fd0:	4a04      	ldr	r2, [pc, #16]	; (8006fe4 <_ZN3phy7AddressILj4EED1Ev+0x1c>)
 8006fd2:	687b      	ldr	r3, [r7, #4]
 8006fd4:	601a      	str	r2, [r3, #0]
 8006fd6:	687b      	ldr	r3, [r7, #4]
 8006fd8:	4618      	mov	r0, r3
 8006fda:	370c      	adds	r7, #12
 8006fdc:	46bd      	mov	sp, r7
 8006fde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fe2:	4770      	bx	lr
 8006fe4:	0801b8d4 	.word	0x0801b8d4

08006fe8 <_ZN3phy7AddressILj4EED0Ev>:
	virtual ~Address()
 8006fe8:	b580      	push	{r7, lr}
 8006fea:	b082      	sub	sp, #8
 8006fec:	af00      	add	r7, sp, #0
 8006fee:	6078      	str	r0, [r7, #4]
	{}
 8006ff0:	6878      	ldr	r0, [r7, #4]
 8006ff2:	f7ff ffe9 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8006ff6:	2108      	movs	r1, #8
 8006ff8:	6878      	ldr	r0, [r7, #4]
 8006ffa:	f00f f8d7 	bl	80161ac <_ZdlPvj>
 8006ffe:	687b      	ldr	r3, [r7, #4]
 8007000:	4618      	mov	r0, r3
 8007002:	3708      	adds	r7, #8
 8007004:	46bd      	mov	sp, r7
 8007006:	bd80      	pop	{r7, pc}

08007008 <_GLOBAL__sub_I__ZN3app24AccelerometerApplicationC2Ev>:
 8007008:	b580      	push	{r7, lr}
 800700a:	af00      	add	r7, sp, #0
 800700c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8007010:	2001      	movs	r0, #1
 8007012:	f7ff ff93 	bl	8006f3c <_Z41__static_initialization_and_destruction_0ii>
 8007016:	bd80      	pop	{r7, pc}

08007018 <_GLOBAL__sub_D__ZN3app24AccelerometerApplicationC2Ev>:
 8007018:	b580      	push	{r7, lr}
 800701a:	af00      	add	r7, sp, #0
 800701c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8007020:	2000      	movs	r0, #0
 8007022:	f7ff ff8b 	bl	8006f3c <_Z41__static_initialization_and_destruction_0ii>
 8007026:	bd80      	pop	{r7, pc}

08007028 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE>:
		 *
		 * @param x The X coordinate.
		 * @param y The Y coordinate.
		 */
		inline explicit Point( int x = 0 , int y = 0 ) : x( x ) , y( y ) {}
		inline Point(std::initializer_list<uint8_t> values)
 8007028:	b580      	push	{r7, lr}
 800702a:	b086      	sub	sp, #24
 800702c:	af00      	add	r7, sp, #0
 800702e:	60f8      	str	r0, [r7, #12]
 8007030:	1d3b      	adds	r3, r7, #4
 8007032:	e883 0006 	stmia.w	r3, {r1, r2}
		{
			assert(values.size() == 2);
 8007036:	1d3b      	adds	r3, r7, #4
 8007038:	4618      	mov	r0, r3
 800703a:	f7ff fcdb 	bl	80069f4 <_ZNKSt16initializer_listIhE4sizeEv>
 800703e:	4603      	mov	r3, r0
 8007040:	2b02      	cmp	r3, #2
 8007042:	d005      	beq.n	8007050 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE+0x28>
 8007044:	4b0d      	ldr	r3, [pc, #52]	; (800707c <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE+0x54>)
 8007046:	4a0e      	ldr	r2, [pc, #56]	; (8007080 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE+0x58>)
 8007048:	213e      	movs	r1, #62	; 0x3e
 800704a:	480e      	ldr	r0, [pc, #56]	; (8007084 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE+0x5c>)
 800704c:	f00f f9a2 	bl	8016394 <__assert_func>
			std::initializer_list<uint8_t>::const_iterator it = values.begin();
 8007050:	1d3b      	adds	r3, r7, #4
 8007052:	4618      	mov	r0, r3
 8007054:	f7ff fcda 	bl	8006a0c <_ZNKSt16initializer_listIhE5beginEv>
 8007058:	6178      	str	r0, [r7, #20]

			x = *it++;
 800705a:	697b      	ldr	r3, [r7, #20]
 800705c:	1c5a      	adds	r2, r3, #1
 800705e:	617a      	str	r2, [r7, #20]
 8007060:	781b      	ldrb	r3, [r3, #0]
 8007062:	461a      	mov	r2, r3
 8007064:	68fb      	ldr	r3, [r7, #12]
 8007066:	601a      	str	r2, [r3, #0]
			y = *it;
 8007068:	697b      	ldr	r3, [r7, #20]
 800706a:	781b      	ldrb	r3, [r3, #0]
 800706c:	461a      	mov	r2, r3
 800706e:	68fb      	ldr	r3, [r7, #12]
 8007070:	605a      	str	r2, [r3, #4]
		}
 8007072:	68fb      	ldr	r3, [r7, #12]
 8007074:	4618      	mov	r0, r3
 8007076:	3718      	adds	r7, #24
 8007078:	46bd      	mov	sp, r7
 800707a:	bd80      	pop	{r7, pc}
 800707c:	08017ac0 	.word	0x08017ac0
 8007080:	08017ad4 	.word	0x08017ad4
 8007084:	08017b1c 	.word	0x08017b1c

08007088 <_ZN5board13AccelerometerC1Ev>:
 * @brief Class interfacing the real accelerometer hardware.
 */
class Accelerometer
{
public:
	Accelerometer() {}
 8007088:	b480      	push	{r7}
 800708a:	b083      	sub	sp, #12
 800708c:	af00      	add	r7, sp, #0
 800708e:	6078      	str	r0, [r7, #4]
 8007090:	687b      	ldr	r3, [r7, #4]
 8007092:	4618      	mov	r0, r3
 8007094:	370c      	adds	r7, #12
 8007096:	46bd      	mov	sp, r7
 8007098:	f85d 7b04 	ldr.w	r7, [sp], #4
 800709c:	4770      	bx	lr

0800709e <_ZN5board13AccelerometerD1Ev>:
	~Accelerometer() {}
 800709e:	b480      	push	{r7}
 80070a0:	b083      	sub	sp, #12
 80070a2:	af00      	add	r7, sp, #0
 80070a4:	6078      	str	r0, [r7, #4]
 80070a6:	687b      	ldr	r3, [r7, #4]
 80070a8:	4618      	mov	r0, r3
 80070aa:	370c      	adds	r7, #12
 80070ac:	46bd      	mov	sp, r7
 80070ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070b2:	4770      	bx	lr

080070b4 <_ZN9Clockwork10initializeEv>:
{
public:
	Clockwork();
	~Clockwork();

	void initialize() {}
 80070b4:	b480      	push	{r7}
 80070b6:	b083      	sub	sp, #12
 80070b8:	af00      	add	r7, sp, #0
 80070ba:	6078      	str	r0, [r7, #4]
 80070bc:	bf00      	nop
 80070be:	370c      	adds	r7, #12
 80070c0:	46bd      	mov	sp, r7
 80070c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070c6:	4770      	bx	lr

080070c8 <_ZN3app7FactoryC1EiPPc>:

namespace app {

Factory * Factory::_pInstance(nullptr);

Factory::Factory(int argc, char ** argv)
 80070c8:	b580      	push	{r7, lr}
 80070ca:	b086      	sub	sp, #24
 80070cc:	af00      	add	r7, sp, #0
 80070ce:	60f8      	str	r0, [r7, #12]
 80070d0:	60b9      	str	r1, [r7, #8]
 80070d2:	607a      	str	r2, [r7, #4]
{
    (void)(argc); (void)(argv);

    assert(!_pInstance);
 80070d4:	4b11      	ldr	r3, [pc, #68]	; (800711c <_ZN3app7FactoryC1EiPPc+0x54>)
 80070d6:	681b      	ldr	r3, [r3, #0]
 80070d8:	2b00      	cmp	r3, #0
 80070da:	d005      	beq.n	80070e8 <_ZN3app7FactoryC1EiPPc+0x20>
 80070dc:	4b10      	ldr	r3, [pc, #64]	; (8007120 <_ZN3app7FactoryC1EiPPc+0x58>)
 80070de:	4a11      	ldr	r2, [pc, #68]	; (8007124 <_ZN3app7FactoryC1EiPPc+0x5c>)
 80070e0:	211e      	movs	r1, #30
 80070e2:	4811      	ldr	r0, [pc, #68]	; (8007128 <_ZN3app7FactoryC1EiPPc+0x60>)
 80070e4:	f00f f956 	bl	8016394 <__assert_func>
    _pInstance = this;
 80070e8:	4a0c      	ldr	r2, [pc, #48]	; (800711c <_ZN3app7FactoryC1EiPPc+0x54>)
 80070ea:	68fb      	ldr	r3, [r7, #12]
 80070ec:	6013      	str	r3, [r2, #0]
        }
    }
#endif // TC_MESHSIM
#ifdef TC_STM32CUBEIDE
    // Update slot number according to the buttons pressed on the navigation switch
    IJoystick::PressedButtons pressedButtons = board::Joystick::instance().navigationButtons();
 80070ee:	f007 fe25 	bl	800ed3c <_ZN5board8Joystick8instanceEv>
 80070f2:	4603      	mov	r3, r0
 80070f4:	4618      	mov	r0, r3
 80070f6:	f007 fe5b 	bl	800edb0 <_ZNK5board8Joystick17navigationButtonsEv>
 80070fa:	6178      	str	r0, [r7, #20]

    pressedButtons >>= 1;       // Shift into the range of 'Left' to 'center pressed'
 80070fc:	697b      	ldr	r3, [r7, #20]
 80070fe:	085b      	lsrs	r3, r3, #1
 8007100:	617b      	str	r3, [r7, #20]
    if (pressedButtons != 0)    // Apply only if at least one button is pressed
 8007102:	697b      	ldr	r3, [r7, #20]
 8007104:	2b00      	cmp	r3, #0
 8007106:	d003      	beq.n	8007110 <_ZN3app7FactoryC1EiPPc+0x48>
    {
        __SLOT_NUMBER = pressedButtons;
 8007108:	697b      	ldr	r3, [r7, #20]
 800710a:	b2da      	uxtb	r2, r3
 800710c:	4b07      	ldr	r3, [pc, #28]	; (800712c <_ZN3app7FactoryC1EiPPc+0x64>)
 800710e:	701a      	strb	r2, [r3, #0]
    }
#endif // TC_STM32CUBEIDE
}
 8007110:	68fb      	ldr	r3, [r7, #12]
 8007112:	4618      	mov	r0, r3
 8007114:	3718      	adds	r7, #24
 8007116:	46bd      	mov	sp, r7
 8007118:	bd80      	pop	{r7, pc}
 800711a:	bf00      	nop
 800711c:	2000032c 	.word	0x2000032c
 8007120:	08017c58 	.word	0x08017c58
 8007124:	08017c64 	.word	0x08017c64
 8007128:	08017c88 	.word	0x08017c88
 800712c:	20000009 	.word	0x20000009

08007130 <_ZN3app7Factory16buildApplicationEv>:

void Factory::buildApplication()
{
 8007130:	b5b0      	push	{r4, r5, r7, lr}
 8007132:	b094      	sub	sp, #80	; 0x50
 8007134:	af00      	add	r7, sp, #0
 8007136:	6078      	str	r0, [r7, #4]
    board::initialize();	// Initialize board specific stuff
 8007138:	f007 fd0a 	bl	800eb50 <_ZN5board10initializeEv>

    Trace::outln("");
 800713c:	4866      	ldr	r0, [pc, #408]	; (80072d8 <_ZN3app7Factory16buildApplicationEv+0x1a8>)
 800713e:	f008 fa85 	bl	800f64c <_ZN5Trace5outlnEPKcz>
    Trace::outln("---------------------------------------------");
 8007142:	4866      	ldr	r0, [pc, #408]	; (80072dc <_ZN3app7Factory16buildApplicationEv+0x1ac>)
 8007144:	f008 fa82 	bl	800f64c <_ZN5Trace5outlnEPKcz>
    Trace::outln("-- Starting Desenet %s                 --", DESNET_NODE_NAME);
 8007148:	4965      	ldr	r1, [pc, #404]	; (80072e0 <_ZN3app7Factory16buildApplicationEv+0x1b0>)
 800714a:	4866      	ldr	r0, [pc, #408]	; (80072e4 <_ZN3app7Factory16buildApplicationEv+0x1b4>)
 800714c:	f008 fa7e 	bl	800f64c <_ZN5Trace5outlnEPKcz>
    Trace::outln("-- Compiled: %s %s          --", __DATE__, __TIME__);
 8007150:	4a65      	ldr	r2, [pc, #404]	; (80072e8 <_ZN3app7Factory16buildApplicationEv+0x1b8>)
 8007152:	4966      	ldr	r1, [pc, #408]	; (80072ec <_ZN3app7Factory16buildApplicationEv+0x1bc>)
 8007154:	4866      	ldr	r0, [pc, #408]	; (80072f0 <_ZN3app7Factory16buildApplicationEv+0x1c0>)
 8007156:	f008 fa79 	bl	800f64c <_ZN5Trace5outlnEPKcz>
    Trace::outln("---------------------------------------------");
 800715a:	4860      	ldr	r0, [pc, #384]	; (80072dc <_ZN3app7Factory16buildApplicationEv+0x1ac>)
 800715c:	f008 fa76 	bl	800f64c <_ZN5Trace5outlnEPKcz>
    // Initialize objects
    //
#ifdef TC_MESHSIM
    meshSimBoard().initialize();
#endif // TC_MESHSIM
    ledController().initialize();
 8007160:	6878      	ldr	r0, [r7, #4]
 8007162:	f000 f9fd 	bl	8007560 <_ZNK3app7Factory13ledControllerEv>
 8007166:	4603      	mov	r3, r0
 8007168:	4618      	mov	r0, r3
 800716a:	f008 f96b 	bl	800f444 <_ZN5board13LedController10initializeEv>
    clockwork().initialize();
 800716e:	6878      	ldr	r0, [r7, #4]
 8007170:	f000 f9c4 	bl	80074fc <_ZNK3app7Factory9clockworkEv>
 8007174:	4603      	mov	r3, r0
 8007176:	4618      	mov	r0, r3
 8007178:	f7ff ff9c 	bl	80070b4 <_ZN9Clockwork10initializeEv>
    accelerometer().initialize();
 800717c:	6878      	ldr	r0, [r7, #4]
 800717e:	f000 f903 	bl	8007388 <_ZNK3app7Factory13accelerometerEv>
 8007182:	4603      	mov	r3, r0
 8007184:	4618      	mov	r0, r3
 8007186:	f007 fbdf 	bl	800e948 <_ZN5board13Accelerometer10initializeEv>
    net().initialize(__SLOT_NUMBER);
 800718a:	6878      	ldr	r0, [r7, #4]
 800718c:	f000 f97c 	bl	8007488 <_ZNK3app7Factory3netEv>
 8007190:	4603      	mov	r3, r0
 8007192:	4958      	ldr	r1, [pc, #352]	; (80072f4 <_ZN3app7Factory16buildApplicationEv+0x1c4>)
 8007194:	4618      	mov	r0, r3
 8007196:	f003 fe1f 	bl	800add8 <_ZN7desenet6sensor3Net10initializeERKh>
#ifdef USE_DISPLAY
    display().initialize();
 800719a:	6878      	ldr	r0, [r7, #4]
 800719c:	f000 f9f4 	bl	8007588 <_ZN3app7Factory7displayEv>
 80071a0:	4603      	mov	r3, r0
 80071a2:	681a      	ldr	r2, [r3, #0]
 80071a4:	3210      	adds	r2, #16
 80071a6:	6812      	ldr	r2, [r2, #0]
 80071a8:	4618      	mov	r0, r3
 80071aa:	4790      	blx	r2
#endif // USE_DISPLAY

    // Initialize applications
    accelerometerApplication().initialize();
 80071ac:	6878      	ldr	r0, [r7, #4]
 80071ae:	f000 f8b1 	bl	8007314 <_ZNK3app7Factory24accelerometerApplicationEv>
 80071b2:	4603      	mov	r3, r0
 80071b4:	4618      	mov	r0, r3
 80071b6:	f7ff fcdb 	bl	8006b70 <_ZN3app24AccelerometerApplication10initializeEv>
    joystick().initialize();
 80071ba:	6878      	ldr	r0, [r7, #4]
 80071bc:	f000 f950 	bl	8007460 <_ZNK3app7Factory8joystickEv>
 80071c0:	4603      	mov	r3, r0
 80071c2:	681a      	ldr	r2, [r3, #0]
 80071c4:	3208      	adds	r2, #8
 80071c6:	6812      	ldr	r2, [r2, #0]
 80071c8:	4618      	mov	r0, r3
 80071ca:	4790      	blx	r2

    // Initialize relations
    joystick().setObserver(&joystickApplication());     // set joystick observer
 80071cc:	6878      	ldr	r0, [r7, #4]
 80071ce:	f000 f947 	bl	8007460 <_ZNK3app7Factory8joystickEv>
 80071d2:	4604      	mov	r4, r0
 80071d4:	6823      	ldr	r3, [r4, #0]
 80071d6:	330c      	adds	r3, #12
 80071d8:	681d      	ldr	r5, [r3, #0]
 80071da:	6878      	ldr	r0, [r7, #4]
 80071dc:	f000 f90e 	bl	80073fc <_ZNK3app7Factory19joystickApplicationEv>
 80071e0:	4603      	mov	r3, r0
 80071e2:	4619      	mov	r1, r3
 80071e4:	4620      	mov	r0, r4
 80071e6:	47a8      	blx	r5

#ifdef USE_DISPLAY
    char str[32];
    display().clear();
 80071e8:	6878      	ldr	r0, [r7, #4]
 80071ea:	f000 f9cd 	bl	8007588 <_ZN3app7Factory7displayEv>
 80071ee:	4603      	mov	r3, r0
 80071f0:	4618      	mov	r0, r3
 80071f2:	f009 fd05 	bl	8010c00 <_ZN13SimpleDisplay5clearEv>
#ifdef TC_STM32CUBEIDE
// Supporting for the moment two different display types:
// ePaper Display on Nucleo board
    // Draw title on display
    display().drawText(DESNET_NODE_NAME, 46, 2);
 80071f6:	6878      	ldr	r0, [r7, #4]
 80071f8:	f000 f9c6 	bl	8007588 <_ZN3app7Factory7displayEv>
 80071fc:	2302      	movs	r3, #2
 80071fe:	222e      	movs	r2, #46	; 0x2e
 8007200:	4937      	ldr	r1, [pc, #220]	; (80072e0 <_ZN3app7Factory16buildApplicationEv+0x1b0>)
 8007202:	f009 fd1d 	bl	8010c40 <_ZN13SimpleDisplay8drawTextEPKctt>
    display().drawLine({5, 50}, {SimpleDisplay::X_MAX - 5, 50});
 8007206:	6878      	ldr	r0, [r7, #4]
 8007208:	f000 f9be 	bl	8007588 <_ZN3app7Factory7displayEv>
 800720c:	4604      	mov	r4, r0
 800720e:	4b3a      	ldr	r3, [pc, #232]	; (80072f8 <_ZN3app7Factory16buildApplicationEv+0x1c8>)
 8007210:	881b      	ldrh	r3, [r3, #0]
 8007212:	873b      	strh	r3, [r7, #56]	; 0x38
 8007214:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8007218:	633b      	str	r3, [r7, #48]	; 0x30
 800721a:	2302      	movs	r3, #2
 800721c:	637b      	str	r3, [r7, #52]	; 0x34
 800721e:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8007222:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007226:	e893 0006 	ldmia.w	r3, {r1, r2}
 800722a:	f7ff fefd 	bl	8007028 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE>
 800722e:	4b33      	ldr	r3, [pc, #204]	; (80072fc <_ZN3app7Factory16buildApplicationEv+0x1cc>)
 8007230:	881b      	ldrh	r3, [r3, #0]
 8007232:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 8007236:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800723a:	647b      	str	r3, [r7, #68]	; 0x44
 800723c:	2302      	movs	r3, #2
 800723e:	64bb      	str	r3, [r7, #72]	; 0x48
 8007240:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8007244:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8007248:	e893 0006 	ldmia.w	r3, {r1, r2}
 800724c:	f7ff feec 	bl	8007028 <_ZN18IMonochromeDisplay5PointC1ESt16initializer_listIhE>
 8007250:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 8007254:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007258:	4619      	mov	r1, r3
 800725a:	4620      	mov	r0, r4
 800725c:	f009 fd3f 	bl	8010cde <_ZN13SimpleDisplay8drawLineERKN18IMonochromeDisplay5PointES3_>
    sprintf(str, "Slot #: %d", __SLOT_NUMBER);
 8007260:	4b24      	ldr	r3, [pc, #144]	; (80072f4 <_ZN3app7Factory16buildApplicationEv+0x1c4>)
 8007262:	781b      	ldrb	r3, [r3, #0]
 8007264:	461a      	mov	r2, r3
 8007266:	f107 0308 	add.w	r3, r7, #8
 800726a:	4925      	ldr	r1, [pc, #148]	; (8007300 <_ZN3app7Factory16buildApplicationEv+0x1d0>)
 800726c:	4618      	mov	r0, r3
 800726e:	f00f fd87 	bl	8016d80 <siprintf>
    display().drawText(str, 5, 10);
 8007272:	6878      	ldr	r0, [r7, #4]
 8007274:	f000 f988 	bl	8007588 <_ZN3app7Factory7displayEv>
 8007278:	f107 0108 	add.w	r1, r7, #8
 800727c:	230a      	movs	r3, #10
 800727e:	2205      	movs	r2, #5
 8007280:	f009 fcde 	bl	8010c40 <_ZN13SimpleDisplay8drawTextEPKctt>
#endif // USE_DISPLAY

    //
    // Start threads and state-machines
    //
    ledController().start();
 8007284:	6878      	ldr	r0, [r7, #4]
 8007286:	f000 f96b 	bl	8007560 <_ZNK3app7Factory13ledControllerEv>
 800728a:	4603      	mov	r3, r0
 800728c:	4618      	mov	r0, r3
 800728e:	f008 f8ee 	bl	800f46e <_ZN5board13LedController5startEv>
    clockwork().start();
 8007292:	6878      	ldr	r0, [r7, #4]
 8007294:	f000 f932 	bl	80074fc <_ZNK3app7Factory9clockworkEv>
 8007298:	4603      	mov	r3, r0
 800729a:	4618      	mov	r0, r3
 800729c:	f001 f866 	bl	800836c <_ZN9Clockwork5startEv>
    net().start();
 80072a0:	6878      	ldr	r0, [r7, #4]
 80072a2:	f000 f8f1 	bl	8007488 <_ZNK3app7Factory3netEv>
 80072a6:	4603      	mov	r3, r0
 80072a8:	4618      	mov	r0, r3
 80072aa:	f003 fdf3 	bl	800ae94 <_ZN7desenet6sensor3Net5startEv>
    accelerometerApplication().start();
 80072ae:	6878      	ldr	r0, [r7, #4]
 80072b0:	f000 f830 	bl	8007314 <_ZNK3app7Factory24accelerometerApplicationEv>
 80072b4:	4603      	mov	r3, r0
 80072b6:	4618      	mov	r0, r3
 80072b8:	f7ff fc70 	bl	8006b9c <_ZN3app24AccelerometerApplication5startEv>
    joystick().start();                     // this is not forcingly necessary because Joystick::start() is empty!
 80072bc:	6878      	ldr	r0, [r7, #4]
 80072be:	f000 f8cf 	bl	8007460 <_ZNK3app7Factory8joystickEv>
 80072c2:	4603      	mov	r3, r0
 80072c4:	681a      	ldr	r2, [r3, #0]
 80072c6:	3210      	adds	r2, #16
 80072c8:	6812      	ldr	r2, [r2, #0]
 80072ca:	4618      	mov	r0, r3
 80072cc:	4790      	blx	r2
}
 80072ce:	bf00      	nop
 80072d0:	3750      	adds	r7, #80	; 0x50
 80072d2:	46bd      	mov	sp, r7
 80072d4:	bdb0      	pop	{r4, r5, r7, pc}
 80072d6:	bf00      	nop
 80072d8:	08017cec 	.word	0x08017cec
 80072dc:	08017cf0 	.word	0x08017cf0
 80072e0:	08017d20 	.word	0x08017d20
 80072e4:	08017d28 	.word	0x08017d28
 80072e8:	08017d54 	.word	0x08017d54
 80072ec:	08017d60 	.word	0x08017d60
 80072f0:	08017d6c 	.word	0x08017d6c
 80072f4:	20000009 	.word	0x20000009
 80072f8:	08017d98 	.word	0x08017d98
 80072fc:	08017d9c 	.word	0x08017d9c
 8007300:	08017d8c 	.word	0x08017d8c

08007304 <__tcf_0>:
}
#endif // TC_MESHSIM

app::AccelerometerApplication & Factory::accelerometerApplication() const
{
    static app::AccelerometerApplication accelerometerApp;
 8007304:	b580      	push	{r7, lr}
 8007306:	af00      	add	r7, sp, #0
 8007308:	4801      	ldr	r0, [pc, #4]	; (8007310 <__tcf_0+0xc>)
 800730a:	f7ff fbfd 	bl	8006b08 <_ZN3app24AccelerometerApplicationD1Ev>
 800730e:	bd80      	pop	{r7, pc}
 8007310:	20000330 	.word	0x20000330

08007314 <_ZNK3app7Factory24accelerometerApplicationEv>:
{
 8007314:	b580      	push	{r7, lr}
 8007316:	b082      	sub	sp, #8
 8007318:	af00      	add	r7, sp, #0
 800731a:	6078      	str	r0, [r7, #4]
    static app::AccelerometerApplication accelerometerApp;
 800731c:	4b13      	ldr	r3, [pc, #76]	; (800736c <_ZNK3app7Factory24accelerometerApplicationEv+0x58>)
 800731e:	781b      	ldrb	r3, [r3, #0]
 8007320:	f3bf 8f5b 	dmb	ish
 8007324:	b2db      	uxtb	r3, r3
 8007326:	f003 0301 	and.w	r3, r3, #1
 800732a:	2b00      	cmp	r3, #0
 800732c:	bf0c      	ite	eq
 800732e:	2301      	moveq	r3, #1
 8007330:	2300      	movne	r3, #0
 8007332:	b2db      	uxtb	r3, r3
 8007334:	2b00      	cmp	r3, #0
 8007336:	d013      	beq.n	8007360 <_ZNK3app7Factory24accelerometerApplicationEv+0x4c>
 8007338:	480c      	ldr	r0, [pc, #48]	; (800736c <_ZNK3app7Factory24accelerometerApplicationEv+0x58>)
 800733a:	f00e ff3b 	bl	80161b4 <__cxa_guard_acquire>
 800733e:	4603      	mov	r3, r0
 8007340:	2b00      	cmp	r3, #0
 8007342:	bf14      	ite	ne
 8007344:	2301      	movne	r3, #1
 8007346:	2300      	moveq	r3, #0
 8007348:	b2db      	uxtb	r3, r3
 800734a:	2b00      	cmp	r3, #0
 800734c:	d008      	beq.n	8007360 <_ZNK3app7Factory24accelerometerApplicationEv+0x4c>
 800734e:	4808      	ldr	r0, [pc, #32]	; (8007370 <_ZNK3app7Factory24accelerometerApplicationEv+0x5c>)
 8007350:	f7ff fbb0 	bl	8006ab4 <_ZN3app24AccelerometerApplicationC1Ev>
 8007354:	4807      	ldr	r0, [pc, #28]	; (8007374 <_ZNK3app7Factory24accelerometerApplicationEv+0x60>)
 8007356:	f00f f83b 	bl	80163d0 <atexit>
 800735a:	4804      	ldr	r0, [pc, #16]	; (800736c <_ZNK3app7Factory24accelerometerApplicationEv+0x58>)
 800735c:	f00e ff36 	bl	80161cc <__cxa_guard_release>

    return accelerometerApp;
 8007360:	4b03      	ldr	r3, [pc, #12]	; (8007370 <_ZNK3app7Factory24accelerometerApplicationEv+0x5c>)
}
 8007362:	4618      	mov	r0, r3
 8007364:	3708      	adds	r7, #8
 8007366:	46bd      	mov	sp, r7
 8007368:	bd80      	pop	{r7, pc}
 800736a:	bf00      	nop
 800736c:	20000348 	.word	0x20000348
 8007370:	20000330 	.word	0x20000330
 8007374:	08007305 	.word	0x08007305

08007378 <__tcf_1>:

board::Accelerometer & Factory::accelerometer() const
{
    static board::Accelerometer accelerometer;
 8007378:	b580      	push	{r7, lr}
 800737a:	af00      	add	r7, sp, #0
 800737c:	4801      	ldr	r0, [pc, #4]	; (8007384 <__tcf_1+0xc>)
 800737e:	f7ff fe8e 	bl	800709e <_ZN5board13AccelerometerD1Ev>
 8007382:	bd80      	pop	{r7, pc}
 8007384:	2000034c 	.word	0x2000034c

08007388 <_ZNK3app7Factory13accelerometerEv>:
{
 8007388:	b580      	push	{r7, lr}
 800738a:	b082      	sub	sp, #8
 800738c:	af00      	add	r7, sp, #0
 800738e:	6078      	str	r0, [r7, #4]
    static board::Accelerometer accelerometer;
 8007390:	4b13      	ldr	r3, [pc, #76]	; (80073e0 <_ZNK3app7Factory13accelerometerEv+0x58>)
 8007392:	781b      	ldrb	r3, [r3, #0]
 8007394:	f3bf 8f5b 	dmb	ish
 8007398:	b2db      	uxtb	r3, r3
 800739a:	f003 0301 	and.w	r3, r3, #1
 800739e:	2b00      	cmp	r3, #0
 80073a0:	bf0c      	ite	eq
 80073a2:	2301      	moveq	r3, #1
 80073a4:	2300      	movne	r3, #0
 80073a6:	b2db      	uxtb	r3, r3
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	d013      	beq.n	80073d4 <_ZNK3app7Factory13accelerometerEv+0x4c>
 80073ac:	480c      	ldr	r0, [pc, #48]	; (80073e0 <_ZNK3app7Factory13accelerometerEv+0x58>)
 80073ae:	f00e ff01 	bl	80161b4 <__cxa_guard_acquire>
 80073b2:	4603      	mov	r3, r0
 80073b4:	2b00      	cmp	r3, #0
 80073b6:	bf14      	ite	ne
 80073b8:	2301      	movne	r3, #1
 80073ba:	2300      	moveq	r3, #0
 80073bc:	b2db      	uxtb	r3, r3
 80073be:	2b00      	cmp	r3, #0
 80073c0:	d008      	beq.n	80073d4 <_ZNK3app7Factory13accelerometerEv+0x4c>
 80073c2:	4808      	ldr	r0, [pc, #32]	; (80073e4 <_ZNK3app7Factory13accelerometerEv+0x5c>)
 80073c4:	f7ff fe60 	bl	8007088 <_ZN5board13AccelerometerC1Ev>
 80073c8:	4807      	ldr	r0, [pc, #28]	; (80073e8 <_ZNK3app7Factory13accelerometerEv+0x60>)
 80073ca:	f00f f801 	bl	80163d0 <atexit>
 80073ce:	4804      	ldr	r0, [pc, #16]	; (80073e0 <_ZNK3app7Factory13accelerometerEv+0x58>)
 80073d0:	f00e fefc 	bl	80161cc <__cxa_guard_release>

    return accelerometer;
 80073d4:	4b03      	ldr	r3, [pc, #12]	; (80073e4 <_ZNK3app7Factory13accelerometerEv+0x5c>)
}
 80073d6:	4618      	mov	r0, r3
 80073d8:	3708      	adds	r7, #8
 80073da:	46bd      	mov	sp, r7
 80073dc:	bd80      	pop	{r7, pc}
 80073de:	bf00      	nop
 80073e0:	20000350 	.word	0x20000350
 80073e4:	2000034c 	.word	0x2000034c
 80073e8:	08007379 	.word	0x08007379

080073ec <__tcf_2>:

app::JoystickApplication & Factory::joystickApplication() const
{
    static app::JoystickApplication joystickApp;
 80073ec:	b580      	push	{r7, lr}
 80073ee:	af00      	add	r7, sp, #0
 80073f0:	4801      	ldr	r0, [pc, #4]	; (80073f8 <__tcf_2+0xc>)
 80073f2:	f000 fa45 	bl	8007880 <_ZN3app19JoystickApplicationD1Ev>
 80073f6:	bd80      	pop	{r7, pc}
 80073f8:	20000354 	.word	0x20000354

080073fc <_ZNK3app7Factory19joystickApplicationEv>:
{
 80073fc:	b580      	push	{r7, lr}
 80073fe:	b082      	sub	sp, #8
 8007400:	af00      	add	r7, sp, #0
 8007402:	6078      	str	r0, [r7, #4]
    static app::JoystickApplication joystickApp;
 8007404:	4b13      	ldr	r3, [pc, #76]	; (8007454 <_ZNK3app7Factory19joystickApplicationEv+0x58>)
 8007406:	781b      	ldrb	r3, [r3, #0]
 8007408:	f3bf 8f5b 	dmb	ish
 800740c:	b2db      	uxtb	r3, r3
 800740e:	f003 0301 	and.w	r3, r3, #1
 8007412:	2b00      	cmp	r3, #0
 8007414:	bf0c      	ite	eq
 8007416:	2301      	moveq	r3, #1
 8007418:	2300      	movne	r3, #0
 800741a:	b2db      	uxtb	r3, r3
 800741c:	2b00      	cmp	r3, #0
 800741e:	d013      	beq.n	8007448 <_ZNK3app7Factory19joystickApplicationEv+0x4c>
 8007420:	480c      	ldr	r0, [pc, #48]	; (8007454 <_ZNK3app7Factory19joystickApplicationEv+0x58>)
 8007422:	f00e fec7 	bl	80161b4 <__cxa_guard_acquire>
 8007426:	4603      	mov	r3, r0
 8007428:	2b00      	cmp	r3, #0
 800742a:	bf14      	ite	ne
 800742c:	2301      	movne	r3, #1
 800742e:	2300      	moveq	r3, #0
 8007430:	b2db      	uxtb	r3, r3
 8007432:	2b00      	cmp	r3, #0
 8007434:	d008      	beq.n	8007448 <_ZNK3app7Factory19joystickApplicationEv+0x4c>
 8007436:	4808      	ldr	r0, [pc, #32]	; (8007458 <_ZNK3app7Factory19joystickApplicationEv+0x5c>)
 8007438:	f000 f9fa 	bl	8007830 <_ZN3app19JoystickApplicationC1Ev>
 800743c:	4807      	ldr	r0, [pc, #28]	; (800745c <_ZNK3app7Factory19joystickApplicationEv+0x60>)
 800743e:	f00e ffc7 	bl	80163d0 <atexit>
 8007442:	4804      	ldr	r0, [pc, #16]	; (8007454 <_ZNK3app7Factory19joystickApplicationEv+0x58>)
 8007444:	f00e fec2 	bl	80161cc <__cxa_guard_release>

    return joystickApp;         // reference to joystick application
 8007448:	4b03      	ldr	r3, [pc, #12]	; (8007458 <_ZNK3app7Factory19joystickApplicationEv+0x5c>)
}
 800744a:	4618      	mov	r0, r3
 800744c:	3708      	adds	r7, #8
 800744e:	46bd      	mov	sp, r7
 8007450:	bd80      	pop	{r7, pc}
 8007452:	bf00      	nop
 8007454:	2000036c 	.word	0x2000036c
 8007458:	20000354 	.word	0x20000354
 800745c:	080073ed 	.word	0x080073ed

08007460 <_ZNK3app7Factory8joystickEv>:

board::Joystick & Factory::joystick() const
{
 8007460:	b580      	push	{r7, lr}
 8007462:	b082      	sub	sp, #8
 8007464:	af00      	add	r7, sp, #0
 8007466:	6078      	str	r0, [r7, #4]
    return board::Joystick::instance();     // reference to the singleton joystick object
 8007468:	f007 fc68 	bl	800ed3c <_ZN5board8Joystick8instanceEv>
 800746c:	4603      	mov	r3, r0
}
 800746e:	4618      	mov	r0, r3
 8007470:	3708      	adds	r7, #8
 8007472:	46bd      	mov	sp, r7
 8007474:	bd80      	pop	{r7, pc}
	...

08007478 <__tcf_3>:

Net & Factory::net() const
{
    static Net net;
 8007478:	b580      	push	{r7, lr}
 800747a:	af00      	add	r7, sp, #0
 800747c:	4801      	ldr	r0, [pc, #4]	; (8007484 <__tcf_3+0xc>)
 800747e:	f003 fc83 	bl	800ad88 <_ZN7desenet6sensor3NetD1Ev>
 8007482:	bd80      	pop	{r7, pc}
 8007484:	20000370 	.word	0x20000370

08007488 <_ZNK3app7Factory3netEv>:
{
 8007488:	b580      	push	{r7, lr}
 800748a:	b082      	sub	sp, #8
 800748c:	af00      	add	r7, sp, #0
 800748e:	6078      	str	r0, [r7, #4]
    static Net net;
 8007490:	4b13      	ldr	r3, [pc, #76]	; (80074e0 <_ZNK3app7Factory3netEv+0x58>)
 8007492:	781b      	ldrb	r3, [r3, #0]
 8007494:	f3bf 8f5b 	dmb	ish
 8007498:	b2db      	uxtb	r3, r3
 800749a:	f003 0301 	and.w	r3, r3, #1
 800749e:	2b00      	cmp	r3, #0
 80074a0:	bf0c      	ite	eq
 80074a2:	2301      	moveq	r3, #1
 80074a4:	2300      	movne	r3, #0
 80074a6:	b2db      	uxtb	r3, r3
 80074a8:	2b00      	cmp	r3, #0
 80074aa:	d013      	beq.n	80074d4 <_ZNK3app7Factory3netEv+0x4c>
 80074ac:	480c      	ldr	r0, [pc, #48]	; (80074e0 <_ZNK3app7Factory3netEv+0x58>)
 80074ae:	f00e fe81 	bl	80161b4 <__cxa_guard_acquire>
 80074b2:	4603      	mov	r3, r0
 80074b4:	2b00      	cmp	r3, #0
 80074b6:	bf14      	ite	ne
 80074b8:	2301      	movne	r3, #1
 80074ba:	2300      	moveq	r3, #0
 80074bc:	b2db      	uxtb	r3, r3
 80074be:	2b00      	cmp	r3, #0
 80074c0:	d008      	beq.n	80074d4 <_ZNK3app7Factory3netEv+0x4c>
 80074c2:	4808      	ldr	r0, [pc, #32]	; (80074e4 <_ZNK3app7Factory3netEv+0x5c>)
 80074c4:	f003 fc2e 	bl	800ad24 <_ZN7desenet6sensor3NetC1Ev>
 80074c8:	4807      	ldr	r0, [pc, #28]	; (80074e8 <_ZNK3app7Factory3netEv+0x60>)
 80074ca:	f00e ff81 	bl	80163d0 <atexit>
 80074ce:	4804      	ldr	r0, [pc, #16]	; (80074e0 <_ZNK3app7Factory3netEv+0x58>)
 80074d0:	f00e fe7c 	bl	80161cc <__cxa_guard_release>

    return net;
 80074d4:	4b03      	ldr	r3, [pc, #12]	; (80074e4 <_ZNK3app7Factory3netEv+0x5c>)
}
 80074d6:	4618      	mov	r0, r3
 80074d8:	3708      	adds	r7, #8
 80074da:	46bd      	mov	sp, r7
 80074dc:	bd80      	pop	{r7, pc}
 80074de:	bf00      	nop
 80074e0:	2000041c 	.word	0x2000041c
 80074e4:	20000370 	.word	0x20000370
 80074e8:	08007479 	.word	0x08007479

080074ec <__tcf_4>:

Clockwork & Factory::clockwork() const
{
    static Clockwork cw;
 80074ec:	b580      	push	{r7, lr}
 80074ee:	af00      	add	r7, sp, #0
 80074f0:	4801      	ldr	r0, [pc, #4]	; (80074f8 <__tcf_4+0xc>)
 80074f2:	f000 ff13 	bl	800831c <_ZN9ClockworkD1Ev>
 80074f6:	bd80      	pop	{r7, pc}
 80074f8:	20000420 	.word	0x20000420

080074fc <_ZNK3app7Factory9clockworkEv>:
{
 80074fc:	b580      	push	{r7, lr}
 80074fe:	b082      	sub	sp, #8
 8007500:	af00      	add	r7, sp, #0
 8007502:	6078      	str	r0, [r7, #4]
    static Clockwork cw;
 8007504:	4b13      	ldr	r3, [pc, #76]	; (8007554 <_ZNK3app7Factory9clockworkEv+0x58>)
 8007506:	781b      	ldrb	r3, [r3, #0]
 8007508:	f3bf 8f5b 	dmb	ish
 800750c:	b2db      	uxtb	r3, r3
 800750e:	f003 0301 	and.w	r3, r3, #1
 8007512:	2b00      	cmp	r3, #0
 8007514:	bf0c      	ite	eq
 8007516:	2301      	moveq	r3, #1
 8007518:	2300      	movne	r3, #0
 800751a:	b2db      	uxtb	r3, r3
 800751c:	2b00      	cmp	r3, #0
 800751e:	d013      	beq.n	8007548 <_ZNK3app7Factory9clockworkEv+0x4c>
 8007520:	480c      	ldr	r0, [pc, #48]	; (8007554 <_ZNK3app7Factory9clockworkEv+0x58>)
 8007522:	f00e fe47 	bl	80161b4 <__cxa_guard_acquire>
 8007526:	4603      	mov	r3, r0
 8007528:	2b00      	cmp	r3, #0
 800752a:	bf14      	ite	ne
 800752c:	2301      	movne	r3, #1
 800752e:	2300      	moveq	r3, #0
 8007530:	b2db      	uxtb	r3, r3
 8007532:	2b00      	cmp	r3, #0
 8007534:	d008      	beq.n	8007548 <_ZNK3app7Factory9clockworkEv+0x4c>
 8007536:	4808      	ldr	r0, [pc, #32]	; (8007558 <_ZNK3app7Factory9clockworkEv+0x5c>)
 8007538:	f000 feb6 	bl	80082a8 <_ZN9ClockworkC1Ev>
 800753c:	4807      	ldr	r0, [pc, #28]	; (800755c <_ZNK3app7Factory9clockworkEv+0x60>)
 800753e:	f00e ff47 	bl	80163d0 <atexit>
 8007542:	4804      	ldr	r0, [pc, #16]	; (8007554 <_ZNK3app7Factory9clockworkEv+0x58>)
 8007544:	f00e fe42 	bl	80161cc <__cxa_guard_release>

    return cw;
 8007548:	4b03      	ldr	r3, [pc, #12]	; (8007558 <_ZNK3app7Factory9clockworkEv+0x5c>)
}
 800754a:	4618      	mov	r0, r3
 800754c:	3708      	adds	r7, #8
 800754e:	46bd      	mov	sp, r7
 8007550:	bd80      	pop	{r7, pc}
 8007552:	bf00      	nop
 8007554:	20000440 	.word	0x20000440
 8007558:	20000420 	.word	0x20000420
 800755c:	080074ed 	.word	0x080074ed

08007560 <_ZNK3app7Factory13ledControllerEv>:

board::LedController & Factory::ledController() const
{
 8007560:	b580      	push	{r7, lr}
 8007562:	b082      	sub	sp, #8
 8007564:	af00      	add	r7, sp, #0
 8007566:	6078      	str	r0, [r7, #4]
    return board::LedController::instance();
 8007568:	f007 ff3e 	bl	800f3e8 <_ZN5board13LedController8instanceEv>
 800756c:	4603      	mov	r3, r0
}
 800756e:	4618      	mov	r0, r3
 8007570:	3708      	adds	r7, #8
 8007572:	46bd      	mov	sp, r7
 8007574:	bd80      	pop	{r7, pc}
	...

08007578 <__tcf_5>:

#ifdef USE_DISPLAY
SimpleDisplay & Factory::display()
{
    static SimpleDisplay display;
 8007578:	b580      	push	{r7, lr}
 800757a:	af00      	add	r7, sp, #0
 800757c:	4801      	ldr	r0, [pc, #4]	; (8007584 <__tcf_5+0xc>)
 800757e:	f009 fb0f 	bl	8010ba0 <_ZN13SimpleDisplayD1Ev>
 8007582:	bd80      	pop	{r7, pc}
 8007584:	20000444 	.word	0x20000444

08007588 <_ZN3app7Factory7displayEv>:
{
 8007588:	b580      	push	{r7, lr}
 800758a:	b082      	sub	sp, #8
 800758c:	af00      	add	r7, sp, #0
 800758e:	6078      	str	r0, [r7, #4]
    static SimpleDisplay display;
 8007590:	4b13      	ldr	r3, [pc, #76]	; (80075e0 <_ZN3app7Factory7displayEv+0x58>)
 8007592:	781b      	ldrb	r3, [r3, #0]
 8007594:	f3bf 8f5b 	dmb	ish
 8007598:	b2db      	uxtb	r3, r3
 800759a:	f003 0301 	and.w	r3, r3, #1
 800759e:	2b00      	cmp	r3, #0
 80075a0:	bf0c      	ite	eq
 80075a2:	2301      	moveq	r3, #1
 80075a4:	2300      	movne	r3, #0
 80075a6:	b2db      	uxtb	r3, r3
 80075a8:	2b00      	cmp	r3, #0
 80075aa:	d013      	beq.n	80075d4 <_ZN3app7Factory7displayEv+0x4c>
 80075ac:	480c      	ldr	r0, [pc, #48]	; (80075e0 <_ZN3app7Factory7displayEv+0x58>)
 80075ae:	f00e fe01 	bl	80161b4 <__cxa_guard_acquire>
 80075b2:	4603      	mov	r3, r0
 80075b4:	2b00      	cmp	r3, #0
 80075b6:	bf14      	ite	ne
 80075b8:	2301      	movne	r3, #1
 80075ba:	2300      	moveq	r3, #0
 80075bc:	b2db      	uxtb	r3, r3
 80075be:	2b00      	cmp	r3, #0
 80075c0:	d008      	beq.n	80075d4 <_ZN3app7Factory7displayEv+0x4c>
 80075c2:	4808      	ldr	r0, [pc, #32]	; (80075e4 <_ZN3app7Factory7displayEv+0x5c>)
 80075c4:	f009 fada 	bl	8010b7c <_ZN13SimpleDisplayC1Ev>
 80075c8:	4807      	ldr	r0, [pc, #28]	; (80075e8 <_ZN3app7Factory7displayEv+0x60>)
 80075ca:	f00e ff01 	bl	80163d0 <atexit>
 80075ce:	4804      	ldr	r0, [pc, #16]	; (80075e0 <_ZN3app7Factory7displayEv+0x58>)
 80075d0:	f00e fdfc 	bl	80161cc <__cxa_guard_release>

    return display;
 80075d4:	4b03      	ldr	r3, [pc, #12]	; (80075e4 <_ZN3app7Factory7displayEv+0x5c>)
}
 80075d6:	4618      	mov	r0, r3
 80075d8:	3708      	adds	r7, #8
 80075da:	46bd      	mov	sp, r7
 80075dc:	bd80      	pop	{r7, pc}
 80075de:	bf00      	nop
 80075e0:	20001810 	.word	0x20001810
 80075e4:	20000444 	.word	0x20000444
 80075e8:	08007579 	.word	0x08007579

080075ec <Factory_init>:
#endif // USE_DISPLAY

} // namespace app

void Factory_init(int argc, char ** argv)
{
 80075ec:	b580      	push	{r7, lr}
 80075ee:	b082      	sub	sp, #8
 80075f0:	af00      	add	r7, sp, #0
 80075f2:	6078      	str	r0, [r7, #4]
 80075f4:	6039      	str	r1, [r7, #0]
    static app::Factory factory(argc, argv);
 80075f6:	4b12      	ldr	r3, [pc, #72]	; (8007640 <Factory_init+0x54>)
 80075f8:	781b      	ldrb	r3, [r3, #0]
 80075fa:	f3bf 8f5b 	dmb	ish
 80075fe:	b2db      	uxtb	r3, r3
 8007600:	f003 0301 	and.w	r3, r3, #1
 8007604:	2b00      	cmp	r3, #0
 8007606:	bf0c      	ite	eq
 8007608:	2301      	moveq	r3, #1
 800760a:	2300      	movne	r3, #0
 800760c:	b2db      	uxtb	r3, r3
 800760e:	2b00      	cmp	r3, #0
 8007610:	d012      	beq.n	8007638 <Factory_init+0x4c>
 8007612:	480b      	ldr	r0, [pc, #44]	; (8007640 <Factory_init+0x54>)
 8007614:	f00e fdce 	bl	80161b4 <__cxa_guard_acquire>
 8007618:	4603      	mov	r3, r0
 800761a:	2b00      	cmp	r3, #0
 800761c:	bf14      	ite	ne
 800761e:	2301      	movne	r3, #1
 8007620:	2300      	moveq	r3, #0
 8007622:	b2db      	uxtb	r3, r3
 8007624:	2b00      	cmp	r3, #0
 8007626:	d007      	beq.n	8007638 <Factory_init+0x4c>
 8007628:	683a      	ldr	r2, [r7, #0]
 800762a:	6879      	ldr	r1, [r7, #4]
 800762c:	4805      	ldr	r0, [pc, #20]	; (8007644 <Factory_init+0x58>)
 800762e:	f7ff fd4b 	bl	80070c8 <_ZN3app7FactoryC1EiPPc>
 8007632:	4803      	ldr	r0, [pc, #12]	; (8007640 <Factory_init+0x54>)
 8007634:	f00e fdca 	bl	80161cc <__cxa_guard_release>
}
 8007638:	bf00      	nop
 800763a:	3708      	adds	r7, #8
 800763c:	46bd      	mov	sp, r7
 800763e:	bd80      	pop	{r7, pc}
 8007640:	20001818 	.word	0x20001818
 8007644:	20001814 	.word	0x20001814

08007648 <Factory_buildApplication>:

void Factory_buildApplication()
{
 8007648:	b580      	push	{r7, lr}
 800764a:	af00      	add	r7, sp, #0
    app::Factory::instance().buildApplication();
 800764c:	f7ff fa1a 	bl	8006a84 <_ZN3app7Factory8instanceEv>
 8007650:	4603      	mov	r3, r0
 8007652:	4618      	mov	r0, r3
 8007654:	f7ff fd6c 	bl	8007130 <_ZN3app7Factory16buildApplicationEv>
}
 8007658:	bf00      	nop
 800765a:	bd80      	pop	{r7, pc}

0800765c <_Z41__static_initialization_and_destruction_0ii>:
 800765c:	b580      	push	{r7, lr}
 800765e:	b088      	sub	sp, #32
 8007660:	af00      	add	r7, sp, #0
 8007662:	6078      	str	r0, [r7, #4]
 8007664:	6039      	str	r1, [r7, #0]
 8007666:	687b      	ldr	r3, [r7, #4]
 8007668:	2b01      	cmp	r3, #1
 800766a:	d122      	bne.n	80076b2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800766c:	683b      	ldr	r3, [r7, #0]
 800766e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007672:	4293      	cmp	r3, r2
 8007674:	d11d      	bne.n	80076b2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8007676:	4b18      	ldr	r3, [pc, #96]	; (80076d8 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8007678:	681b      	ldr	r3, [r3, #0]
 800767a:	613b      	str	r3, [r7, #16]
 800767c:	f107 0310 	add.w	r3, r7, #16
 8007680:	60bb      	str	r3, [r7, #8]
 8007682:	2304      	movs	r3, #4
 8007684:	60fb      	str	r3, [r7, #12]
 8007686:	f107 0308 	add.w	r3, r7, #8
 800768a:	e893 0006 	ldmia.w	r3, {r1, r2}
 800768e:	4813      	ldr	r0, [pc, #76]	; (80076dc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8007690:	f7ff fb50 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8007694:	4b12      	ldr	r3, [pc, #72]	; (80076e0 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8007696:	681b      	ldr	r3, [r3, #0]
 8007698:	61fb      	str	r3, [r7, #28]
 800769a:	f107 031c 	add.w	r3, r7, #28
 800769e:	617b      	str	r3, [r7, #20]
 80076a0:	2304      	movs	r3, #4
 80076a2:	61bb      	str	r3, [r7, #24]
 80076a4:	f107 0314 	add.w	r3, r7, #20
 80076a8:	e893 0006 	ldmia.w	r3, {r1, r2}
 80076ac:	480d      	ldr	r0, [pc, #52]	; (80076e4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80076ae:	f7ff fb41 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 80076b2:	687b      	ldr	r3, [r7, #4]
 80076b4:	2b00      	cmp	r3, #0
 80076b6:	d10a      	bne.n	80076ce <_Z41__static_initialization_and_destruction_0ii+0x72>
 80076b8:	683b      	ldr	r3, [r7, #0]
 80076ba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80076be:	4293      	cmp	r3, r2
 80076c0:	d105      	bne.n	80076ce <_Z41__static_initialization_and_destruction_0ii+0x72>
 80076c2:	4808      	ldr	r0, [pc, #32]	; (80076e4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80076c4:	f7ff fc80 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 80076c8:	4804      	ldr	r0, [pc, #16]	; (80076dc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 80076ca:	f7ff fc7d 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 80076ce:	bf00      	nop
 80076d0:	3720      	adds	r7, #32
 80076d2:	46bd      	mov	sp, r7
 80076d4:	bd80      	pop	{r7, pc}
 80076d6:	bf00      	nop
 80076d8:	08017e88 	.word	0x08017e88
 80076dc:	2000031c 	.word	0x2000031c
 80076e0:	08017e8c 	.word	0x08017e8c
 80076e4:	20000324 	.word	0x20000324

080076e8 <_GLOBAL__sub_I___SLOT_NUMBER>:
 80076e8:	b580      	push	{r7, lr}
 80076ea:	af00      	add	r7, sp, #0
 80076ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80076f0:	2001      	movs	r0, #1
 80076f2:	f7ff ffb3 	bl	800765c <_Z41__static_initialization_and_destruction_0ii>
 80076f6:	bd80      	pop	{r7, pc}

080076f8 <_GLOBAL__sub_D___SLOT_NUMBER>:
 80076f8:	b580      	push	{r7, lr}
 80076fa:	af00      	add	r7, sp, #0
 80076fc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8007700:	2000      	movs	r0, #0
 8007702:	f7ff ffab 	bl	800765c <_Z41__static_initialization_and_destruction_0ii>
 8007706:	bd80      	pop	{r7, pc}

08007708 <_ZnwjPv>:
#endif // __cpp_sized_deallocation
#endif // __cpp_aligned_new

// Default placement versions of operator new.
_GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }
 8007708:	b480      	push	{r7}
 800770a:	b083      	sub	sp, #12
 800770c:	af00      	add	r7, sp, #0
 800770e:	6078      	str	r0, [r7, #4]
 8007710:	6039      	str	r1, [r7, #0]
 8007712:	683b      	ldr	r3, [r7, #0]
 8007714:	4618      	mov	r0, r3
 8007716:	370c      	adds	r7, #12
 8007718:	46bd      	mov	sp, r7
 800771a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800771e:	4770      	bx	lr

08007720 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>:
    {
 8007720:	b580      	push	{r7, lr}
 8007722:	b082      	sub	sp, #8
 8007724:	af00      	add	r7, sp, #0
 8007726:	6078      	str	r0, [r7, #4]
      if (--_M_use_count == 0)
 8007728:	687b      	ldr	r3, [r7, #4]
 800772a:	685b      	ldr	r3, [r3, #4]
 800772c:	1e5a      	subs	r2, r3, #1
 800772e:	687b      	ldr	r3, [r7, #4]
 8007730:	605a      	str	r2, [r3, #4]
 8007732:	687b      	ldr	r3, [r7, #4]
 8007734:	685b      	ldr	r3, [r3, #4]
 8007736:	2b00      	cmp	r3, #0
 8007738:	bf0c      	ite	eq
 800773a:	2301      	moveq	r3, #1
 800773c:	2300      	movne	r3, #0
 800773e:	b2db      	uxtb	r3, r3
 8007740:	2b00      	cmp	r3, #0
 8007742:	d019      	beq.n	8007778 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv+0x58>
          _M_dispose();
 8007744:	687b      	ldr	r3, [r7, #4]
 8007746:	681b      	ldr	r3, [r3, #0]
 8007748:	3308      	adds	r3, #8
 800774a:	681b      	ldr	r3, [r3, #0]
 800774c:	6878      	ldr	r0, [r7, #4]
 800774e:	4798      	blx	r3
          if (--_M_weak_count == 0)
 8007750:	687b      	ldr	r3, [r7, #4]
 8007752:	689b      	ldr	r3, [r3, #8]
 8007754:	1e5a      	subs	r2, r3, #1
 8007756:	687b      	ldr	r3, [r7, #4]
 8007758:	609a      	str	r2, [r3, #8]
 800775a:	687b      	ldr	r3, [r7, #4]
 800775c:	689b      	ldr	r3, [r3, #8]
 800775e:	2b00      	cmp	r3, #0
 8007760:	bf0c      	ite	eq
 8007762:	2301      	moveq	r3, #1
 8007764:	2300      	movne	r3, #0
 8007766:	b2db      	uxtb	r3, r3
 8007768:	2b00      	cmp	r3, #0
 800776a:	d005      	beq.n	8007778 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv+0x58>
            _M_destroy();
 800776c:	687b      	ldr	r3, [r7, #4]
 800776e:	681b      	ldr	r3, [r3, #0]
 8007770:	330c      	adds	r3, #12
 8007772:	681b      	ldr	r3, [r3, #0]
 8007774:	6878      	ldr	r0, [r7, #4]
 8007776:	4798      	blx	r3
    }
 8007778:	bf00      	nop
 800777a:	3708      	adds	r7, #8
 800777c:	46bd      	mov	sp, r7
 800777e:	bd80      	pop	{r7, pc}

08007780 <_ZN17IJoystickObserverC1Ev>:
 */
class IJoystickObserver
{
protected:
	// It is just an interface, so constructor and destructor should be not public.
	explicit IJoystickObserver() {}
 8007780:	b480      	push	{r7}
 8007782:	b083      	sub	sp, #12
 8007784:	af00      	add	r7, sp, #0
 8007786:	6078      	str	r0, [r7, #4]
 8007788:	4a04      	ldr	r2, [pc, #16]	; (800779c <_ZN17IJoystickObserverC1Ev+0x1c>)
 800778a:	687b      	ldr	r3, [r7, #4]
 800778c:	601a      	str	r2, [r3, #0]
 800778e:	687b      	ldr	r3, [r7, #4]
 8007790:	4618      	mov	r0, r3
 8007792:	370c      	adds	r7, #12
 8007794:	46bd      	mov	sp, r7
 8007796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800779a:	4770      	bx	lr
 800779c:	0801b92c 	.word	0x0801b92c

080077a0 <_ZN17IJoystickObserverD1Ev>:
	virtual ~IJoystickObserver() {}
 80077a0:	b480      	push	{r7}
 80077a2:	b083      	sub	sp, #12
 80077a4:	af00      	add	r7, sp, #0
 80077a6:	6078      	str	r0, [r7, #4]
 80077a8:	4a04      	ldr	r2, [pc, #16]	; (80077bc <_ZN17IJoystickObserverD1Ev+0x1c>)
 80077aa:	687b      	ldr	r3, [r7, #4]
 80077ac:	601a      	str	r2, [r3, #0]
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	4618      	mov	r0, r3
 80077b2:	370c      	adds	r7, #12
 80077b4:	46bd      	mov	sp, r7
 80077b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077ba:	4770      	bx	lr
 80077bc:	0801b92c 	.word	0x0801b92c

080077c0 <_ZN17IJoystickObserverD0Ev>:
 80077c0:	b580      	push	{r7, lr}
 80077c2:	b082      	sub	sp, #8
 80077c4:	af00      	add	r7, sp, #0
 80077c6:	6078      	str	r0, [r7, #4]
 80077c8:	6878      	ldr	r0, [r7, #4]
 80077ca:	f7ff ffe9 	bl	80077a0 <_ZN17IJoystickObserverD1Ev>
 80077ce:	2104      	movs	r1, #4
 80077d0:	6878      	ldr	r0, [r7, #4]
 80077d2:	f00e fceb 	bl	80161ac <_ZdlPvj>
 80077d6:	687b      	ldr	r3, [r7, #4]
 80077d8:	4618      	mov	r0, r3
 80077da:	3708      	adds	r7, #8
 80077dc:	46bd      	mov	sp, r7
 80077de:	bd80      	pop	{r7, pc}

080077e0 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~__shared_ptr() = default;
 80077e0:	b580      	push	{r7, lr}
 80077e2:	b082      	sub	sp, #8
 80077e4:	af00      	add	r7, sp, #0
 80077e6:	6078      	str	r0, [r7, #4]
 80077e8:	687b      	ldr	r3, [r7, #4]
 80077ea:	3304      	adds	r3, #4
 80077ec:	4618      	mov	r0, r3
 80077ee:	f000 f8f3 	bl	80079d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80077f2:	687b      	ldr	r3, [r7, #4]
 80077f4:	4618      	mov	r0, r3
 80077f6:	3708      	adds	r7, #8
 80077f8:	46bd      	mov	sp, r7
 80077fa:	bd80      	pop	{r7, pc}

080077fc <_ZNSt10shared_ptrIhED1Ev>:
   * the stored pointer returned by `get()`, not the owned pointer.
   * To test whether two `shared_ptr` objects share ownership of the same
   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.
  */
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
 80077fc:	b580      	push	{r7, lr}
 80077fe:	b082      	sub	sp, #8
 8007800:	af00      	add	r7, sp, #0
 8007802:	6078      	str	r0, [r7, #4]
 8007804:	687b      	ldr	r3, [r7, #4]
 8007806:	4618      	mov	r0, r3
 8007808:	f7ff ffea 	bl	80077e0 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EED1Ev>
 800780c:	687b      	ldr	r3, [r7, #4]
 800780e:	4618      	mov	r0, r3
 8007810:	3708      	adds	r7, #8
 8007812:	46bd      	mov	sp, r7
 8007814:	bd80      	pop	{r7, pc}

08007816 <_ZN3hei12SharedBufferIhED1Ev>:
    class SharedBuffer {
 8007816:	b580      	push	{r7, lr}
 8007818:	b082      	sub	sp, #8
 800781a:	af00      	add	r7, sp, #0
 800781c:	6078      	str	r0, [r7, #4]
 800781e:	687b      	ldr	r3, [r7, #4]
 8007820:	4618      	mov	r0, r3
 8007822:	f7ff ffeb 	bl	80077fc <_ZNSt10shared_ptrIhED1Ev>
 8007826:	687b      	ldr	r3, [r7, #4]
 8007828:	4618      	mov	r0, r3
 800782a:	3708      	adds	r7, #8
 800782c:	46bd      	mov	sp, r7
 800782e:	bd80      	pop	{r7, pc}

08007830 <_ZN3app19JoystickApplicationC1Ev>:


/**
 * @brief   constructor creates the event buffer with the initial size
 */
JoystickApplication::JoystickApplication()
 8007830:	b580      	push	{r7, lr}
 8007832:	b082      	sub	sp, #8
 8007834:	af00      	add	r7, sp, #0
 8007836:	6078      	str	r0, [r7, #4]
    : joystickEventBufferSize(1)                        // initialize buffer size
    , joystickEventBuffer(joystickEventBufferSize)      // call SharedByteBuffer constructor
 8007838:	687b      	ldr	r3, [r7, #4]
 800783a:	4618      	mov	r0, r3
 800783c:	f7ff ffa0 	bl	8007780 <_ZN17IJoystickObserverC1Ev>
 8007840:	687b      	ldr	r3, [r7, #4]
 8007842:	3304      	adds	r3, #4
 8007844:	4618      	mov	r0, r3
 8007846:	f7ff f8ed 	bl	8006a24 <_ZN7desenet6sensor19AbstractApplicationC1Ev>
 800784a:	4a0b      	ldr	r2, [pc, #44]	; (8007878 <_ZN3app19JoystickApplicationC1Ev+0x48>)
 800784c:	687b      	ldr	r3, [r7, #4]
 800784e:	601a      	str	r2, [r3, #0]
 8007850:	4a0a      	ldr	r2, [pc, #40]	; (800787c <_ZN3app19JoystickApplicationC1Ev+0x4c>)
 8007852:	687b      	ldr	r3, [r7, #4]
 8007854:	605a      	str	r2, [r3, #4]
 8007856:	687b      	ldr	r3, [r7, #4]
 8007858:	2201      	movs	r2, #1
 800785a:	721a      	strb	r2, [r3, #8]
 800785c:	687b      	ldr	r3, [r7, #4]
 800785e:	f103 020c 	add.w	r2, r3, #12
 8007862:	687b      	ldr	r3, [r7, #4]
 8007864:	7a1b      	ldrb	r3, [r3, #8]
 8007866:	4619      	mov	r1, r3
 8007868:	4610      	mov	r0, r2
 800786a:	f000 f87c 	bl	8007966 <_ZN3hei12SharedBufferIhEC1Ej>
{
}
 800786e:	687b      	ldr	r3, [r7, #4]
 8007870:	4618      	mov	r0, r3
 8007872:	3708      	adds	r7, #8
 8007874:	46bd      	mov	sp, r7
 8007876:	bd80      	pop	{r7, pc}
 8007878:	0801b900 	.word	0x0801b900
 800787c:	0801b914 	.word	0x0801b914

08007880 <_ZN3app19JoystickApplicationD1Ev>:


/**
 * @brief   destructor (unused)
 */
JoystickApplication::~JoystickApplication() {}
 8007880:	b580      	push	{r7, lr}
 8007882:	b082      	sub	sp, #8
 8007884:	af00      	add	r7, sp, #0
 8007886:	6078      	str	r0, [r7, #4]
 8007888:	4a0c      	ldr	r2, [pc, #48]	; (80078bc <_ZN3app19JoystickApplicationD1Ev+0x3c>)
 800788a:	687b      	ldr	r3, [r7, #4]
 800788c:	601a      	str	r2, [r3, #0]
 800788e:	4a0c      	ldr	r2, [pc, #48]	; (80078c0 <_ZN3app19JoystickApplicationD1Ev+0x40>)
 8007890:	687b      	ldr	r3, [r7, #4]
 8007892:	605a      	str	r2, [r3, #4]
 8007894:	687b      	ldr	r3, [r7, #4]
 8007896:	330c      	adds	r3, #12
 8007898:	4618      	mov	r0, r3
 800789a:	f7ff ffbc 	bl	8007816 <_ZN3hei12SharedBufferIhED1Ev>
 800789e:	687b      	ldr	r3, [r7, #4]
 80078a0:	3304      	adds	r3, #4
 80078a2:	4618      	mov	r0, r3
 80078a4:	f7ff f8ce 	bl	8006a44 <_ZN7desenet6sensor19AbstractApplicationD1Ev>
 80078a8:	687b      	ldr	r3, [r7, #4]
 80078aa:	4618      	mov	r0, r3
 80078ac:	f7ff ff78 	bl	80077a0 <_ZN17IJoystickObserverD1Ev>
 80078b0:	687b      	ldr	r3, [r7, #4]
 80078b2:	4618      	mov	r0, r3
 80078b4:	3708      	adds	r7, #8
 80078b6:	46bd      	mov	sp, r7
 80078b8:	bd80      	pop	{r7, pc}
 80078ba:	bf00      	nop
 80078bc:	0801b900 	.word	0x0801b900
 80078c0:	0801b914 	.word	0x0801b914

080078c4 <_ZThn4_N3app19JoystickApplicationD1Ev>:
    class JoystickApplication : public IJoystickObserver
                              , public desenet::sensor::AbstractApplication
    {
    public:
        JoystickApplication();
        ~JoystickApplication();
 80078c4:	f1a0 0004 	sub.w	r0, r0, #4
 80078c8:	f7ff bfda 	b.w	8007880 <_ZN3app19JoystickApplicationD1Ev>

080078cc <_ZN3app19JoystickApplicationD0Ev>:
 80078cc:	b580      	push	{r7, lr}
 80078ce:	b082      	sub	sp, #8
 80078d0:	af00      	add	r7, sp, #0
 80078d2:	6078      	str	r0, [r7, #4]
 80078d4:	6878      	ldr	r0, [r7, #4]
 80078d6:	f7ff ffd3 	bl	8007880 <_ZN3app19JoystickApplicationD1Ev>
 80078da:	2118      	movs	r1, #24
 80078dc:	6878      	ldr	r0, [r7, #4]
 80078de:	f00e fc65 	bl	80161ac <_ZdlPvj>
 80078e2:	687b      	ldr	r3, [r7, #4]
 80078e4:	4618      	mov	r0, r3
 80078e6:	3708      	adds	r7, #8
 80078e8:	46bd      	mov	sp, r7
 80078ea:	bd80      	pop	{r7, pc}

080078ec <_ZThn4_N3app19JoystickApplicationD0Ev>:
 80078ec:	f1a0 0004 	sub.w	r0, r0, #4
 80078f0:	f7ff bfec 	b.w	80078cc <_ZN3app19JoystickApplicationD0Ev>

080078f4 <_ZN3app19JoystickApplication16onPositionChangeEN9IJoystick8PositionE>:
 *                                                                      Pressed = 0x20
 *
 * @return  void
*/
void JoystickApplication::onPositionChange(IJoystick::Position position)
{
 80078f4:	b580      	push	{r7, lr}
 80078f6:	b082      	sub	sp, #8
 80078f8:	af00      	add	r7, sp, #0
 80078fa:	6078      	str	r0, [r7, #4]
 80078fc:	6039      	str	r1, [r7, #0]
    memcpy(&joystickEventBuffer, &position, joystickEventBufferSize);
 80078fe:	687b      	ldr	r3, [r7, #4]
 8007900:	f103 000c 	add.w	r0, r3, #12
 8007904:	687b      	ldr	r3, [r7, #4]
 8007906:	7a1b      	ldrb	r3, [r3, #8]
 8007908:	461a      	mov	r2, r3
 800790a:	463b      	mov	r3, r7
 800790c:	4619      	mov	r1, r3
 800790e:	f00e fdb1 	bl	8016474 <memcpy>
    sensor::AbstractApplication::evPublishRequest(EVID_JOYSTICK, joystickEventBuffer);
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	330c      	adds	r3, #12
 8007916:	4619      	mov	r1, r3
 8007918:	2008      	movs	r0, #8
 800791a:	f003 f983 	bl	800ac24 <_ZN7desenet6sensor19AbstractApplication16evPublishRequestEtRKN3hei12SharedBufferIhEE>
}
 800791e:	bf00      	nop
 8007920:	3708      	adds	r7, #8
 8007922:	46bd      	mov	sp, r7
 8007924:	bd80      	pop	{r7, pc}

08007926 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 8007926:	b580      	push	{r7, lr}
 8007928:	b082      	sub	sp, #8
 800792a:	af00      	add	r7, sp, #0
 800792c:	6078      	str	r0, [r7, #4]
      { delete this; }
 800792e:	687b      	ldr	r3, [r7, #4]
 8007930:	2b00      	cmp	r3, #0
 8007932:	d005      	beq.n	8007940 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv+0x1a>
 8007934:	687b      	ldr	r3, [r7, #4]
 8007936:	681b      	ldr	r3, [r3, #0]
 8007938:	3304      	adds	r3, #4
 800793a:	681b      	ldr	r3, [r3, #0]
 800793c:	6878      	ldr	r0, [r7, #4]
 800793e:	4798      	blx	r3
 8007940:	bf00      	nop
 8007942:	3708      	adds	r7, #8
 8007944:	46bd      	mov	sp, r7
 8007946:	bd80      	pop	{r7, pc}

08007948 <_ZZN3hei12SharedBufferIhEC4EjENKUlPhE_clES2_>:
            data_ = std::shared_ptr<T>(new T[length * sizeof(T)], [](pointer p){delete[] p;});
 8007948:	b580      	push	{r7, lr}
 800794a:	b082      	sub	sp, #8
 800794c:	af00      	add	r7, sp, #0
 800794e:	6078      	str	r0, [r7, #4]
 8007950:	6039      	str	r1, [r7, #0]
 8007952:	683b      	ldr	r3, [r7, #0]
 8007954:	2b00      	cmp	r3, #0
 8007956:	d002      	beq.n	800795e <_ZZN3hei12SharedBufferIhEC4EjENKUlPhE_clES2_+0x16>
 8007958:	6838      	ldr	r0, [r7, #0]
 800795a:	f00e fc29 	bl	80161b0 <_ZdaPv>
 800795e:	bf00      	nop
 8007960:	3708      	adds	r7, #8
 8007962:	46bd      	mov	sp, r7
 8007964:	bd80      	pop	{r7, pc}

08007966 <_ZN3hei12SharedBufferIhEC1Ej>:
        explicit SharedBuffer(sizeType length) {
 8007966:	b5b0      	push	{r4, r5, r7, lr}
 8007968:	b084      	sub	sp, #16
 800796a:	af00      	add	r7, sp, #0
 800796c:	6078      	str	r0, [r7, #4]
 800796e:	6039      	str	r1, [r7, #0]
 8007970:	687b      	ldr	r3, [r7, #4]
 8007972:	4618      	mov	r0, r3
 8007974:	f000 f862 	bl	8007a3c <_ZNSt10shared_ptrIhEC1Ev>
            data_ = std::shared_ptr<T>(new T[length * sizeof(T)], [](pointer p){delete[] p;});
 8007978:	687c      	ldr	r4, [r7, #4]
 800797a:	683b      	ldr	r3, [r7, #0]
 800797c:	4618      	mov	r0, r3
 800797e:	f00e fc39 	bl	80161f4 <_Znaj>
 8007982:	4603      	mov	r3, r0
 8007984:	4619      	mov	r1, r3
 8007986:	f107 0308 	add.w	r3, r7, #8
 800798a:	462a      	mov	r2, r5
 800798c:	4618      	mov	r0, r3
 800798e:	f000 f862 	bl	8007a56 <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhEC4EjEUlPhE_vEEPT_T0_>
 8007992:	f107 0308 	add.w	r3, r7, #8
 8007996:	4619      	mov	r1, r3
 8007998:	4620      	mov	r0, r4
 800799a:	f000 f871 	bl	8007a80 <_ZNSt10shared_ptrIhEaSEOS0_>
 800799e:	f107 0308 	add.w	r3, r7, #8
 80079a2:	4618      	mov	r0, r3
 80079a4:	f7ff ff2a 	bl	80077fc <_ZNSt10shared_ptrIhED1Ev>
            if (data_.get() != nullptr)
 80079a8:	687b      	ldr	r3, [r7, #4]
 80079aa:	4618      	mov	r0, r3
 80079ac:	f7ff fa2f 	bl	8006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>
 80079b0:	4603      	mov	r3, r0
 80079b2:	2b00      	cmp	r3, #0
 80079b4:	bf14      	ite	ne
 80079b6:	2301      	movne	r3, #1
 80079b8:	2300      	moveq	r3, #0
 80079ba:	b2db      	uxtb	r3, r3
 80079bc:	2b00      	cmp	r3, #0
 80079be:	d003      	beq.n	80079c8 <_ZN3hei12SharedBufferIhEC1Ej+0x62>
                length_ = length;
 80079c0:	687b      	ldr	r3, [r7, #4]
 80079c2:	683a      	ldr	r2, [r7, #0]
 80079c4:	609a      	str	r2, [r3, #8]
 80079c6:	e002      	b.n	80079ce <_ZN3hei12SharedBufferIhEC1Ej+0x68>
                length_ = 0;
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	2200      	movs	r2, #0
 80079cc:	609a      	str	r2, [r3, #8]
        }
 80079ce:	687b      	ldr	r3, [r7, #4]
 80079d0:	4618      	mov	r0, r3
 80079d2:	3710      	adds	r7, #16
 80079d4:	46bd      	mov	sp, r7
 80079d6:	bdb0      	pop	{r4, r5, r7, pc}

080079d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~__shared_count() noexcept
 80079d8:	b580      	push	{r7, lr}
 80079da:	b082      	sub	sp, #8
 80079dc:	af00      	add	r7, sp, #0
 80079de:	6078      	str	r0, [r7, #4]
	if (_M_pi != nullptr)
 80079e0:	687b      	ldr	r3, [r7, #4]
 80079e2:	681b      	ldr	r3, [r3, #0]
 80079e4:	2b00      	cmp	r3, #0
 80079e6:	d004      	beq.n	80079f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x1a>
	  _M_pi->_M_release();
 80079e8:	687b      	ldr	r3, [r7, #4]
 80079ea:	681b      	ldr	r3, [r3, #0]
 80079ec:	4618      	mov	r0, r3
 80079ee:	f7ff fe97 	bl	8007720 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
      }
 80079f2:	687b      	ldr	r3, [r7, #4]
 80079f4:	4618      	mov	r0, r3
 80079f6:	3708      	adds	r7, #8
 80079f8:	46bd      	mov	sp, r7
 80079fa:	bd80      	pop	{r7, pc}

080079fc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_base() noexcept
 80079fc:	b480      	push	{r7}
 80079fe:	b083      	sub	sp, #12
 8007a00:	af00      	add	r7, sp, #0
 8007a02:	6078      	str	r0, [r7, #4]
      { }
 8007a04:	4a04      	ldr	r2, [pc, #16]	; (8007a18 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x1c>)
 8007a06:	687b      	ldr	r3, [r7, #4]
 8007a08:	601a      	str	r2, [r3, #0]
 8007a0a:	687b      	ldr	r3, [r7, #4]
 8007a0c:	4618      	mov	r0, r3
 8007a0e:	370c      	adds	r7, #12
 8007a10:	46bd      	mov	sp, r7
 8007a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a16:	4770      	bx	lr
 8007a18:	0801b940 	.word	0x0801b940

08007a1c <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED0Ev>:
      ~_Sp_counted_base() noexcept
 8007a1c:	b580      	push	{r7, lr}
 8007a1e:	b082      	sub	sp, #8
 8007a20:	af00      	add	r7, sp, #0
 8007a22:	6078      	str	r0, [r7, #4]
      { }
 8007a24:	6878      	ldr	r0, [r7, #4]
 8007a26:	f7ff ffe9 	bl	80079fc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 8007a2a:	210c      	movs	r1, #12
 8007a2c:	6878      	ldr	r0, [r7, #4]
 8007a2e:	f00e fbbd 	bl	80161ac <_ZdlPvj>
 8007a32:	687b      	ldr	r3, [r7, #4]
 8007a34:	4618      	mov	r0, r3
 8007a36:	3708      	adds	r7, #8
 8007a38:	46bd      	mov	sp, r7
 8007a3a:	bd80      	pop	{r7, pc}

08007a3c <_ZNSt10shared_ptrIhEC1Ev>:
#endif
      /**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }
 8007a3c:	b580      	push	{r7, lr}
 8007a3e:	b082      	sub	sp, #8
 8007a40:	af00      	add	r7, sp, #0
 8007a42:	6078      	str	r0, [r7, #4]
 8007a44:	687b      	ldr	r3, [r7, #4]
 8007a46:	4618      	mov	r0, r3
 8007a48:	f000 f82d 	bl	8007aa6 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1Ev>
 8007a4c:	687b      	ldr	r3, [r7, #4]
 8007a4e:	4618      	mov	r0, r3
 8007a50:	3708      	adds	r7, #8
 8007a52:	46bd      	mov	sp, r7
 8007a54:	bd80      	pop	{r7, pc}

08007a56 <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhEC4EjEUlPhE_vEEPT_T0_>:
       *
       *  __shared_ptr will release __p by calling __d(__p)
       */
      template<typename _Yp, typename _Deleter,
	       typename = _Constructible<_Yp*, _Deleter>>
	shared_ptr(_Yp* __p, _Deleter __d)
 8007a56:	b5b0      	push	{r4, r5, r7, lr}
 8007a58:	b084      	sub	sp, #16
 8007a5a:	af00      	add	r7, sp, #0
 8007a5c:	60f8      	str	r0, [r7, #12]
 8007a5e:	60b9      	str	r1, [r7, #8]
 8007a60:	713a      	strb	r2, [r7, #4]
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
 8007a62:	68fc      	ldr	r4, [r7, #12]
 8007a64:	1d3b      	adds	r3, r7, #4
 8007a66:	4618      	mov	r0, r3
 8007a68:	f000 f82e 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007a6c:	462a      	mov	r2, r5
 8007a6e:	68b9      	ldr	r1, [r7, #8]
 8007a70:	4620      	mov	r0, r4
 8007a72:	f000 f834 	bl	8007ade <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhEC4EjEUlPhE_vEEPT_T0_>
 8007a76:	68fb      	ldr	r3, [r7, #12]
 8007a78:	4618      	mov	r0, r3
 8007a7a:	3710      	adds	r7, #16
 8007a7c:	46bd      	mov	sp, r7
 8007a7e:	bdb0      	pop	{r4, r5, r7, pc}

08007a80 <_ZNSt10shared_ptrIhEaSEOS0_>:
	}
#pragma GCC diagnostic pop
#endif

      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
 8007a80:	b590      	push	{r4, r7, lr}
 8007a82:	b083      	sub	sp, #12
 8007a84:	af00      	add	r7, sp, #0
 8007a86:	6078      	str	r0, [r7, #4]
 8007a88:	6039      	str	r1, [r7, #0]
      {
	this->__shared_ptr<_Tp>::operator=(std::move(__r));
 8007a8a:	687c      	ldr	r4, [r7, #4]
 8007a8c:	6838      	ldr	r0, [r7, #0]
 8007a8e:	f000 f843 	bl	8007b18 <_ZSt4moveIRSt10shared_ptrIhEEONSt16remove_referenceIT_E4typeEOS4_>
 8007a92:	4603      	mov	r3, r0
 8007a94:	4619      	mov	r1, r3
 8007a96:	4620      	mov	r0, r4
 8007a98:	f000 f849 	bl	8007b2e <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEaSEOS2_>
	return *this;
 8007a9c:	687b      	ldr	r3, [r7, #4]
      }
 8007a9e:	4618      	mov	r0, r3
 8007aa0:	370c      	adds	r7, #12
 8007aa2:	46bd      	mov	sp, r7
 8007aa4:	bd90      	pop	{r4, r7, pc}

08007aa6 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1Ev>:
      constexpr __shared_ptr() noexcept
 8007aa6:	b580      	push	{r7, lr}
 8007aa8:	b082      	sub	sp, #8
 8007aaa:	af00      	add	r7, sp, #0
 8007aac:	6078      	str	r0, [r7, #4]
      : _M_ptr(0), _M_refcount()
 8007aae:	687b      	ldr	r3, [r7, #4]
 8007ab0:	2200      	movs	r2, #0
 8007ab2:	601a      	str	r2, [r3, #0]
 8007ab4:	687b      	ldr	r3, [r7, #4]
 8007ab6:	3304      	adds	r3, #4
 8007ab8:	4618      	mov	r0, r3
 8007aba:	f000 f857 	bl	8007b6c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1Ev>
      { }
 8007abe:	687b      	ldr	r3, [r7, #4]
 8007ac0:	4618      	mov	r0, r3
 8007ac2:	3708      	adds	r7, #8
 8007ac4:	46bd      	mov	sp, r7
 8007ac6:	bd80      	pop	{r7, pc}

08007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>:
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
 8007ac8:	b480      	push	{r7}
 8007aca:	b083      	sub	sp, #12
 8007acc:	af00      	add	r7, sp, #0
 8007ace:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8007ad0:	687b      	ldr	r3, [r7, #4]
 8007ad2:	4618      	mov	r0, r3
 8007ad4:	370c      	adds	r7, #12
 8007ad6:	46bd      	mov	sp, r7
 8007ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007adc:	4770      	bx	lr

08007ade <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhEC4EjEUlPhE_vEEPT_T0_>:
	__shared_ptr(_Yp* __p, _Deleter __d)
 8007ade:	b5b0      	push	{r4, r5, r7, lr}
 8007ae0:	b084      	sub	sp, #16
 8007ae2:	af00      	add	r7, sp, #0
 8007ae4:	60f8      	str	r0, [r7, #12]
 8007ae6:	60b9      	str	r1, [r7, #8]
 8007ae8:	713a      	strb	r2, [r7, #4]
	: _M_ptr(__p), _M_refcount(__p, std::move(__d))
 8007aea:	68fb      	ldr	r3, [r7, #12]
 8007aec:	68ba      	ldr	r2, [r7, #8]
 8007aee:	601a      	str	r2, [r3, #0]
 8007af0:	68fb      	ldr	r3, [r7, #12]
 8007af2:	1d1c      	adds	r4, r3, #4
 8007af4:	1d3b      	adds	r3, r7, #4
 8007af6:	4618      	mov	r0, r3
 8007af8:	f7ff ffe6 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007afc:	462a      	mov	r2, r5
 8007afe:	68b9      	ldr	r1, [r7, #8]
 8007b00:	4620      	mov	r0, r4
 8007b02:	f000 f841 	bl	8007b88 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhEC4EjEUlS4_E_vEET_T0_>
	  _M_enable_shared_from_this_with(__p);
 8007b06:	68b9      	ldr	r1, [r7, #8]
 8007b08:	68f8      	ldr	r0, [r7, #12]
 8007b0a:	f000 f852 	bl	8007bb2 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE31_M_enable_shared_from_this_withIhhEENSt9enable_ifIXntsrNS2_15__has_esft_baseIT0_vEE5valueEvE4typeEPT_>
	}
 8007b0e:	68fb      	ldr	r3, [r7, #12]
 8007b10:	4618      	mov	r0, r3
 8007b12:	3710      	adds	r7, #16
 8007b14:	46bd      	mov	sp, r7
 8007b16:	bdb0      	pop	{r4, r5, r7, pc}

08007b18 <_ZSt4moveIRSt10shared_ptrIhEEONSt16remove_referenceIT_E4typeEOS4_>:
    move(_Tp&& __t) noexcept
 8007b18:	b480      	push	{r7}
 8007b1a:	b083      	sub	sp, #12
 8007b1c:	af00      	add	r7, sp, #0
 8007b1e:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8007b20:	687b      	ldr	r3, [r7, #4]
 8007b22:	4618      	mov	r0, r3
 8007b24:	370c      	adds	r7, #12
 8007b26:	46bd      	mov	sp, r7
 8007b28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b2c:	4770      	bx	lr

08007b2e <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEaSEOS2_>:
      operator=(__shared_ptr&& __r) noexcept
 8007b2e:	b580      	push	{r7, lr}
 8007b30:	b084      	sub	sp, #16
 8007b32:	af00      	add	r7, sp, #0
 8007b34:	6078      	str	r0, [r7, #4]
 8007b36:	6039      	str	r1, [r7, #0]
	__shared_ptr(std::move(__r)).swap(*this);
 8007b38:	6838      	ldr	r0, [r7, #0]
 8007b3a:	f000 f845 	bl	8007bc8 <_ZSt4moveIRSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEEONSt16remove_referenceIT_E4typeEOS6_>
 8007b3e:	4602      	mov	r2, r0
 8007b40:	f107 0308 	add.w	r3, r7, #8
 8007b44:	4611      	mov	r1, r2
 8007b46:	4618      	mov	r0, r3
 8007b48:	f000 f849 	bl	8007bde <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1EOS2_>
 8007b4c:	f107 0308 	add.w	r3, r7, #8
 8007b50:	6879      	ldr	r1, [r7, #4]
 8007b52:	4618      	mov	r0, r3
 8007b54:	f000 f861 	bl	8007c1a <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE4swapERS2_>
 8007b58:	f107 0308 	add.w	r3, r7, #8
 8007b5c:	4618      	mov	r0, r3
 8007b5e:	f7ff fe3f 	bl	80077e0 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EED1Ev>
	return *this;
 8007b62:	687b      	ldr	r3, [r7, #4]
      }
 8007b64:	4618      	mov	r0, r3
 8007b66:	3710      	adds	r7, #16
 8007b68:	46bd      	mov	sp, r7
 8007b6a:	bd80      	pop	{r7, pc}

08007b6c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1Ev>:
      constexpr __shared_count() noexcept : _M_pi(0)
 8007b6c:	b480      	push	{r7}
 8007b6e:	b083      	sub	sp, #12
 8007b70:	af00      	add	r7, sp, #0
 8007b72:	6078      	str	r0, [r7, #4]
 8007b74:	687b      	ldr	r3, [r7, #4]
 8007b76:	2200      	movs	r2, #0
 8007b78:	601a      	str	r2, [r3, #0]
      { }
 8007b7a:	687b      	ldr	r3, [r7, #4]
 8007b7c:	4618      	mov	r0, r3
 8007b7e:	370c      	adds	r7, #12
 8007b80:	46bd      	mov	sp, r7
 8007b82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b86:	4770      	bx	lr

08007b88 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhEC4EjEUlS4_E_vEET_T0_>:
	__shared_count(_Ptr __p, _Deleter __d)
 8007b88:	b5b0      	push	{r4, r5, r7, lr}
 8007b8a:	b084      	sub	sp, #16
 8007b8c:	af00      	add	r7, sp, #0
 8007b8e:	60f8      	str	r0, [r7, #12]
 8007b90:	60b9      	str	r1, [r7, #8]
 8007b92:	713a      	strb	r2, [r7, #4]
	: __shared_count(__p, std::move(__d), allocator<void>())
 8007b94:	1d3b      	adds	r3, r7, #4
 8007b96:	4618      	mov	r0, r3
 8007b98:	f7ff ff96 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007b9c:	462b      	mov	r3, r5
 8007b9e:	4622      	mov	r2, r4
 8007ba0:	68b9      	ldr	r1, [r7, #8]
 8007ba2:	68f8      	ldr	r0, [r7, #12]
 8007ba4:	f000 f850 	bl	8007c48 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhEC4EjEUlS4_E_SaIvEvEET_T0_T1_>
	{ }
 8007ba8:	68fb      	ldr	r3, [r7, #12]
 8007baa:	4618      	mov	r0, r3
 8007bac:	3710      	adds	r7, #16
 8007bae:	46bd      	mov	sp, r7
 8007bb0:	bdb0      	pop	{r4, r5, r7, pc}

08007bb2 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE31_M_enable_shared_from_this_withIhhEENSt9enable_ifIXntsrNS2_15__has_esft_baseIT0_vEE5valueEvE4typeEPT_>:
	    __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
	}

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
	typename enable_if<!__has_esft_base<_Yp2>::value>::type
	_M_enable_shared_from_this_with(_Yp*) noexcept
 8007bb2:	b480      	push	{r7}
 8007bb4:	b083      	sub	sp, #12
 8007bb6:	af00      	add	r7, sp, #0
 8007bb8:	6078      	str	r0, [r7, #4]
 8007bba:	6039      	str	r1, [r7, #0]
	{ }
 8007bbc:	bf00      	nop
 8007bbe:	370c      	adds	r7, #12
 8007bc0:	46bd      	mov	sp, r7
 8007bc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007bc6:	4770      	bx	lr

08007bc8 <_ZSt4moveIRSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEEONSt16remove_referenceIT_E4typeEOS6_>:
    move(_Tp&& __t) noexcept
 8007bc8:	b480      	push	{r7}
 8007bca:	b083      	sub	sp, #12
 8007bcc:	af00      	add	r7, sp, #0
 8007bce:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8007bd0:	687b      	ldr	r3, [r7, #4]
 8007bd2:	4618      	mov	r0, r3
 8007bd4:	370c      	adds	r7, #12
 8007bd6:	46bd      	mov	sp, r7
 8007bd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007bdc:	4770      	bx	lr

08007bde <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1EOS2_>:
      __shared_ptr(__shared_ptr&& __r) noexcept
 8007bde:	b580      	push	{r7, lr}
 8007be0:	b082      	sub	sp, #8
 8007be2:	af00      	add	r7, sp, #0
 8007be4:	6078      	str	r0, [r7, #4]
 8007be6:	6039      	str	r1, [r7, #0]
      : _M_ptr(__r._M_ptr), _M_refcount()
 8007be8:	683b      	ldr	r3, [r7, #0]
 8007bea:	681a      	ldr	r2, [r3, #0]
 8007bec:	687b      	ldr	r3, [r7, #4]
 8007bee:	601a      	str	r2, [r3, #0]
 8007bf0:	687b      	ldr	r3, [r7, #4]
 8007bf2:	3304      	adds	r3, #4
 8007bf4:	4618      	mov	r0, r3
 8007bf6:	f7ff ffb9 	bl	8007b6c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1Ev>
	_M_refcount._M_swap(__r._M_refcount);
 8007bfa:	687b      	ldr	r3, [r7, #4]
 8007bfc:	1d1a      	adds	r2, r3, #4
 8007bfe:	683b      	ldr	r3, [r7, #0]
 8007c00:	3304      	adds	r3, #4
 8007c02:	4619      	mov	r1, r3
 8007c04:	4610      	mov	r0, r2
 8007c06:	f000 f86a 	bl	8007cde <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EE7_M_swapERS2_>
	__r._M_ptr = 0;
 8007c0a:	683b      	ldr	r3, [r7, #0]
 8007c0c:	2200      	movs	r2, #0
 8007c0e:	601a      	str	r2, [r3, #0]
      }
 8007c10:	687b      	ldr	r3, [r7, #4]
 8007c12:	4618      	mov	r0, r3
 8007c14:	3708      	adds	r7, #8
 8007c16:	46bd      	mov	sp, r7
 8007c18:	bd80      	pop	{r7, pc}

08007c1a <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE4swapERS2_>:
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
 8007c1a:	b580      	push	{r7, lr}
 8007c1c:	b082      	sub	sp, #8
 8007c1e:	af00      	add	r7, sp, #0
 8007c20:	6078      	str	r0, [r7, #4]
 8007c22:	6039      	str	r1, [r7, #0]
	std::swap(_M_ptr, __other._M_ptr);
 8007c24:	687b      	ldr	r3, [r7, #4]
 8007c26:	683a      	ldr	r2, [r7, #0]
 8007c28:	4611      	mov	r1, r2
 8007c2a:	4618      	mov	r0, r3
 8007c2c:	f000 f877 	bl	8007d1e <_ZSt4swapIPhENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
	_M_refcount._M_swap(__other._M_refcount);
 8007c30:	687b      	ldr	r3, [r7, #4]
 8007c32:	1d1a      	adds	r2, r3, #4
 8007c34:	683b      	ldr	r3, [r7, #0]
 8007c36:	3304      	adds	r3, #4
 8007c38:	4619      	mov	r1, r3
 8007c3a:	4610      	mov	r0, r2
 8007c3c:	f000 f84f 	bl	8007cde <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EE7_M_swapERS2_>
      }
 8007c40:	bf00      	nop
 8007c42:	3708      	adds	r7, #8
 8007c44:	46bd      	mov	sp, r7
 8007c46:	bd80      	pop	{r7, pc}

08007c48 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhEC4EjEUlS4_E_SaIvEvEET_T0_T1_>:
	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 8007c48:	b590      	push	{r4, r7, lr}
 8007c4a:	b08b      	sub	sp, #44	; 0x2c
 8007c4c:	af00      	add	r7, sp, #0
 8007c4e:	60f8      	str	r0, [r7, #12]
 8007c50:	60b9      	str	r1, [r7, #8]
 8007c52:	713a      	strb	r2, [r7, #4]
 8007c54:	703b      	strb	r3, [r7, #0]
 8007c56:	68fb      	ldr	r3, [r7, #12]
 8007c58:	2200      	movs	r2, #0
 8007c5a:	601a      	str	r2, [r3, #0]
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 8007c5c:	463a      	mov	r2, r7
 8007c5e:	f107 031c 	add.w	r3, r7, #28
 8007c62:	4611      	mov	r1, r2
 8007c64:	4618      	mov	r0, r3
 8007c66:	f000 f879 	bl	8007d5c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	      auto __guard = std::__allocate_guarded(__a2);
 8007c6a:	f107 0314 	add.w	r3, r7, #20
 8007c6e:	f107 021c 	add.w	r2, r7, #28
 8007c72:	4611      	mov	r1, r2
 8007c74:	4618      	mov	r0, r3
 8007c76:	f000 f88a 	bl	8007d8e <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSC_>
	      _Sp_cd_type* __mem = __guard.get();
 8007c7a:	f107 0314 	add.w	r3, r7, #20
 8007c7e:	4618      	mov	r0, r3
 8007c80:	f000 f8ad 	bl	8007dde <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>
 8007c84:	6278      	str	r0, [r7, #36]	; 0x24
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 8007c86:	1d3b      	adds	r3, r7, #4
 8007c88:	4618      	mov	r0, r3
 8007c8a:	f7ff ff1d 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007c8e:	463b      	mov	r3, r7
 8007c90:	4618      	mov	r0, r3
 8007c92:	f000 f8b2 	bl	8007dfa <_ZSt4moveIRSaIvEEONSt16remove_referenceIT_E4typeEOS3_>
 8007c96:	4604      	mov	r4, r0
 8007c98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c9a:	4619      	mov	r1, r3
 8007c9c:	2010      	movs	r0, #16
 8007c9e:	f7ff fd33 	bl	8007708 <_ZnwjPv>
 8007ca2:	4623      	mov	r3, r4
 8007ca4:	f897 2020 	ldrb.w	r2, [r7, #32]
 8007ca8:	68b9      	ldr	r1, [r7, #8]
 8007caa:	f000 f8b1 	bl	8007e10 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_>
	      _M_pi = __mem;
 8007cae:	68fb      	ldr	r3, [r7, #12]
 8007cb0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007cb2:	601a      	str	r2, [r3, #0]
	      __guard = nullptr;
 8007cb4:	f107 0314 	add.w	r3, r7, #20
 8007cb8:	2100      	movs	r1, #0
 8007cba:	4618      	mov	r0, r3
 8007cbc:	f000 f8ca 	bl	8007e54 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>
	      auto __guard = std::__allocate_guarded(__a2);
 8007cc0:	f107 0314 	add.w	r3, r7, #20
 8007cc4:	4618      	mov	r0, r3
 8007cc6:	f000 f875 	bl	8007db4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 8007cca:	f107 031c 	add.w	r3, r7, #28
 8007cce:	4618      	mov	r0, r3
 8007cd0:	f000 f851 	bl	8007d76 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
	}
 8007cd4:	68fb      	ldr	r3, [r7, #12]
 8007cd6:	4618      	mov	r0, r3
 8007cd8:	372c      	adds	r7, #44	; 0x2c
 8007cda:	46bd      	mov	sp, r7
 8007cdc:	bd90      	pop	{r4, r7, pc}

08007cde <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EE7_M_swapERS2_>:
      _M_swap(__shared_count& __r) noexcept
 8007cde:	b480      	push	{r7}
 8007ce0:	b085      	sub	sp, #20
 8007ce2:	af00      	add	r7, sp, #0
 8007ce4:	6078      	str	r0, [r7, #4]
 8007ce6:	6039      	str	r1, [r7, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 8007ce8:	683b      	ldr	r3, [r7, #0]
 8007cea:	681b      	ldr	r3, [r3, #0]
 8007cec:	60fb      	str	r3, [r7, #12]
	__r._M_pi = _M_pi;
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	681a      	ldr	r2, [r3, #0]
 8007cf2:	683b      	ldr	r3, [r7, #0]
 8007cf4:	601a      	str	r2, [r3, #0]
	_M_pi = __tmp;
 8007cf6:	687b      	ldr	r3, [r7, #4]
 8007cf8:	68fa      	ldr	r2, [r7, #12]
 8007cfa:	601a      	str	r2, [r3, #0]
      }
 8007cfc:	bf00      	nop
 8007cfe:	3714      	adds	r7, #20
 8007d00:	46bd      	mov	sp, r7
 8007d02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d06:	4770      	bx	lr

08007d08 <_ZSt4moveIRPhEONSt16remove_referenceIT_E4typeEOS3_>:
    move(_Tp&& __t) noexcept
 8007d08:	b480      	push	{r7}
 8007d0a:	b083      	sub	sp, #12
 8007d0c:	af00      	add	r7, sp, #0
 8007d0e:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8007d10:	687b      	ldr	r3, [r7, #4]
 8007d12:	4618      	mov	r0, r3
 8007d14:	370c      	adds	r7, #12
 8007d16:	46bd      	mov	sp, r7
 8007d18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d1c:	4770      	bx	lr

08007d1e <_ZSt4swapIPhENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
			      is_move_constructible<_Tp>,
			      is_move_assignable<_Tp>>::value>::type
#else
    void
#endif
    swap(_Tp& __a, _Tp& __b)
 8007d1e:	b580      	push	{r7, lr}
 8007d20:	b084      	sub	sp, #16
 8007d22:	af00      	add	r7, sp, #0
 8007d24:	6078      	str	r0, [r7, #4]
 8007d26:	6039      	str	r1, [r7, #0]
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 8007d28:	6878      	ldr	r0, [r7, #4]
 8007d2a:	f7ff ffed 	bl	8007d08 <_ZSt4moveIRPhEONSt16remove_referenceIT_E4typeEOS3_>
 8007d2e:	4603      	mov	r3, r0
 8007d30:	681b      	ldr	r3, [r3, #0]
 8007d32:	60fb      	str	r3, [r7, #12]
      __a = _GLIBCXX_MOVE(__b);
 8007d34:	6838      	ldr	r0, [r7, #0]
 8007d36:	f7ff ffe7 	bl	8007d08 <_ZSt4moveIRPhEONSt16remove_referenceIT_E4typeEOS3_>
 8007d3a:	4603      	mov	r3, r0
 8007d3c:	681a      	ldr	r2, [r3, #0]
 8007d3e:	687b      	ldr	r3, [r7, #4]
 8007d40:	601a      	str	r2, [r3, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 8007d42:	f107 030c 	add.w	r3, r7, #12
 8007d46:	4618      	mov	r0, r3
 8007d48:	f7ff ffde 	bl	8007d08 <_ZSt4moveIRPhEONSt16remove_referenceIT_E4typeEOS3_>
 8007d4c:	4603      	mov	r3, r0
 8007d4e:	681a      	ldr	r2, [r3, #0]
 8007d50:	683b      	ldr	r3, [r7, #0]
 8007d52:	601a      	str	r2, [r3, #0]
    }
 8007d54:	bf00      	nop
 8007d56:	3710      	adds	r7, #16
 8007d58:	46bd      	mov	sp, r7
 8007d5a:	bd80      	pop	{r7, pc}

08007d5c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>:
      allocator& operator=(const allocator&) = default;
#endif

      template<typename _Tp1>
	_GLIBCXX20_CONSTEXPR
	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
 8007d5c:	b580      	push	{r7, lr}
 8007d5e:	b082      	sub	sp, #8
 8007d60:	af00      	add	r7, sp, #0
 8007d62:	6078      	str	r0, [r7, #4]
 8007d64:	6039      	str	r1, [r7, #0]
 8007d66:	6878      	ldr	r0, [r7, #4]
 8007d68:	f000 f883 	bl	8007e72 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>
 8007d6c:	687b      	ldr	r3, [r7, #4]
 8007d6e:	4618      	mov	r0, r3
 8007d70:	3708      	adds	r7, #8
 8007d72:	46bd      	mov	sp, r7
 8007d74:	bd80      	pop	{r7, pc}

08007d76 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>:

#if __cpp_constexpr_dynamic_alloc
      constexpr
#endif
      ~allocator() _GLIBCXX_NOTHROW { }
 8007d76:	b580      	push	{r7, lr}
 8007d78:	b082      	sub	sp, #8
 8007d7a:	af00      	add	r7, sp, #0
 8007d7c:	6078      	str	r0, [r7, #4]
 8007d7e:	6878      	ldr	r0, [r7, #4]
 8007d80:	f000 f882 	bl	8007e88 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>
 8007d84:	687b      	ldr	r3, [r7, #4]
 8007d86:	4618      	mov	r0, r3
 8007d88:	3708      	adds	r7, #8
 8007d8a:	46bd      	mov	sp, r7
 8007d8c:	bd80      	pop	{r7, pc}

08007d8e <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSC_>:
    };

  /// Allocate space for a single object using __a
  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
 8007d8e:	b580      	push	{r7, lr}
 8007d90:	b082      	sub	sp, #8
 8007d92:	af00      	add	r7, sp, #0
 8007d94:	6078      	str	r0, [r7, #4]
 8007d96:	6039      	str	r1, [r7, #0]
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
 8007d98:	2101      	movs	r1, #1
 8007d9a:	6838      	ldr	r0, [r7, #0]
 8007d9c:	f000 f87f 	bl	8007e9e <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSA_j>
 8007da0:	4603      	mov	r3, r0
 8007da2:	461a      	mov	r2, r3
 8007da4:	6839      	ldr	r1, [r7, #0]
 8007da6:	6878      	ldr	r0, [r7, #4]
 8007da8:	f000 f888 	bl	8007ebc <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>
    }
 8007dac:	6878      	ldr	r0, [r7, #4]
 8007dae:	3708      	adds	r7, #8
 8007db0:	46bd      	mov	sp, r7
 8007db2:	bd80      	pop	{r7, pc}

08007db4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>:
      ~__allocated_ptr()
 8007db4:	b580      	push	{r7, lr}
 8007db6:	b082      	sub	sp, #8
 8007db8:	af00      	add	r7, sp, #0
 8007dba:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 8007dbc:	687b      	ldr	r3, [r7, #4]
 8007dbe:	685b      	ldr	r3, [r3, #4]
 8007dc0:	2b00      	cmp	r3, #0
 8007dc2:	d007      	beq.n	8007dd4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 8007dc4:	687b      	ldr	r3, [r7, #4]
 8007dc6:	6818      	ldr	r0, [r3, #0]
 8007dc8:	687b      	ldr	r3, [r7, #4]
 8007dca:	685b      	ldr	r3, [r3, #4]
 8007dcc:	2201      	movs	r2, #1
 8007dce:	4619      	mov	r1, r3
 8007dd0:	f000 f888 	bl	8007ee4 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSA_PS9_j>
      }
 8007dd4:	687b      	ldr	r3, [r7, #4]
 8007dd6:	4618      	mov	r0, r3
 8007dd8:	3708      	adds	r7, #8
 8007dda:	46bd      	mov	sp, r7
 8007ddc:	bd80      	pop	{r7, pc}

08007dde <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>:
      value_type* get() { return std::__to_address(_M_ptr); }
 8007dde:	b580      	push	{r7, lr}
 8007de0:	b082      	sub	sp, #8
 8007de2:	af00      	add	r7, sp, #0
 8007de4:	6078      	str	r0, [r7, #4]
 8007de6:	687b      	ldr	r3, [r7, #4]
 8007de8:	685b      	ldr	r3, [r3, #4]
 8007dea:	4618      	mov	r0, r3
 8007dec:	f000 f889 	bl	8007f02 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SB_>
 8007df0:	4603      	mov	r3, r0
 8007df2:	4618      	mov	r0, r3
 8007df4:	3708      	adds	r7, #8
 8007df6:	46bd      	mov	sp, r7
 8007df8:	bd80      	pop	{r7, pc}

08007dfa <_ZSt4moveIRSaIvEEONSt16remove_referenceIT_E4typeEOS3_>:
    move(_Tp&& __t) noexcept
 8007dfa:	b480      	push	{r7}
 8007dfc:	b083      	sub	sp, #12
 8007dfe:	af00      	add	r7, sp, #0
 8007e00:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8007e02:	687b      	ldr	r3, [r7, #4]
 8007e04:	4618      	mov	r0, r3
 8007e06:	370c      	adds	r7, #12
 8007e08:	46bd      	mov	sp, r7
 8007e0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e0e:	4770      	bx	lr

08007e10 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_>:
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 8007e10:	b5b0      	push	{r4, r5, r7, lr}
 8007e12:	b084      	sub	sp, #16
 8007e14:	af00      	add	r7, sp, #0
 8007e16:	60f8      	str	r0, [r7, #12]
 8007e18:	60b9      	str	r1, [r7, #8]
 8007e1a:	713a      	strb	r2, [r7, #4]
 8007e1c:	603b      	str	r3, [r7, #0]
      : _M_impl(__p, std::move(__d), __a) { }
 8007e1e:	68fb      	ldr	r3, [r7, #12]
 8007e20:	4618      	mov	r0, r3
 8007e22:	f000 f879 	bl	8007f18 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EEC1Ev>
 8007e26:	4a0a      	ldr	r2, [pc, #40]	; (8007e50 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_+0x40>)
 8007e28:	68fb      	ldr	r3, [r7, #12]
 8007e2a:	601a      	str	r2, [r3, #0]
 8007e2c:	68fb      	ldr	r3, [r7, #12]
 8007e2e:	f103 040c 	add.w	r4, r3, #12
 8007e32:	1d3b      	adds	r3, r7, #4
 8007e34:	4618      	mov	r0, r3
 8007e36:	f7ff fe47 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007e3a:	683b      	ldr	r3, [r7, #0]
 8007e3c:	462a      	mov	r2, r5
 8007e3e:	68b9      	ldr	r1, [r7, #8]
 8007e40:	4620      	mov	r0, r4
 8007e42:	f000 f87f 	bl	8007f44 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S4_RKS5_>
 8007e46:	68fb      	ldr	r3, [r7, #12]
 8007e48:	4618      	mov	r0, r3
 8007e4a:	3710      	adds	r7, #16
 8007e4c:	46bd      	mov	sp, r7
 8007e4e:	bdb0      	pop	{r4, r5, r7, pc}
 8007e50:	0801b8e4 	.word	0x0801b8e4

08007e54 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 8007e54:	b480      	push	{r7}
 8007e56:	b083      	sub	sp, #12
 8007e58:	af00      	add	r7, sp, #0
 8007e5a:	6078      	str	r0, [r7, #4]
 8007e5c:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 8007e5e:	687b      	ldr	r3, [r7, #4]
 8007e60:	2200      	movs	r2, #0
 8007e62:	605a      	str	r2, [r3, #4]
	return *this;
 8007e64:	687b      	ldr	r3, [r7, #4]
      }
 8007e66:	4618      	mov	r0, r3
 8007e68:	370c      	adds	r7, #12
 8007e6a:	46bd      	mov	sp, r7
 8007e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e70:	4770      	bx	lr

08007e72 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>:
      // 2103. propagate_on_container_move_assignment
      typedef std::true_type propagate_on_container_move_assignment;
#endif

      _GLIBCXX20_CONSTEXPR
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8007e72:	b480      	push	{r7}
 8007e74:	b083      	sub	sp, #12
 8007e76:	af00      	add	r7, sp, #0
 8007e78:	6078      	str	r0, [r7, #4]
 8007e7a:	687b      	ldr	r3, [r7, #4]
 8007e7c:	4618      	mov	r0, r3
 8007e7e:	370c      	adds	r7, #12
 8007e80:	46bd      	mov	sp, r7
 8007e82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e86:	4770      	bx	lr

08007e88 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>:
      template<typename _Tp1>
	_GLIBCXX20_CONSTEXPR
	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }

#if __cplusplus <= 201703L
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8007e88:	b480      	push	{r7}
 8007e8a:	b083      	sub	sp, #12
 8007e8c:	af00      	add	r7, sp, #0
 8007e8e:	6078      	str	r0, [r7, #4]
 8007e90:	687b      	ldr	r3, [r7, #4]
 8007e92:	4618      	mov	r0, r3
 8007e94:	370c      	adds	r7, #12
 8007e96:	46bd      	mov	sp, r7
 8007e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e9c:	4770      	bx	lr

08007e9e <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSA_j>:
       *  @param  __n  The number of objects to allocate space for.
       *
       *  Calls @c a.allocate(n)
      */
      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
      allocate(allocator_type& __a, size_type __n)
 8007e9e:	b580      	push	{r7, lr}
 8007ea0:	b082      	sub	sp, #8
 8007ea2:	af00      	add	r7, sp, #0
 8007ea4:	6078      	str	r0, [r7, #4]
 8007ea6:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 8007ea8:	2200      	movs	r2, #0
 8007eaa:	6839      	ldr	r1, [r7, #0]
 8007eac:	6878      	ldr	r0, [r7, #4]
 8007eae:	f000 f865 	bl	8007f7c <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>
 8007eb2:	4603      	mov	r3, r0
 8007eb4:	4618      	mov	r0, r3
 8007eb6:	3708      	adds	r7, #8
 8007eb8:	46bd      	mov	sp, r7
 8007eba:	bd80      	pop	{r7, pc}

08007ebc <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 8007ebc:	b580      	push	{r7, lr}
 8007ebe:	b084      	sub	sp, #16
 8007ec0:	af00      	add	r7, sp, #0
 8007ec2:	60f8      	str	r0, [r7, #12]
 8007ec4:	60b9      	str	r1, [r7, #8]
 8007ec6:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 8007ec8:	68b8      	ldr	r0, [r7, #8]
 8007eca:	f000 f875 	bl	8007fb8 <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSB_>
 8007ece:	4602      	mov	r2, r0
 8007ed0:	68fb      	ldr	r3, [r7, #12]
 8007ed2:	601a      	str	r2, [r3, #0]
 8007ed4:	68fb      	ldr	r3, [r7, #12]
 8007ed6:	687a      	ldr	r2, [r7, #4]
 8007ed8:	605a      	str	r2, [r3, #4]
      { }
 8007eda:	68fb      	ldr	r3, [r7, #12]
 8007edc:	4618      	mov	r0, r3
 8007ede:	3710      	adds	r7, #16
 8007ee0:	46bd      	mov	sp, r7
 8007ee2:	bd80      	pop	{r7, pc}

08007ee4 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSA_PS9_j>:
       *  @param  __n  The number of objects space was allocated for.
       *
       *  Calls <tt> a.deallocate(p, n) </tt>
      */
      static _GLIBCXX20_CONSTEXPR void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8007ee4:	b580      	push	{r7, lr}
 8007ee6:	b084      	sub	sp, #16
 8007ee8:	af00      	add	r7, sp, #0
 8007eea:	60f8      	str	r0, [r7, #12]
 8007eec:	60b9      	str	r1, [r7, #8]
 8007eee:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 8007ef0:	687a      	ldr	r2, [r7, #4]
 8007ef2:	68b9      	ldr	r1, [r7, #8]
 8007ef4:	68f8      	ldr	r0, [r7, #12]
 8007ef6:	f000 f86a 	bl	8007fce <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPS9_j>
 8007efa:	bf00      	nop
 8007efc:	3710      	adds	r7, #16
 8007efe:	46bd      	mov	sp, r7
 8007f00:	bd80      	pop	{r7, pc}

08007f02 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SB_>:
  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
 8007f02:	b480      	push	{r7}
 8007f04:	b083      	sub	sp, #12
 8007f06:	af00      	add	r7, sp, #0
 8007f08:	6078      	str	r0, [r7, #4]
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
 8007f0a:	687b      	ldr	r3, [r7, #4]
    }
 8007f0c:	4618      	mov	r0, r3
 8007f0e:	370c      	adds	r7, #12
 8007f10:	46bd      	mov	sp, r7
 8007f12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f16:	4770      	bx	lr

08007f18 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EEC1Ev>:
      _Sp_counted_base() noexcept
 8007f18:	b480      	push	{r7}
 8007f1a:	b083      	sub	sp, #12
 8007f1c:	af00      	add	r7, sp, #0
 8007f1e:	6078      	str	r0, [r7, #4]
      : _M_use_count(1), _M_weak_count(1) { }
 8007f20:	4a07      	ldr	r2, [pc, #28]	; (8007f40 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EEC1Ev+0x28>)
 8007f22:	687b      	ldr	r3, [r7, #4]
 8007f24:	601a      	str	r2, [r3, #0]
 8007f26:	687b      	ldr	r3, [r7, #4]
 8007f28:	2201      	movs	r2, #1
 8007f2a:	605a      	str	r2, [r3, #4]
 8007f2c:	687b      	ldr	r3, [r7, #4]
 8007f2e:	2201      	movs	r2, #1
 8007f30:	609a      	str	r2, [r3, #8]
 8007f32:	687b      	ldr	r3, [r7, #4]
 8007f34:	4618      	mov	r0, r3
 8007f36:	370c      	adds	r7, #12
 8007f38:	46bd      	mov	sp, r7
 8007f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f3e:	4770      	bx	lr
 8007f40:	0801b940 	.word	0x0801b940

08007f44 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S4_RKS5_>:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 8007f44:	b580      	push	{r7, lr}
 8007f46:	b084      	sub	sp, #16
 8007f48:	af00      	add	r7, sp, #0
 8007f4a:	60f8      	str	r0, [r7, #12]
 8007f4c:	60b9      	str	r1, [r7, #8]
 8007f4e:	713a      	strb	r2, [r7, #4]
 8007f50:	603b      	str	r3, [r7, #0]
	: _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 8007f52:	1d3b      	adds	r3, r7, #4
 8007f54:	4618      	mov	r0, r3
 8007f56:	f7ff fdb7 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007f5a:	4603      	mov	r3, r0
 8007f5c:	4619      	mov	r1, r3
 8007f5e:	68f8      	ldr	r0, [r7, #12]
 8007f60:	f000 f845 	bl	8007fee <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhEC4EjEUlPhE_Lb1EEC1EOS4_>
 8007f64:	6839      	ldr	r1, [r7, #0]
 8007f66:	68f8      	ldr	r0, [r7, #12]
 8007f68:	f000 f84e 	bl	8008008 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EEC1ERKS0_>
 8007f6c:	68fb      	ldr	r3, [r7, #12]
 8007f6e:	68ba      	ldr	r2, [r7, #8]
 8007f70:	601a      	str	r2, [r3, #0]
	{ }
 8007f72:	68fb      	ldr	r3, [r7, #12]
 8007f74:	4618      	mov	r0, r3
 8007f76:	3710      	adds	r7, #16
 8007f78:	46bd      	mov	sp, r7
 8007f7a:	bd80      	pop	{r7, pc}

08007f7c <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>:
#endif

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      _GLIBCXX_NODISCARD _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 8007f7c:	b580      	push	{r7, lr}
 8007f7e:	b084      	sub	sp, #16
 8007f80:	af00      	add	r7, sp, #0
 8007f82:	60f8      	str	r0, [r7, #12]
 8007f84:	60b9      	str	r1, [r7, #8]
 8007f86:	607a      	str	r2, [r7, #4]
	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
	 // 3308. std::allocator<void>().allocate(n)
	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
#endif

	if (__n > this->_M_max_size())
 8007f88:	68f8      	ldr	r0, [r7, #12]
 8007f8a:	f000 f849 	bl	8008020 <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>
 8007f8e:	4602      	mov	r2, r0
 8007f90:	68bb      	ldr	r3, [r7, #8]
 8007f92:	4293      	cmp	r3, r2
 8007f94:	bf8c      	ite	hi
 8007f96:	2301      	movhi	r3, #1
 8007f98:	2300      	movls	r3, #0
 8007f9a:	b2db      	uxtb	r3, r3
 8007f9c:	2b00      	cmp	r3, #0
 8007f9e:	d001      	beq.n	8007fa4 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 8007fa0:	f00e f93b 	bl	801621a <_ZSt17__throw_bad_allocv>
	  {
	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
	  }
#endif
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 8007fa4:	68bb      	ldr	r3, [r7, #8]
 8007fa6:	011b      	lsls	r3, r3, #4
 8007fa8:	4618      	mov	r0, r3
 8007faa:	f00e f912 	bl	80161d2 <_Znwj>
 8007fae:	4603      	mov	r3, r0
      }
 8007fb0:	4618      	mov	r0, r3
 8007fb2:	3710      	adds	r7, #16
 8007fb4:	46bd      	mov	sp, r7
 8007fb6:	bd80      	pop	{r7, pc}

08007fb8 <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSB_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 8007fb8:	b480      	push	{r7}
 8007fba:	b083      	sub	sp, #12
 8007fbc:	af00      	add	r7, sp, #0
 8007fbe:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 8007fc0:	687b      	ldr	r3, [r7, #4]
 8007fc2:	4618      	mov	r0, r3
 8007fc4:	370c      	adds	r7, #12
 8007fc6:	46bd      	mov	sp, r7
 8007fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fcc:	4770      	bx	lr

08007fce <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPS9_j>:

      // __p is not permitted to be a null pointer.
      void
      deallocate(_Tp* __p, size_type __t)
 8007fce:	b580      	push	{r7, lr}
 8007fd0:	b084      	sub	sp, #16
 8007fd2:	af00      	add	r7, sp, #0
 8007fd4:	60f8      	str	r0, [r7, #12]
 8007fd6:	60b9      	str	r1, [r7, #8]
 8007fd8:	607a      	str	r2, [r7, #4]
# endif
			      std::align_val_t(alignof(_Tp)));
	    return;
	  }
#endif
	::operator delete(__p
 8007fda:	687b      	ldr	r3, [r7, #4]
 8007fdc:	011b      	lsls	r3, r3, #4
 8007fde:	4619      	mov	r1, r3
 8007fe0:	68b8      	ldr	r0, [r7, #8]
 8007fe2:	f00e f8e3 	bl	80161ac <_ZdlPvj>
#if __cpp_sized_deallocation
			  , __t * sizeof(_Tp)
#endif
			 );
      }
 8007fe6:	bf00      	nop
 8007fe8:	3710      	adds	r7, #16
 8007fea:	46bd      	mov	sp, r7
 8007fec:	bd80      	pop	{r7, pc}

08007fee <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhEC4EjEUlPhE_Lb1EEC1EOS4_>:
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }
 8007fee:	b580      	push	{r7, lr}
 8007ff0:	b082      	sub	sp, #8
 8007ff2:	af00      	add	r7, sp, #0
 8007ff4:	6078      	str	r0, [r7, #4]
 8007ff6:	6039      	str	r1, [r7, #0]
 8007ff8:	6838      	ldr	r0, [r7, #0]
 8007ffa:	f7ff fd65 	bl	8007ac8 <_ZSt4moveIRZN3hei12SharedBufferIhEC4EjEUlPhE_EONSt16remove_referenceIT_E4typeEOS7_>
 8007ffe:	687b      	ldr	r3, [r7, #4]
 8008000:	4618      	mov	r0, r3
 8008002:	3708      	adds	r7, #8
 8008004:	46bd      	mov	sp, r7
 8008006:	bd80      	pop	{r7, pc}

08008008 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EEC1ERKS0_>:
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
 8008008:	b480      	push	{r7}
 800800a:	b083      	sub	sp, #12
 800800c:	af00      	add	r7, sp, #0
 800800e:	6078      	str	r0, [r7, #4]
 8008010:	6039      	str	r1, [r7, #0]
 8008012:	687b      	ldr	r3, [r7, #4]
 8008014:	4618      	mov	r0, r3
 8008016:	370c      	adds	r7, #12
 8008018:	46bd      	mov	sp, r7
 800801a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800801e:	4770      	bx	lr

08008020 <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>:
	{ return false; }
#endif

    private:
      _GLIBCXX_CONSTEXPR size_type
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 8008020:	b480      	push	{r7}
 8008022:	b083      	sub	sp, #12
 8008024:	af00      	add	r7, sp, #0
 8008026:	6078      	str	r0, [r7, #4]
      {
#if __PTRDIFF_MAX__ < __SIZE_MAX__
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 8008028:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
#else
	return std::size_t(-1) / sizeof(_Tp);
#endif
      }
 800802c:	4618      	mov	r0, r3
 800802e:	370c      	adds	r7, #12
 8008030:	46bd      	mov	sp, r7
 8008032:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008036:	4770      	bx	lr

08008038 <_Z41__static_initialization_and_destruction_0ii>:
 8008038:	b580      	push	{r7, lr}
 800803a:	b088      	sub	sp, #32
 800803c:	af00      	add	r7, sp, #0
 800803e:	6078      	str	r0, [r7, #4]
 8008040:	6039      	str	r1, [r7, #0]
 8008042:	687b      	ldr	r3, [r7, #4]
 8008044:	2b01      	cmp	r3, #1
 8008046:	d122      	bne.n	800808e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008048:	683b      	ldr	r3, [r7, #0]
 800804a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800804e:	4293      	cmp	r3, r2
 8008050:	d11d      	bne.n	800808e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008052:	4b18      	ldr	r3, [pc, #96]	; (80080b4 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8008054:	681b      	ldr	r3, [r3, #0]
 8008056:	613b      	str	r3, [r7, #16]
 8008058:	f107 0310 	add.w	r3, r7, #16
 800805c:	60bb      	str	r3, [r7, #8]
 800805e:	2304      	movs	r3, #4
 8008060:	60fb      	str	r3, [r7, #12]
 8008062:	f107 0308 	add.w	r3, r7, #8
 8008066:	e893 0006 	ldmia.w	r3, {r1, r2}
 800806a:	4813      	ldr	r0, [pc, #76]	; (80080b8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800806c:	f7fe fe62 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8008070:	4b12      	ldr	r3, [pc, #72]	; (80080bc <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8008072:	681b      	ldr	r3, [r3, #0]
 8008074:	61fb      	str	r3, [r7, #28]
 8008076:	f107 031c 	add.w	r3, r7, #28
 800807a:	617b      	str	r3, [r7, #20]
 800807c:	2304      	movs	r3, #4
 800807e:	61bb      	str	r3, [r7, #24]
 8008080:	f107 0314 	add.w	r3, r7, #20
 8008084:	e893 0006 	ldmia.w	r3, {r1, r2}
 8008088:	480d      	ldr	r0, [pc, #52]	; (80080c0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800808a:	f7fe fe53 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800808e:	687b      	ldr	r3, [r7, #4]
 8008090:	2b00      	cmp	r3, #0
 8008092:	d10a      	bne.n	80080aa <_Z41__static_initialization_and_destruction_0ii+0x72>
 8008094:	683b      	ldr	r3, [r7, #0]
 8008096:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800809a:	4293      	cmp	r3, r2
 800809c:	d105      	bne.n	80080aa <_Z41__static_initialization_and_destruction_0ii+0x72>
 800809e:	4808      	ldr	r0, [pc, #32]	; (80080c0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80080a0:	f7fe ff92 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 80080a4:	4804      	ldr	r0, [pc, #16]	; (80080b8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 80080a6:	f7fe ff8f 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 80080aa:	bf00      	nop
 80080ac:	3720      	adds	r7, #32
 80080ae:	46bd      	mov	sp, r7
 80080b0:	bd80      	pop	{r7, pc}
 80080b2:	bf00      	nop
 80080b4:	08017f78 	.word	0x08017f78
 80080b8:	2000181c 	.word	0x2000181c
 80080bc:	08017f7c 	.word	0x08017f7c
 80080c0:	20001824 	.word	0x20001824

080080c4 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_deleter() noexcept { }
 80080c4:	b580      	push	{r7, lr}
 80080c6:	b082      	sub	sp, #8
 80080c8:	af00      	add	r7, sp, #0
 80080ca:	6078      	str	r0, [r7, #4]
 80080cc:	4a05      	ldr	r2, [pc, #20]	; (80080e4 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev+0x20>)
 80080ce:	687b      	ldr	r3, [r7, #4]
 80080d0:	601a      	str	r2, [r3, #0]
 80080d2:	687b      	ldr	r3, [r7, #4]
 80080d4:	4618      	mov	r0, r3
 80080d6:	f7ff fc91 	bl	80079fc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80080da:	687b      	ldr	r3, [r7, #4]
 80080dc:	4618      	mov	r0, r3
 80080de:	3708      	adds	r7, #8
 80080e0:	46bd      	mov	sp, r7
 80080e2:	bd80      	pop	{r7, pc}
 80080e4:	0801b8e4 	.word	0x0801b8e4

080080e8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
 80080e8:	b580      	push	{r7, lr}
 80080ea:	b082      	sub	sp, #8
 80080ec:	af00      	add	r7, sp, #0
 80080ee:	6078      	str	r0, [r7, #4]
 80080f0:	6878      	ldr	r0, [r7, #4]
 80080f2:	f7ff ffe7 	bl	80080c4 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80080f6:	2110      	movs	r1, #16
 80080f8:	6878      	ldr	r0, [r7, #4]
 80080fa:	f00e f857 	bl	80161ac <_ZdlPvj>
 80080fe:	687b      	ldr	r3, [r7, #4]
 8008100:	4618      	mov	r0, r3
 8008102:	3708      	adds	r7, #8
 8008104:	46bd      	mov	sp, r7
 8008106:	bd80      	pop	{r7, pc}

08008108 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 8008108:	b580      	push	{r7, lr}
 800810a:	b082      	sub	sp, #8
 800810c:	af00      	add	r7, sp, #0
 800810e:	6078      	str	r0, [r7, #4]
      { _M_impl._M_del()(_M_impl._M_ptr); }
 8008110:	687b      	ldr	r3, [r7, #4]
 8008112:	330c      	adds	r3, #12
 8008114:	4618      	mov	r0, r3
 8008116:	f000 f840 	bl	800819a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>
 800811a:	4602      	mov	r2, r0
 800811c:	687b      	ldr	r3, [r7, #4]
 800811e:	68db      	ldr	r3, [r3, #12]
 8008120:	4619      	mov	r1, r3
 8008122:	4610      	mov	r0, r2
 8008124:	f7ff fc10 	bl	8007948 <_ZZN3hei12SharedBufferIhEC4EjENKUlPhE_clES2_>
 8008128:	bf00      	nop
 800812a:	3708      	adds	r7, #8
 800812c:	46bd      	mov	sp, r7
 800812e:	bd80      	pop	{r7, pc}

08008130 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 8008130:	b580      	push	{r7, lr}
 8008132:	b086      	sub	sp, #24
 8008134:	af00      	add	r7, sp, #0
 8008136:	6078      	str	r0, [r7, #4]
	__allocator_type __a(_M_impl._M_alloc());
 8008138:	687b      	ldr	r3, [r7, #4]
 800813a:	330c      	adds	r3, #12
 800813c:	4618      	mov	r0, r3
 800813e:	f000 f838 	bl	80081b2 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>
 8008142:	4602      	mov	r2, r0
 8008144:	f107 0314 	add.w	r3, r7, #20
 8008148:	4611      	mov	r1, r2
 800814a:	4618      	mov	r0, r3
 800814c:	f7ff fe06 	bl	8007d5c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8008150:	f107 0114 	add.w	r1, r7, #20
 8008154:	f107 030c 	add.w	r3, r7, #12
 8008158:	687a      	ldr	r2, [r7, #4]
 800815a:	4618      	mov	r0, r3
 800815c:	f7ff feae 	bl	8007ebc <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>
	this->~_Sp_counted_deleter();
 8008160:	6878      	ldr	r0, [r7, #4]
 8008162:	f7ff ffaf 	bl	80080c4 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8008166:	f107 030c 	add.w	r3, r7, #12
 800816a:	4618      	mov	r0, r3
 800816c:	f7ff fe22 	bl	8007db4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	__allocator_type __a(_M_impl._M_alloc());
 8008170:	f107 0314 	add.w	r3, r7, #20
 8008174:	4618      	mov	r0, r3
 8008176:	f7ff fdfe 	bl	8007d76 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
      }
 800817a:	bf00      	nop
 800817c:	3718      	adds	r7, #24
 800817e:	46bd      	mov	sp, r7
 8008180:	bd80      	pop	{r7, pc}

08008182 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_get_deleter(const std::type_info& __ti) noexcept
 8008182:	b480      	push	{r7}
 8008184:	b083      	sub	sp, #12
 8008186:	af00      	add	r7, sp, #0
 8008188:	6078      	str	r0, [r7, #4]
 800818a:	6039      	str	r1, [r7, #0]
        return nullptr;
 800818c:	2300      	movs	r3, #0
      }
 800818e:	4618      	mov	r0, r3
 8008190:	370c      	adds	r7, #12
 8008192:	46bd      	mov	sp, r7
 8008194:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008198:	4770      	bx	lr

0800819a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>:
	_Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 800819a:	b580      	push	{r7, lr}
 800819c:	b082      	sub	sp, #8
 800819e:	af00      	add	r7, sp, #0
 80081a0:	6078      	str	r0, [r7, #4]
 80081a2:	6878      	ldr	r0, [r7, #4]
 80081a4:	f000 f811 	bl	80081ca <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhEC4EjEUlPhE_Lb1EE6_S_getERS5_>
 80081a8:	4603      	mov	r3, r0
 80081aa:	4618      	mov	r0, r3
 80081ac:	3708      	adds	r7, #8
 80081ae:	46bd      	mov	sp, r7
 80081b0:	bd80      	pop	{r7, pc}

080081b2 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhEC4EjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>:
	_Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }
 80081b2:	b580      	push	{r7, lr}
 80081b4:	b082      	sub	sp, #8
 80081b6:	af00      	add	r7, sp, #0
 80081b8:	6078      	str	r0, [r7, #4]
 80081ba:	6878      	ldr	r0, [r7, #4]
 80081bc:	f000 f810 	bl	80081e0 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EE6_S_getERS1_>
 80081c0:	4603      	mov	r3, r0
 80081c2:	4618      	mov	r0, r3
 80081c4:	3708      	adds	r7, #8
 80081c6:	46bd      	mov	sp, r7
 80081c8:	bd80      	pop	{r7, pc}

080081ca <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhEC4EjEUlPhE_Lb1EE6_S_getERS5_>:
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
 80081ca:	b480      	push	{r7}
 80081cc:	b083      	sub	sp, #12
 80081ce:	af00      	add	r7, sp, #0
 80081d0:	6078      	str	r0, [r7, #4]
 80081d2:	687b      	ldr	r3, [r7, #4]
 80081d4:	4618      	mov	r0, r3
 80081d6:	370c      	adds	r7, #12
 80081d8:	46bd      	mov	sp, r7
 80081da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081de:	4770      	bx	lr

080081e0 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EE6_S_getERS1_>:
 80081e0:	b480      	push	{r7}
 80081e2:	b083      	sub	sp, #12
 80081e4:	af00      	add	r7, sp, #0
 80081e6:	6078      	str	r0, [r7, #4]
 80081e8:	687b      	ldr	r3, [r7, #4]
 80081ea:	4618      	mov	r0, r3
 80081ec:	370c      	adds	r7, #12
 80081ee:	46bd      	mov	sp, r7
 80081f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081f4:	4770      	bx	lr

080081f6 <_GLOBAL__sub_I__ZN3app19JoystickApplicationC2Ev>:
 80081f6:	b580      	push	{r7, lr}
 80081f8:	af00      	add	r7, sp, #0
 80081fa:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80081fe:	2001      	movs	r0, #1
 8008200:	f7ff ff1a 	bl	8008038 <_Z41__static_initialization_and_destruction_0ii>
 8008204:	bd80      	pop	{r7, pc}

08008206 <_GLOBAL__sub_D__ZN3app19JoystickApplicationC2Ev>:
 8008206:	b580      	push	{r7, lr}
 8008208:	af00      	add	r7, sp, #0
 800820a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800820e:	2000      	movs	r0, #0
 8008210:	f7ff ff12 	bl	8008038 <_Z41__static_initialization_and_destruction_0ii>
 8008214:	bd80      	pop	{r7, pc}

08008216 <_ZNK16XFTimeoutManager12tickIntervalEv>:
    void start();

    void scheduleTimeout(int timeoutId, int interval, IXFReactive * pReactive);
    void unscheduleTimeout(int timeoutId, IXFReactive * pReactive);
    void tick();														///< Called regularly in XFTimeoutManager::_tickInterval time
    inline int tickInterval() const { return _tickInterval; }			///< Returns tick time interval in milliseconds.
 8008216:	b480      	push	{r7}
 8008218:	b083      	sub	sp, #12
 800821a:	af00      	add	r7, sp, #0
 800821c:	6078      	str	r0, [r7, #4]
 800821e:	687b      	ldr	r3, [r7, #4]
 8008220:	685b      	ldr	r3, [r3, #4]
 8008222:	4618      	mov	r0, r3
 8008224:	370c      	adds	r7, #12
 8008226:	46bd      	mov	sp, r7
 8008228:	f85d 7b04 	ldr.w	r7, [sp], #4
 800822c:	4770      	bx	lr

0800822e <_ZNK16XFTimeoutManager12sysTicksInMsEv>:
    inline uint32_t sysTicksInMs() const { return _sysTicksInMs; }		///< Returns time in milliseconds since system start up.
 800822e:	b480      	push	{r7}
 8008230:	b083      	sub	sp, #12
 8008232:	af00      	add	r7, sp, #0
 8008234:	6078      	str	r0, [r7, #4]
 8008236:	687b      	ldr	r3, [r7, #4]
 8008238:	695b      	ldr	r3, [r3, #20]
 800823a:	4618      	mov	r0, r3
 800823c:	370c      	adds	r7, #12
 800823e:	46bd      	mov	sp, r7
 8008240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008244:	4770      	bx	lr

08008246 <_ZNK5TTime4hourEv>:
				unsigned short & milliseconds) const;	///< Returns stored time as part of hours, minutes, seconds and milliseconds.

	unsigned long getMds() const;						///< Returns stored time in milliseconds.
	bool isNull() const;

	inline unsigned char hour() const					///< Returns hour part of the stored time.
 8008246:	b480      	push	{r7}
 8008248:	b083      	sub	sp, #12
 800824a:	af00      	add	r7, sp, #0
 800824c:	6078      	str	r0, [r7, #4]
	{ return mTHours; }
 800824e:	687b      	ldr	r3, [r7, #4]
 8008250:	781b      	ldrb	r3, [r3, #0]
 8008252:	4618      	mov	r0, r3
 8008254:	370c      	adds	r7, #12
 8008256:	46bd      	mov	sp, r7
 8008258:	f85d 7b04 	ldr.w	r7, [sp], #4
 800825c:	4770      	bx	lr

0800825e <_ZNK5TTime6minuteEv>:
	inline unsigned char minute() const					///< Returns minute part of the stored time.
 800825e:	b480      	push	{r7}
 8008260:	b083      	sub	sp, #12
 8008262:	af00      	add	r7, sp, #0
 8008264:	6078      	str	r0, [r7, #4]
	{ return mTMinutes; }
 8008266:	687b      	ldr	r3, [r7, #4]
 8008268:	785b      	ldrb	r3, [r3, #1]
 800826a:	4618      	mov	r0, r3
 800826c:	370c      	adds	r7, #12
 800826e:	46bd      	mov	sp, r7
 8008270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008274:	4770      	bx	lr

08008276 <_ZNK5TTime6secondEv>:
	inline unsigned char second() const					///< Returns second part of the stored time.
 8008276:	b480      	push	{r7}
 8008278:	b083      	sub	sp, #12
 800827a:	af00      	add	r7, sp, #0
 800827c:	6078      	str	r0, [r7, #4]
	{ return mTSeconds; }
 800827e:	687b      	ldr	r3, [r7, #4]
 8008280:	789b      	ldrb	r3, [r3, #2]
 8008282:	4618      	mov	r0, r3
 8008284:	370c      	adds	r7, #12
 8008286:	46bd      	mov	sp, r7
 8008288:	f85d 7b04 	ldr.w	r7, [sp], #4
 800828c:	4770      	bx	lr

0800828e <_ZNK5TTime4msecEv>:
	inline unsigned short msec() const					///< Returns millisecond part of the stored time.
 800828e:	b480      	push	{r7}
 8008290:	b083      	sub	sp, #12
 8008292:	af00      	add	r7, sp, #0
 8008294:	6078      	str	r0, [r7, #4]
	{ return mTMilliseconds; }
 8008296:	687b      	ldr	r3, [r7, #4]
 8008298:	889b      	ldrh	r3, [r3, #4]
 800829a:	4618      	mov	r0, r3
 800829c:	370c      	adds	r7, #12
 800829e:	46bd      	mov	sp, r7
 80082a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082a4:	4770      	bx	lr
	...

080082a8 <_ZN9ClockworkC1Ev>:
#include "xf/xfevent.h"
#include "clockwork.h"

Clockwork * Clockwork::_pInstance;

Clockwork::Clockwork()
 80082a8:	b580      	push	{r7, lr}
 80082aa:	b082      	sub	sp, #8
 80082ac:	af00      	add	r7, sp, #0
 80082ae:	6078      	str	r0, [r7, #4]
: _currentState(STATE_UNKOWN),
  _oldTick(0),
  _bCurrentTimeReceived(false)
 80082b0:	687b      	ldr	r3, [r7, #4]
 80082b2:	2100      	movs	r1, #0
 80082b4:	4618      	mov	r0, r3
 80082b6:	f00b ff35 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 80082ba:	4a13      	ldr	r2, [pc, #76]	; (8008308 <_ZN9ClockworkC1Ev+0x60>)
 80082bc:	687b      	ldr	r3, [r7, #4]
 80082be:	601a      	str	r2, [r3, #0]
 80082c0:	687b      	ldr	r3, [r7, #4]
 80082c2:	2200      	movs	r2, #0
 80082c4:	731a      	strb	r2, [r3, #12]
 80082c6:	6879      	ldr	r1, [r7, #4]
 80082c8:	f04f 0200 	mov.w	r2, #0
 80082cc:	f04f 0300 	mov.w	r3, #0
 80082d0:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80082d4:	687b      	ldr	r3, [r7, #4]
 80082d6:	3318      	adds	r3, #24
 80082d8:	4618      	mov	r0, r3
 80082da:	f000 fab5 	bl	8008848 <_ZN5TTimeC1Ev>
 80082de:	687b      	ldr	r3, [r7, #4]
 80082e0:	2200      	movs	r2, #0
 80082e2:	779a      	strb	r2, [r3, #30]
{
	assert(!_pInstance);	// Only one instance allowed.
 80082e4:	4b09      	ldr	r3, [pc, #36]	; (800830c <_ZN9ClockworkC1Ev+0x64>)
 80082e6:	681b      	ldr	r3, [r3, #0]
 80082e8:	2b00      	cmp	r3, #0
 80082ea:	d005      	beq.n	80082f8 <_ZN9ClockworkC1Ev+0x50>
 80082ec:	4b08      	ldr	r3, [pc, #32]	; (8008310 <_ZN9ClockworkC1Ev+0x68>)
 80082ee:	4a09      	ldr	r2, [pc, #36]	; (8008314 <_ZN9ClockworkC1Ev+0x6c>)
 80082f0:	210f      	movs	r1, #15
 80082f2:	4809      	ldr	r0, [pc, #36]	; (8008318 <_ZN9ClockworkC1Ev+0x70>)
 80082f4:	f00e f84e 	bl	8016394 <__assert_func>
	_pInstance = this;
 80082f8:	4a04      	ldr	r2, [pc, #16]	; (800830c <_ZN9ClockworkC1Ev+0x64>)
 80082fa:	687b      	ldr	r3, [r7, #4]
 80082fc:	6013      	str	r3, [r2, #0]
}
 80082fe:	687b      	ldr	r3, [r7, #4]
 8008300:	4618      	mov	r0, r3
 8008302:	3708      	adds	r7, #8
 8008304:	46bd      	mov	sp, r7
 8008306:	bd80      	pop	{r7, pc}
 8008308:	0801b95c 	.word	0x0801b95c
 800830c:	2000183c 	.word	0x2000183c
 8008310:	08017f80 	.word	0x08017f80
 8008314:	08017f8c 	.word	0x08017f8c
 8008318:	08017fa4 	.word	0x08017fa4

0800831c <_ZN9ClockworkD1Ev>:

Clockwork::~Clockwork()
 800831c:	b580      	push	{r7, lr}
 800831e:	b082      	sub	sp, #8
 8008320:	af00      	add	r7, sp, #0
 8008322:	6078      	str	r0, [r7, #4]
 8008324:	4a08      	ldr	r2, [pc, #32]	; (8008348 <_ZN9ClockworkD1Ev+0x2c>)
 8008326:	687b      	ldr	r3, [r7, #4]
 8008328:	601a      	str	r2, [r3, #0]
 800832a:	687b      	ldr	r3, [r7, #4]
 800832c:	3318      	adds	r3, #24
 800832e:	4618      	mov	r0, r3
 8008330:	f000 faa1 	bl	8008876 <_ZN5TTimeD1Ev>
 8008334:	687b      	ldr	r3, [r7, #4]
 8008336:	4618      	mov	r0, r3
 8008338:	f00b ff16 	bl	8014168 <_ZN10XFReactiveD1Ev>
{
}
 800833c:	687b      	ldr	r3, [r7, #4]
 800833e:	4618      	mov	r0, r3
 8008340:	3708      	adds	r7, #8
 8008342:	46bd      	mov	sp, r7
 8008344:	bd80      	pop	{r7, pc}
 8008346:	bf00      	nop
 8008348:	0801b95c 	.word	0x0801b95c

0800834c <_ZN9ClockworkD0Ev>:
Clockwork::~Clockwork()
 800834c:	b580      	push	{r7, lr}
 800834e:	b082      	sub	sp, #8
 8008350:	af00      	add	r7, sp, #0
 8008352:	6078      	str	r0, [r7, #4]
}
 8008354:	6878      	ldr	r0, [r7, #4]
 8008356:	f7ff ffe1 	bl	800831c <_ZN9ClockworkD1Ev>
 800835a:	2120      	movs	r1, #32
 800835c:	6878      	ldr	r0, [r7, #4]
 800835e:	f00d ff25 	bl	80161ac <_ZdlPvj>
 8008362:	687b      	ldr	r3, [r7, #4]
 8008364:	4618      	mov	r0, r3
 8008366:	3708      	adds	r7, #8
 8008368:	46bd      	mov	sp, r7
 800836a:	bd80      	pop	{r7, pc}

0800836c <_ZN9Clockwork5startEv>:

void Clockwork::start()
{
 800836c:	b580      	push	{r7, lr}
 800836e:	b082      	sub	sp, #8
 8008370:	af00      	add	r7, sp, #0
 8008372:	6078      	str	r0, [r7, #4]
	startBehavior();	// Start state machine
 8008374:	687a      	ldr	r2, [r7, #4]
 8008376:	687b      	ldr	r3, [r7, #4]
 8008378:	681b      	ldr	r3, [r3, #0]
 800837a:	3308      	adds	r3, #8
 800837c:	681b      	ldr	r3, [r3, #0]
 800837e:	4610      	mov	r0, r2
 8008380:	4798      	blx	r3
}
 8008382:	bf00      	nop
 8008384:	3708      	adds	r7, #8
 8008386:	46bd      	mov	sp, r7
 8008388:	bd80      	pop	{r7, pc}

0800838a <_ZN9Clockwork11currentTimeEv>:

const TTime & Clockwork::currentTime()
{
 800838a:	b580      	push	{r7, lr}
 800838c:	b082      	sub	sp, #8
 800838e:	af00      	add	r7, sp, #0
 8008390:	6078      	str	r0, [r7, #4]
	doSecondUpdate();
 8008392:	687b      	ldr	r3, [r7, #4]
 8008394:	681b      	ldr	r3, [r3, #0]
 8008396:	3320      	adds	r3, #32
 8008398:	681b      	ldr	r3, [r3, #0]
 800839a:	6878      	ldr	r0, [r7, #4]
 800839c:	4798      	blx	r3

	return _time;
 800839e:	687b      	ldr	r3, [r7, #4]
 80083a0:	3318      	adds	r3, #24
}
 80083a2:	4618      	mov	r0, r3
 80083a4:	3708      	adds	r7, #8
 80083a6:	46bd      	mov	sp, r7
 80083a8:	bd80      	pop	{r7, pc}
	...

080083ac <_ZN9Clockwork8instanceEv>:

Clockwork & Clockwork::instance()
{
 80083ac:	b580      	push	{r7, lr}
 80083ae:	af00      	add	r7, sp, #0
	assert(_pInstance);
 80083b0:	4b06      	ldr	r3, [pc, #24]	; (80083cc <_ZN9Clockwork8instanceEv+0x20>)
 80083b2:	681b      	ldr	r3, [r3, #0]
 80083b4:	2b00      	cmp	r3, #0
 80083b6:	d105      	bne.n	80083c4 <_ZN9Clockwork8instanceEv+0x18>
 80083b8:	4b05      	ldr	r3, [pc, #20]	; (80083d0 <_ZN9Clockwork8instanceEv+0x24>)
 80083ba:	4a06      	ldr	r2, [pc, #24]	; (80083d4 <_ZN9Clockwork8instanceEv+0x28>)
 80083bc:	2125      	movs	r1, #37	; 0x25
 80083be:	4806      	ldr	r0, [pc, #24]	; (80083d8 <_ZN9Clockwork8instanceEv+0x2c>)
 80083c0:	f00d ffe8 	bl	8016394 <__assert_func>
	return *_pInstance;
 80083c4:	4b01      	ldr	r3, [pc, #4]	; (80083cc <_ZN9Clockwork8instanceEv+0x20>)
 80083c6:	681b      	ldr	r3, [r3, #0]
}
 80083c8:	4618      	mov	r0, r3
 80083ca:	bd80      	pop	{r7, pc}
 80083cc:	2000183c 	.word	0x2000183c
 80083d0:	0801801c 	.word	0x0801801c
 80083d4:	08018028 	.word	0x08018028
 80083d8:	08017fa4 	.word	0x08017fa4

080083dc <_ZN9Clockwork12processEventEv>:
	seconds = _time.second();
	milliseconds = _time.msec();
}

EventStatus Clockwork::processEvent()
{
 80083dc:	b580      	push	{r7, lr}
 80083de:	b084      	sub	sp, #16
 80083e0:	af00      	add	r7, sp, #0
 80083e2:	6078      	str	r0, [r7, #4]
	eMainState newState = _currentState;
 80083e4:	687b      	ldr	r3, [r7, #4]
 80083e6:	7b1b      	ldrb	r3, [r3, #12]
 80083e8:	73fb      	strb	r3, [r7, #15]

	switch (_currentState)
 80083ea:	687b      	ldr	r3, [r7, #4]
 80083ec:	7b1b      	ldrb	r3, [r3, #12]
 80083ee:	2b01      	cmp	r3, #1
 80083f0:	dc02      	bgt.n	80083f8 <_ZN9Clockwork12processEventEv+0x1c>
 80083f2:	2b00      	cmp	r3, #0
 80083f4:	da03      	bge.n	80083fe <_ZN9Clockwork12processEventEv+0x22>
 80083f6:	e07e      	b.n	80084f6 <_ZN9Clockwork12processEventEv+0x11a>
 80083f8:	2b02      	cmp	r3, #2
 80083fa:	d026      	beq.n	800844a <_ZN9Clockwork12processEventEv+0x6e>
 80083fc:	e07b      	b.n	80084f6 <_ZN9Clockwork12processEventEv+0x11a>
	{
	case STATE_UNKOWN:
	case STATE_INITIAL:
		if (getCurrentEvent()->getEventType() == IXFEvent::Initial)
 80083fe:	687b      	ldr	r3, [r7, #4]
 8008400:	4618      	mov	r0, r3
 8008402:	f00b ff6d 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8008406:	4603      	mov	r3, r0
 8008408:	4618      	mov	r0, r3
 800840a:	f7fe faca 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800840e:	4603      	mov	r3, r0
 8008410:	2b01      	cmp	r3, #1
 8008412:	bf0c      	ite	eq
 8008414:	2301      	moveq	r3, #1
 8008416:	2300      	movne	r3, #0
 8008418:	b2db      	uxtb	r3, r3
 800841a:	2b00      	cmp	r3, #0
 800841c:	d068      	beq.n	80084f0 <_ZN9Clockwork12processEventEv+0x114>
		{
			newState = STATE_ROOT;	// Move to state ROOT
 800841e:	2302      	movs	r3, #2
 8008420:	73fb      	strb	r3, [r7, #15]

			doInit();
 8008422:	687b      	ldr	r3, [r7, #4]
 8008424:	681b      	ldr	r3, [r3, #0]
 8008426:	331c      	adds	r3, #28
 8008428:	681b      	ldr	r3, [r3, #0]
 800842a:	6878      	ldr	r0, [r7, #4]
 800842c:	4798      	blx	r3

			// Start timeout
			getThread()->scheduleTimeout(SECOND_INTERVAL_id, 1000, this);
 800842e:	687a      	ldr	r2, [r7, #4]
 8008430:	687b      	ldr	r3, [r7, #4]
 8008432:	681b      	ldr	r3, [r3, #0]
 8008434:	3318      	adds	r3, #24
 8008436:	681b      	ldr	r3, [r3, #0]
 8008438:	4610      	mov	r0, r2
 800843a:	4798      	blx	r3
 800843c:	687b      	ldr	r3, [r7, #4]
 800843e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8008442:	2101      	movs	r1, #1
 8008444:	f00c f907 	bl	8014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>
		}
		break;
 8008448:	e052      	b.n	80084f0 <_ZN9Clockwork12processEventEv+0x114>
	case STATE_ROOT:
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 800844a:	687b      	ldr	r3, [r7, #4]
 800844c:	4618      	mov	r0, r3
 800844e:	f00b ff47 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8008452:	4603      	mov	r3, r0
 8008454:	4618      	mov	r0, r3
 8008456:	f7fe faa4 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800845a:	4603      	mov	r3, r0
 800845c:	2b04      	cmp	r3, #4
 800845e:	d10c      	bne.n	800847a <_ZN9Clockwork12processEventEv+0x9e>
			getCurrentTimeout()->getId() == SECOND_INTERVAL_id)
 8008460:	687b      	ldr	r3, [r7, #4]
 8008462:	4618      	mov	r0, r3
 8008464:	f00b ff56 	bl	8014314 <_ZN10XFReactive17getCurrentTimeoutEv>
 8008468:	4603      	mov	r3, r0
 800846a:	4618      	mov	r0, r3
 800846c:	f7fe faa6 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 8008470:	4603      	mov	r3, r0
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 8008472:	2b01      	cmp	r3, #1
 8008474:	d101      	bne.n	800847a <_ZN9Clockwork12processEventEv+0x9e>
 8008476:	2301      	movs	r3, #1
 8008478:	e000      	b.n	800847c <_ZN9Clockwork12processEventEv+0xa0>
 800847a:	2300      	movs	r3, #0
 800847c:	2b00      	cmp	r3, #0
 800847e:	d015      	beq.n	80084ac <_ZN9Clockwork12processEventEv+0xd0>
		{
			newState = STATE_ROOT;	// Stay in state
 8008480:	2302      	movs	r3, #2
 8008482:	73fb      	strb	r3, [r7, #15]

			doSecondUpdate();
 8008484:	687b      	ldr	r3, [r7, #4]
 8008486:	681b      	ldr	r3, [r3, #0]
 8008488:	3320      	adds	r3, #32
 800848a:	681b      	ldr	r3, [r3, #0]
 800848c:	6878      	ldr	r0, [r7, #4]
 800848e:	4798      	blx	r3

			// Start timeout
			getThread()->scheduleTimeout(SECOND_INTERVAL_id, 1000, this);
 8008490:	687a      	ldr	r2, [r7, #4]
 8008492:	687b      	ldr	r3, [r7, #4]
 8008494:	681b      	ldr	r3, [r3, #0]
 8008496:	3318      	adds	r3, #24
 8008498:	681b      	ldr	r3, [r3, #0]
 800849a:	4610      	mov	r0, r2
 800849c:	4798      	blx	r3
 800849e:	687b      	ldr	r3, [r7, #4]
 80084a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80084a4:	2101      	movs	r1, #1
 80084a6:	f00c f8d6 	bl	8014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>
		else if(getCurrentEvent()->getEventType() == IXFEvent::Event &&
				getCurrentEvent()->getId() == EV_MINUTE_ELAPSED_id)
		{
			doShowCurrentTime();
		}
		break;
 80084aa:	e023      	b.n	80084f4 <_ZN9Clockwork12processEventEv+0x118>
		else if(getCurrentEvent()->getEventType() == IXFEvent::Event &&
 80084ac:	687b      	ldr	r3, [r7, #4]
 80084ae:	4618      	mov	r0, r3
 80084b0:	f00b ff16 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 80084b4:	4603      	mov	r3, r0
 80084b6:	4618      	mov	r0, r3
 80084b8:	f7fe fa73 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 80084bc:	4603      	mov	r3, r0
 80084be:	2b03      	cmp	r3, #3
 80084c0:	d10c      	bne.n	80084dc <_ZN9Clockwork12processEventEv+0x100>
				getCurrentEvent()->getId() == EV_MINUTE_ELAPSED_id)
 80084c2:	687b      	ldr	r3, [r7, #4]
 80084c4:	4618      	mov	r0, r3
 80084c6:	f00b ff0b 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 80084ca:	4603      	mov	r3, r0
 80084cc:	4618      	mov	r0, r3
 80084ce:	f7fe fa75 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 80084d2:	4603      	mov	r3, r0
		else if(getCurrentEvent()->getEventType() == IXFEvent::Event &&
 80084d4:	2b01      	cmp	r3, #1
 80084d6:	d101      	bne.n	80084dc <_ZN9Clockwork12processEventEv+0x100>
 80084d8:	2301      	movs	r3, #1
 80084da:	e000      	b.n	80084de <_ZN9Clockwork12processEventEv+0x102>
 80084dc:	2300      	movs	r3, #0
 80084de:	2b00      	cmp	r3, #0
 80084e0:	d008      	beq.n	80084f4 <_ZN9Clockwork12processEventEv+0x118>
			doShowCurrentTime();
 80084e2:	687b      	ldr	r3, [r7, #4]
 80084e4:	681b      	ldr	r3, [r3, #0]
 80084e6:	3324      	adds	r3, #36	; 0x24
 80084e8:	681b      	ldr	r3, [r3, #0]
 80084ea:	6878      	ldr	r0, [r7, #4]
 80084ec:	4798      	blx	r3
		break;
 80084ee:	e001      	b.n	80084f4 <_ZN9Clockwork12processEventEv+0x118>
		break;
 80084f0:	bf00      	nop
 80084f2:	e000      	b.n	80084f6 <_ZN9Clockwork12processEventEv+0x11a>
		break;
 80084f4:	bf00      	nop
	}

	_currentState = newState;		// Save new state to actual
 80084f6:	687b      	ldr	r3, [r7, #4]
 80084f8:	7bfa      	ldrb	r2, [r7, #15]
 80084fa:	731a      	strb	r2, [r3, #12]

	return EventStatus::Consumed;	// We consume all given events/timeouts
 80084fc:	f107 030c 	add.w	r3, r7, #12
 8008500:	2101      	movs	r1, #1
 8008502:	4618      	mov	r0, r3
 8008504:	f7fe fa66 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 8008508:	7b3b      	ldrb	r3, [r7, #12]
}
 800850a:	4618      	mov	r0, r3
 800850c:	3710      	adds	r7, #16
 800850e:	46bd      	mov	sp, r7
 8008510:	bd80      	pop	{r7, pc}
	...

08008514 <_ZN9Clockwork6doInitEv>:

void Clockwork::doInit()
{
 8008514:	b5b0      	push	{r4, r5, r7, lr}
 8008516:	b082      	sub	sp, #8
 8008518:	af00      	add	r7, sp, #0
 800851a:	6078      	str	r0, [r7, #4]
#if (CLOCKWORK_VERBOSE != 0)
	Trace::outln("Starting Clockwork (CW)");
 800851c:	480f      	ldr	r0, [pc, #60]	; (800855c <_ZN9Clockwork6doInitEv+0x48>)
 800851e:	f007 f895 	bl	800f64c <_ZN5Trace5outlnEPKcz>
	Trace::outln("CW: Framework tick interval: %d ms", XFTimeoutManager::getInstance()->tickInterval());
 8008522:	f00d f8b7 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 8008526:	4603      	mov	r3, r0
 8008528:	4618      	mov	r0, r3
 800852a:	f7ff fe74 	bl	8008216 <_ZNK16XFTimeoutManager12tickIntervalEv>
 800852e:	4603      	mov	r3, r0
 8008530:	4619      	mov	r1, r3
 8008532:	480b      	ldr	r0, [pc, #44]	; (8008560 <_ZN9Clockwork6doInitEv+0x4c>)
 8008534:	f007 f88a 	bl	800f64c <_ZN5Trace5outlnEPKcz>
#endif

	// Update old tick value
	_oldTick = XFTimeoutManager::getInstance()->sysTicksInMs();
 8008538:	f00d f8ac 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 800853c:	4603      	mov	r3, r0
 800853e:	4618      	mov	r0, r3
 8008540:	f7ff fe75 	bl	800822e <_ZNK16XFTimeoutManager12sysTicksInMsEv>
 8008544:	4603      	mov	r3, r0
 8008546:	2200      	movs	r2, #0
 8008548:	461c      	mov	r4, r3
 800854a:	4615      	mov	r5, r2
 800854c:	687b      	ldr	r3, [r7, #4]
 800854e:	e9c3 4504 	strd	r4, r5, [r3, #16]
}
 8008552:	bf00      	nop
 8008554:	3708      	adds	r7, #8
 8008556:	46bd      	mov	sp, r7
 8008558:	bdb0      	pop	{r4, r5, r7, pc}
 800855a:	bf00      	nop
 800855c:	08018050 	.word	0x08018050
 8008560:	08018068 	.word	0x08018068

08008564 <_ZN9Clockwork17doShowCurrentTimeEv>:

void Clockwork::doShowCurrentTime()
{
 8008564:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008566:	b085      	sub	sp, #20
 8008568:	af02      	add	r7, sp, #8
 800856a:	6078      	str	r0, [r7, #4]
#if (CLOCKWORK_SHOWCURRENTTIME != 0)
	Trace::outln("Time: %02d:%02d:%02d.%03d",
			 	 _time.hour(),
 800856c:	687b      	ldr	r3, [r7, #4]
 800856e:	3318      	adds	r3, #24
 8008570:	4618      	mov	r0, r3
 8008572:	f7ff fe68 	bl	8008246 <_ZNK5TTime4hourEv>
 8008576:	4603      	mov	r3, r0
	Trace::outln("Time: %02d:%02d:%02d.%03d",
 8008578:	461c      	mov	r4, r3
			 	 _time.minute(),
 800857a:	687b      	ldr	r3, [r7, #4]
 800857c:	3318      	adds	r3, #24
 800857e:	4618      	mov	r0, r3
 8008580:	f7ff fe6d 	bl	800825e <_ZNK5TTime6minuteEv>
 8008584:	4603      	mov	r3, r0
	Trace::outln("Time: %02d:%02d:%02d.%03d",
 8008586:	461d      	mov	r5, r3
			 	 _time.second(),
 8008588:	687b      	ldr	r3, [r7, #4]
 800858a:	3318      	adds	r3, #24
 800858c:	4618      	mov	r0, r3
 800858e:	f7ff fe72 	bl	8008276 <_ZNK5TTime6secondEv>
 8008592:	4603      	mov	r3, r0
	Trace::outln("Time: %02d:%02d:%02d.%03d",
 8008594:	461e      	mov	r6, r3
			 	 _time.msec());
 8008596:	687b      	ldr	r3, [r7, #4]
 8008598:	3318      	adds	r3, #24
 800859a:	4618      	mov	r0, r3
 800859c:	f7ff fe77 	bl	800828e <_ZNK5TTime4msecEv>
 80085a0:	4603      	mov	r3, r0
	Trace::outln("Time: %02d:%02d:%02d.%03d",
 80085a2:	9300      	str	r3, [sp, #0]
 80085a4:	4633      	mov	r3, r6
 80085a6:	462a      	mov	r2, r5
 80085a8:	4621      	mov	r1, r4
 80085aa:	4803      	ldr	r0, [pc, #12]	; (80085b8 <_ZN9Clockwork17doShowCurrentTimeEv+0x54>)
 80085ac:	f007 f84e 	bl	800f64c <_ZN5Trace5outlnEPKcz>
#endif
}
 80085b0:	bf00      	nop
 80085b2:	370c      	adds	r7, #12
 80085b4:	46bd      	mov	sp, r7
 80085b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80085b8:	0801808c 	.word	0x0801808c

080085bc <_ZN9Clockwork14doSecondUpdateEv>:

void Clockwork::doSecondUpdate()
{
 80085bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80085c0:	b089      	sub	sp, #36	; 0x24
 80085c2:	af02      	add	r7, sp, #8
 80085c4:	6078      	str	r0, [r7, #4]
	uint32_t ticksElapsed = XFTimeoutManager::getInstance()->sysTicksInMs() - _oldTick;
 80085c6:	f00d f865 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 80085ca:	4603      	mov	r3, r0
 80085cc:	4618      	mov	r0, r3
 80085ce:	f7ff fe2e 	bl	800822e <_ZNK16XFTimeoutManager12sysTicksInMsEv>
 80085d2:	4601      	mov	r1, r0
 80085d4:	687b      	ldr	r3, [r7, #4]
 80085d6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80085da:	4613      	mov	r3, r2
 80085dc:	1acb      	subs	r3, r1, r3
 80085de:	60fb      	str	r3, [r7, #12]
	uint32_t millisecondsElapsed, msLong;
	uint8_t hours = _time.hour();
 80085e0:	687b      	ldr	r3, [r7, #4]
 80085e2:	3318      	adds	r3, #24
 80085e4:	4618      	mov	r0, r3
 80085e6:	f7ff fe2e 	bl	8008246 <_ZNK5TTime4hourEv>
 80085ea:	4603      	mov	r3, r0
 80085ec:	74fb      	strb	r3, [r7, #19]
	uint8_t minutes = _time.minute();
 80085ee:	687b      	ldr	r3, [r7, #4]
 80085f0:	3318      	adds	r3, #24
 80085f2:	4618      	mov	r0, r3
 80085f4:	f7ff fe33 	bl	800825e <_ZNK5TTime6minuteEv>
 80085f8:	4603      	mov	r3, r0
 80085fa:	74bb      	strb	r3, [r7, #18]
	uint8_t seconds = _time.second();
 80085fc:	687b      	ldr	r3, [r7, #4]
 80085fe:	3318      	adds	r3, #24
 8008600:	4618      	mov	r0, r3
 8008602:	f7ff fe38 	bl	8008276 <_ZNK5TTime6secondEv>
 8008606:	4603      	mov	r3, r0
 8008608:	747b      	strb	r3, [r7, #17]

	_oldTick += ticksElapsed;
 800860a:	687b      	ldr	r3, [r7, #4]
 800860c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008610:	68f9      	ldr	r1, [r7, #12]
 8008612:	2000      	movs	r0, #0
 8008614:	460c      	mov	r4, r1
 8008616:	4605      	mov	r5, r0
 8008618:	eb12 0804 	adds.w	r8, r2, r4
 800861c:	eb43 0905 	adc.w	r9, r3, r5
 8008620:	687b      	ldr	r3, [r7, #4]
 8008622:	e9c3 8904 	strd	r8, r9, [r3, #16]

	millisecondsElapsed = ticksElapsed;
 8008626:	68fb      	ldr	r3, [r7, #12]
 8008628:	60bb      	str	r3, [r7, #8]

	// Sum elapsed milliseconds
	msLong = millisecondsElapsed + _time.msec();
 800862a:	687b      	ldr	r3, [r7, #4]
 800862c:	3318      	adds	r3, #24
 800862e:	4618      	mov	r0, r3
 8008630:	f7ff fe2d 	bl	800828e <_ZNK5TTime4msecEv>
 8008634:	4603      	mov	r3, r0
 8008636:	461a      	mov	r2, r3
 8008638:	68bb      	ldr	r3, [r7, #8]
 800863a:	4413      	add	r3, r2
 800863c:	617b      	str	r3, [r7, #20]

	if (msLong >= 3600000)
 800863e:	697b      	ldr	r3, [r7, #20]
 8008640:	4a50      	ldr	r2, [pc, #320]	; (8008784 <_ZN9Clockwork14doSecondUpdateEv+0x1c8>)
 8008642:	4293      	cmp	r3, r2
 8008644:	d312      	bcc.n	800866c <_ZN9Clockwork14doSecondUpdateEv+0xb0>
	{
		// Add first hours
		hours += msLong / 3600000;
 8008646:	697b      	ldr	r3, [r7, #20]
 8008648:	4a4f      	ldr	r2, [pc, #316]	; (8008788 <_ZN9Clockwork14doSecondUpdateEv+0x1cc>)
 800864a:	fba2 2303 	umull	r2, r3, r2, r3
 800864e:	0d5b      	lsrs	r3, r3, #21
 8008650:	b2da      	uxtb	r2, r3
 8008652:	7cfb      	ldrb	r3, [r7, #19]
 8008654:	4413      	add	r3, r2
 8008656:	74fb      	strb	r3, [r7, #19]
		msLong %= 3600000;
 8008658:	697b      	ldr	r3, [r7, #20]
 800865a:	4a4b      	ldr	r2, [pc, #300]	; (8008788 <_ZN9Clockwork14doSecondUpdateEv+0x1cc>)
 800865c:	fba2 1203 	umull	r1, r2, r2, r3
 8008660:	0d52      	lsrs	r2, r2, #21
 8008662:	4948      	ldr	r1, [pc, #288]	; (8008784 <_ZN9Clockwork14doSecondUpdateEv+0x1c8>)
 8008664:	fb01 f202 	mul.w	r2, r1, r2
 8008668:	1a9b      	subs	r3, r3, r2
 800866a:	617b      	str	r3, [r7, #20]
	}

	if (msLong >= 60000)
 800866c:	697b      	ldr	r3, [r7, #20]
 800866e:	f64e 225f 	movw	r2, #59999	; 0xea5f
 8008672:	4293      	cmp	r3, r2
 8008674:	d913      	bls.n	800869e <_ZN9Clockwork14doSecondUpdateEv+0xe2>
	{
		// then minutes
		minutes += msLong / 60000;
 8008676:	697b      	ldr	r3, [r7, #20]
 8008678:	4a44      	ldr	r2, [pc, #272]	; (800878c <_ZN9Clockwork14doSecondUpdateEv+0x1d0>)
 800867a:	fba2 2303 	umull	r2, r3, r2, r3
 800867e:	0b9b      	lsrs	r3, r3, #14
 8008680:	b2da      	uxtb	r2, r3
 8008682:	7cbb      	ldrb	r3, [r7, #18]
 8008684:	4413      	add	r3, r2
 8008686:	74bb      	strb	r3, [r7, #18]
		msLong %= 60000;
 8008688:	697b      	ldr	r3, [r7, #20]
 800868a:	4a40      	ldr	r2, [pc, #256]	; (800878c <_ZN9Clockwork14doSecondUpdateEv+0x1d0>)
 800868c:	fba2 1203 	umull	r1, r2, r2, r3
 8008690:	0b92      	lsrs	r2, r2, #14
 8008692:	f64e 2160 	movw	r1, #60000	; 0xea60
 8008696:	fb01 f202 	mul.w	r2, r1, r2
 800869a:	1a9b      	subs	r3, r3, r2
 800869c:	617b      	str	r3, [r7, #20]
	}

	// Add seconds elapsed
	seconds += (msLong / 1000);
 800869e:	697b      	ldr	r3, [r7, #20]
 80086a0:	4a3b      	ldr	r2, [pc, #236]	; (8008790 <_ZN9Clockwork14doSecondUpdateEv+0x1d4>)
 80086a2:	fba2 2303 	umull	r2, r3, r2, r3
 80086a6:	099b      	lsrs	r3, r3, #6
 80086a8:	b2da      	uxtb	r2, r3
 80086aa:	7c7b      	ldrb	r3, [r7, #17]
 80086ac:	4413      	add	r3, r2
 80086ae:	747b      	strb	r3, [r7, #17]
	msLong %= 1000;
 80086b0:	697b      	ldr	r3, [r7, #20]
 80086b2:	4a37      	ldr	r2, [pc, #220]	; (8008790 <_ZN9Clockwork14doSecondUpdateEv+0x1d4>)
 80086b4:	fba2 1203 	umull	r1, r2, r2, r3
 80086b8:	0992      	lsrs	r2, r2, #6
 80086ba:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80086be:	fb01 f202 	mul.w	r2, r1, r2
 80086c2:	1a9b      	subs	r3, r3, r2
 80086c4:	617b      	str	r3, [r7, #20]

	if (seconds >= 60)
 80086c6:	7c7b      	ldrb	r3, [r7, #17]
 80086c8:	2b3b      	cmp	r3, #59	; 0x3b
 80086ca:	d925      	bls.n	8008718 <_ZN9Clockwork14doSecondUpdateEv+0x15c>
	{
		// Increment minutes
		minutes += (seconds / 60);
 80086cc:	7c7b      	ldrb	r3, [r7, #17]
 80086ce:	4a31      	ldr	r2, [pc, #196]	; (8008794 <_ZN9Clockwork14doSecondUpdateEv+0x1d8>)
 80086d0:	fba2 2303 	umull	r2, r3, r2, r3
 80086d4:	095b      	lsrs	r3, r3, #5
 80086d6:	b2da      	uxtb	r2, r3
 80086d8:	7cbb      	ldrb	r3, [r7, #18]
 80086da:	4413      	add	r3, r2
 80086dc:	74bb      	strb	r3, [r7, #18]
		seconds %= 60;
 80086de:	7c7a      	ldrb	r2, [r7, #17]
 80086e0:	4b2c      	ldr	r3, [pc, #176]	; (8008794 <_ZN9Clockwork14doSecondUpdateEv+0x1d8>)
 80086e2:	fba3 1302 	umull	r1, r3, r3, r2
 80086e6:	0959      	lsrs	r1, r3, #5
 80086e8:	460b      	mov	r3, r1
 80086ea:	011b      	lsls	r3, r3, #4
 80086ec:	1a5b      	subs	r3, r3, r1
 80086ee:	009b      	lsls	r3, r3, #2
 80086f0:	1ad3      	subs	r3, r2, r3
 80086f2:	747b      	strb	r3, [r7, #17]

		// Tell state machine one more minute elapsed
		pushEvent(new XFEvent(EV_MINUTE_ELAPSED_id));
 80086f4:	687d      	ldr	r5, [r7, #4]
 80086f6:	687b      	ldr	r3, [r7, #4]
 80086f8:	681b      	ldr	r3, [r3, #0]
 80086fa:	330c      	adds	r3, #12
 80086fc:	681c      	ldr	r4, [r3, #0]
 80086fe:	2014      	movs	r0, #20
 8008700:	f00d fd67 	bl	80161d2 <_Znwj>
 8008704:	4603      	mov	r3, r0
 8008706:	461e      	mov	r6, r3
 8008708:	2200      	movs	r2, #0
 800870a:	2101      	movs	r1, #1
 800870c:	4630      	mov	r0, r6
 800870e:	f00b fc59 	bl	8013fc4 <_ZN7XFEventC1EiP11IXFReactive>
 8008712:	4631      	mov	r1, r6
 8008714:	4628      	mov	r0, r5
 8008716:	47a0      	blx	r4
	}

	if (minutes >= 60)
 8008718:	7cbb      	ldrb	r3, [r7, #18]
 800871a:	2b3b      	cmp	r3, #59	; 0x3b
 800871c:	d913      	bls.n	8008746 <_ZN9Clockwork14doSecondUpdateEv+0x18a>
	{
		hours += (minutes / 60);
 800871e:	7cbb      	ldrb	r3, [r7, #18]
 8008720:	4a1c      	ldr	r2, [pc, #112]	; (8008794 <_ZN9Clockwork14doSecondUpdateEv+0x1d8>)
 8008722:	fba2 2303 	umull	r2, r3, r2, r3
 8008726:	095b      	lsrs	r3, r3, #5
 8008728:	b2da      	uxtb	r2, r3
 800872a:	7cfb      	ldrb	r3, [r7, #19]
 800872c:	4413      	add	r3, r2
 800872e:	74fb      	strb	r3, [r7, #19]
		minutes %= 60;
 8008730:	7cba      	ldrb	r2, [r7, #18]
 8008732:	4b18      	ldr	r3, [pc, #96]	; (8008794 <_ZN9Clockwork14doSecondUpdateEv+0x1d8>)
 8008734:	fba3 1302 	umull	r1, r3, r3, r2
 8008738:	0959      	lsrs	r1, r3, #5
 800873a:	460b      	mov	r3, r1
 800873c:	011b      	lsls	r3, r3, #4
 800873e:	1a5b      	subs	r3, r3, r1
 8008740:	009b      	lsls	r3, r3, #2
 8008742:	1ad3      	subs	r3, r2, r3
 8008744:	74bb      	strb	r3, [r7, #18]
	}

	if (hours >= 24)
 8008746:	7cfb      	ldrb	r3, [r7, #19]
 8008748:	2b17      	cmp	r3, #23
 800874a:	d90a      	bls.n	8008762 <_ZN9Clockwork14doSecondUpdateEv+0x1a6>
	{
		hours %= 24;
 800874c:	7cfa      	ldrb	r2, [r7, #19]
 800874e:	4b12      	ldr	r3, [pc, #72]	; (8008798 <_ZN9Clockwork14doSecondUpdateEv+0x1dc>)
 8008750:	fba3 1302 	umull	r1, r3, r3, r2
 8008754:	0919      	lsrs	r1, r3, #4
 8008756:	460b      	mov	r3, r1
 8008758:	005b      	lsls	r3, r3, #1
 800875a:	440b      	add	r3, r1
 800875c:	00db      	lsls	r3, r3, #3
 800875e:	1ad3      	subs	r3, r2, r3
 8008760:	74fb      	strb	r3, [r7, #19]
	}

	// Set calculated time
	_time.setHMS(hours,
 8008762:	687b      	ldr	r3, [r7, #4]
 8008764:	f103 0018 	add.w	r0, r3, #24
 8008768:	697b      	ldr	r3, [r7, #20]
 800876a:	b29b      	uxth	r3, r3
 800876c:	7c7c      	ldrb	r4, [r7, #17]
 800876e:	7cba      	ldrb	r2, [r7, #18]
 8008770:	7cf9      	ldrb	r1, [r7, #19]
 8008772:	9300      	str	r3, [sp, #0]
 8008774:	4623      	mov	r3, r4
 8008776:	f000 f8cb 	bl	8008910 <_ZN5TTime6setHMSEhhht>
			minutes,
			seconds,
			(uint16_t)msLong /* remaining milliseconds*/);
}
 800877a:	bf00      	nop
 800877c:	371c      	adds	r7, #28
 800877e:	46bd      	mov	sp, r7
 8008780:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008784:	0036ee80 	.word	0x0036ee80
 8008788:	95217cb1 	.word	0x95217cb1
 800878c:	45e7b273 	.word	0x45e7b273
 8008790:	10624dd3 	.word	0x10624dd3
 8008794:	88888889 	.word	0x88888889
 8008798:	aaaaaaab 	.word	0xaaaaaaab

0800879c <_Z41__static_initialization_and_destruction_0ii>:
 800879c:	b580      	push	{r7, lr}
 800879e:	b088      	sub	sp, #32
 80087a0:	af00      	add	r7, sp, #0
 80087a2:	6078      	str	r0, [r7, #4]
 80087a4:	6039      	str	r1, [r7, #0]
 80087a6:	687b      	ldr	r3, [r7, #4]
 80087a8:	2b01      	cmp	r3, #1
 80087aa:	d122      	bne.n	80087f2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 80087ac:	683b      	ldr	r3, [r7, #0]
 80087ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80087b2:	4293      	cmp	r3, r2
 80087b4:	d11d      	bne.n	80087f2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 80087b6:	4b18      	ldr	r3, [pc, #96]	; (8008818 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 80087b8:	681b      	ldr	r3, [r3, #0]
 80087ba:	613b      	str	r3, [r7, #16]
 80087bc:	f107 0310 	add.w	r3, r7, #16
 80087c0:	60bb      	str	r3, [r7, #8]
 80087c2:	2304      	movs	r3, #4
 80087c4:	60fb      	str	r3, [r7, #12]
 80087c6:	f107 0308 	add.w	r3, r7, #8
 80087ca:	e893 0006 	ldmia.w	r3, {r1, r2}
 80087ce:	4813      	ldr	r0, [pc, #76]	; (800881c <_Z41__static_initialization_and_destruction_0ii+0x80>)
 80087d0:	f7fe fab0 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 80087d4:	4b12      	ldr	r3, [pc, #72]	; (8008820 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 80087d6:	681b      	ldr	r3, [r3, #0]
 80087d8:	61fb      	str	r3, [r7, #28]
 80087da:	f107 031c 	add.w	r3, r7, #28
 80087de:	617b      	str	r3, [r7, #20]
 80087e0:	2304      	movs	r3, #4
 80087e2:	61bb      	str	r3, [r7, #24]
 80087e4:	f107 0314 	add.w	r3, r7, #20
 80087e8:	e893 0006 	ldmia.w	r3, {r1, r2}
 80087ec:	480d      	ldr	r0, [pc, #52]	; (8008824 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80087ee:	f7fe faa1 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 80087f2:	687b      	ldr	r3, [r7, #4]
 80087f4:	2b00      	cmp	r3, #0
 80087f6:	d10a      	bne.n	800880e <_Z41__static_initialization_and_destruction_0ii+0x72>
 80087f8:	683b      	ldr	r3, [r7, #0]
 80087fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80087fe:	4293      	cmp	r3, r2
 8008800:	d105      	bne.n	800880e <_Z41__static_initialization_and_destruction_0ii+0x72>
 8008802:	4808      	ldr	r0, [pc, #32]	; (8008824 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8008804:	f7fe fbe0 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8008808:	4804      	ldr	r0, [pc, #16]	; (800881c <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800880a:	f7fe fbdd 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800880e:	bf00      	nop
 8008810:	3720      	adds	r7, #32
 8008812:	46bd      	mov	sp, r7
 8008814:	bd80      	pop	{r7, pc}
 8008816:	bf00      	nop
 8008818:	08018190 	.word	0x08018190
 800881c:	2000182c 	.word	0x2000182c
 8008820:	08018194 	.word	0x08018194
 8008824:	20001834 	.word	0x20001834

08008828 <_GLOBAL__sub_I__ZN9Clockwork10_pInstanceE>:
 8008828:	b580      	push	{r7, lr}
 800882a:	af00      	add	r7, sp, #0
 800882c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008830:	2001      	movs	r0, #1
 8008832:	f7ff ffb3 	bl	800879c <_Z41__static_initialization_and_destruction_0ii>
 8008836:	bd80      	pop	{r7, pc}

08008838 <_GLOBAL__sub_D__ZN9Clockwork10_pInstanceE>:
 8008838:	b580      	push	{r7, lr}
 800883a:	af00      	add	r7, sp, #0
 800883c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008840:	2000      	movs	r0, #0
 8008842:	f7ff ffab 	bl	800879c <_Z41__static_initialization_and_destruction_0ii>
 8008846:	bd80      	pop	{r7, pc}

08008848 <_ZN5TTimeC1Ev>:
#include <platform-config.h>
#include <trace/trace.h>
#include "clockwork.h"
#include "ttime.h"

TTime::TTime()
 8008848:	b480      	push	{r7}
 800884a:	b083      	sub	sp, #12
 800884c:	af00      	add	r7, sp, #0
 800884e:	6078      	str	r0, [r7, #4]
 : mTHours(0),
   mTMinutes(0),
   mTSeconds(0),
   mTMilliseconds(0)
 8008850:	687b      	ldr	r3, [r7, #4]
 8008852:	2200      	movs	r2, #0
 8008854:	701a      	strb	r2, [r3, #0]
 8008856:	687b      	ldr	r3, [r7, #4]
 8008858:	2200      	movs	r2, #0
 800885a:	705a      	strb	r2, [r3, #1]
 800885c:	687b      	ldr	r3, [r7, #4]
 800885e:	2200      	movs	r2, #0
 8008860:	709a      	strb	r2, [r3, #2]
 8008862:	687b      	ldr	r3, [r7, #4]
 8008864:	2200      	movs	r2, #0
 8008866:	809a      	strh	r2, [r3, #4]
{
}
 8008868:	687b      	ldr	r3, [r7, #4]
 800886a:	4618      	mov	r0, r3
 800886c:	370c      	adds	r7, #12
 800886e:	46bd      	mov	sp, r7
 8008870:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008874:	4770      	bx	lr

08008876 <_ZN5TTimeD1Ev>:

TTime::~TTime()
 8008876:	b480      	push	{r7}
 8008878:	b083      	sub	sp, #12
 800887a:	af00      	add	r7, sp, #0
 800887c:	6078      	str	r0, [r7, #4]
{
}
 800887e:	687b      	ldr	r3, [r7, #4]
 8008880:	4618      	mov	r0, r3
 8008882:	370c      	adds	r7, #12
 8008884:	46bd      	mov	sp, r7
 8008886:	f85d 7b04 	ldr.w	r7, [sp], #4
 800888a:	4770      	bx	lr

0800888c <_ZN5TTime11currentTimeEv>:
	return time;
}

// static
TTime TTime::currentTime()
{
 800888c:	b580      	push	{r7, lr}
 800888e:	b082      	sub	sp, #8
 8008890:	af00      	add	r7, sp, #0
 8008892:	6078      	str	r0, [r7, #4]
	return Clockwork::instance().currentTime();
 8008894:	f7ff fd8a 	bl	80083ac <_ZN9Clockwork8instanceEv>
 8008898:	4603      	mov	r3, r0
 800889a:	4618      	mov	r0, r3
 800889c:	f7ff fd75 	bl	800838a <_ZN9Clockwork11currentTimeEv>
 80088a0:	4602      	mov	r2, r0
 80088a2:	687b      	ldr	r3, [r7, #4]
 80088a4:	6811      	ldr	r1, [r2, #0]
 80088a6:	6019      	str	r1, [r3, #0]
 80088a8:	8892      	ldrh	r2, [r2, #4]
 80088aa:	809a      	strh	r2, [r3, #4]
}
 80088ac:	6878      	ldr	r0, [r7, #4]
 80088ae:	3708      	adds	r7, #8
 80088b0:	46bd      	mov	sp, r7
 80088b2:	bd80      	pop	{r7, pc}

080088b4 <_ZNK5TTime6getMdsEv>:
	seconds = mTSeconds;
	milliseconds = mTMilliseconds;
}

unsigned long TTime::getMds() const
{
 80088b4:	b480      	push	{r7}
 80088b6:	b085      	sub	sp, #20
 80088b8:	af00      	add	r7, sp, #0
 80088ba:	6078      	str	r0, [r7, #4]
	unsigned long mds;

	mds = (unsigned long)mTHours * 3600000;
 80088bc:	687b      	ldr	r3, [r7, #4]
 80088be:	781b      	ldrb	r3, [r3, #0]
 80088c0:	461a      	mov	r2, r3
 80088c2:	4b12      	ldr	r3, [pc, #72]	; (800890c <_ZNK5TTime6getMdsEv+0x58>)
 80088c4:	fb02 f303 	mul.w	r3, r2, r3
 80088c8:	60fb      	str	r3, [r7, #12]
	mds += (unsigned long)mTMinutes * 60000;
 80088ca:	687b      	ldr	r3, [r7, #4]
 80088cc:	785b      	ldrb	r3, [r3, #1]
 80088ce:	461a      	mov	r2, r3
 80088d0:	f64e 2360 	movw	r3, #60000	; 0xea60
 80088d4:	fb02 f303 	mul.w	r3, r2, r3
 80088d8:	68fa      	ldr	r2, [r7, #12]
 80088da:	4413      	add	r3, r2
 80088dc:	60fb      	str	r3, [r7, #12]
	mds += (unsigned long)mTSeconds * 1000;
 80088de:	687b      	ldr	r3, [r7, #4]
 80088e0:	789b      	ldrb	r3, [r3, #2]
 80088e2:	461a      	mov	r2, r3
 80088e4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80088e8:	fb02 f303 	mul.w	r3, r2, r3
 80088ec:	68fa      	ldr	r2, [r7, #12]
 80088ee:	4413      	add	r3, r2
 80088f0:	60fb      	str	r3, [r7, #12]
	mds += (unsigned long)mTMilliseconds;
 80088f2:	687b      	ldr	r3, [r7, #4]
 80088f4:	889b      	ldrh	r3, [r3, #4]
 80088f6:	461a      	mov	r2, r3
 80088f8:	68fb      	ldr	r3, [r7, #12]
 80088fa:	4413      	add	r3, r2
 80088fc:	60fb      	str	r3, [r7, #12]

	return mds;
 80088fe:	68fb      	ldr	r3, [r7, #12]
}
 8008900:	4618      	mov	r0, r3
 8008902:	3714      	adds	r7, #20
 8008904:	46bd      	mov	sp, r7
 8008906:	f85d 7b04 	ldr.w	r7, [sp], #4
 800890a:	4770      	bx	lr
 800890c:	0036ee80 	.word	0x0036ee80

08008910 <_ZN5TTime6setHMSEhhht>:

	return *this;
}

void TTime::setHMS(uint8_t hours, uint8_t minutes, uint8_t seconds, uint16_t milliseconds)
{
 8008910:	b480      	push	{r7}
 8008912:	b083      	sub	sp, #12
 8008914:	af00      	add	r7, sp, #0
 8008916:	6078      	str	r0, [r7, #4]
 8008918:	4608      	mov	r0, r1
 800891a:	4611      	mov	r1, r2
 800891c:	461a      	mov	r2, r3
 800891e:	4603      	mov	r3, r0
 8008920:	70fb      	strb	r3, [r7, #3]
 8008922:	460b      	mov	r3, r1
 8008924:	70bb      	strb	r3, [r7, #2]
 8008926:	4613      	mov	r3, r2
 8008928:	707b      	strb	r3, [r7, #1]
	if (hours < 24 &&
 800892a:	78fb      	ldrb	r3, [r7, #3]
 800892c:	2b17      	cmp	r3, #23
 800892e:	d815      	bhi.n	800895c <_ZN5TTime6setHMSEhhht+0x4c>
 8008930:	78bb      	ldrb	r3, [r7, #2]
 8008932:	2b3b      	cmp	r3, #59	; 0x3b
 8008934:	d812      	bhi.n	800895c <_ZN5TTime6setHMSEhhht+0x4c>
		minutes < 60 &&
 8008936:	787b      	ldrb	r3, [r7, #1]
 8008938:	2b3b      	cmp	r3, #59	; 0x3b
 800893a:	d80f      	bhi.n	800895c <_ZN5TTime6setHMSEhhht+0x4c>
		seconds < 60 &&
 800893c:	8a3b      	ldrh	r3, [r7, #16]
 800893e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8008942:	d20b      	bcs.n	800895c <_ZN5TTime6setHMSEhhht+0x4c>
		milliseconds < 1000)
	{
		mTHours = hours;
 8008944:	687b      	ldr	r3, [r7, #4]
 8008946:	78fa      	ldrb	r2, [r7, #3]
 8008948:	701a      	strb	r2, [r3, #0]
		mTMinutes = minutes;
 800894a:	687b      	ldr	r3, [r7, #4]
 800894c:	78ba      	ldrb	r2, [r7, #2]
 800894e:	705a      	strb	r2, [r3, #1]
		mTSeconds = seconds;
 8008950:	687b      	ldr	r3, [r7, #4]
 8008952:	787a      	ldrb	r2, [r7, #1]
 8008954:	709a      	strb	r2, [r3, #2]
		mTMilliseconds = milliseconds;
 8008956:	687b      	ldr	r3, [r7, #4]
 8008958:	8a3a      	ldrh	r2, [r7, #16]
 800895a:	809a      	strh	r2, [r3, #4]
	}
	else
	{
//		Trace::outln("TTime: Received bad formatted time");
	}
}
 800895c:	bf00      	nop
 800895e:	370c      	adds	r7, #12
 8008960:	46bd      	mov	sp, r7
 8008962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008966:	4770      	bx	lr

08008968 <_Z41__static_initialization_and_destruction_0ii>:
	// Trace::outln("setMds: %02d:%02d:%02d.%03d",
	//	  mTHours,
	//	  mTMinutes,
	//	  mTSeconds,
	//	  mTMilliseconds);
}
 8008968:	b580      	push	{r7, lr}
 800896a:	b088      	sub	sp, #32
 800896c:	af00      	add	r7, sp, #0
 800896e:	6078      	str	r0, [r7, #4]
 8008970:	6039      	str	r1, [r7, #0]
 8008972:	687b      	ldr	r3, [r7, #4]
 8008974:	2b01      	cmp	r3, #1
 8008976:	d122      	bne.n	80089be <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008978:	683b      	ldr	r3, [r7, #0]
 800897a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800897e:	4293      	cmp	r3, r2
 8008980:	d11d      	bne.n	80089be <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008982:	4b18      	ldr	r3, [pc, #96]	; (80089e4 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8008984:	681b      	ldr	r3, [r3, #0]
 8008986:	613b      	str	r3, [r7, #16]
 8008988:	f107 0310 	add.w	r3, r7, #16
 800898c:	60bb      	str	r3, [r7, #8]
 800898e:	2304      	movs	r3, #4
 8008990:	60fb      	str	r3, [r7, #12]
 8008992:	f107 0308 	add.w	r3, r7, #8
 8008996:	e893 0006 	ldmia.w	r3, {r1, r2}
 800899a:	4813      	ldr	r0, [pc, #76]	; (80089e8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800899c:	f7fe f9ca 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 80089a0:	4b12      	ldr	r3, [pc, #72]	; (80089ec <_Z41__static_initialization_and_destruction_0ii+0x84>)
 80089a2:	681b      	ldr	r3, [r3, #0]
 80089a4:	61fb      	str	r3, [r7, #28]
 80089a6:	f107 031c 	add.w	r3, r7, #28
 80089aa:	617b      	str	r3, [r7, #20]
 80089ac:	2304      	movs	r3, #4
 80089ae:	61bb      	str	r3, [r7, #24]
 80089b0:	f107 0314 	add.w	r3, r7, #20
 80089b4:	e893 0006 	ldmia.w	r3, {r1, r2}
 80089b8:	480d      	ldr	r0, [pc, #52]	; (80089f0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80089ba:	f7fe f9bb 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 80089be:	687b      	ldr	r3, [r7, #4]
 80089c0:	2b00      	cmp	r3, #0
 80089c2:	d10a      	bne.n	80089da <_Z41__static_initialization_and_destruction_0ii+0x72>
 80089c4:	683b      	ldr	r3, [r7, #0]
 80089c6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80089ca:	4293      	cmp	r3, r2
 80089cc:	d105      	bne.n	80089da <_Z41__static_initialization_and_destruction_0ii+0x72>
 80089ce:	4808      	ldr	r0, [pc, #32]	; (80089f0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80089d0:	f7fe fafa 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 80089d4:	4804      	ldr	r0, [pc, #16]	; (80089e8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 80089d6:	f7fe faf7 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 80089da:	bf00      	nop
 80089dc:	3720      	adds	r7, #32
 80089de:	46bd      	mov	sp, r7
 80089e0:	bd80      	pop	{r7, pc}
 80089e2:	bf00      	nop
 80089e4:	08018280 	.word	0x08018280
 80089e8:	20001840 	.word	0x20001840
 80089ec:	08018284 	.word	0x08018284
 80089f0:	20001848 	.word	0x20001848

080089f4 <_GLOBAL__sub_I__ZN5TTimeC2Ev>:
 80089f4:	b580      	push	{r7, lr}
 80089f6:	af00      	add	r7, sp, #0
 80089f8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80089fc:	2001      	movs	r0, #1
 80089fe:	f7ff ffb3 	bl	8008968 <_Z41__static_initialization_and_destruction_0ii>
 8008a02:	bd80      	pop	{r7, pc}

08008a04 <_GLOBAL__sub_D__ZN5TTimeC2Ev>:
 8008a04:	b580      	push	{r7, lr}
 8008a06:	af00      	add	r7, sp, #0
 8008a08:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008a0c:	2000      	movs	r0, #0
 8008a0e:	f7ff ffab 	bl	8008968 <_Z41__static_initialization_and_destruction_0ii>
 8008a12:	bd80      	pop	{r7, pc}

08008a14 <_ZNSt12_Base_bitsetILj1EEC1Ey>:
      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
      : _M_w(0)
      { }

#if __cplusplus >= 201103L
      constexpr _Base_bitset(unsigned long long __val) noexcept
 8008a14:	b480      	push	{r7}
 8008a16:	b085      	sub	sp, #20
 8008a18:	af00      	add	r7, sp, #0
 8008a1a:	60f8      	str	r0, [r7, #12]
 8008a1c:	e9c7 2300 	strd	r2, r3, [r7]
#else
      _Base_bitset(unsigned long __val)
#endif
      : _M_w(__val)
 8008a20:	683a      	ldr	r2, [r7, #0]
 8008a22:	68fb      	ldr	r3, [r7, #12]
 8008a24:	601a      	str	r2, [r3, #0]
      { }
 8008a26:	68fb      	ldr	r3, [r7, #12]
 8008a28:	4618      	mov	r0, r3
 8008a2a:	3714      	adds	r7, #20
 8008a2c:	46bd      	mov	sp, r7
 8008a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a32:	4770      	bx	lr

08008a34 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE15_M_add_ref_copyEv>:
    { ++_M_use_count; }
 8008a34:	b480      	push	{r7}
 8008a36:	b083      	sub	sp, #12
 8008a38:	af00      	add	r7, sp, #0
 8008a3a:	6078      	str	r0, [r7, #4]
 8008a3c:	687b      	ldr	r3, [r7, #4]
 8008a3e:	685b      	ldr	r3, [r3, #4]
 8008a40:	1c5a      	adds	r2, r3, #1
 8008a42:	687b      	ldr	r3, [r7, #4]
 8008a44:	605a      	str	r2, [r3, #4]
 8008a46:	bf00      	nop
 8008a48:	370c      	adds	r7, #12
 8008a4a:	46bd      	mov	sp, r7
 8008a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a50:	4770      	bx	lr

08008a52 <_ZN7desenet5Frame6bufferEv>:
         *
         * Respect the maximal buffer length by calling the reservedLength() method and never write over out the buffer bounds, please.
         *
         * @return  Pointer to the buffer.
         */
        std::uint8_t * buffer()
 8008a52:	b580      	push	{r7, lr}
 8008a54:	b082      	sub	sp, #8
 8008a56:	af00      	add	r7, sp, #0
 8008a58:	6078      	str	r0, [r7, #4]
        {
            return buffer_.data();
 8008a5a:	687b      	ldr	r3, [r7, #4]
 8008a5c:	4618      	mov	r0, r3
 8008a5e:	f000 f89d 	bl	8008b9c <_ZN3hei12SharedBufferIhE4dataEv>
 8008a62:	4603      	mov	r3, r0
        }
 8008a64:	4618      	mov	r0, r3
 8008a66:	3708      	adds	r7, #8
 8008a68:	46bd      	mov	sp, r7
 8008a6a:	bd80      	pop	{r7, pc}

08008a6c <_ZNK7desenet5Frame6bufferEv>:
        /**
         * @brief Returns a readonly pointer to the buffer.
         *
         * @return  Readonly pointer to the buffer.
         */
        const std::uint8_t *buffer() const
 8008a6c:	b580      	push	{r7, lr}
 8008a6e:	b082      	sub	sp, #8
 8008a70:	af00      	add	r7, sp, #0
 8008a72:	6078      	str	r0, [r7, #4]
        {
            return buffer_.data();
 8008a74:	687b      	ldr	r3, [r7, #4]
 8008a76:	4618      	mov	r0, r3
 8008a78:	f000 f89d 	bl	8008bb6 <_ZNK3hei12SharedBufferIhE4dataEv>
 8008a7c:	4603      	mov	r3, r0
        }
 8008a7e:	4618      	mov	r0, r3
 8008a80:	3708      	adds	r7, #8
 8008a82:	46bd      	mov	sp, r7
 8008a84:	bd80      	pop	{r7, pc}

08008a86 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
      __shared_ptr(const __shared_ptr&) noexcept = default;
 8008a86:	b580      	push	{r7, lr}
 8008a88:	b082      	sub	sp, #8
 8008a8a:	af00      	add	r7, sp, #0
 8008a8c:	6078      	str	r0, [r7, #4]
 8008a8e:	6039      	str	r1, [r7, #0]
 8008a90:	683b      	ldr	r3, [r7, #0]
 8008a92:	681a      	ldr	r2, [r3, #0]
 8008a94:	687b      	ldr	r3, [r7, #4]
 8008a96:	601a      	str	r2, [r3, #0]
 8008a98:	687b      	ldr	r3, [r7, #4]
 8008a9a:	1d1a      	adds	r2, r3, #4
 8008a9c:	683b      	ldr	r3, [r7, #0]
 8008a9e:	3304      	adds	r3, #4
 8008aa0:	4619      	mov	r1, r3
 8008aa2:	4610      	mov	r0, r2
 8008aa4:	f000 f894 	bl	8008bd0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 8008aa8:	687b      	ldr	r3, [r7, #4]
 8008aaa:	4618      	mov	r0, r3
 8008aac:	3708      	adds	r7, #8
 8008aae:	46bd      	mov	sp, r7
 8008ab0:	bd80      	pop	{r7, pc}

08008ab2 <_ZNSt10shared_ptrIhEC1ERKS0_>:
      shared_ptr(const shared_ptr&) noexcept = default; ///< Copy constructor
 8008ab2:	b580      	push	{r7, lr}
 8008ab4:	b082      	sub	sp, #8
 8008ab6:	af00      	add	r7, sp, #0
 8008ab8:	6078      	str	r0, [r7, #4]
 8008aba:	6039      	str	r1, [r7, #0]
 8008abc:	687b      	ldr	r3, [r7, #4]
 8008abe:	683a      	ldr	r2, [r7, #0]
 8008ac0:	4611      	mov	r1, r2
 8008ac2:	4618      	mov	r0, r3
 8008ac4:	f7ff ffdf 	bl	8008a86 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 8008ac8:	687b      	ldr	r3, [r7, #4]
 8008aca:	4618      	mov	r0, r3
 8008acc:	3708      	adds	r7, #8
 8008ace:	46bd      	mov	sp, r7
 8008ad0:	bd80      	pop	{r7, pc}

08008ad2 <_ZN3hei12SharedBufferIhEC1ERKS1_>:
    class SharedBuffer {
 8008ad2:	b580      	push	{r7, lr}
 8008ad4:	b082      	sub	sp, #8
 8008ad6:	af00      	add	r7, sp, #0
 8008ad8:	6078      	str	r0, [r7, #4]
 8008ada:	6039      	str	r1, [r7, #0]
 8008adc:	687b      	ldr	r3, [r7, #4]
 8008ade:	683a      	ldr	r2, [r7, #0]
 8008ae0:	4611      	mov	r1, r2
 8008ae2:	4618      	mov	r0, r3
 8008ae4:	f7ff ffe5 	bl	8008ab2 <_ZNSt10shared_ptrIhEC1ERKS0_>
 8008ae8:	683b      	ldr	r3, [r7, #0]
 8008aea:	689a      	ldr	r2, [r3, #8]
 8008aec:	687b      	ldr	r3, [r7, #4]
 8008aee:	609a      	str	r2, [r3, #8]
 8008af0:	687b      	ldr	r3, [r7, #4]
 8008af2:	4618      	mov	r0, r3
 8008af4:	3708      	adds	r7, #8
 8008af6:	46bd      	mov	sp, r7
 8008af8:	bd80      	pop	{r7, pc}

08008afa <_ZN7desenet5FrameC1ERKS0_>:
    class Frame
 8008afa:	b580      	push	{r7, lr}
 8008afc:	b082      	sub	sp, #8
 8008afe:	af00      	add	r7, sp, #0
 8008b00:	6078      	str	r0, [r7, #4]
 8008b02:	6039      	str	r1, [r7, #0]
 8008b04:	687b      	ldr	r3, [r7, #4]
 8008b06:	683a      	ldr	r2, [r7, #0]
 8008b08:	4611      	mov	r1, r2
 8008b0a:	4618      	mov	r0, r3
 8008b0c:	f7ff ffe1 	bl	8008ad2 <_ZN3hei12SharedBufferIhEC1ERKS1_>
 8008b10:	683b      	ldr	r3, [r7, #0]
 8008b12:	68da      	ldr	r2, [r3, #12]
 8008b14:	687b      	ldr	r3, [r7, #4]
 8008b16:	60da      	str	r2, [r3, #12]
 8008b18:	687b      	ldr	r3, [r7, #4]
 8008b1a:	4618      	mov	r0, r3
 8008b1c:	3708      	adds	r7, #8
 8008b1e:	46bd      	mov	sp, r7
 8008b20:	bd80      	pop	{r7, pc}

08008b22 <_ZN7desenet6BeaconC1ERKNS_5FrameE>:
    setType(FrameType::Beacon);
    setNetworkTime(0);
    setCycleInterval(cycleInterval);
}

desenet::Beacon::Beacon(const Frame & frame)
 8008b22:	b580      	push	{r7, lr}
 8008b24:	b082      	sub	sp, #8
 8008b26:	af00      	add	r7, sp, #0
 8008b28:	6078      	str	r0, [r7, #4]
 8008b2a:	6039      	str	r1, [r7, #0]
 : Frame(frame)
 8008b2c:	687b      	ldr	r3, [r7, #4]
 8008b2e:	6839      	ldr	r1, [r7, #0]
 8008b30:	4618      	mov	r0, r3
 8008b32:	f7ff ffe2 	bl	8008afa <_ZN7desenet5FrameC1ERKS0_>
{
}
 8008b36:	687b      	ldr	r3, [r7, #4]
 8008b38:	4618      	mov	r0, r3
 8008b3a:	3708      	adds	r7, #8
 8008b3c:	46bd      	mov	sp, r7
 8008b3e:	bd80      	pop	{r7, pc}

08008b40 <_ZN7desenet6Beacon12slotDurationEv>:
{
    memcpy(buffer() + Frame::HEADER_SIZE + 5, &interval, 3 /* bytes */);
}

desenet::SlotDuration desenet::Beacon::slotDuration()
{
 8008b40:	b580      	push	{r7, lr}
 8008b42:	b084      	sub	sp, #16
 8008b44:	af00      	add	r7, sp, #0
 8008b46:	6078      	str	r0, [r7, #4]
	desenet::SlotDuration slotDuration;

    memcpy(&slotDuration, buffer() + Frame::HEADER_SIZE + 8, sizeof(slotDuration));
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	4618      	mov	r0, r3
 8008b4c:	f7ff ff81 	bl	8008a52 <_ZN7desenet5Frame6bufferEv>
 8008b50:	4603      	mov	r3, r0
 8008b52:	330d      	adds	r3, #13
 8008b54:	881b      	ldrh	r3, [r3, #0]
 8008b56:	b29b      	uxth	r3, r3
 8008b58:	81fb      	strh	r3, [r7, #14]

	return slotDuration;
 8008b5a:	89fb      	ldrh	r3, [r7, #14]
}
 8008b5c:	4618      	mov	r0, r3
 8008b5e:	3710      	adds	r7, #16
 8008b60:	46bd      	mov	sp, r7
 8008b62:	bd80      	pop	{r7, pc}

08008b64 <_ZNK7desenet6Beacon11svGroupMaskEv>:
{
	memcpy(buffer() + Frame::HEADER_SIZE + 8, &slotDuration, sizeof(slotDuration));
}

desenet::SvGroupMask desenet::Beacon::svGroupMask() const
{
 8008b64:	b5b0      	push	{r4, r5, r7, lr}
 8008b66:	b084      	sub	sp, #16
 8008b68:	af00      	add	r7, sp, #0
 8008b6a:	6078      	str	r0, [r7, #4]
    uint32_t bits;
    memcpy(&bits, buffer() + Frame::HEADER_SIZE + 10, sizeof(bits));
 8008b6c:	687b      	ldr	r3, [r7, #4]
 8008b6e:	4618      	mov	r0, r3
 8008b70:	f7ff ff7c 	bl	8008a6c <_ZNK7desenet5Frame6bufferEv>
 8008b74:	4603      	mov	r3, r0
 8008b76:	330f      	adds	r3, #15
 8008b78:	681b      	ldr	r3, [r3, #0]
 8008b7a:	60bb      	str	r3, [r7, #8]
    return SvGroupMask(bits);
 8008b7c:	68bb      	ldr	r3, [r7, #8]
 8008b7e:	2200      	movs	r2, #0
 8008b80:	461c      	mov	r4, r3
 8008b82:	4615      	mov	r5, r2
 8008b84:	f107 010c 	add.w	r1, r7, #12
 8008b88:	4622      	mov	r2, r4
 8008b8a:	462b      	mov	r3, r5
 8008b8c:	4608      	mov	r0, r1
 8008b8e:	f000 f836 	bl	8008bfe <_ZNSt6bitsetILj16EEC1Ey>
 8008b92:	68fb      	ldr	r3, [r7, #12]
}
 8008b94:	4618      	mov	r0, r3
 8008b96:	3710      	adds	r7, #16
 8008b98:	46bd      	mov	sp, r7
 8008b9a:	bdb0      	pop	{r4, r5, r7, pc}

08008b9c <_ZN3hei12SharedBufferIhE4dataEv>:
         * @brief Returns pointer to the underlying array serving as element storage. The pointer is such that range
         *        [data(); data() + size()) is always a valid range, even if the container is empty.
         *
         * @return Pointer to the underlying element storage. For non-empty containers, returns &front().
         */
        pointer data() {
 8008b9c:	b580      	push	{r7, lr}
 8008b9e:	b082      	sub	sp, #8
 8008ba0:	af00      	add	r7, sp, #0
 8008ba2:	6078      	str	r0, [r7, #4]
            return data_.get();
 8008ba4:	687b      	ldr	r3, [r7, #4]
 8008ba6:	4618      	mov	r0, r3
 8008ba8:	f7fe f931 	bl	8006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>
 8008bac:	4603      	mov	r3, r0
        }
 8008bae:	4618      	mov	r0, r3
 8008bb0:	3708      	adds	r7, #8
 8008bb2:	46bd      	mov	sp, r7
 8008bb4:	bd80      	pop	{r7, pc}

08008bb6 <_ZNK3hei12SharedBufferIhE4dataEv>:
         * @brief Returns pointer to the underlying array serving as element storage. The pointer is such that range
         *        [data(); data() + size()) is always a valid range, even if the container is empty.
         *
         * @return Pointer to the underlying element storage. For non-empty containers, returns &front().
         */
        constPointer data() const {
 8008bb6:	b580      	push	{r7, lr}
 8008bb8:	b082      	sub	sp, #8
 8008bba:	af00      	add	r7, sp, #0
 8008bbc:	6078      	str	r0, [r7, #4]
            return data_.get();
 8008bbe:	687b      	ldr	r3, [r7, #4]
 8008bc0:	4618      	mov	r0, r3
 8008bc2:	f7fe f924 	bl	8006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>
 8008bc6:	4603      	mov	r3, r0
        }
 8008bc8:	4618      	mov	r0, r3
 8008bca:	3708      	adds	r7, #8
 8008bcc:	46bd      	mov	sp, r7
 8008bce:	bd80      	pop	{r7, pc}

08008bd0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
      __shared_count(const __shared_count& __r) noexcept
 8008bd0:	b580      	push	{r7, lr}
 8008bd2:	b082      	sub	sp, #8
 8008bd4:	af00      	add	r7, sp, #0
 8008bd6:	6078      	str	r0, [r7, #4]
 8008bd8:	6039      	str	r1, [r7, #0]
      : _M_pi(__r._M_pi)
 8008bda:	683b      	ldr	r3, [r7, #0]
 8008bdc:	681a      	ldr	r2, [r3, #0]
 8008bde:	687b      	ldr	r3, [r7, #4]
 8008be0:	601a      	str	r2, [r3, #0]
	if (_M_pi != 0)
 8008be2:	687b      	ldr	r3, [r7, #4]
 8008be4:	681b      	ldr	r3, [r3, #0]
 8008be6:	2b00      	cmp	r3, #0
 8008be8:	d004      	beq.n	8008bf4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0x24>
	  _M_pi->_M_add_ref_copy();
 8008bea:	687b      	ldr	r3, [r7, #4]
 8008bec:	681b      	ldr	r3, [r3, #0]
 8008bee:	4618      	mov	r0, r3
 8008bf0:	f7ff ff20 	bl	8008a34 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE15_M_add_ref_copyEv>
      }
 8008bf4:	687b      	ldr	r3, [r7, #4]
 8008bf6:	4618      	mov	r0, r3
 8008bf8:	3708      	adds	r7, #8
 8008bfa:	46bd      	mov	sp, r7
 8008bfc:	bd80      	pop	{r7, pc}

08008bfe <_ZNSt6bitsetILj16EEC1Ey>:
      _GLIBCXX_CONSTEXPR bitset() _GLIBCXX_NOEXCEPT
      { }

      /// Initial bits bitwise-copied from a single word (others set to zero).
#if __cplusplus >= 201103L
      constexpr bitset(unsigned long long __val) noexcept
 8008bfe:	b590      	push	{r4, r7, lr}
 8008c00:	b085      	sub	sp, #20
 8008c02:	af00      	add	r7, sp, #0
 8008c04:	60f8      	str	r0, [r7, #12]
 8008c06:	e9c7 2300 	strd	r2, r3, [r7]
      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
 8008c0a:	68fc      	ldr	r4, [r7, #12]
 8008c0c:	e9d7 0100 	ldrd	r0, r1, [r7]
 8008c10:	f000 f80a 	bl	8008c28 <_ZNSt13_Sanitize_valILj16ELb1EE18_S_do_sanitize_valEy>
 8008c14:	4602      	mov	r2, r0
 8008c16:	460b      	mov	r3, r1
 8008c18:	4620      	mov	r0, r4
 8008c1a:	f7ff fefb 	bl	8008a14 <_ZNSt12_Base_bitsetILj1EEC1Ey>
 8008c1e:	68fb      	ldr	r3, [r7, #12]
 8008c20:	4618      	mov	r0, r3
 8008c22:	3714      	adds	r7, #20
 8008c24:	46bd      	mov	sp, r7
 8008c26:	bd90      	pop	{r4, r7, pc}

08008c28 <_ZNSt13_Sanitize_valILj16ELb1EE18_S_do_sanitize_valEy>:
      _S_do_sanitize_val(unsigned long long __val)
 8008c28:	b480      	push	{r7}
 8008c2a:	b083      	sub	sp, #12
 8008c2c:	af00      	add	r7, sp, #0
 8008c2e:	e9c7 0100 	strd	r0, r1, [r7]
      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
 8008c32:	e9d7 0100 	ldrd	r0, r1, [r7]
 8008c36:	b282      	uxth	r2, r0
 8008c38:	2300      	movs	r3, #0
 8008c3a:	4610      	mov	r0, r2
 8008c3c:	4619      	mov	r1, r3
 8008c3e:	370c      	adds	r7, #12
 8008c40:	46bd      	mov	sp, r7
 8008c42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c46:	4770      	bx	lr

08008c48 <_Z41__static_initialization_and_destruction_0ii>:

void desenet::Beacon::setSvGroupMask(const desenet::SvGroupMask & mask)
{
    uint32_t bits = mask.to_ulong();
    memcpy(buffer() + Frame::HEADER_SIZE + 10, &bits, sizeof(bits));
}
 8008c48:	b580      	push	{r7, lr}
 8008c4a:	b088      	sub	sp, #32
 8008c4c:	af00      	add	r7, sp, #0
 8008c4e:	6078      	str	r0, [r7, #4]
 8008c50:	6039      	str	r1, [r7, #0]
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	2b01      	cmp	r3, #1
 8008c56:	d122      	bne.n	8008c9e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008c58:	683b      	ldr	r3, [r7, #0]
 8008c5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008c5e:	4293      	cmp	r3, r2
 8008c60:	d11d      	bne.n	8008c9e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8008c62:	4b18      	ldr	r3, [pc, #96]	; (8008cc4 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8008c64:	681b      	ldr	r3, [r3, #0]
 8008c66:	613b      	str	r3, [r7, #16]
 8008c68:	f107 0310 	add.w	r3, r7, #16
 8008c6c:	60bb      	str	r3, [r7, #8]
 8008c6e:	2304      	movs	r3, #4
 8008c70:	60fb      	str	r3, [r7, #12]
 8008c72:	f107 0308 	add.w	r3, r7, #8
 8008c76:	e893 0006 	ldmia.w	r3, {r1, r2}
 8008c7a:	4813      	ldr	r0, [pc, #76]	; (8008cc8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8008c7c:	f7fe f85a 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8008c80:	4b12      	ldr	r3, [pc, #72]	; (8008ccc <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8008c82:	681b      	ldr	r3, [r3, #0]
 8008c84:	61fb      	str	r3, [r7, #28]
 8008c86:	f107 031c 	add.w	r3, r7, #28
 8008c8a:	617b      	str	r3, [r7, #20]
 8008c8c:	2304      	movs	r3, #4
 8008c8e:	61bb      	str	r3, [r7, #24]
 8008c90:	f107 0314 	add.w	r3, r7, #20
 8008c94:	e893 0006 	ldmia.w	r3, {r1, r2}
 8008c98:	480d      	ldr	r0, [pc, #52]	; (8008cd0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8008c9a:	f7fe f84b 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8008c9e:	687b      	ldr	r3, [r7, #4]
 8008ca0:	2b00      	cmp	r3, #0
 8008ca2:	d10a      	bne.n	8008cba <_Z41__static_initialization_and_destruction_0ii+0x72>
 8008ca4:	683b      	ldr	r3, [r7, #0]
 8008ca6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008caa:	4293      	cmp	r3, r2
 8008cac:	d105      	bne.n	8008cba <_Z41__static_initialization_and_destruction_0ii+0x72>
 8008cae:	4808      	ldr	r0, [pc, #32]	; (8008cd0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8008cb0:	f7fe f98a 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8008cb4:	4804      	ldr	r0, [pc, #16]	; (8008cc8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8008cb6:	f7fe f987 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8008cba:	bf00      	nop
 8008cbc:	3720      	adds	r7, #32
 8008cbe:	46bd      	mov	sp, r7
 8008cc0:	bd80      	pop	{r7, pc}
 8008cc2:	bf00      	nop
 8008cc4:	08018370 	.word	0x08018370
 8008cc8:	20001850 	.word	0x20001850
 8008ccc:	08018374 	.word	0x08018374
 8008cd0:	20001858 	.word	0x20001858

08008cd4 <_GLOBAL__sub_I__ZN7desenet6BeaconC2Em>:
 8008cd4:	b580      	push	{r7, lr}
 8008cd6:	af00      	add	r7, sp, #0
 8008cd8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008cdc:	2001      	movs	r0, #1
 8008cde:	f7ff ffb3 	bl	8008c48 <_Z41__static_initialization_and_destruction_0ii>
 8008ce2:	bd80      	pop	{r7, pc}

08008ce4 <_GLOBAL__sub_D__ZN7desenet6BeaconC2Em>:
 8008ce4:	b580      	push	{r7, lr}
 8008ce6:	af00      	add	r7, sp, #0
 8008ce8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008cec:	2000      	movs	r0, #0
 8008cee:	f7ff ffab 	bl	8008c48 <_Z41__static_initialization_and_destruction_0ii>
 8008cf2:	bd80      	pop	{r7, pc}

08008cf4 <_ZNK7desenet5Frame6lengthEv>:
        std::size_t length() const {
 8008cf4:	b480      	push	{r7}
 8008cf6:	b083      	sub	sp, #12
 8008cf8:	af00      	add	r7, sp, #0
 8008cfa:	6078      	str	r0, [r7, #4]
            return frameLength_;
 8008cfc:	687b      	ldr	r3, [r7, #4]
 8008cfe:	68db      	ldr	r3, [r3, #12]
        }
 8008d00:	4618      	mov	r0, r3
 8008d02:	370c      	adds	r7, #12
 8008d04:	46bd      	mov	sp, r7
 8008d06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d0a:	4770      	bx	lr

08008d0c <_ZN7desenet5FrameC1Ej>:
using std::shared_ptr;
using std::make_shared;
using std::memcpy;
using desenet::NetworkInterfaceDriver;

desenet::Frame::Frame(size_t initialLength)
 8008d0c:	b580      	push	{r7, lr}
 8008d0e:	b082      	sub	sp, #8
 8008d10:	af00      	add	r7, sp, #0
 8008d12:	6078      	str	r0, [r7, #4]
 8008d14:	6039      	str	r1, [r7, #0]
 : buffer_(initialLength),
   frameLength_(0)
 8008d16:	687b      	ldr	r3, [r7, #4]
 8008d18:	6839      	ldr	r1, [r7, #0]
 8008d1a:	4618      	mov	r0, r3
 8008d1c:	f7fe fe23 	bl	8007966 <_ZN3hei12SharedBufferIhEC1Ej>
 8008d20:	687b      	ldr	r3, [r7, #4]
 8008d22:	2200      	movs	r2, #0
 8008d24:	60da      	str	r2, [r3, #12]
{
    assert(buffer_.data());
 8008d26:	687b      	ldr	r3, [r7, #4]
 8008d28:	4618      	mov	r0, r3
 8008d2a:	f7ff ff37 	bl	8008b9c <_ZN3hei12SharedBufferIhE4dataEv>
 8008d2e:	4603      	mov	r3, r0
 8008d30:	2b00      	cmp	r3, #0
 8008d32:	d105      	bne.n	8008d40 <_ZN7desenet5FrameC1Ej+0x34>
 8008d34:	4b07      	ldr	r3, [pc, #28]	; (8008d54 <_ZN7desenet5FrameC1Ej+0x48>)
 8008d36:	4a08      	ldr	r2, [pc, #32]	; (8008d58 <_ZN7desenet5FrameC1Ej+0x4c>)
 8008d38:	2112      	movs	r1, #18
 8008d3a:	4808      	ldr	r0, [pc, #32]	; (8008d5c <_ZN7desenet5FrameC1Ej+0x50>)
 8008d3c:	f00d fb2a 	bl	8016394 <__assert_func>

    setLength(initialLength);
 8008d40:	6839      	ldr	r1, [r7, #0]
 8008d42:	6878      	ldr	r0, [r7, #4]
 8008d44:	f000 f870 	bl	8008e28 <_ZN7desenet5Frame9setLengthEj>
}
 8008d48:	687b      	ldr	r3, [r7, #4]
 8008d4a:	4618      	mov	r0, r3
 8008d4c:	3708      	adds	r7, #8
 8008d4e:	46bd      	mov	sp, r7
 8008d50:	bd80      	pop	{r7, pc}
 8008d52:	bf00      	nop
 8008d54:	08018378 	.word	0x08018378
 8008d58:	08018388 	.word	0x08018388
 8008d5c:	080183ac 	.word	0x080183ac

08008d60 <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE>:

desenet::Frame::Frame(const SharedByteBuffer &buffer): buffer_(buffer)
 8008d60:	b580      	push	{r7, lr}
 8008d62:	b082      	sub	sp, #8
 8008d64:	af00      	add	r7, sp, #0
 8008d66:	6078      	str	r0, [r7, #4]
 8008d68:	6039      	str	r1, [r7, #0]
 8008d6a:	687b      	ldr	r3, [r7, #4]
 8008d6c:	6839      	ldr	r1, [r7, #0]
 8008d6e:	4618      	mov	r0, r3
 8008d70:	f7ff feaf 	bl	8008ad2 <_ZN3hei12SharedBufferIhEC1ERKS1_>
{
    assert(buffer_.data());
 8008d74:	687b      	ldr	r3, [r7, #4]
 8008d76:	4618      	mov	r0, r3
 8008d78:	f7ff ff10 	bl	8008b9c <_ZN3hei12SharedBufferIhE4dataEv>
 8008d7c:	4603      	mov	r3, r0
 8008d7e:	2b00      	cmp	r3, #0
 8008d80:	d105      	bne.n	8008d8e <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE+0x2e>
 8008d82:	4b08      	ldr	r3, [pc, #32]	; (8008da4 <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE+0x44>)
 8008d84:	4a08      	ldr	r2, [pc, #32]	; (8008da8 <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE+0x48>)
 8008d86:	2119      	movs	r1, #25
 8008d88:	4808      	ldr	r0, [pc, #32]	; (8008dac <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE+0x4c>)
 8008d8a:	f00d fb03 	bl	8016394 <__assert_func>
    frameLength_ = buffer.length();
 8008d8e:	6838      	ldr	r0, [r7, #0]
 8008d90:	f000 f998 	bl	80090c4 <_ZNK3hei12SharedBufferIhE6lengthEv>
 8008d94:	4602      	mov	r2, r0
 8008d96:	687b      	ldr	r3, [r7, #4]
 8008d98:	60da      	str	r2, [r3, #12]
}
 8008d9a:	687b      	ldr	r3, [r7, #4]
 8008d9c:	4618      	mov	r0, r3
 8008d9e:	3708      	adds	r7, #8
 8008da0:	46bd      	mov	sp, r7
 8008da2:	bd80      	pop	{r7, pc}
 8008da4:	08018378 	.word	0x08018378
 8008da8:	0801841c 	.word	0x0801841c
 8008dac:	080183ac 	.word	0x080183ac

08008db0 <_ZN7desenet5Frame9useBufferEPKhj>:
{
    return Frame(SharedByteBuffer::proxy(buffer, length));
}

const desenet::Frame desenet::Frame::useBuffer(const uint8_t * const buffer, size_t length)
{
 8008db0:	b580      	push	{r7, lr}
 8008db2:	b088      	sub	sp, #32
 8008db4:	af00      	add	r7, sp, #0
 8008db6:	60f8      	str	r0, [r7, #12]
 8008db8:	60b9      	str	r1, [r7, #8]
 8008dba:	607a      	str	r2, [r7, #4]
    return Frame(SharedByteBuffer::proxy(buffer, length));
 8008dbc:	f107 0314 	add.w	r3, r7, #20
 8008dc0:	687a      	ldr	r2, [r7, #4]
 8008dc2:	68b9      	ldr	r1, [r7, #8]
 8008dc4:	4618      	mov	r0, r3
 8008dc6:	f000 f9c3 	bl	8009150 <_ZN3hei12SharedBufferIhE5proxyEPKhj>
 8008dca:	f107 0314 	add.w	r3, r7, #20
 8008dce:	4619      	mov	r1, r3
 8008dd0:	68f8      	ldr	r0, [r7, #12]
 8008dd2:	f7ff ffc5 	bl	8008d60 <_ZN7desenet5FrameC1ERKN3hei12SharedBufferIhEE>
 8008dd6:	f107 0314 	add.w	r3, r7, #20
 8008dda:	4618      	mov	r0, r3
 8008ddc:	f7fe fd1b 	bl	8007816 <_ZN3hei12SharedBufferIhED1Ev>
 8008de0:	bf00      	nop
}
 8008de2:	68f8      	ldr	r0, [r7, #12]
 8008de4:	3720      	adds	r7, #32
 8008de6:	46bd      	mov	sp, r7
 8008de8:	bd80      	pop	{r7, pc}

08008dea <_ZNK7desenet5Frame7isValidEv>:
{
    return Frame(SharedByteBuffer::copy(buffer, length));
}

bool desenet::Frame::isValid() const
{
 8008dea:	b580      	push	{r7, lr}
 8008dec:	b082      	sub	sp, #8
 8008dee:	af00      	add	r7, sp, #0
 8008df0:	6078      	str	r0, [r7, #4]
    return !buffer_.empty() &&
 8008df2:	687b      	ldr	r3, [r7, #4]
 8008df4:	4618      	mov	r0, r3
 8008df6:	f000 f9cf 	bl	8009198 <_ZNK3hei12SharedBufferIhE5emptyEv>
 8008dfa:	4603      	mov	r3, r0
 8008dfc:	f083 0301 	eor.w	r3, r3, #1
 8008e00:	b2db      	uxtb	r3, r3
    		frameLength_ >= Frame::HEADER_SIZE + 1 &&	// + 1 for byte containing frame type
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	d00b      	beq.n	8008e1e <_ZNK7desenet5Frame7isValidEv+0x34>
 8008e06:	687b      	ldr	r3, [r7, #4]
 8008e08:	68db      	ldr	r3, [r3, #12]
    return !buffer_.empty() &&
 8008e0a:	2b05      	cmp	r3, #5
 8008e0c:	d907      	bls.n	8008e1e <_ZNK7desenet5Frame7isValidEv+0x34>
    		type() != FrameType::Invalid;
 8008e0e:	6878      	ldr	r0, [r7, #4]
 8008e10:	f000 f881 	bl	8008f16 <_ZNK7desenet5Frame4typeEv>
 8008e14:	4603      	mov	r3, r0
    		frameLength_ >= Frame::HEADER_SIZE + 1 &&	// + 1 for byte containing frame type
 8008e16:	2b00      	cmp	r3, #0
 8008e18:	d001      	beq.n	8008e1e <_ZNK7desenet5Frame7isValidEv+0x34>
 8008e1a:	2301      	movs	r3, #1
 8008e1c:	e000      	b.n	8008e20 <_ZNK7desenet5Frame7isValidEv+0x36>
 8008e1e:	2300      	movs	r3, #0
}
 8008e20:	4618      	mov	r0, r3
 8008e22:	3708      	adds	r7, #8
 8008e24:	46bd      	mov	sp, r7
 8008e26:	bd80      	pop	{r7, pc}

08008e28 <_ZN7desenet5Frame9setLengthEj>:

void desenet::Frame::setLength(size_t length)
{
 8008e28:	b580      	push	{r7, lr}
 8008e2a:	b082      	sub	sp, #8
 8008e2c:	af00      	add	r7, sp, #0
 8008e2e:	6078      	str	r0, [r7, #4]
 8008e30:	6039      	str	r1, [r7, #0]
    if (length <= buffer_.length())
 8008e32:	687b      	ldr	r3, [r7, #4]
 8008e34:	4618      	mov	r0, r3
 8008e36:	f000 f945 	bl	80090c4 <_ZNK3hei12SharedBufferIhE6lengthEv>
 8008e3a:	4602      	mov	r2, r0
 8008e3c:	683b      	ldr	r3, [r7, #0]
 8008e3e:	4293      	cmp	r3, r2
 8008e40:	bf94      	ite	ls
 8008e42:	2301      	movls	r3, #1
 8008e44:	2300      	movhi	r3, #0
 8008e46:	b2db      	uxtb	r3, r3
 8008e48:	2b00      	cmp	r3, #0
 8008e4a:	d00b      	beq.n	8008e64 <_ZN7desenet5Frame9setLengthEj+0x3c>
    {
        frameLength_ = length;
 8008e4c:	687b      	ldr	r3, [r7, #4]
 8008e4e:	683a      	ldr	r2, [r7, #0]
 8008e50:	60da      	str	r2, [r3, #12]

        // Set also the payload field accordingly
        setPayloadSize(length - (Frame::HEADER_SIZE + Frame::FOOTER_SIZE));
 8008e52:	683b      	ldr	r3, [r7, #0]
 8008e54:	b2db      	uxtb	r3, r3
 8008e56:	3b05      	subs	r3, #5
 8008e58:	b2db      	uxtb	r3, r3
 8008e5a:	4619      	mov	r1, r3
 8008e5c:	6878      	ldr	r0, [r7, #4]
 8008e5e:	f000 f845 	bl	8008eec <_ZN7desenet5Frame14setPayloadSizeEh>
    }
    else
    {
    	assert(false);	// Frame length too big for buffer!
    }
}
 8008e62:	e005      	b.n	8008e70 <_ZN7desenet5Frame9setLengthEj+0x48>
    	assert(false);	// Frame length too big for buffer!
 8008e64:	4b04      	ldr	r3, [pc, #16]	; (8008e78 <_ZN7desenet5Frame9setLengthEj+0x50>)
 8008e66:	4a05      	ldr	r2, [pc, #20]	; (8008e7c <_ZN7desenet5Frame9setLengthEj+0x54>)
 8008e68:	213e      	movs	r1, #62	; 0x3e
 8008e6a:	4805      	ldr	r0, [pc, #20]	; (8008e80 <_ZN7desenet5Frame9setLengthEj+0x58>)
 8008e6c:	f00d fa92 	bl	8016394 <__assert_func>
}
 8008e70:	3708      	adds	r7, #8
 8008e72:	46bd      	mov	sp, r7
 8008e74:	bd80      	pop	{r7, pc}
 8008e76:	bf00      	nop
 8008e78:	0801844c 	.word	0x0801844c
 8008e7c:	08018454 	.word	0x08018454
 8008e80:	080183ac 	.word	0x080183ac

08008e84 <_ZNK7desenet5Frame11destinationEv>:

desenet::Address desenet::Frame::destination() const
{
 8008e84:	b580      	push	{r7, lr}
 8008e86:	b082      	sub	sp, #8
 8008e88:	af00      	add	r7, sp, #0
 8008e8a:	6078      	str	r0, [r7, #4]
 8008e8c:	6039      	str	r1, [r7, #0]
    Address destination;
 8008e8e:	6878      	ldr	r0, [r7, #4]
 8008e90:	f000 f994 	bl	80091bc <_ZN3phy7AddressILj4EEC1Ev>

    if (frameLength_ >= ADDRESS_SIZE)
 8008e94:	683b      	ldr	r3, [r7, #0]
 8008e96:	68db      	ldr	r3, [r3, #12]
 8008e98:	2b03      	cmp	r3, #3
 8008e9a:	d908      	bls.n	8008eae <_ZNK7desenet5Frame11destinationEv+0x2a>
    {
        destination.copyFrom(buffer_.data());
 8008e9c:	683b      	ldr	r3, [r7, #0]
 8008e9e:	4618      	mov	r0, r3
 8008ea0:	f7ff fe89 	bl	8008bb6 <_ZNK3hei12SharedBufferIhE4dataEv>
 8008ea4:	4603      	mov	r3, r0
 8008ea6:	4619      	mov	r1, r3
 8008ea8:	6878      	ldr	r0, [r7, #4]
 8008eaa:	f000 f99d 	bl	80091e8 <_ZN3phy7AddressILj4EE8copyFromEPKh>
    }
    return destination;
 8008eae:	bf00      	nop
}
 8008eb0:	6878      	ldr	r0, [r7, #4]
 8008eb2:	3708      	adds	r7, #8
 8008eb4:	46bd      	mov	sp, r7
 8008eb6:	bd80      	pop	{r7, pc}

08008eb8 <_ZN7desenet5Frame14setDestinationERKN3phy7AddressILj4EEE>:

	return payloadSize;
}

void desenet::Frame::setDestination(const desenet::Address & destination)
{
 8008eb8:	b5b0      	push	{r4, r5, r7, lr}
 8008eba:	b082      	sub	sp, #8
 8008ebc:	af00      	add	r7, sp, #0
 8008ebe:	6078      	str	r0, [r7, #4]
 8008ec0:	6039      	str	r1, [r7, #0]
	// Destination address is first field in frame
	memcpy(buffer_.data(), destination.data(), destination.addressSize());
 8008ec2:	687b      	ldr	r3, [r7, #4]
 8008ec4:	4618      	mov	r0, r3
 8008ec6:	f7ff fe69 	bl	8008b9c <_ZN3hei12SharedBufferIhE4dataEv>
 8008eca:	4604      	mov	r4, r0
 8008ecc:	6838      	ldr	r0, [r7, #0]
 8008ece:	f000 f9b3 	bl	8009238 <_ZNK3phy7AddressILj4EE4dataEv>
 8008ed2:	4605      	mov	r5, r0
 8008ed4:	f000 f9a8 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 8008ed8:	4603      	mov	r3, r0
 8008eda:	461a      	mov	r2, r3
 8008edc:	4629      	mov	r1, r5
 8008ede:	4620      	mov	r0, r4
 8008ee0:	f00d fac8 	bl	8016474 <memcpy>
}
 8008ee4:	bf00      	nop
 8008ee6:	3708      	adds	r7, #8
 8008ee8:	46bd      	mov	sp, r7
 8008eea:	bdb0      	pop	{r4, r5, r7, pc}

08008eec <_ZN7desenet5Frame14setPayloadSizeEh>:

void desenet::Frame::setPayloadSize(uint8_t payloadSize)
{
 8008eec:	b590      	push	{r4, r7, lr}
 8008eee:	b083      	sub	sp, #12
 8008ef0:	af00      	add	r7, sp, #0
 8008ef2:	6078      	str	r0, [r7, #4]
 8008ef4:	460b      	mov	r3, r1
 8008ef6:	70fb      	strb	r3, [r7, #3]
	memcpy(buffer_.data() + desenet::Address::addressSize(), &payloadSize, sizeof(payloadSize));
 8008ef8:	687b      	ldr	r3, [r7, #4]
 8008efa:	4618      	mov	r0, r3
 8008efc:	f7ff fe4e 	bl	8008b9c <_ZN3hei12SharedBufferIhE4dataEv>
 8008f00:	4604      	mov	r4, r0
 8008f02:	f000 f991 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 8008f06:	4603      	mov	r3, r0
 8008f08:	4423      	add	r3, r4
 8008f0a:	78fa      	ldrb	r2, [r7, #3]
 8008f0c:	701a      	strb	r2, [r3, #0]
}
 8008f0e:	bf00      	nop
 8008f10:	370c      	adds	r7, #12
 8008f12:	46bd      	mov	sp, r7
 8008f14:	bd90      	pop	{r4, r7, pc}

08008f16 <_ZNK7desenet5Frame4typeEv>:

desenet::FrameType desenet::Frame::type() const {
 8008f16:	b580      	push	{r7, lr}
 8008f18:	b082      	sub	sp, #8
 8008f1a:	af00      	add	r7, sp, #0
 8008f1c:	6078      	str	r0, [r7, #4]
    if (frameLength_ >= 1 && ((buffer_[Frame::HEADER_SIZE + 0] & 0x80) == 0x00))
 8008f1e:	687b      	ldr	r3, [r7, #4]
 8008f20:	68db      	ldr	r3, [r3, #12]
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d00b      	beq.n	8008f3e <_ZNK7desenet5Frame4typeEv+0x28>
 8008f26:	687b      	ldr	r3, [r7, #4]
 8008f28:	2105      	movs	r1, #5
 8008f2a:	4618      	mov	r0, r3
 8008f2c:	f000 f8ba 	bl	80090a4 <_ZNK3hei12SharedBufferIhEixEj>
 8008f30:	4603      	mov	r3, r0
 8008f32:	781b      	ldrb	r3, [r3, #0]
 8008f34:	b25b      	sxtb	r3, r3
 8008f36:	2b00      	cmp	r3, #0
 8008f38:	db01      	blt.n	8008f3e <_ZNK7desenet5Frame4typeEv+0x28>
 8008f3a:	2301      	movs	r3, #1
 8008f3c:	e000      	b.n	8008f40 <_ZNK7desenet5Frame4typeEv+0x2a>
 8008f3e:	2300      	movs	r3, #0
 8008f40:	2b00      	cmp	r3, #0
 8008f42:	d001      	beq.n	8008f48 <_ZNK7desenet5Frame4typeEv+0x32>
        return FrameType::Beacon;
 8008f44:	2301      	movs	r3, #1
 8008f46:	e016      	b.n	8008f76 <_ZNK7desenet5Frame4typeEv+0x60>
    else if (frameLength_ >= 1 && ((buffer_[Frame::HEADER_SIZE + 0] & 0x80) == 0x80))
 8008f48:	687b      	ldr	r3, [r7, #4]
 8008f4a:	68db      	ldr	r3, [r3, #12]
 8008f4c:	2b00      	cmp	r3, #0
 8008f4e:	d00c      	beq.n	8008f6a <_ZNK7desenet5Frame4typeEv+0x54>
 8008f50:	687b      	ldr	r3, [r7, #4]
 8008f52:	2105      	movs	r1, #5
 8008f54:	4618      	mov	r0, r3
 8008f56:	f000 f8a5 	bl	80090a4 <_ZNK3hei12SharedBufferIhEixEj>
 8008f5a:	4603      	mov	r3, r0
 8008f5c:	781b      	ldrb	r3, [r3, #0]
 8008f5e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008f62:	2b80      	cmp	r3, #128	; 0x80
 8008f64:	d101      	bne.n	8008f6a <_ZNK7desenet5Frame4typeEv+0x54>
 8008f66:	2301      	movs	r3, #1
 8008f68:	e000      	b.n	8008f6c <_ZNK7desenet5Frame4typeEv+0x56>
 8008f6a:	2300      	movs	r3, #0
 8008f6c:	2b00      	cmp	r3, #0
 8008f6e:	d001      	beq.n	8008f74 <_ZNK7desenet5Frame4typeEv+0x5e>
        return FrameType::MPDU;
 8008f70:	2302      	movs	r3, #2
 8008f72:	e000      	b.n	8008f76 <_ZNK7desenet5Frame4typeEv+0x60>
    else
        return FrameType::Invalid;
 8008f74:	2300      	movs	r3, #0
}
 8008f76:	4618      	mov	r0, r3
 8008f78:	3708      	adds	r7, #8
 8008f7a:	46bd      	mov	sp, r7
 8008f7c:	bd80      	pop	{r7, pc}

08008f7e <_ZN7desenet5Frame7setTypeENS_9FrameTypeE>:

void desenet::Frame::setType(desenet::FrameType type)
{
 8008f7e:	b580      	push	{r7, lr}
 8008f80:	b082      	sub	sp, #8
 8008f82:	af00      	add	r7, sp, #0
 8008f84:	6078      	str	r0, [r7, #4]
 8008f86:	6039      	str	r1, [r7, #0]
	switch (type)
 8008f88:	683b      	ldr	r3, [r7, #0]
 8008f8a:	2b02      	cmp	r3, #2
 8008f8c:	d015      	beq.n	8008fba <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x3c>
 8008f8e:	683b      	ldr	r3, [r7, #0]
 8008f90:	2b02      	cmp	r3, #2
 8008f92:	dc1f      	bgt.n	8008fd4 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x56>
 8008f94:	683b      	ldr	r3, [r7, #0]
 8008f96:	2b00      	cmp	r3, #0
 8008f98:	d01b      	beq.n	8008fd2 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x54>
 8008f9a:	683b      	ldr	r3, [r7, #0]
 8008f9c:	2b01      	cmp	r3, #1
 8008f9e:	d000      	beq.n	8008fa2 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x24>
		break;
	case FrameType::MPDU:
		buffer_[Frame::HEADER_SIZE + 0] |= 0x80;	// Set bit 7 to one
		break;
	}
}
 8008fa0:	e018      	b.n	8008fd4 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x56>
		buffer_[Frame::HEADER_SIZE + 0] &= ~0x80;	// Set bit 7 to zero
 8008fa2:	687b      	ldr	r3, [r7, #4]
 8008fa4:	2105      	movs	r1, #5
 8008fa6:	4618      	mov	r0, r3
 8008fa8:	f7fd fef8 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8008fac:	4603      	mov	r3, r0
 8008fae:	781a      	ldrb	r2, [r3, #0]
 8008fb0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8008fb4:	b2d2      	uxtb	r2, r2
 8008fb6:	701a      	strb	r2, [r3, #0]
		break;
 8008fb8:	e00c      	b.n	8008fd4 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x56>
		buffer_[Frame::HEADER_SIZE + 0] |= 0x80;	// Set bit 7 to one
 8008fba:	687b      	ldr	r3, [r7, #4]
 8008fbc:	2105      	movs	r1, #5
 8008fbe:	4618      	mov	r0, r3
 8008fc0:	f7fd feec 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8008fc4:	4603      	mov	r3, r0
 8008fc6:	781a      	ldrb	r2, [r3, #0]
 8008fc8:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8008fcc:	b2d2      	uxtb	r2, r2
 8008fce:	701a      	strb	r2, [r3, #0]
		break;
 8008fd0:	e000      	b.n	8008fd4 <_ZN7desenet5Frame7setTypeENS_9FrameTypeE+0x56>
		break;
 8008fd2:	bf00      	nop
}
 8008fd4:	bf00      	nop
 8008fd6:	3708      	adds	r7, #8
 8008fd8:	46bd      	mov	sp, r7
 8008fda:	bd80      	pop	{r7, pc}

08008fdc <_ZNK7desenet5Frame8toStringEv>:

const char * desenet::Frame::toString() const
{
 8008fdc:	b590      	push	{r4, r7, lr}
 8008fde:	b085      	sub	sp, #20
 8008fe0:	af00      	add	r7, sp, #0
 8008fe2:	6078      	str	r0, [r7, #4]
	return toString(buffer_.data(), length());		// Call the static version of toString()
 8008fe4:	687b      	ldr	r3, [r7, #4]
 8008fe6:	4618      	mov	r0, r3
 8008fe8:	f7ff fde5 	bl	8008bb6 <_ZNK3hei12SharedBufferIhE4dataEv>
 8008fec:	4604      	mov	r4, r0
 8008fee:	6878      	ldr	r0, [r7, #4]
 8008ff0:	f7ff fe80 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8008ff4:	4603      	mov	r3, r0
 8008ff6:	60fb      	str	r3, [r7, #12]
 8008ff8:	f107 030c 	add.w	r3, r7, #12
 8008ffc:	4619      	mov	r1, r3
 8008ffe:	4620      	mov	r0, r4
 8009000:	f000 f806 	bl	8009010 <_ZN7desenet5Frame8toStringEPKhRKj>
 8009004:	4603      	mov	r3, r0
}
 8009006:	4618      	mov	r0, r3
 8009008:	3714      	adds	r7, #20
 800900a:	46bd      	mov	sp, r7
 800900c:	bd90      	pop	{r4, r7, pc}
	...

08009010 <_ZN7desenet5Frame8toStringEPKhRKj>:

//static
const char * desenet::Frame::toString(const uint8_t * const buffer, const std::size_t & length)
{
 8009010:	b580      	push	{r7, lr}
 8009012:	b084      	sub	sp, #16
 8009014:	af00      	add	r7, sp, #0
 8009016:	6078      	str	r0, [r7, #4]
 8009018:	6039      	str	r1, [r7, #0]
	static char str[3 * Frame::Mtu];

	for (size_t i = 0; i < length; i++)
 800901a:	2300      	movs	r3, #0
 800901c:	60fb      	str	r3, [r7, #12]
 800901e:	683b      	ldr	r3, [r7, #0]
 8009020:	681b      	ldr	r3, [r3, #0]
 8009022:	68fa      	ldr	r2, [r7, #12]
 8009024:	429a      	cmp	r2, r3
 8009026:	d211      	bcs.n	800904c <_ZN7desenet5Frame8toStringEPKhRKj+0x3c>
	{
		sprintf(str + (i * 3), "%02x ", buffer[i]);
 8009028:	68fa      	ldr	r2, [r7, #12]
 800902a:	4613      	mov	r3, r2
 800902c:	005b      	lsls	r3, r3, #1
 800902e:	4413      	add	r3, r2
 8009030:	4a0d      	ldr	r2, [pc, #52]	; (8009068 <_ZN7desenet5Frame8toStringEPKhRKj+0x58>)
 8009032:	1898      	adds	r0, r3, r2
 8009034:	687a      	ldr	r2, [r7, #4]
 8009036:	68fb      	ldr	r3, [r7, #12]
 8009038:	4413      	add	r3, r2
 800903a:	781b      	ldrb	r3, [r3, #0]
 800903c:	461a      	mov	r2, r3
 800903e:	490b      	ldr	r1, [pc, #44]	; (800906c <_ZN7desenet5Frame8toStringEPKhRKj+0x5c>)
 8009040:	f00d fe9e 	bl	8016d80 <siprintf>
	for (size_t i = 0; i < length; i++)
 8009044:	68fb      	ldr	r3, [r7, #12]
 8009046:	3301      	adds	r3, #1
 8009048:	60fb      	str	r3, [r7, #12]
 800904a:	e7e8      	b.n	800901e <_ZN7desenet5Frame8toStringEPKhRKj+0xe>
	}

	str[length * 3] = '\0';		// Finish the string
 800904c:	683b      	ldr	r3, [r7, #0]
 800904e:	681a      	ldr	r2, [r3, #0]
 8009050:	4613      	mov	r3, r2
 8009052:	005b      	lsls	r3, r3, #1
 8009054:	4413      	add	r3, r2
 8009056:	4a04      	ldr	r2, [pc, #16]	; (8009068 <_ZN7desenet5Frame8toStringEPKhRKj+0x58>)
 8009058:	2100      	movs	r1, #0
 800905a:	54d1      	strb	r1, [r2, r3]

	return str;
 800905c:	4b02      	ldr	r3, [pc, #8]	; (8009068 <_ZN7desenet5Frame8toStringEPKhRKj+0x58>)
}
 800905e:	4618      	mov	r0, r3
 8009060:	3710      	adds	r7, #16
 8009062:	46bd      	mov	sp, r7
 8009064:	bd80      	pop	{r7, pc}
 8009066:	bf00      	nop
 8009068:	20001870 	.word	0x20001870
 800906c:	08018480 	.word	0x08018480

08009070 <_ZN7desenetlsERNS_22NetworkInterfaceDriverERKNS_5FrameE>:

NetworkInterfaceDriver & desenet::operator <<(NetworkInterfaceDriver & driver, const desenet::Frame & frame)
{
 8009070:	b5b0      	push	{r4, r5, r7, lr}
 8009072:	b082      	sub	sp, #8
 8009074:	af00      	add	r7, sp, #0
 8009076:	6078      	str	r0, [r7, #4]
 8009078:	6039      	str	r1, [r7, #0]
    driver.transmit(frame.buffer(), frame.length());
 800907a:	687b      	ldr	r3, [r7, #4]
 800907c:	681b      	ldr	r3, [r3, #0]
 800907e:	3318      	adds	r3, #24
 8009080:	681c      	ldr	r4, [r3, #0]
 8009082:	6838      	ldr	r0, [r7, #0]
 8009084:	f7ff fcf2 	bl	8008a6c <_ZNK7desenet5Frame6bufferEv>
 8009088:	4605      	mov	r5, r0
 800908a:	6838      	ldr	r0, [r7, #0]
 800908c:	f7ff fe32 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8009090:	4603      	mov	r3, r0
 8009092:	461a      	mov	r2, r3
 8009094:	4629      	mov	r1, r5
 8009096:	6878      	ldr	r0, [r7, #4]
 8009098:	47a0      	blx	r4
    return driver;
 800909a:	687b      	ldr	r3, [r7, #4]
}
 800909c:	4618      	mov	r0, r3
 800909e:	3708      	adds	r7, #8
 80090a0:	46bd      	mov	sp, r7
 80090a2:	bdb0      	pop	{r4, r5, r7, pc}

080090a4 <_ZNK3hei12SharedBufferIhEixEj>:
        const reference operator [](sizeType pos) const {
 80090a4:	b580      	push	{r7, lr}
 80090a6:	b082      	sub	sp, #8
 80090a8:	af00      	add	r7, sp, #0
 80090aa:	6078      	str	r0, [r7, #4]
 80090ac:	6039      	str	r1, [r7, #0]
            return data_.get()[pos];
 80090ae:	687b      	ldr	r3, [r7, #4]
 80090b0:	4618      	mov	r0, r3
 80090b2:	f7fd feac 	bl	8006e0e <_ZNKSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE3getEv>
 80090b6:	4602      	mov	r2, r0
 80090b8:	683b      	ldr	r3, [r7, #0]
 80090ba:	4413      	add	r3, r2
        }
 80090bc:	4618      	mov	r0, r3
 80090be:	3708      	adds	r7, #8
 80090c0:	46bd      	mov	sp, r7
 80090c2:	bd80      	pop	{r7, pc}

080090c4 <_ZNK3hei12SharedBufferIhE6lengthEv>:
        sizeType length() const {
 80090c4:	b480      	push	{r7}
 80090c6:	b083      	sub	sp, #12
 80090c8:	af00      	add	r7, sp, #0
 80090ca:	6078      	str	r0, [r7, #4]
            return length_ / sizeof(T);
 80090cc:	687b      	ldr	r3, [r7, #4]
 80090ce:	689b      	ldr	r3, [r3, #8]
        }
 80090d0:	4618      	mov	r0, r3
 80090d2:	370c      	adds	r7, #12
 80090d4:	46bd      	mov	sp, r7
 80090d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090da:	4770      	bx	lr

080090dc <_ZZN3hei12SharedBufferIhE5proxyEPhjENKUlS2_E_clES2_>:
            buffer.data_ = std::shared_ptr<T>(data, [](pointer){});
 80090dc:	b480      	push	{r7}
 80090de:	b083      	sub	sp, #12
 80090e0:	af00      	add	r7, sp, #0
 80090e2:	6078      	str	r0, [r7, #4]
 80090e4:	6039      	str	r1, [r7, #0]
 80090e6:	bf00      	nop
 80090e8:	370c      	adds	r7, #12
 80090ea:	46bd      	mov	sp, r7
 80090ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090f0:	4770      	bx	lr

080090f2 <_ZN3hei12SharedBufferIhE5proxyEPhj>:
        static SharedBuffer proxy(pointer data, sizeType length) {
 80090f2:	b5b0      	push	{r4, r5, r7, lr}
 80090f4:	b086      	sub	sp, #24
 80090f6:	af00      	add	r7, sp, #0
 80090f8:	60f8      	str	r0, [r7, #12]
 80090fa:	60b9      	str	r1, [r7, #8]
 80090fc:	607a      	str	r2, [r7, #4]
            SharedBuffer buffer;
 80090fe:	68f8      	ldr	r0, [r7, #12]
 8009100:	f000 f8a6 	bl	8009250 <_ZN3hei12SharedBufferIhEC1Ev>
            buffer.data_ = std::shared_ptr<T>(data, [](pointer){});
 8009104:	68fc      	ldr	r4, [r7, #12]
 8009106:	f107 0310 	add.w	r3, r7, #16
 800910a:	462a      	mov	r2, r5
 800910c:	68b9      	ldr	r1, [r7, #8]
 800910e:	4618      	mov	r0, r3
 8009110:	f000 f8af 	bl	8009272 <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhE5proxyEPhjEUlS5_E_vEEPT_T0_>
 8009114:	f107 0310 	add.w	r3, r7, #16
 8009118:	4619      	mov	r1, r3
 800911a:	4620      	mov	r0, r4
 800911c:	f7fe fcb0 	bl	8007a80 <_ZNSt10shared_ptrIhEaSEOS0_>
 8009120:	f107 0310 	add.w	r3, r7, #16
 8009124:	4618      	mov	r0, r3
 8009126:	f7fe fb69 	bl	80077fc <_ZNSt10shared_ptrIhED1Ev>
            buffer.length_ = length * sizeof(T);
 800912a:	68fb      	ldr	r3, [r7, #12]
 800912c:	687a      	ldr	r2, [r7, #4]
 800912e:	609a      	str	r2, [r3, #8]
            return buffer;
 8009130:	bf00      	nop
        }
 8009132:	68f8      	ldr	r0, [r7, #12]
 8009134:	3718      	adds	r7, #24
 8009136:	46bd      	mov	sp, r7
 8009138:	bdb0      	pop	{r4, r5, r7, pc}

0800913a <_ZZN3hei12SharedBufferIhE5proxyEPKhjENKUlPhE_clES4_>:
            buffer.data_ = std::shared_ptr<T>(const_cast<pointer>(data), [](pointer){});
 800913a:	b480      	push	{r7}
 800913c:	b083      	sub	sp, #12
 800913e:	af00      	add	r7, sp, #0
 8009140:	6078      	str	r0, [r7, #4]
 8009142:	6039      	str	r1, [r7, #0]
 8009144:	bf00      	nop
 8009146:	370c      	adds	r7, #12
 8009148:	46bd      	mov	sp, r7
 800914a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800914e:	4770      	bx	lr

08009150 <_ZN3hei12SharedBufferIhE5proxyEPKhj>:
        static const SharedBuffer proxy(constPointer data, sizeType length) {
 8009150:	b5b0      	push	{r4, r5, r7, lr}
 8009152:	b086      	sub	sp, #24
 8009154:	af00      	add	r7, sp, #0
 8009156:	60f8      	str	r0, [r7, #12]
 8009158:	60b9      	str	r1, [r7, #8]
 800915a:	607a      	str	r2, [r7, #4]
            SharedBuffer buffer;
 800915c:	68f8      	ldr	r0, [r7, #12]
 800915e:	f000 f877 	bl	8009250 <_ZN3hei12SharedBufferIhEC1Ev>
            buffer.data_ = std::shared_ptr<T>(const_cast<pointer>(data), [](pointer){});
 8009162:	68fc      	ldr	r4, [r7, #12]
 8009164:	f107 0310 	add.w	r3, r7, #16
 8009168:	462a      	mov	r2, r5
 800916a:	68b9      	ldr	r1, [r7, #8]
 800916c:	4618      	mov	r0, r3
 800916e:	f000 f895 	bl	800929c <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_vEEPT_T0_>
 8009172:	f107 0310 	add.w	r3, r7, #16
 8009176:	4619      	mov	r1, r3
 8009178:	4620      	mov	r0, r4
 800917a:	f7fe fc81 	bl	8007a80 <_ZNSt10shared_ptrIhEaSEOS0_>
 800917e:	f107 0310 	add.w	r3, r7, #16
 8009182:	4618      	mov	r0, r3
 8009184:	f7fe fb3a 	bl	80077fc <_ZNSt10shared_ptrIhED1Ev>
            buffer.length_ = length * sizeof(T);
 8009188:	68fb      	ldr	r3, [r7, #12]
 800918a:	687a      	ldr	r2, [r7, #4]
 800918c:	609a      	str	r2, [r3, #8]
            return buffer;
 800918e:	bf00      	nop
        }
 8009190:	68f8      	ldr	r0, [r7, #12]
 8009192:	3718      	adds	r7, #24
 8009194:	46bd      	mov	sp, r7
 8009196:	bdb0      	pop	{r4, r5, r7, pc}

08009198 <_ZNK3hei12SharedBufferIhE5emptyEv>:
        bool empty() const {
 8009198:	b480      	push	{r7}
 800919a:	b083      	sub	sp, #12
 800919c:	af00      	add	r7, sp, #0
 800919e:	6078      	str	r0, [r7, #4]
            return !length_;
 80091a0:	687b      	ldr	r3, [r7, #4]
 80091a2:	689b      	ldr	r3, [r3, #8]
 80091a4:	2b00      	cmp	r3, #0
 80091a6:	bf0c      	ite	eq
 80091a8:	2301      	moveq	r3, #1
 80091aa:	2300      	movne	r3, #0
 80091ac:	b2db      	uxtb	r3, r3
        }
 80091ae:	4618      	mov	r0, r3
 80091b0:	370c      	adds	r7, #12
 80091b2:	46bd      	mov	sp, r7
 80091b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091b8:	4770      	bx	lr
	...

080091bc <_ZN3phy7AddressILj4EEC1Ev>:
	explicit Address()
 80091bc:	b580      	push	{r7, lr}
 80091be:	b082      	sub	sp, #8
 80091c0:	af00      	add	r7, sp, #0
 80091c2:	6078      	str	r0, [r7, #4]
	{
 80091c4:	4a07      	ldr	r2, [pc, #28]	; (80091e4 <_ZN3phy7AddressILj4EEC1Ev+0x28>)
 80091c6:	687b      	ldr	r3, [r7, #4]
 80091c8:	601a      	str	r2, [r3, #0]
		memset( _address , 0 , size );
 80091ca:	687b      	ldr	r3, [r7, #4]
 80091cc:	3304      	adds	r3, #4
 80091ce:	2204      	movs	r2, #4
 80091d0:	2100      	movs	r1, #0
 80091d2:	4618      	mov	r0, r3
 80091d4:	f00d f976 	bl	80164c4 <memset>
	}
 80091d8:	687b      	ldr	r3, [r7, #4]
 80091da:	4618      	mov	r0, r3
 80091dc:	3708      	adds	r7, #8
 80091de:	46bd      	mov	sp, r7
 80091e0:	bd80      	pop	{r7, pc}
 80091e2:	bf00      	nop
 80091e4:	0801b8d4 	.word	0x0801b8d4

080091e8 <_ZN3phy7AddressILj4EE8copyFromEPKh>:
	 *
	 * Note that you are responsible to ensure that the memory region is big enough for the address.
	 *
	 * @param from Pointer to the memory location to copy the address from.
	 */
	void copyFrom( const uint8_t * const from )
 80091e8:	b580      	push	{r7, lr}
 80091ea:	b082      	sub	sp, #8
 80091ec:	af00      	add	r7, sp, #0
 80091ee:	6078      	str	r0, [r7, #4]
 80091f0:	6039      	str	r1, [r7, #0]
	{
		assert( from );
 80091f2:	683b      	ldr	r3, [r7, #0]
 80091f4:	2b00      	cmp	r3, #0
 80091f6:	d105      	bne.n	8009204 <_ZN3phy7AddressILj4EE8copyFromEPKh+0x1c>
 80091f8:	4b08      	ldr	r3, [pc, #32]	; (800921c <_ZN3phy7AddressILj4EE8copyFromEPKh+0x34>)
 80091fa:	4a09      	ldr	r2, [pc, #36]	; (8009220 <_ZN3phy7AddressILj4EE8copyFromEPKh+0x38>)
 80091fc:	2175      	movs	r1, #117	; 0x75
 80091fe:	4809      	ldr	r0, [pc, #36]	; (8009224 <_ZN3phy7AddressILj4EE8copyFromEPKh+0x3c>)
 8009200:	f00d f8c8 	bl	8016394 <__assert_func>
		if ( from )
 8009204:	683b      	ldr	r3, [r7, #0]
 8009206:	2b00      	cmp	r3, #0
 8009208:	d004      	beq.n	8009214 <_ZN3phy7AddressILj4EE8copyFromEPKh+0x2c>
			memcpy( _address , from , size );
 800920a:	687b      	ldr	r3, [r7, #4]
 800920c:	3304      	adds	r3, #4
 800920e:	683a      	ldr	r2, [r7, #0]
 8009210:	6812      	ldr	r2, [r2, #0]
 8009212:	601a      	str	r2, [r3, #0]
	}
 8009214:	bf00      	nop
 8009216:	3708      	adds	r7, #8
 8009218:	46bd      	mov	sp, r7
 800921a:	bd80      	pop	{r7, pc}
 800921c:	08018570 	.word	0x08018570
 8009220:	08018578 	.word	0x08018578
 8009224:	080184fc 	.word	0x080184fc

08009228 <_ZN3phy7AddressILj4EE11addressSizeEv>:
	static size_t addressSize()
 8009228:	b480      	push	{r7}
 800922a:	af00      	add	r7, sp, #0
		return size;
 800922c:	2304      	movs	r3, #4
	}
 800922e:	4618      	mov	r0, r3
 8009230:	46bd      	mov	sp, r7
 8009232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009236:	4770      	bx	lr

08009238 <_ZNK3phy7AddressILj4EE4dataEv>:
			address[i] = rand() % 255;

		return address;
	}

	inline const uint8_t * data() const { return _address; }	///< @brief Direct access to address.
 8009238:	b480      	push	{r7}
 800923a:	b083      	sub	sp, #12
 800923c:	af00      	add	r7, sp, #0
 800923e:	6078      	str	r0, [r7, #4]
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	3304      	adds	r3, #4
 8009244:	4618      	mov	r0, r3
 8009246:	370c      	adds	r7, #12
 8009248:	46bd      	mov	sp, r7
 800924a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800924e:	4770      	bx	lr

08009250 <_ZN3hei12SharedBufferIhEC1Ev>:
        SharedBuffer(): data_(nullptr), length_(0) {}
 8009250:	b580      	push	{r7, lr}
 8009252:	b082      	sub	sp, #8
 8009254:	af00      	add	r7, sp, #0
 8009256:	6078      	str	r0, [r7, #4]
 8009258:	687b      	ldr	r3, [r7, #4]
 800925a:	2100      	movs	r1, #0
 800925c:	4618      	mov	r0, r3
 800925e:	f000 f832 	bl	80092c6 <_ZNSt10shared_ptrIhEC1EDn>
 8009262:	687b      	ldr	r3, [r7, #4]
 8009264:	2200      	movs	r2, #0
 8009266:	609a      	str	r2, [r3, #8]
 8009268:	687b      	ldr	r3, [r7, #4]
 800926a:	4618      	mov	r0, r3
 800926c:	3708      	adds	r7, #8
 800926e:	46bd      	mov	sp, r7
 8009270:	bd80      	pop	{r7, pc}

08009272 <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhE5proxyEPhjEUlS5_E_vEEPT_T0_>:
	shared_ptr(_Yp* __p, _Deleter __d)
 8009272:	b5b0      	push	{r4, r5, r7, lr}
 8009274:	b084      	sub	sp, #16
 8009276:	af00      	add	r7, sp, #0
 8009278:	60f8      	str	r0, [r7, #12]
 800927a:	60b9      	str	r1, [r7, #8]
 800927c:	713a      	strb	r2, [r7, #4]
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
 800927e:	68fc      	ldr	r4, [r7, #12]
 8009280:	1d3b      	adds	r3, r7, #4
 8009282:	4618      	mov	r0, r3
 8009284:	f000 f82c 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 8009288:	462a      	mov	r2, r5
 800928a:	68b9      	ldr	r1, [r7, #8]
 800928c:	4620      	mov	r0, r4
 800928e:	f000 f832 	bl	80092f6 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhE5proxyEPhjEUlS7_E_vEEPT_T0_>
 8009292:	68fb      	ldr	r3, [r7, #12]
 8009294:	4618      	mov	r0, r3
 8009296:	3710      	adds	r7, #16
 8009298:	46bd      	mov	sp, r7
 800929a:	bdb0      	pop	{r4, r5, r7, pc}

0800929c <_ZNSt10shared_ptrIhEC1IhZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_vEEPT_T0_>:
	shared_ptr(_Yp* __p, _Deleter __d)
 800929c:	b5b0      	push	{r4, r5, r7, lr}
 800929e:	b084      	sub	sp, #16
 80092a0:	af00      	add	r7, sp, #0
 80092a2:	60f8      	str	r0, [r7, #12]
 80092a4:	60b9      	str	r1, [r7, #8]
 80092a6:	713a      	strb	r2, [r7, #4]
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
 80092a8:	68fc      	ldr	r4, [r7, #12]
 80092aa:	1d3b      	adds	r3, r7, #4
 80092ac:	4618      	mov	r0, r3
 80092ae:	f000 f83f 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 80092b2:	462a      	mov	r2, r5
 80092b4:	68b9      	ldr	r1, [r7, #8]
 80092b6:	4620      	mov	r0, r4
 80092b8:	f000 f845 	bl	8009346 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_vEEPT_T0_>
 80092bc:	68fb      	ldr	r3, [r7, #12]
 80092be:	4618      	mov	r0, r3
 80092c0:	3710      	adds	r7, #16
 80092c2:	46bd      	mov	sp, r7
 80092c4:	bdb0      	pop	{r4, r5, r7, pc}

080092c6 <_ZNSt10shared_ptrIhEC1EDn>:
      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
 80092c6:	b580      	push	{r7, lr}
 80092c8:	b082      	sub	sp, #8
 80092ca:	af00      	add	r7, sp, #0
 80092cc:	6078      	str	r0, [r7, #4]
 80092ce:	6039      	str	r1, [r7, #0]
 80092d0:	6878      	ldr	r0, [r7, #4]
 80092d2:	f7fe fbb3 	bl	8007a3c <_ZNSt10shared_ptrIhEC1Ev>
 80092d6:	687b      	ldr	r3, [r7, #4]
 80092d8:	4618      	mov	r0, r3
 80092da:	3708      	adds	r7, #8
 80092dc:	46bd      	mov	sp, r7
 80092de:	bd80      	pop	{r7, pc}

080092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>:
    move(_Tp&& __t) noexcept
 80092e0:	b480      	push	{r7}
 80092e2:	b083      	sub	sp, #12
 80092e4:	af00      	add	r7, sp, #0
 80092e6:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	4618      	mov	r0, r3
 80092ec:	370c      	adds	r7, #12
 80092ee:	46bd      	mov	sp, r7
 80092f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092f4:	4770      	bx	lr

080092f6 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhE5proxyEPhjEUlS7_E_vEEPT_T0_>:
	__shared_ptr(_Yp* __p, _Deleter __d)
 80092f6:	b5b0      	push	{r4, r5, r7, lr}
 80092f8:	b084      	sub	sp, #16
 80092fa:	af00      	add	r7, sp, #0
 80092fc:	60f8      	str	r0, [r7, #12]
 80092fe:	60b9      	str	r1, [r7, #8]
 8009300:	713a      	strb	r2, [r7, #4]
	: _M_ptr(__p), _M_refcount(__p, std::move(__d))
 8009302:	68fb      	ldr	r3, [r7, #12]
 8009304:	68ba      	ldr	r2, [r7, #8]
 8009306:	601a      	str	r2, [r3, #0]
 8009308:	68fb      	ldr	r3, [r7, #12]
 800930a:	1d1c      	adds	r4, r3, #4
 800930c:	1d3b      	adds	r3, r7, #4
 800930e:	4618      	mov	r0, r3
 8009310:	f7ff ffe6 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 8009314:	462a      	mov	r2, r5
 8009316:	68b9      	ldr	r1, [r7, #8]
 8009318:	4620      	mov	r0, r4
 800931a:	f000 f831 	bl	8009380 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyES4_jEUlS4_E_vEET_T0_>
	  _M_enable_shared_from_this_with(__p);
 800931e:	68b9      	ldr	r1, [r7, #8]
 8009320:	68f8      	ldr	r0, [r7, #12]
 8009322:	f7fe fc46 	bl	8007bb2 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE31_M_enable_shared_from_this_withIhhEENSt9enable_ifIXntsrNS2_15__has_esft_baseIT0_vEE5valueEvE4typeEPT_>
	}
 8009326:	68fb      	ldr	r3, [r7, #12]
 8009328:	4618      	mov	r0, r3
 800932a:	3710      	adds	r7, #16
 800932c:	46bd      	mov	sp, r7
 800932e:	bdb0      	pop	{r4, r5, r7, pc}

08009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>:
    move(_Tp&& __t) noexcept
 8009330:	b480      	push	{r7}
 8009332:	b083      	sub	sp, #12
 8009334:	af00      	add	r7, sp, #0
 8009336:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8009338:	687b      	ldr	r3, [r7, #4]
 800933a:	4618      	mov	r0, r3
 800933c:	370c      	adds	r7, #12
 800933e:	46bd      	mov	sp, r7
 8009340:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009344:	4770      	bx	lr

08009346 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEC1IhZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_vEEPT_T0_>:
	__shared_ptr(_Yp* __p, _Deleter __d)
 8009346:	b5b0      	push	{r4, r5, r7, lr}
 8009348:	b084      	sub	sp, #16
 800934a:	af00      	add	r7, sp, #0
 800934c:	60f8      	str	r0, [r7, #12]
 800934e:	60b9      	str	r1, [r7, #8]
 8009350:	713a      	strb	r2, [r7, #4]
	: _M_ptr(__p), _M_refcount(__p, std::move(__d))
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	68ba      	ldr	r2, [r7, #8]
 8009356:	601a      	str	r2, [r3, #0]
 8009358:	68fb      	ldr	r3, [r7, #12]
 800935a:	1d1c      	adds	r4, r3, #4
 800935c:	1d3b      	adds	r3, r7, #4
 800935e:	4618      	mov	r0, r3
 8009360:	f7ff ffe6 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 8009364:	462a      	mov	r2, r5
 8009366:	68b9      	ldr	r1, [r7, #8]
 8009368:	4620      	mov	r0, r4
 800936a:	f000 f81e 	bl	80093aa <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS4_E_vEET_T0_>
	  _M_enable_shared_from_this_with(__p);
 800936e:	68b9      	ldr	r1, [r7, #8]
 8009370:	68f8      	ldr	r0, [r7, #12]
 8009372:	f7fe fc1e 	bl	8007bb2 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EE31_M_enable_shared_from_this_withIhhEENSt9enable_ifIXntsrNS2_15__has_esft_baseIT0_vEE5valueEvE4typeEPT_>
	}
 8009376:	68fb      	ldr	r3, [r7, #12]
 8009378:	4618      	mov	r0, r3
 800937a:	3710      	adds	r7, #16
 800937c:	46bd      	mov	sp, r7
 800937e:	bdb0      	pop	{r4, r5, r7, pc}

08009380 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyES4_jEUlS4_E_vEET_T0_>:
	__shared_count(_Ptr __p, _Deleter __d)
 8009380:	b5b0      	push	{r4, r5, r7, lr}
 8009382:	b084      	sub	sp, #16
 8009384:	af00      	add	r7, sp, #0
 8009386:	60f8      	str	r0, [r7, #12]
 8009388:	60b9      	str	r1, [r7, #8]
 800938a:	713a      	strb	r2, [r7, #4]
	: __shared_count(__p, std::move(__d), allocator<void>())
 800938c:	1d3b      	adds	r3, r7, #4
 800938e:	4618      	mov	r0, r3
 8009390:	f7ff ffa6 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 8009394:	462b      	mov	r3, r5
 8009396:	4622      	mov	r2, r4
 8009398:	68b9      	ldr	r1, [r7, #8]
 800939a:	68f8      	ldr	r0, [r7, #12]
 800939c:	f000 f81a 	bl	80093d4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyES4_jEUlS4_E_SaIvEvEET_T0_T1_>
	{ }
 80093a0:	68fb      	ldr	r3, [r7, #12]
 80093a2:	4618      	mov	r0, r3
 80093a4:	3710      	adds	r7, #16
 80093a6:	46bd      	mov	sp, r7
 80093a8:	bdb0      	pop	{r4, r5, r7, pc}

080093aa <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS4_E_vEET_T0_>:
	__shared_count(_Ptr __p, _Deleter __d)
 80093aa:	b5b0      	push	{r4, r5, r7, lr}
 80093ac:	b084      	sub	sp, #16
 80093ae:	af00      	add	r7, sp, #0
 80093b0:	60f8      	str	r0, [r7, #12]
 80093b2:	60b9      	str	r1, [r7, #8]
 80093b4:	713a      	strb	r2, [r7, #4]
	: __shared_count(__p, std::move(__d), allocator<void>())
 80093b6:	1d3b      	adds	r3, r7, #4
 80093b8:	4618      	mov	r0, r3
 80093ba:	f7ff ffb9 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 80093be:	462b      	mov	r3, r5
 80093c0:	4622      	mov	r2, r4
 80093c2:	68b9      	ldr	r1, [r7, #8]
 80093c4:	68f8      	ldr	r0, [r7, #12]
 80093c6:	f000 f850 	bl	800946a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS4_E_SaIvEvEET_T0_T1_>
	{ }
 80093ca:	68fb      	ldr	r3, [r7, #12]
 80093cc:	4618      	mov	r0, r3
 80093ce:	3710      	adds	r7, #16
 80093d0:	46bd      	mov	sp, r7
 80093d2:	bdb0      	pop	{r4, r5, r7, pc}

080093d4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyES4_jEUlS4_E_SaIvEvEET_T0_T1_>:
	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 80093d4:	b590      	push	{r4, r7, lr}
 80093d6:	b08b      	sub	sp, #44	; 0x2c
 80093d8:	af00      	add	r7, sp, #0
 80093da:	60f8      	str	r0, [r7, #12]
 80093dc:	60b9      	str	r1, [r7, #8]
 80093de:	713a      	strb	r2, [r7, #4]
 80093e0:	703b      	strb	r3, [r7, #0]
 80093e2:	68fb      	ldr	r3, [r7, #12]
 80093e4:	2200      	movs	r2, #0
 80093e6:	601a      	str	r2, [r3, #0]
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 80093e8:	463a      	mov	r2, r7
 80093ea:	f107 031c 	add.w	r3, r7, #28
 80093ee:	4611      	mov	r1, r2
 80093f0:	4618      	mov	r0, r3
 80093f2:	f000 f885 	bl	8009500 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	      auto __guard = std::__allocate_guarded(__a2);
 80093f6:	f107 0314 	add.w	r3, r7, #20
 80093fa:	f107 021c 	add.w	r2, r7, #28
 80093fe:	4611      	mov	r1, r2
 8009400:	4618      	mov	r0, r3
 8009402:	f000 f896 	bl	8009532 <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSC_>
	      _Sp_cd_type* __mem = __guard.get();
 8009406:	f107 0314 	add.w	r3, r7, #20
 800940a:	4618      	mov	r0, r3
 800940c:	f000 f8b9 	bl	8009582 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>
 8009410:	6278      	str	r0, [r7, #36]	; 0x24
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 8009412:	1d3b      	adds	r3, r7, #4
 8009414:	4618      	mov	r0, r3
 8009416:	f7ff ff63 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 800941a:	463b      	mov	r3, r7
 800941c:	4618      	mov	r0, r3
 800941e:	f7fe fcec 	bl	8007dfa <_ZSt4moveIRSaIvEEONSt16remove_referenceIT_E4typeEOS3_>
 8009422:	4604      	mov	r4, r0
 8009424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009426:	4619      	mov	r1, r3
 8009428:	2010      	movs	r0, #16
 800942a:	f7fe f96d 	bl	8007708 <_ZnwjPv>
 800942e:	4623      	mov	r3, r4
 8009430:	f897 2020 	ldrb.w	r2, [r7, #32]
 8009434:	68b9      	ldr	r1, [r7, #8]
 8009436:	f000 f8b3 	bl	80095a0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_>
	      _M_pi = __mem;
 800943a:	68fb      	ldr	r3, [r7, #12]
 800943c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800943e:	601a      	str	r2, [r3, #0]
	      __guard = nullptr;
 8009440:	f107 0314 	add.w	r3, r7, #20
 8009444:	2100      	movs	r1, #0
 8009446:	4618      	mov	r0, r3
 8009448:	f000 f8cc 	bl	80095e4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>
	      auto __guard = std::__allocate_guarded(__a2);
 800944c:	f107 0314 	add.w	r3, r7, #20
 8009450:	4618      	mov	r0, r3
 8009452:	f000 f881 	bl	8009558 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 8009456:	f107 031c 	add.w	r3, r7, #28
 800945a:	4618      	mov	r0, r3
 800945c:	f000 f85d 	bl	800951a <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
	}
 8009460:	68fb      	ldr	r3, [r7, #12]
 8009462:	4618      	mov	r0, r3
 8009464:	372c      	adds	r7, #44	; 0x2c
 8009466:	46bd      	mov	sp, r7
 8009468:	bd90      	pop	{r4, r7, pc}

0800946a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS4_E_SaIvEvEET_T0_T1_>:
	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 800946a:	b590      	push	{r4, r7, lr}
 800946c:	b08b      	sub	sp, #44	; 0x2c
 800946e:	af00      	add	r7, sp, #0
 8009470:	60f8      	str	r0, [r7, #12]
 8009472:	60b9      	str	r1, [r7, #8]
 8009474:	713a      	strb	r2, [r7, #4]
 8009476:	703b      	strb	r3, [r7, #0]
 8009478:	68fb      	ldr	r3, [r7, #12]
 800947a:	2200      	movs	r2, #0
 800947c:	601a      	str	r2, [r3, #0]
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 800947e:	463a      	mov	r2, r7
 8009480:	f107 031c 	add.w	r3, r7, #28
 8009484:	4611      	mov	r1, r2
 8009486:	4618      	mov	r0, r3
 8009488:	f000 f8bb 	bl	8009602 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	      auto __guard = std::__allocate_guarded(__a2);
 800948c:	f107 0314 	add.w	r3, r7, #20
 8009490:	f107 021c 	add.w	r2, r7, #28
 8009494:	4611      	mov	r1, r2
 8009496:	4618      	mov	r0, r3
 8009498:	f000 f8cc 	bl	8009634 <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSE_>
	      _Sp_cd_type* __mem = __guard.get();
 800949c:	f107 0314 	add.w	r3, r7, #20
 80094a0:	4618      	mov	r0, r3
 80094a2:	f000 f8ef 	bl	8009684 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>
 80094a6:	6278      	str	r0, [r7, #36]	; 0x24
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 80094a8:	1d3b      	adds	r3, r7, #4
 80094aa:	4618      	mov	r0, r3
 80094ac:	f7ff ff40 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 80094b0:	463b      	mov	r3, r7
 80094b2:	4618      	mov	r0, r3
 80094b4:	f7fe fca1 	bl	8007dfa <_ZSt4moveIRSaIvEEONSt16remove_referenceIT_E4typeEOS3_>
 80094b8:	4604      	mov	r4, r0
 80094ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80094bc:	4619      	mov	r1, r3
 80094be:	2010      	movs	r0, #16
 80094c0:	f7fe f922 	bl	8007708 <_ZnwjPv>
 80094c4:	4623      	mov	r3, r4
 80094c6:	f897 2020 	ldrb.w	r2, [r7, #32]
 80094ca:	68b9      	ldr	r1, [r7, #8]
 80094cc:	f000 f8e8 	bl	80096a0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S6_RKS7_>
	      _M_pi = __mem;
 80094d0:	68fb      	ldr	r3, [r7, #12]
 80094d2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80094d4:	601a      	str	r2, [r3, #0]
	      __guard = nullptr;
 80094d6:	f107 0314 	add.w	r3, r7, #20
 80094da:	2100      	movs	r1, #0
 80094dc:	4618      	mov	r0, r3
 80094de:	f000 f901 	bl	80096e4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>
	      auto __guard = std::__allocate_guarded(__a2);
 80094e2:	f107 0314 	add.w	r3, r7, #20
 80094e6:	4618      	mov	r0, r3
 80094e8:	f000 f8b7 	bl	800965a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	      typename _Sp_cd_type::__allocator_type __a2(__a);
 80094ec:	f107 031c 	add.w	r3, r7, #28
 80094f0:	4618      	mov	r0, r3
 80094f2:	f000 f893 	bl	800961c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
	}
 80094f6:	68fb      	ldr	r3, [r7, #12]
 80094f8:	4618      	mov	r0, r3
 80094fa:	372c      	adds	r7, #44	; 0x2c
 80094fc:	46bd      	mov	sp, r7
 80094fe:	bd90      	pop	{r4, r7, pc}

08009500 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>:
	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
 8009500:	b580      	push	{r7, lr}
 8009502:	b082      	sub	sp, #8
 8009504:	af00      	add	r7, sp, #0
 8009506:	6078      	str	r0, [r7, #4]
 8009508:	6039      	str	r1, [r7, #0]
 800950a:	6878      	ldr	r0, [r7, #4]
 800950c:	f000 f8f9 	bl	8009702 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>
 8009510:	687b      	ldr	r3, [r7, #4]
 8009512:	4618      	mov	r0, r3
 8009514:	3708      	adds	r7, #8
 8009516:	46bd      	mov	sp, r7
 8009518:	bd80      	pop	{r7, pc}

0800951a <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 800951a:	b580      	push	{r7, lr}
 800951c:	b082      	sub	sp, #8
 800951e:	af00      	add	r7, sp, #0
 8009520:	6078      	str	r0, [r7, #4]
 8009522:	6878      	ldr	r0, [r7, #4]
 8009524:	f000 f8f8 	bl	8009718 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>
 8009528:	687b      	ldr	r3, [r7, #4]
 800952a:	4618      	mov	r0, r3
 800952c:	3708      	adds	r7, #8
 800952e:	46bd      	mov	sp, r7
 8009530:	bd80      	pop	{r7, pc}

08009532 <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSC_>:
    __allocate_guarded(_Alloc& __a)
 8009532:	b580      	push	{r7, lr}
 8009534:	b082      	sub	sp, #8
 8009536:	af00      	add	r7, sp, #0
 8009538:	6078      	str	r0, [r7, #4]
 800953a:	6039      	str	r1, [r7, #0]
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
 800953c:	2101      	movs	r1, #1
 800953e:	6838      	ldr	r0, [r7, #0]
 8009540:	f000 f8f5 	bl	800972e <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSA_j>
 8009544:	4603      	mov	r3, r0
 8009546:	461a      	mov	r2, r3
 8009548:	6839      	ldr	r1, [r7, #0]
 800954a:	6878      	ldr	r0, [r7, #4]
 800954c:	f000 f8fe 	bl	800974c <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>
    }
 8009550:	6878      	ldr	r0, [r7, #4]
 8009552:	3708      	adds	r7, #8
 8009554:	46bd      	mov	sp, r7
 8009556:	bd80      	pop	{r7, pc}

08009558 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>:
      ~__allocated_ptr()
 8009558:	b580      	push	{r7, lr}
 800955a:	b082      	sub	sp, #8
 800955c:	af00      	add	r7, sp, #0
 800955e:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 8009560:	687b      	ldr	r3, [r7, #4]
 8009562:	685b      	ldr	r3, [r3, #4]
 8009564:	2b00      	cmp	r3, #0
 8009566:	d007      	beq.n	8009578 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 8009568:	687b      	ldr	r3, [r7, #4]
 800956a:	6818      	ldr	r0, [r3, #0]
 800956c:	687b      	ldr	r3, [r7, #4]
 800956e:	685b      	ldr	r3, [r3, #4]
 8009570:	2201      	movs	r2, #1
 8009572:	4619      	mov	r1, r3
 8009574:	f000 f8fe 	bl	8009774 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSA_PS9_j>
      }
 8009578:	687b      	ldr	r3, [r7, #4]
 800957a:	4618      	mov	r0, r3
 800957c:	3708      	adds	r7, #8
 800957e:	46bd      	mov	sp, r7
 8009580:	bd80      	pop	{r7, pc}

08009582 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>:
      value_type* get() { return std::__to_address(_M_ptr); }
 8009582:	b580      	push	{r7, lr}
 8009584:	b082      	sub	sp, #8
 8009586:	af00      	add	r7, sp, #0
 8009588:	6078      	str	r0, [r7, #4]
 800958a:	687b      	ldr	r3, [r7, #4]
 800958c:	685b      	ldr	r3, [r3, #4]
 800958e:	4618      	mov	r0, r3
 8009590:	f000 f8ff 	bl	8009792 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SB_>
 8009594:	4603      	mov	r3, r0
 8009596:	4618      	mov	r0, r3
 8009598:	3708      	adds	r7, #8
 800959a:	46bd      	mov	sp, r7
 800959c:	bd80      	pop	{r7, pc}
	...

080095a0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_>:
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 80095a0:	b5b0      	push	{r4, r5, r7, lr}
 80095a2:	b084      	sub	sp, #16
 80095a4:	af00      	add	r7, sp, #0
 80095a6:	60f8      	str	r0, [r7, #12]
 80095a8:	60b9      	str	r1, [r7, #8]
 80095aa:	713a      	strb	r2, [r7, #4]
 80095ac:	603b      	str	r3, [r7, #0]
      : _M_impl(__p, std::move(__d), __a) { }
 80095ae:	68fb      	ldr	r3, [r7, #12]
 80095b0:	4618      	mov	r0, r3
 80095b2:	f7fe fcb1 	bl	8007f18 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EEC1Ev>
 80095b6:	4a0a      	ldr	r2, [pc, #40]	; (80095e0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S4_RKS5_+0x40>)
 80095b8:	68fb      	ldr	r3, [r7, #12]
 80095ba:	601a      	str	r2, [r3, #0]
 80095bc:	68fb      	ldr	r3, [r7, #12]
 80095be:	f103 040c 	add.w	r4, r3, #12
 80095c2:	1d3b      	adds	r3, r7, #4
 80095c4:	4618      	mov	r0, r3
 80095c6:	f7ff fe8b 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 80095ca:	683b      	ldr	r3, [r7, #0]
 80095cc:	462a      	mov	r2, r5
 80095ce:	68b9      	ldr	r1, [r7, #8]
 80095d0:	4620      	mov	r0, r4
 80095d2:	f000 f8e9 	bl	80097a8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S4_RKS5_>
 80095d6:	68fb      	ldr	r3, [r7, #12]
 80095d8:	4618      	mov	r0, r3
 80095da:	3710      	adds	r7, #16
 80095dc:	46bd      	mov	sp, r7
 80095de:	bdb0      	pop	{r4, r5, r7, pc}
 80095e0:	0801b9a8 	.word	0x0801b9a8

080095e4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 80095e4:	b480      	push	{r7}
 80095e6:	b083      	sub	sp, #12
 80095e8:	af00      	add	r7, sp, #0
 80095ea:	6078      	str	r0, [r7, #4]
 80095ec:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 80095ee:	687b      	ldr	r3, [r7, #4]
 80095f0:	2200      	movs	r2, #0
 80095f2:	605a      	str	r2, [r3, #4]
	return *this;
 80095f4:	687b      	ldr	r3, [r7, #4]
      }
 80095f6:	4618      	mov	r0, r3
 80095f8:	370c      	adds	r7, #12
 80095fa:	46bd      	mov	sp, r7
 80095fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009600:	4770      	bx	lr

08009602 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>:
	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
 8009602:	b580      	push	{r7, lr}
 8009604:	b082      	sub	sp, #8
 8009606:	af00      	add	r7, sp, #0
 8009608:	6078      	str	r0, [r7, #4]
 800960a:	6039      	str	r1, [r7, #0]
 800960c:	6878      	ldr	r0, [r7, #4]
 800960e:	f000 f8e7 	bl	80097e0 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>
 8009612:	687b      	ldr	r3, [r7, #4]
 8009614:	4618      	mov	r0, r3
 8009616:	3708      	adds	r7, #8
 8009618:	46bd      	mov	sp, r7
 800961a:	bd80      	pop	{r7, pc}

0800961c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 800961c:	b580      	push	{r7, lr}
 800961e:	b082      	sub	sp, #8
 8009620:	af00      	add	r7, sp, #0
 8009622:	6078      	str	r0, [r7, #4]
 8009624:	6878      	ldr	r0, [r7, #4]
 8009626:	f000 f8e6 	bl	80097f6 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>
 800962a:	687b      	ldr	r3, [r7, #4]
 800962c:	4618      	mov	r0, r3
 800962e:	3708      	adds	r7, #8
 8009630:	46bd      	mov	sp, r7
 8009632:	bd80      	pop	{r7, pc}

08009634 <_ZSt18__allocate_guardedISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEESt15__allocated_ptrIT_ERSE_>:
    __allocate_guarded(_Alloc& __a)
 8009634:	b580      	push	{r7, lr}
 8009636:	b082      	sub	sp, #8
 8009638:	af00      	add	r7, sp, #0
 800963a:	6078      	str	r0, [r7, #4]
 800963c:	6039      	str	r1, [r7, #0]
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
 800963e:	2101      	movs	r1, #1
 8009640:	6838      	ldr	r0, [r7, #0]
 8009642:	f000 f8e3 	bl	800980c <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSC_j>
 8009646:	4603      	mov	r3, r0
 8009648:	461a      	mov	r2, r3
 800964a:	6839      	ldr	r1, [r7, #0]
 800964c:	6878      	ldr	r0, [r7, #4]
 800964e:	f000 f8ec 	bl	800982a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSC_PSB_>
    }
 8009652:	6878      	ldr	r0, [r7, #4]
 8009654:	3708      	adds	r7, #8
 8009656:	46bd      	mov	sp, r7
 8009658:	bd80      	pop	{r7, pc}

0800965a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>:
      ~__allocated_ptr()
 800965a:	b580      	push	{r7, lr}
 800965c:	b082      	sub	sp, #8
 800965e:	af00      	add	r7, sp, #0
 8009660:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 8009662:	687b      	ldr	r3, [r7, #4]
 8009664:	685b      	ldr	r3, [r3, #4]
 8009666:	2b00      	cmp	r3, #0
 8009668:	d007      	beq.n	800967a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 800966a:	687b      	ldr	r3, [r7, #4]
 800966c:	6818      	ldr	r0, [r3, #0]
 800966e:	687b      	ldr	r3, [r7, #4]
 8009670:	685b      	ldr	r3, [r3, #4]
 8009672:	2201      	movs	r2, #1
 8009674:	4619      	mov	r1, r3
 8009676:	f000 f8ec 	bl	8009852 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSC_PSB_j>
      }
 800967a:	687b      	ldr	r3, [r7, #4]
 800967c:	4618      	mov	r0, r3
 800967e:	3708      	adds	r7, #8
 8009680:	46bd      	mov	sp, r7
 8009682:	bd80      	pop	{r7, pc}

08009684 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE3getEv>:
      value_type* get() { return std::__to_address(_M_ptr); }
 8009684:	b580      	push	{r7, lr}
 8009686:	b082      	sub	sp, #8
 8009688:	af00      	add	r7, sp, #0
 800968a:	6078      	str	r0, [r7, #4]
 800968c:	687b      	ldr	r3, [r7, #4]
 800968e:	685b      	ldr	r3, [r3, #4]
 8009690:	4618      	mov	r0, r3
 8009692:	f000 f8ed 	bl	8009870 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SD_>
 8009696:	4603      	mov	r3, r0
 8009698:	4618      	mov	r0, r3
 800969a:	3708      	adds	r7, #8
 800969c:	46bd      	mov	sp, r7
 800969e:	bd80      	pop	{r7, pc}

080096a0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S6_RKS7_>:
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 80096a0:	b5b0      	push	{r4, r5, r7, lr}
 80096a2:	b084      	sub	sp, #16
 80096a4:	af00      	add	r7, sp, #0
 80096a6:	60f8      	str	r0, [r7, #12]
 80096a8:	60b9      	str	r1, [r7, #8]
 80096aa:	713a      	strb	r2, [r7, #4]
 80096ac:	603b      	str	r3, [r7, #0]
      : _M_impl(__p, std::move(__d), __a) { }
 80096ae:	68fb      	ldr	r3, [r7, #12]
 80096b0:	4618      	mov	r0, r3
 80096b2:	f7fe fc31 	bl	8007f18 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EEC1Ev>
 80096b6:	4a0a      	ldr	r2, [pc, #40]	; (80096e0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEC1ES0_S6_RKS7_+0x40>)
 80096b8:	68fb      	ldr	r3, [r7, #12]
 80096ba:	601a      	str	r2, [r3, #0]
 80096bc:	68fb      	ldr	r3, [r7, #12]
 80096be:	f103 040c 	add.w	r4, r3, #12
 80096c2:	1d3b      	adds	r3, r7, #4
 80096c4:	4618      	mov	r0, r3
 80096c6:	f7ff fe33 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 80096ca:	683b      	ldr	r3, [r7, #0]
 80096cc:	462a      	mov	r2, r5
 80096ce:	68b9      	ldr	r1, [r7, #8]
 80096d0:	4620      	mov	r0, r4
 80096d2:	f000 f8d8 	bl	8009886 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S6_RKS7_>
 80096d6:	68fb      	ldr	r3, [r7, #12]
 80096d8:	4618      	mov	r0, r3
 80096da:	3710      	adds	r7, #16
 80096dc:	46bd      	mov	sp, r7
 80096de:	bdb0      	pop	{r4, r5, r7, pc}
 80096e0:	0801b98c 	.word	0x0801b98c

080096e4 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 80096e4:	b480      	push	{r7}
 80096e6:	b083      	sub	sp, #12
 80096e8:	af00      	add	r7, sp, #0
 80096ea:	6078      	str	r0, [r7, #4]
 80096ec:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 80096ee:	687b      	ldr	r3, [r7, #4]
 80096f0:	2200      	movs	r2, #0
 80096f2:	605a      	str	r2, [r3, #4]
	return *this;
 80096f4:	687b      	ldr	r3, [r7, #4]
      }
 80096f6:	4618      	mov	r0, r3
 80096f8:	370c      	adds	r7, #12
 80096fa:	46bd      	mov	sp, r7
 80096fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009700:	4770      	bx	lr

08009702 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8009702:	b480      	push	{r7}
 8009704:	b083      	sub	sp, #12
 8009706:	af00      	add	r7, sp, #0
 8009708:	6078      	str	r0, [r7, #4]
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	4618      	mov	r0, r3
 800970e:	370c      	adds	r7, #12
 8009710:	46bd      	mov	sp, r7
 8009712:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009716:	4770      	bx	lr

08009718 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8009718:	b480      	push	{r7}
 800971a:	b083      	sub	sp, #12
 800971c:	af00      	add	r7, sp, #0
 800971e:	6078      	str	r0, [r7, #4]
 8009720:	687b      	ldr	r3, [r7, #4]
 8009722:	4618      	mov	r0, r3
 8009724:	370c      	adds	r7, #12
 8009726:	46bd      	mov	sp, r7
 8009728:	f85d 7b04 	ldr.w	r7, [sp], #4
 800972c:	4770      	bx	lr

0800972e <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSA_j>:
      allocate(allocator_type& __a, size_type __n)
 800972e:	b580      	push	{r7, lr}
 8009730:	b082      	sub	sp, #8
 8009732:	af00      	add	r7, sp, #0
 8009734:	6078      	str	r0, [r7, #4]
 8009736:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 8009738:	2200      	movs	r2, #0
 800973a:	6839      	ldr	r1, [r7, #0]
 800973c:	6878      	ldr	r0, [r7, #4]
 800973e:	f000 f8be 	bl	80098be <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>
 8009742:	4603      	mov	r3, r0
 8009744:	4618      	mov	r0, r3
 8009746:	3708      	adds	r7, #8
 8009748:	46bd      	mov	sp, r7
 800974a:	bd80      	pop	{r7, pc}

0800974c <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 800974c:	b580      	push	{r7, lr}
 800974e:	b084      	sub	sp, #16
 8009750:	af00      	add	r7, sp, #0
 8009752:	60f8      	str	r0, [r7, #12]
 8009754:	60b9      	str	r1, [r7, #8]
 8009756:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 8009758:	68b8      	ldr	r0, [r7, #8]
 800975a:	f000 f8ce 	bl	80098fa <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSB_>
 800975e:	4602      	mov	r2, r0
 8009760:	68fb      	ldr	r3, [r7, #12]
 8009762:	601a      	str	r2, [r3, #0]
 8009764:	68fb      	ldr	r3, [r7, #12]
 8009766:	687a      	ldr	r2, [r7, #4]
 8009768:	605a      	str	r2, [r3, #4]
      { }
 800976a:	68fb      	ldr	r3, [r7, #12]
 800976c:	4618      	mov	r0, r3
 800976e:	3710      	adds	r7, #16
 8009770:	46bd      	mov	sp, r7
 8009772:	bd80      	pop	{r7, pc}

08009774 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSA_PS9_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8009774:	b580      	push	{r7, lr}
 8009776:	b084      	sub	sp, #16
 8009778:	af00      	add	r7, sp, #0
 800977a:	60f8      	str	r0, [r7, #12]
 800977c:	60b9      	str	r1, [r7, #8]
 800977e:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 8009780:	687a      	ldr	r2, [r7, #4]
 8009782:	68b9      	ldr	r1, [r7, #8]
 8009784:	68f8      	ldr	r0, [r7, #12]
 8009786:	f000 f8c3 	bl	8009910 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPS9_j>
 800978a:	bf00      	nop
 800978c:	3710      	adds	r7, #16
 800978e:	46bd      	mov	sp, r7
 8009790:	bd80      	pop	{r7, pc}

08009792 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SB_>:
    __to_address(_Tp* __ptr) noexcept
 8009792:	b480      	push	{r7}
 8009794:	b083      	sub	sp, #12
 8009796:	af00      	add	r7, sp, #0
 8009798:	6078      	str	r0, [r7, #4]
      return __ptr;
 800979a:	687b      	ldr	r3, [r7, #4]
    }
 800979c:	4618      	mov	r0, r3
 800979e:	370c      	adds	r7, #12
 80097a0:	46bd      	mov	sp, r7
 80097a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097a6:	4770      	bx	lr

080097a8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S4_RKS5_>:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 80097a8:	b580      	push	{r7, lr}
 80097aa:	b084      	sub	sp, #16
 80097ac:	af00      	add	r7, sp, #0
 80097ae:	60f8      	str	r0, [r7, #12]
 80097b0:	60b9      	str	r1, [r7, #8]
 80097b2:	713a      	strb	r2, [r7, #4]
 80097b4:	603b      	str	r3, [r7, #0]
	: _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 80097b6:	1d3b      	adds	r3, r7, #4
 80097b8:	4618      	mov	r0, r3
 80097ba:	f7ff fd91 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 80097be:	4603      	mov	r3, r0
 80097c0:	4619      	mov	r1, r3
 80097c2:	68f8      	ldr	r0, [r7, #12]
 80097c4:	f000 f8b4 	bl	8009930 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_Lb1EEC1EOS4_>
 80097c8:	6839      	ldr	r1, [r7, #0]
 80097ca:	68f8      	ldr	r0, [r7, #12]
 80097cc:	f7fe fc1c 	bl	8008008 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EEC1ERKS0_>
 80097d0:	68fb      	ldr	r3, [r7, #12]
 80097d2:	68ba      	ldr	r2, [r7, #8]
 80097d4:	601a      	str	r2, [r3, #0]
	{ }
 80097d6:	68fb      	ldr	r3, [r7, #12]
 80097d8:	4618      	mov	r0, r3
 80097da:	3710      	adds	r7, #16
 80097dc:	46bd      	mov	sp, r7
 80097de:	bd80      	pop	{r7, pc}

080097e0 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 80097e0:	b480      	push	{r7}
 80097e2:	b083      	sub	sp, #12
 80097e4:	af00      	add	r7, sp, #0
 80097e6:	6078      	str	r0, [r7, #4]
 80097e8:	687b      	ldr	r3, [r7, #4]
 80097ea:	4618      	mov	r0, r3
 80097ec:	370c      	adds	r7, #12
 80097ee:	46bd      	mov	sp, r7
 80097f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097f4:	4770      	bx	lr

080097f6 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 80097f6:	b480      	push	{r7}
 80097f8:	b083      	sub	sp, #12
 80097fa:	af00      	add	r7, sp, #0
 80097fc:	6078      	str	r0, [r7, #4]
 80097fe:	687b      	ldr	r3, [r7, #4]
 8009800:	4618      	mov	r0, r3
 8009802:	370c      	adds	r7, #12
 8009804:	46bd      	mov	sp, r7
 8009806:	f85d 7b04 	ldr.w	r7, [sp], #4
 800980a:	4770      	bx	lr

0800980c <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE8allocateERSC_j>:
      allocate(allocator_type& __a, size_type __n)
 800980c:	b580      	push	{r7, lr}
 800980e:	b082      	sub	sp, #8
 8009810:	af00      	add	r7, sp, #0
 8009812:	6078      	str	r0, [r7, #4]
 8009814:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 8009816:	2200      	movs	r2, #0
 8009818:	6839      	ldr	r1, [r7, #0]
 800981a:	6878      	ldr	r0, [r7, #4]
 800981c:	f000 f895 	bl	800994a <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>
 8009820:	4603      	mov	r3, r0
 8009822:	4618      	mov	r0, r3
 8009824:	3708      	adds	r7, #8
 8009826:	46bd      	mov	sp, r7
 8009828:	bd80      	pop	{r7, pc}

0800982a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSC_PSB_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 800982a:	b580      	push	{r7, lr}
 800982c:	b084      	sub	sp, #16
 800982e:	af00      	add	r7, sp, #0
 8009830:	60f8      	str	r0, [r7, #12]
 8009832:	60b9      	str	r1, [r7, #8]
 8009834:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 8009836:	68b8      	ldr	r0, [r7, #8]
 8009838:	f000 f8a5 	bl	8009986 <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSD_>
 800983c:	4602      	mov	r2, r0
 800983e:	68fb      	ldr	r3, [r7, #12]
 8009840:	601a      	str	r2, [r3, #0]
 8009842:	68fb      	ldr	r3, [r7, #12]
 8009844:	687a      	ldr	r2, [r7, #4]
 8009846:	605a      	str	r2, [r3, #4]
      { }
 8009848:	68fb      	ldr	r3, [r7, #12]
 800984a:	4618      	mov	r0, r3
 800984c:	3710      	adds	r7, #16
 800984e:	46bd      	mov	sp, r7
 8009850:	bd80      	pop	{r7, pc}

08009852 <_ZNSt16allocator_traitsISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEE10deallocateERSC_PSB_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8009852:	b580      	push	{r7, lr}
 8009854:	b084      	sub	sp, #16
 8009856:	af00      	add	r7, sp, #0
 8009858:	60f8      	str	r0, [r7, #12]
 800985a:	60b9      	str	r1, [r7, #8]
 800985c:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 800985e:	687a      	ldr	r2, [r7, #4]
 8009860:	68b9      	ldr	r1, [r7, #8]
 8009862:	68f8      	ldr	r0, [r7, #12]
 8009864:	f000 f89a 	bl	800999c <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPSB_j>
 8009868:	bf00      	nop
 800986a:	3710      	adds	r7, #16
 800986c:	46bd      	mov	sp, r7
 800986e:	bd80      	pop	{r7, pc}

08009870 <_ZSt12__to_addressISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEPT_SD_>:
    __to_address(_Tp* __ptr) noexcept
 8009870:	b480      	push	{r7}
 8009872:	b083      	sub	sp, #12
 8009874:	af00      	add	r7, sp, #0
 8009876:	6078      	str	r0, [r7, #4]
      return __ptr;
 8009878:	687b      	ldr	r3, [r7, #4]
    }
 800987a:	4618      	mov	r0, r3
 800987c:	370c      	adds	r7, #12
 800987e:	46bd      	mov	sp, r7
 8009880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009884:	4770      	bx	lr

08009886 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_ImplC1ES0_S6_RKS7_>:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 8009886:	b580      	push	{r7, lr}
 8009888:	b084      	sub	sp, #16
 800988a:	af00      	add	r7, sp, #0
 800988c:	60f8      	str	r0, [r7, #12]
 800988e:	60b9      	str	r1, [r7, #8]
 8009890:	713a      	strb	r2, [r7, #4]
 8009892:	603b      	str	r3, [r7, #0]
	: _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 8009894:	1d3b      	adds	r3, r7, #4
 8009896:	4618      	mov	r0, r3
 8009898:	f7ff fd4a 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 800989c:	4603      	mov	r3, r0
 800989e:	4619      	mov	r1, r3
 80098a0:	68f8      	ldr	r0, [r7, #12]
 80098a2:	f000 f88b 	bl	80099bc <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_Lb1EEC1EOS6_>
 80098a6:	6839      	ldr	r1, [r7, #0]
 80098a8:	68f8      	ldr	r0, [r7, #12]
 80098aa:	f7fe fbad 	bl	8008008 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EEC1ERKS0_>
 80098ae:	68fb      	ldr	r3, [r7, #12]
 80098b0:	68ba      	ldr	r2, [r7, #8]
 80098b2:	601a      	str	r2, [r3, #0]
	{ }
 80098b4:	68fb      	ldr	r3, [r7, #12]
 80098b6:	4618      	mov	r0, r3
 80098b8:	3710      	adds	r7, #16
 80098ba:	46bd      	mov	sp, r7
 80098bc:	bd80      	pop	{r7, pc}

080098be <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 80098be:	b580      	push	{r7, lr}
 80098c0:	b084      	sub	sp, #16
 80098c2:	af00      	add	r7, sp, #0
 80098c4:	60f8      	str	r0, [r7, #12]
 80098c6:	60b9      	str	r1, [r7, #8]
 80098c8:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 80098ca:	68f8      	ldr	r0, [r7, #12]
 80098cc:	f000 f883 	bl	80099d6 <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>
 80098d0:	4602      	mov	r2, r0
 80098d2:	68bb      	ldr	r3, [r7, #8]
 80098d4:	4293      	cmp	r3, r2
 80098d6:	bf8c      	ite	hi
 80098d8:	2301      	movhi	r3, #1
 80098da:	2300      	movls	r3, #0
 80098dc:	b2db      	uxtb	r3, r3
 80098de:	2b00      	cmp	r3, #0
 80098e0:	d001      	beq.n	80098e6 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 80098e2:	f00c fc9a 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80098e6:	68bb      	ldr	r3, [r7, #8]
 80098e8:	011b      	lsls	r3, r3, #4
 80098ea:	4618      	mov	r0, r3
 80098ec:	f00c fc71 	bl	80161d2 <_Znwj>
 80098f0:	4603      	mov	r3, r0
      }
 80098f2:	4618      	mov	r0, r3
 80098f4:	3710      	adds	r7, #16
 80098f6:	46bd      	mov	sp, r7
 80098f8:	bd80      	pop	{r7, pc}

080098fa <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSB_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 80098fa:	b480      	push	{r7}
 80098fc:	b083      	sub	sp, #12
 80098fe:	af00      	add	r7, sp, #0
 8009900:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 8009902:	687b      	ldr	r3, [r7, #4]
 8009904:	4618      	mov	r0, r3
 8009906:	370c      	adds	r7, #12
 8009908:	46bd      	mov	sp, r7
 800990a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800990e:	4770      	bx	lr

08009910 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPS9_j>:
      deallocate(_Tp* __p, size_type __t)
 8009910:	b580      	push	{r7, lr}
 8009912:	b084      	sub	sp, #16
 8009914:	af00      	add	r7, sp, #0
 8009916:	60f8      	str	r0, [r7, #12]
 8009918:	60b9      	str	r1, [r7, #8]
 800991a:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	011b      	lsls	r3, r3, #4
 8009920:	4619      	mov	r1, r3
 8009922:	68b8      	ldr	r0, [r7, #8]
 8009924:	f00c fc42 	bl	80161ac <_ZdlPvj>
      }
 8009928:	bf00      	nop
 800992a:	3710      	adds	r7, #16
 800992c:	46bd      	mov	sp, r7
 800992e:	bd80      	pop	{r7, pc}

08009930 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_Lb1EEC1EOS4_>:
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }
 8009930:	b580      	push	{r7, lr}
 8009932:	b082      	sub	sp, #8
 8009934:	af00      	add	r7, sp, #0
 8009936:	6078      	str	r0, [r7, #4]
 8009938:	6039      	str	r1, [r7, #0]
 800993a:	6838      	ldr	r0, [r7, #0]
 800993c:	f7ff fcd0 	bl	80092e0 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_EONSt16remove_referenceIT_E4typeEOS7_>
 8009940:	687b      	ldr	r3, [r7, #4]
 8009942:	4618      	mov	r0, r3
 8009944:	3708      	adds	r7, #8
 8009946:	46bd      	mov	sp, r7
 8009948:	bd80      	pop	{r7, pc}

0800994a <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 800994a:	b580      	push	{r7, lr}
 800994c:	b084      	sub	sp, #16
 800994e:	af00      	add	r7, sp, #0
 8009950:	60f8      	str	r0, [r7, #12]
 8009952:	60b9      	str	r1, [r7, #8]
 8009954:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 8009956:	68f8      	ldr	r0, [r7, #12]
 8009958:	f000 f849 	bl	80099ee <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>
 800995c:	4602      	mov	r2, r0
 800995e:	68bb      	ldr	r3, [r7, #8]
 8009960:	4293      	cmp	r3, r2
 8009962:	bf8c      	ite	hi
 8009964:	2301      	movhi	r3, #1
 8009966:	2300      	movls	r3, #0
 8009968:	b2db      	uxtb	r3, r3
 800996a:	2b00      	cmp	r3, #0
 800996c:	d001      	beq.n	8009972 <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 800996e:	f00c fc54 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 8009972:	68bb      	ldr	r3, [r7, #8]
 8009974:	011b      	lsls	r3, r3, #4
 8009976:	4618      	mov	r0, r3
 8009978:	f00c fc2b 	bl	80161d2 <_Znwj>
 800997c:	4603      	mov	r3, r0
      }
 800997e:	4618      	mov	r0, r3
 8009980:	3710      	adds	r7, #16
 8009982:	46bd      	mov	sp, r7
 8009984:	bd80      	pop	{r7, pc}

08009986 <_ZSt11__addressofISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEPT_RSD_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 8009986:	b480      	push	{r7}
 8009988:	b083      	sub	sp, #12
 800998a:	af00      	add	r7, sp, #0
 800998c:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 800998e:	687b      	ldr	r3, [r7, #4]
 8009990:	4618      	mov	r0, r3
 8009992:	370c      	adds	r7, #12
 8009994:	46bd      	mov	sp, r7
 8009996:	f85d 7b04 	ldr.w	r7, [sp], #4
 800999a:	4770      	bx	lr

0800999c <_ZN9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE10deallocateEPSB_j>:
      deallocate(_Tp* __p, size_type __t)
 800999c:	b580      	push	{r7, lr}
 800999e:	b084      	sub	sp, #16
 80099a0:	af00      	add	r7, sp, #0
 80099a2:	60f8      	str	r0, [r7, #12]
 80099a4:	60b9      	str	r1, [r7, #8]
 80099a6:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 80099a8:	687b      	ldr	r3, [r7, #4]
 80099aa:	011b      	lsls	r3, r3, #4
 80099ac:	4619      	mov	r1, r3
 80099ae:	68b8      	ldr	r0, [r7, #8]
 80099b0:	f00c fbfc 	bl	80161ac <_ZdlPvj>
      }
 80099b4:	bf00      	nop
 80099b6:	3710      	adds	r7, #16
 80099b8:	46bd      	mov	sp, r7
 80099ba:	bd80      	pop	{r7, pc}

080099bc <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_Lb1EEC1EOS6_>:
 80099bc:	b580      	push	{r7, lr}
 80099be:	b082      	sub	sp, #8
 80099c0:	af00      	add	r7, sp, #0
 80099c2:	6078      	str	r0, [r7, #4]
 80099c4:	6039      	str	r1, [r7, #0]
 80099c6:	6838      	ldr	r0, [r7, #0]
 80099c8:	f7ff fcb2 	bl	8009330 <_ZSt4moveIRZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_EONSt16remove_referenceIT_E4typeEOS9_>
 80099cc:	687b      	ldr	r3, [r7, #4]
 80099ce:	4618      	mov	r0, r3
 80099d0:	3708      	adds	r7, #8
 80099d2:	46bd      	mov	sp, r7
 80099d4:	bd80      	pop	{r7, pc}

080099d6 <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES2_jEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 80099d6:	b480      	push	{r7}
 80099d8:	b083      	sub	sp, #12
 80099da:	af00      	add	r7, sp, #0
 80099dc:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 80099de:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
      }
 80099e2:	4618      	mov	r0, r3
 80099e4:	370c      	adds	r7, #12
 80099e6:	46bd      	mov	sp, r7
 80099e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099ec:	4770      	bx	lr

080099ee <_ZNK9__gnu_cxx13new_allocatorISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS2_E_SaIvELNS_12_Lock_policyE0EEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 80099ee:	b480      	push	{r7}
 80099f0:	b083      	sub	sp, #12
 80099f2:	af00      	add	r7, sp, #0
 80099f4:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 80099f6:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
      }
 80099fa:	4618      	mov	r0, r3
 80099fc:	370c      	adds	r7, #12
 80099fe:	46bd      	mov	sp, r7
 8009a00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a04:	4770      	bx	lr
	...

08009a08 <_Z41__static_initialization_and_destruction_0ii>:
 8009a08:	b580      	push	{r7, lr}
 8009a0a:	b088      	sub	sp, #32
 8009a0c:	af00      	add	r7, sp, #0
 8009a0e:	6078      	str	r0, [r7, #4]
 8009a10:	6039      	str	r1, [r7, #0]
 8009a12:	687b      	ldr	r3, [r7, #4]
 8009a14:	2b01      	cmp	r3, #1
 8009a16:	d122      	bne.n	8009a5e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8009a18:	683b      	ldr	r3, [r7, #0]
 8009a1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009a1e:	4293      	cmp	r3, r2
 8009a20:	d11d      	bne.n	8009a5e <_Z41__static_initialization_and_destruction_0ii+0x56>
 8009a22:	4b18      	ldr	r3, [pc, #96]	; (8009a84 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8009a24:	681b      	ldr	r3, [r3, #0]
 8009a26:	613b      	str	r3, [r7, #16]
 8009a28:	f107 0310 	add.w	r3, r7, #16
 8009a2c:	60bb      	str	r3, [r7, #8]
 8009a2e:	2304      	movs	r3, #4
 8009a30:	60fb      	str	r3, [r7, #12]
 8009a32:	f107 0308 	add.w	r3, r7, #8
 8009a36:	e893 0006 	ldmia.w	r3, {r1, r2}
 8009a3a:	4813      	ldr	r0, [pc, #76]	; (8009a88 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8009a3c:	f7fd f97a 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8009a40:	4b12      	ldr	r3, [pc, #72]	; (8009a8c <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8009a42:	681b      	ldr	r3, [r3, #0]
 8009a44:	61fb      	str	r3, [r7, #28]
 8009a46:	f107 031c 	add.w	r3, r7, #28
 8009a4a:	617b      	str	r3, [r7, #20]
 8009a4c:	2304      	movs	r3, #4
 8009a4e:	61bb      	str	r3, [r7, #24]
 8009a50:	f107 0314 	add.w	r3, r7, #20
 8009a54:	e893 0006 	ldmia.w	r3, {r1, r2}
 8009a58:	480d      	ldr	r0, [pc, #52]	; (8009a90 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8009a5a:	f7fd f96b 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8009a5e:	687b      	ldr	r3, [r7, #4]
 8009a60:	2b00      	cmp	r3, #0
 8009a62:	d10a      	bne.n	8009a7a <_Z41__static_initialization_and_destruction_0ii+0x72>
 8009a64:	683b      	ldr	r3, [r7, #0]
 8009a66:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009a6a:	4293      	cmp	r3, r2
 8009a6c:	d105      	bne.n	8009a7a <_Z41__static_initialization_and_destruction_0ii+0x72>
 8009a6e:	4808      	ldr	r0, [pc, #32]	; (8009a90 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8009a70:	f7fd faaa 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8009a74:	4804      	ldr	r0, [pc, #16]	; (8009a88 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8009a76:	f7fd faa7 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8009a7a:	bf00      	nop
 8009a7c:	3720      	adds	r7, #32
 8009a7e:	46bd      	mov	sp, r7
 8009a80:	bd80      	pop	{r7, pc}
 8009a82:	bf00      	nop
 8009a84:	080185e0 	.word	0x080185e0
 8009a88:	20001860 	.word	0x20001860
 8009a8c:	080185e4 	.word	0x080185e4
 8009a90:	20001868 	.word	0x20001868

08009a94 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_deleter() noexcept { }
 8009a94:	b580      	push	{r7, lr}
 8009a96:	b082      	sub	sp, #8
 8009a98:	af00      	add	r7, sp, #0
 8009a9a:	6078      	str	r0, [r7, #4]
 8009a9c:	4a05      	ldr	r2, [pc, #20]	; (8009ab4 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev+0x20>)
 8009a9e:	687b      	ldr	r3, [r7, #4]
 8009aa0:	601a      	str	r2, [r3, #0]
 8009aa2:	687b      	ldr	r3, [r7, #4]
 8009aa4:	4618      	mov	r0, r3
 8009aa6:	f7fd ffa9 	bl	80079fc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	4618      	mov	r0, r3
 8009aae:	3708      	adds	r7, #8
 8009ab0:	46bd      	mov	sp, r7
 8009ab2:	bd80      	pop	{r7, pc}
 8009ab4:	0801b98c 	.word	0x0801b98c

08009ab8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
 8009ab8:	b580      	push	{r7, lr}
 8009aba:	b082      	sub	sp, #8
 8009abc:	af00      	add	r7, sp, #0
 8009abe:	6078      	str	r0, [r7, #4]
 8009ac0:	6878      	ldr	r0, [r7, #4]
 8009ac2:	f7ff ffe7 	bl	8009a94 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
 8009ac6:	2110      	movs	r1, #16
 8009ac8:	6878      	ldr	r0, [r7, #4]
 8009aca:	f00c fb6f 	bl	80161ac <_ZdlPvj>
 8009ace:	687b      	ldr	r3, [r7, #4]
 8009ad0:	4618      	mov	r0, r3
 8009ad2:	3708      	adds	r7, #8
 8009ad4:	46bd      	mov	sp, r7
 8009ad6:	bd80      	pop	{r7, pc}

08009ad8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 8009ad8:	b580      	push	{r7, lr}
 8009ada:	b082      	sub	sp, #8
 8009adc:	af00      	add	r7, sp, #0
 8009ade:	6078      	str	r0, [r7, #4]
      { _M_impl._M_del()(_M_impl._M_ptr); }
 8009ae0:	687b      	ldr	r3, [r7, #4]
 8009ae2:	330c      	adds	r3, #12
 8009ae4:	4618      	mov	r0, r3
 8009ae6:	f000 f8ac 	bl	8009c42 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>
 8009aea:	4602      	mov	r2, r0
 8009aec:	687b      	ldr	r3, [r7, #4]
 8009aee:	68db      	ldr	r3, [r3, #12]
 8009af0:	4619      	mov	r1, r3
 8009af2:	4610      	mov	r0, r2
 8009af4:	f7ff fb21 	bl	800913a <_ZZN3hei12SharedBufferIhE5proxyEPKhjENKUlPhE_clES4_>
 8009af8:	bf00      	nop
 8009afa:	3708      	adds	r7, #8
 8009afc:	46bd      	mov	sp, r7
 8009afe:	bd80      	pop	{r7, pc}

08009b00 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 8009b00:	b580      	push	{r7, lr}
 8009b02:	b086      	sub	sp, #24
 8009b04:	af00      	add	r7, sp, #0
 8009b06:	6078      	str	r0, [r7, #4]
	__allocator_type __a(_M_impl._M_alloc());
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	330c      	adds	r3, #12
 8009b0c:	4618      	mov	r0, r3
 8009b0e:	f000 f8a4 	bl	8009c5a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>
 8009b12:	4602      	mov	r2, r0
 8009b14:	f107 0314 	add.w	r3, r7, #20
 8009b18:	4611      	mov	r1, r2
 8009b1a:	4618      	mov	r0, r3
 8009b1c:	f7ff fd71 	bl	8009602 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8009b20:	f107 0114 	add.w	r1, r7, #20
 8009b24:	f107 030c 	add.w	r3, r7, #12
 8009b28:	687a      	ldr	r2, [r7, #4]
 8009b2a:	4618      	mov	r0, r3
 8009b2c:	f7ff fe7d 	bl	800982a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSC_PSB_>
	this->~_Sp_counted_deleter();
 8009b30:	6878      	ldr	r0, [r7, #4]
 8009b32:	f7ff ffaf 	bl	8009a94 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8009b36:	f107 030c 	add.w	r3, r7, #12
 8009b3a:	4618      	mov	r0, r3
 8009b3c:	f7ff fd8d 	bl	800965a <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	__allocator_type __a(_M_impl._M_alloc());
 8009b40:	f107 0314 	add.w	r3, r7, #20
 8009b44:	4618      	mov	r0, r3
 8009b46:	f7ff fd69 	bl	800961c <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
      }
 8009b4a:	bf00      	nop
 8009b4c:	3718      	adds	r7, #24
 8009b4e:	46bd      	mov	sp, r7
 8009b50:	bd80      	pop	{r7, pc}

08009b52 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_get_deleter(const std::type_info& __ti) noexcept
 8009b52:	b480      	push	{r7}
 8009b54:	b083      	sub	sp, #12
 8009b56:	af00      	add	r7, sp, #0
 8009b58:	6078      	str	r0, [r7, #4]
 8009b5a:	6039      	str	r1, [r7, #0]
        return nullptr;
 8009b5c:	2300      	movs	r3, #0
      }
 8009b5e:	4618      	mov	r0, r3
 8009b60:	370c      	adds	r7, #12
 8009b62:	46bd      	mov	sp, r7
 8009b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b68:	4770      	bx	lr
	...

08009b6c <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_deleter() noexcept { }
 8009b6c:	b580      	push	{r7, lr}
 8009b6e:	b082      	sub	sp, #8
 8009b70:	af00      	add	r7, sp, #0
 8009b72:	6078      	str	r0, [r7, #4]
 8009b74:	4a05      	ldr	r2, [pc, #20]	; (8009b8c <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev+0x20>)
 8009b76:	687b      	ldr	r3, [r7, #4]
 8009b78:	601a      	str	r2, [r3, #0]
 8009b7a:	687b      	ldr	r3, [r7, #4]
 8009b7c:	4618      	mov	r0, r3
 8009b7e:	f7fd ff3d 	bl	80079fc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 8009b82:	687b      	ldr	r3, [r7, #4]
 8009b84:	4618      	mov	r0, r3
 8009b86:	3708      	adds	r7, #8
 8009b88:	46bd      	mov	sp, r7
 8009b8a:	bd80      	pop	{r7, pc}
 8009b8c:	0801b9a8 	.word	0x0801b9a8

08009b90 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
 8009b90:	b580      	push	{r7, lr}
 8009b92:	b082      	sub	sp, #8
 8009b94:	af00      	add	r7, sp, #0
 8009b96:	6078      	str	r0, [r7, #4]
 8009b98:	6878      	ldr	r0, [r7, #4]
 8009b9a:	f7ff ffe7 	bl	8009b6c <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
 8009b9e:	2110      	movs	r1, #16
 8009ba0:	6878      	ldr	r0, [r7, #4]
 8009ba2:	f00c fb03 	bl	80161ac <_ZdlPvj>
 8009ba6:	687b      	ldr	r3, [r7, #4]
 8009ba8:	4618      	mov	r0, r3
 8009baa:	3708      	adds	r7, #8
 8009bac:	46bd      	mov	sp, r7
 8009bae:	bd80      	pop	{r7, pc}

08009bb0 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 8009bb0:	b580      	push	{r7, lr}
 8009bb2:	b082      	sub	sp, #8
 8009bb4:	af00      	add	r7, sp, #0
 8009bb6:	6078      	str	r0, [r7, #4]
      { _M_impl._M_del()(_M_impl._M_ptr); }
 8009bb8:	687b      	ldr	r3, [r7, #4]
 8009bba:	330c      	adds	r3, #12
 8009bbc:	4618      	mov	r0, r3
 8009bbe:	f000 f858 	bl	8009c72 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>
 8009bc2:	4602      	mov	r2, r0
 8009bc4:	687b      	ldr	r3, [r7, #4]
 8009bc6:	68db      	ldr	r3, [r3, #12]
 8009bc8:	4619      	mov	r1, r3
 8009bca:	4610      	mov	r0, r2
 8009bcc:	f7ff fa86 	bl	80090dc <_ZZN3hei12SharedBufferIhE5proxyEPhjENKUlS2_E_clES2_>
 8009bd0:	bf00      	nop
 8009bd2:	3708      	adds	r7, #8
 8009bd4:	46bd      	mov	sp, r7
 8009bd6:	bd80      	pop	{r7, pc}

08009bd8 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 8009bd8:	b580      	push	{r7, lr}
 8009bda:	b086      	sub	sp, #24
 8009bdc:	af00      	add	r7, sp, #0
 8009bde:	6078      	str	r0, [r7, #4]
	__allocator_type __a(_M_impl._M_alloc());
 8009be0:	687b      	ldr	r3, [r7, #4]
 8009be2:	330c      	adds	r3, #12
 8009be4:	4618      	mov	r0, r3
 8009be6:	f000 f850 	bl	8009c8a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>
 8009bea:	4602      	mov	r2, r0
 8009bec:	f107 0314 	add.w	r3, r7, #20
 8009bf0:	4611      	mov	r1, r2
 8009bf2:	4618      	mov	r0, r3
 8009bf4:	f7ff fc84 	bl	8009500 <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEC1IvEERKSaIT_E>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8009bf8:	f107 0114 	add.w	r1, r7, #20
 8009bfc:	f107 030c 	add.w	r3, r7, #12
 8009c00:	687a      	ldr	r2, [r7, #4]
 8009c02:	4618      	mov	r0, r3
 8009c04:	f7ff fda2 	bl	800974c <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEEC1ERSA_PS9_>
	this->~_Sp_counted_deleter();
 8009c08:	6878      	ldr	r0, [r7, #4]
 8009c0a:	f7ff ffaf 	bl	8009b6c <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EED1Ev>
	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 8009c0e:	f107 030c 	add.w	r3, r7, #12
 8009c12:	4618      	mov	r0, r3
 8009c14:	f7ff fca0 	bl	8009558 <_ZNSt15__allocated_ptrISaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES1_jEUlS1_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEEED1Ev>
	__allocator_type __a(_M_impl._M_alloc());
 8009c18:	f107 0314 	add.w	r3, r7, #20
 8009c1c:	4618      	mov	r0, r3
 8009c1e:	f7ff fc7c 	bl	800951a <_ZNSaISt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EEED1Ev>
      }
 8009c22:	bf00      	nop
 8009c24:	3718      	adds	r7, #24
 8009c26:	46bd      	mov	sp, r7
 8009c28:	bd80      	pop	{r7, pc}

08009c2a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_get_deleter(const std::type_info& __ti) noexcept
 8009c2a:	b480      	push	{r7}
 8009c2c:	b083      	sub	sp, #12
 8009c2e:	af00      	add	r7, sp, #0
 8009c30:	6078      	str	r0, [r7, #4]
 8009c32:	6039      	str	r1, [r7, #0]
        return nullptr;
 8009c34:	2300      	movs	r3, #0
      }
 8009c36:	4618      	mov	r0, r3
 8009c38:	370c      	adds	r7, #12
 8009c3a:	46bd      	mov	sp, r7
 8009c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c40:	4770      	bx	lr

08009c42 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>:
	_Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 8009c42:	b580      	push	{r7, lr}
 8009c44:	b082      	sub	sp, #8
 8009c46:	af00      	add	r7, sp, #0
 8009c48:	6078      	str	r0, [r7, #4]
 8009c4a:	6878      	ldr	r0, [r7, #4]
 8009c4c:	f000 f829 	bl	8009ca2 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_Lb1EE6_S_getERS7_>
 8009c50:	4603      	mov	r3, r0
 8009c52:	4618      	mov	r0, r3
 8009c54:	3708      	adds	r7, #8
 8009c56:	46bd      	mov	sp, r7
 8009c58:	bd80      	pop	{r7, pc}

08009c5a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyEPKhjEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>:
	_Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }
 8009c5a:	b580      	push	{r7, lr}
 8009c5c:	b082      	sub	sp, #8
 8009c5e:	af00      	add	r7, sp, #0
 8009c60:	6078      	str	r0, [r7, #4]
 8009c62:	6878      	ldr	r0, [r7, #4]
 8009c64:	f7fe fabc 	bl	80081e0 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EE6_S_getERS1_>
 8009c68:	4603      	mov	r3, r0
 8009c6a:	4618      	mov	r0, r3
 8009c6c:	3708      	adds	r7, #8
 8009c6e:	46bd      	mov	sp, r7
 8009c70:	bd80      	pop	{r7, pc}

08009c72 <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl6_M_delEv>:
	_Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 8009c72:	b580      	push	{r7, lr}
 8009c74:	b082      	sub	sp, #8
 8009c76:	af00      	add	r7, sp, #0
 8009c78:	6078      	str	r0, [r7, #4]
 8009c7a:	6878      	ldr	r0, [r7, #4]
 8009c7c:	f000 f81c 	bl	8009cb8 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_Lb1EE6_S_getERS5_>
 8009c80:	4603      	mov	r3, r0
 8009c82:	4618      	mov	r0, r3
 8009c84:	3708      	adds	r7, #8
 8009c86:	46bd      	mov	sp, r7
 8009c88:	bd80      	pop	{r7, pc}

08009c8a <_ZNSt19_Sp_counted_deleterIPhZN3hei12SharedBufferIhE5proxyES0_jEUlS0_E_SaIvELN9__gnu_cxx12_Lock_policyE0EE5_Impl8_M_allocEv>:
	_Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }
 8009c8a:	b580      	push	{r7, lr}
 8009c8c:	b082      	sub	sp, #8
 8009c8e:	af00      	add	r7, sp, #0
 8009c90:	6078      	str	r0, [r7, #4]
 8009c92:	6878      	ldr	r0, [r7, #4]
 8009c94:	f7fe faa4 	bl	80081e0 <_ZNSt14_Sp_ebo_helperILi1ESaIvELb1EE6_S_getERS1_>
 8009c98:	4603      	mov	r3, r0
 8009c9a:	4618      	mov	r0, r3
 8009c9c:	3708      	adds	r7, #8
 8009c9e:	46bd      	mov	sp, r7
 8009ca0:	bd80      	pop	{r7, pc}

08009ca2 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPKhjEUlPhE_Lb1EE6_S_getERS7_>:
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
 8009ca2:	b480      	push	{r7}
 8009ca4:	b083      	sub	sp, #12
 8009ca6:	af00      	add	r7, sp, #0
 8009ca8:	6078      	str	r0, [r7, #4]
 8009caa:	687b      	ldr	r3, [r7, #4]
 8009cac:	4618      	mov	r0, r3
 8009cae:	370c      	adds	r7, #12
 8009cb0:	46bd      	mov	sp, r7
 8009cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cb6:	4770      	bx	lr

08009cb8 <_ZNSt14_Sp_ebo_helperILi0EZN3hei12SharedBufferIhE5proxyEPhjEUlS3_E_Lb1EE6_S_getERS5_>:
 8009cb8:	b480      	push	{r7}
 8009cba:	b083      	sub	sp, #12
 8009cbc:	af00      	add	r7, sp, #0
 8009cbe:	6078      	str	r0, [r7, #4]
 8009cc0:	687b      	ldr	r3, [r7, #4]
 8009cc2:	4618      	mov	r0, r3
 8009cc4:	370c      	adds	r7, #12
 8009cc6:	46bd      	mov	sp, r7
 8009cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ccc:	4770      	bx	lr

08009cce <_GLOBAL__sub_I__ZN7desenet5FrameC2Ej>:
 8009cce:	b580      	push	{r7, lr}
 8009cd0:	af00      	add	r7, sp, #0
 8009cd2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009cd6:	2001      	movs	r0, #1
 8009cd8:	f7ff fe96 	bl	8009a08 <_Z41__static_initialization_and_destruction_0ii>
 8009cdc:	bd80      	pop	{r7, pc}

08009cde <_GLOBAL__sub_D__ZN7desenet5FrameC2Ej>:
 8009cde:	b580      	push	{r7, lr}
 8009ce0:	af00      	add	r7, sp, #0
 8009ce2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009ce6:	2000      	movs	r0, #0
 8009ce8:	f7ff fe8e 	bl	8009a08 <_Z41__static_initialization_and_destruction_0ii>
 8009cec:	bd80      	pop	{r7, pc}

08009cee <_ZN7desenet5FrameD1Ev>:
    class Frame
 8009cee:	b580      	push	{r7, lr}
 8009cf0:	b082      	sub	sp, #8
 8009cf2:	af00      	add	r7, sp, #0
 8009cf4:	6078      	str	r0, [r7, #4]
 8009cf6:	687b      	ldr	r3, [r7, #4]
 8009cf8:	4618      	mov	r0, r3
 8009cfa:	f7fd fd8c 	bl	8007816 <_ZN3hei12SharedBufferIhED1Ev>
 8009cfe:	687b      	ldr	r3, [r7, #4]
 8009d00:	4618      	mov	r0, r3
 8009d02:	3708      	adds	r7, #8
 8009d04:	46bd      	mov	sp, r7
 8009d06:	bd80      	pop	{r7, pc}

08009d08 <_ZN7desenet8MultiPDUC1Ev>:

/**
 * @brief constructor of MultiPDU class, which is a Frame
 *        => create Frame with maximum transfer unit (MTU)
 */
MultiPDU::MultiPDU() : Frame(Frame::Mtu)
 8009d08:	b580      	push	{r7, lr}
 8009d0a:	b082      	sub	sp, #8
 8009d0c:	af00      	add	r7, sp, #0
 8009d0e:	6078      	str	r0, [r7, #4]
                     , EMPTY_DATA_LENGTH(2)
                     , MAX_DATA_LENGTH(Frame::Mtu - Frame::HEADER_SIZE - Frame::FOOTER_SIZE - EMPTY_DATA_LENGTH)
                     , ePDUcnt(0)
 8009d10:	687b      	ldr	r3, [r7, #4]
 8009d12:	2125      	movs	r1, #37	; 0x25
 8009d14:	4618      	mov	r0, r3
 8009d16:	f7fe fff9 	bl	8008d0c <_ZN7desenet5FrameC1Ej>
 8009d1a:	687b      	ldr	r3, [r7, #4]
 8009d1c:	2202      	movs	r2, #2
 8009d1e:	615a      	str	r2, [r3, #20]
                     , MAX_DATA_LENGTH(Frame::Mtu - Frame::HEADER_SIZE - Frame::FOOTER_SIZE - EMPTY_DATA_LENGTH)
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	695b      	ldr	r3, [r3, #20]
 8009d24:	f1c3 0220 	rsb	r2, r3, #32
                     , ePDUcnt(0)
 8009d28:	687b      	ldr	r3, [r7, #4]
 8009d2a:	619a      	str	r2, [r3, #24]
 8009d2c:	687b      	ldr	r3, [r7, #4]
 8009d2e:	2200      	movs	r2, #0
 8009d30:	771a      	strb	r2, [r3, #28]
{
    // set up index variable and pointer to buffer
    currentDataByteIdx = EMPTY_DATA_LENGTH;
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	695b      	ldr	r3, [r3, #20]
 8009d36:	b2da      	uxtb	r2, r3
 8009d38:	687b      	ldr	r3, [r7, #4]
 8009d3a:	775a      	strb	r2, [r3, #29]
    bufferStartAddr = buffer();
 8009d3c:	687b      	ldr	r3, [r7, #4]
 8009d3e:	4618      	mov	r0, r3
 8009d40:	f7fe fe87 	bl	8008a52 <_ZN7desenet5Frame6bufferEv>
 8009d44:	4602      	mov	r2, r0
 8009d46:	687b      	ldr	r3, [r7, #4]
 8009d48:	611a      	str	r2, [r3, #16]

    // set up an empty default frame
    setDestination(GATEWAY_ADDRESS);                // destination is fixed to  GATEWAY_ADDRESS (constant)
 8009d4a:	687b      	ldr	r3, [r7, #4]
 8009d4c:	490e      	ldr	r1, [pc, #56]	; (8009d88 <_ZN7desenet8MultiPDUC1Ev+0x80>)
 8009d4e:	4618      	mov	r0, r3
 8009d50:	f7ff f8b2 	bl	8008eb8 <_ZN7desenet5Frame14setDestinationERKN3phy7AddressILj4EEE>
    setLength(Frame::HEADER_SIZE +
 8009d54:	687a      	ldr	r2, [r7, #4]
              currentDataByteIdx +                  // length of data is 2 because 1st byte contains frame type and sensor ID, 2nd byte contains ePDU length = 0
 8009d56:	687b      	ldr	r3, [r7, #4]
 8009d58:	7f5b      	ldrb	r3, [r3, #29]
    setLength(Frame::HEADER_SIZE +
 8009d5a:	3305      	adds	r3, #5
 8009d5c:	4619      	mov	r1, r3
 8009d5e:	4610      	mov	r0, r2
 8009d60:	f7ff f862 	bl	8008e28 <_ZN7desenet5Frame9setLengthEj>
              Frame::FOOTER_SIZE);
    memcpy(bufferStartAddr + Frame::HEADER_SIZE,    // Copy default sensor slot number (<=> default sensor ID) into first data byte of buffer
 8009d64:	687b      	ldr	r3, [r7, #4]
 8009d66:	691b      	ldr	r3, [r3, #16]
 8009d68:	3305      	adds	r3, #5
 8009d6a:	2201      	movs	r2, #1
 8009d6c:	701a      	strb	r2, [r3, #0]
           &DEFAULT_DESENET_SLOT_NUMBER,
           sizeof(DEFAULT_DESENET_SLOT_NUMBER));
    setType(FrameType::MPDU);                       // AFTER having set slot number => set type to MPDU (constantly)
 8009d6e:	687b      	ldr	r3, [r7, #4]
 8009d70:	2102      	movs	r1, #2
 8009d72:	4618      	mov	r0, r3
 8009d74:	f7ff f903 	bl	8008f7e <_ZN7desenet5Frame7setTypeENS_9FrameTypeE>
    updateEPDUcnt();                                // Set the ePDU counter to 0 (2nd data byte)
 8009d78:	6878      	ldr	r0, [r7, #4]
 8009d7a:	f000 f89c 	bl	8009eb6 <_ZN7desenet8MultiPDU13updateEPDUcntEv>
}
 8009d7e:	687b      	ldr	r3, [r7, #4]
 8009d80:	4618      	mov	r0, r3
 8009d82:	3708      	adds	r7, #8
 8009d84:	46bd      	mov	sp, r7
 8009d86:	bd80      	pop	{r7, pc}
 8009d88:	200018e0 	.word	0x200018e0

08009d8c <_ZN7desenet8MultiPDUD1Ev>:

/**
 * @brief destructor (unused)
 */
MultiPDU::~MultiPDU() {}
 8009d8c:	b580      	push	{r7, lr}
 8009d8e:	b082      	sub	sp, #8
 8009d90:	af00      	add	r7, sp, #0
 8009d92:	6078      	str	r0, [r7, #4]
 8009d94:	687b      	ldr	r3, [r7, #4]
 8009d96:	4618      	mov	r0, r3
 8009d98:	f7ff ffa9 	bl	8009cee <_ZN7desenet5FrameD1Ev>
 8009d9c:	687b      	ldr	r3, [r7, #4]
 8009d9e:	4618      	mov	r0, r3
 8009da0:	3708      	adds	r7, #8
 8009da2:	46bd      	mov	sp, r7
 8009da4:	bd80      	pop	{r7, pc}

08009da6 <_ZN7desenet8MultiPDU13addEPDUheaderEhhh>:
 * @param   length      the number of bytes of the ePDU frame
 *
 * @return  void
 */
void MultiPDU::addEPDUheader(uint8_t type, SvGroup group, uint8_t length)
{
 8009da6:	b480      	push	{r7}
 8009da8:	b085      	sub	sp, #20
 8009daa:	af00      	add	r7, sp, #0
 8009dac:	6078      	str	r0, [r7, #4]
 8009dae:	4608      	mov	r0, r1
 8009db0:	4611      	mov	r1, r2
 8009db2:	461a      	mov	r2, r3
 8009db4:	4603      	mov	r3, r0
 8009db6:	70fb      	strb	r3, [r7, #3]
 8009db8:	460b      	mov	r3, r1
 8009dba:	70bb      	strb	r3, [r7, #2]
 8009dbc:	4613      	mov	r3, r2
 8009dbe:	707b      	strb	r3, [r7, #1]
    // create ePDU header
    EPDUH2Byte e2b;
    e2b.header.size = length;                                  // length of ePDU payload
 8009dc0:	787b      	ldrb	r3, [r7, #1]
 8009dc2:	f003 0307 	and.w	r3, r3, #7
 8009dc6:	b2da      	uxtb	r2, r3
 8009dc8:	7b3b      	ldrb	r3, [r7, #12]
 8009dca:	f362 0302 	bfi	r3, r2, #0, #3
 8009dce:	733b      	strb	r3, [r7, #12]
    e2b.header.group = group;                                  // group nbr of SV
 8009dd0:	78bb      	ldrb	r3, [r7, #2]
 8009dd2:	f003 030f 	and.w	r3, r3, #15
 8009dd6:	b2da      	uxtb	r2, r3
 8009dd8:	7b3b      	ldrb	r3, [r7, #12]
 8009dda:	f362 03c6 	bfi	r3, r2, #3, #4
 8009dde:	733b      	strb	r3, [r7, #12]
    e2b.header.type = type;                                    // always zero for SV ePDU
 8009de0:	78fb      	ldrb	r3, [r7, #3]
 8009de2:	f003 0301 	and.w	r3, r3, #1
 8009de6:	b2da      	uxtb	r2, r3
 8009de8:	7b3b      	ldrb	r3, [r7, #12]
 8009dea:	f362 13c7 	bfi	r3, r2, #7, #1
 8009dee:	733b      	strb	r3, [r7, #12]

    // copy first byte (<=> e2b.byte) into MPDU
    memcpy(bufferStartAddr + Frame::HEADER_SIZE + currentDataByteIdx + Frame::FOOTER_SIZE,
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	691a      	ldr	r2, [r3, #16]
 8009df4:	687b      	ldr	r3, [r7, #4]
 8009df6:	7f5b      	ldrb	r3, [r3, #29]
 8009df8:	3305      	adds	r3, #5
 8009dfa:	4413      	add	r3, r2
 8009dfc:	7b3a      	ldrb	r2, [r7, #12]
 8009dfe:	701a      	strb	r2, [r3, #0]
           &e2b.byte,
           sizeof(e2b.byte));

    // increase current data byte index to write the data after header
    currentDataByteIdx++;
 8009e00:	687b      	ldr	r3, [r7, #4]
 8009e02:	7f5b      	ldrb	r3, [r3, #29]
 8009e04:	3301      	adds	r3, #1
 8009e06:	b2da      	uxtb	r2, r3
 8009e08:	687b      	ldr	r3, [r7, #4]
 8009e0a:	775a      	strb	r2, [r3, #29]
}
 8009e0c:	bf00      	nop
 8009e0e:	3714      	adds	r7, #20
 8009e10:	46bd      	mov	sp, r7
 8009e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e16:	4770      	bx	lr

08009e18 <_ZN7desenet8MultiPDU13addEPDUheaderEhth>:
 * @param   length      the number of bytes of the ePDU frame
 *
 * @return  void
 */
void MultiPDU::addEPDUheader(uint8_t type, EvId evID, uint8_t length)
{
 8009e18:	b480      	push	{r7}
 8009e1a:	b085      	sub	sp, #20
 8009e1c:	af00      	add	r7, sp, #0
 8009e1e:	6078      	str	r0, [r7, #4]
 8009e20:	4608      	mov	r0, r1
 8009e22:	4611      	mov	r1, r2
 8009e24:	461a      	mov	r2, r3
 8009e26:	4603      	mov	r3, r0
 8009e28:	70fb      	strb	r3, [r7, #3]
 8009e2a:	460b      	mov	r3, r1
 8009e2c:	803b      	strh	r3, [r7, #0]
 8009e2e:	4613      	mov	r3, r2
 8009e30:	70bb      	strb	r3, [r7, #2]
    // create ePDU header
    EPDUH2Byte e2b;
    e2b.header.size = length;                                  // length of ePDU payload
 8009e32:	78bb      	ldrb	r3, [r7, #2]
 8009e34:	f003 0307 	and.w	r3, r3, #7
 8009e38:	b2da      	uxtb	r2, r3
 8009e3a:	7b3b      	ldrb	r3, [r7, #12]
 8009e3c:	f362 0302 	bfi	r3, r2, #0, #3
 8009e40:	733b      	strb	r3, [r7, #12]
    e2b.header.group = evID;                                   // Event ID
 8009e42:	883b      	ldrh	r3, [r7, #0]
 8009e44:	f003 030f 	and.w	r3, r3, #15
 8009e48:	b2da      	uxtb	r2, r3
 8009e4a:	7b3b      	ldrb	r3, [r7, #12]
 8009e4c:	f362 03c6 	bfi	r3, r2, #3, #4
 8009e50:	733b      	strb	r3, [r7, #12]
    e2b.header.type = type;                                    // always one for EV ePDU
 8009e52:	78fb      	ldrb	r3, [r7, #3]
 8009e54:	f003 0301 	and.w	r3, r3, #1
 8009e58:	b2da      	uxtb	r2, r3
 8009e5a:	7b3b      	ldrb	r3, [r7, #12]
 8009e5c:	f362 13c7 	bfi	r3, r2, #7, #1
 8009e60:	733b      	strb	r3, [r7, #12]

    // copy first byte (<=> e2b.byte) into MPDU
    memcpy(bufferStartAddr + Frame::HEADER_SIZE + currentDataByteIdx + Frame::FOOTER_SIZE,
 8009e62:	687b      	ldr	r3, [r7, #4]
 8009e64:	691a      	ldr	r2, [r3, #16]
 8009e66:	687b      	ldr	r3, [r7, #4]
 8009e68:	7f5b      	ldrb	r3, [r3, #29]
 8009e6a:	3305      	adds	r3, #5
 8009e6c:	4413      	add	r3, r2
 8009e6e:	7b3a      	ldrb	r2, [r7, #12]
 8009e70:	701a      	strb	r2, [r3, #0]
           &e2b.byte,
           sizeof(e2b.byte));

    // increase current data byte index to write the data after header
    currentDataByteIdx++;
 8009e72:	687b      	ldr	r3, [r7, #4]
 8009e74:	7f5b      	ldrb	r3, [r3, #29]
 8009e76:	3301      	adds	r3, #1
 8009e78:	b2da      	uxtb	r2, r3
 8009e7a:	687b      	ldr	r3, [r7, #4]
 8009e7c:	775a      	strb	r2, [r3, #29]
}
 8009e7e:	bf00      	nop
 8009e80:	3714      	adds	r7, #20
 8009e82:	46bd      	mov	sp, r7
 8009e84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e88:	4770      	bx	lr

08009e8a <_ZN7desenet8MultiPDU15insertEventEPDUERKN3hei12SharedBufferIhEEh>:
 * @param   length      the number of bytes to write
 *
 * @return  void
*/
void MultiPDU::insertEventEPDU(const SharedByteBuffer& data, uint8_t length)
{
 8009e8a:	b580      	push	{r7, lr}
 8009e8c:	b084      	sub	sp, #16
 8009e8e:	af00      	add	r7, sp, #0
 8009e90:	60f8      	str	r0, [r7, #12]
 8009e92:	60b9      	str	r1, [r7, #8]
 8009e94:	4613      	mov	r3, r2
 8009e96:	71fb      	strb	r3, [r7, #7]
    memcpy(bufferStartAddr + Frame::HEADER_SIZE + currentDataByteIdx + Frame::FOOTER_SIZE,
 8009e98:	68fb      	ldr	r3, [r7, #12]
 8009e9a:	691a      	ldr	r2, [r3, #16]
 8009e9c:	68fb      	ldr	r3, [r7, #12]
 8009e9e:	7f5b      	ldrb	r3, [r3, #29]
 8009ea0:	3305      	adds	r3, #5
 8009ea2:	4413      	add	r3, r2
 8009ea4:	79fa      	ldrb	r2, [r7, #7]
 8009ea6:	68b9      	ldr	r1, [r7, #8]
 8009ea8:	4618      	mov	r0, r3
 8009eaa:	f00c fae3 	bl	8016474 <memcpy>
           &data,
           length);
}
 8009eae:	bf00      	nop
 8009eb0:	3710      	adds	r7, #16
 8009eb2:	46bd      	mov	sp, r7
 8009eb4:	bd80      	pop	{r7, pc}

08009eb6 <_ZN7desenet8MultiPDU13updateEPDUcntEv>:
 * @param   none
 *
 * @return  void
*/
void MultiPDU::updateEPDUcnt()
{
 8009eb6:	b480      	push	{r7}
 8009eb8:	b083      	sub	sp, #12
 8009eba:	af00      	add	r7, sp, #0
 8009ebc:	6078      	str	r0, [r7, #4]
    memcpy(bufferStartAddr + Frame::HEADER_SIZE + 1, &ePDUcnt, sizeof(ePDUcnt));
 8009ebe:	687b      	ldr	r3, [r7, #4]
 8009ec0:	691b      	ldr	r3, [r3, #16]
 8009ec2:	3306      	adds	r3, #6
 8009ec4:	687a      	ldr	r2, [r7, #4]
 8009ec6:	321c      	adds	r2, #28
 8009ec8:	7812      	ldrb	r2, [r2, #0]
 8009eca:	701a      	strb	r2, [r3, #0]
}
 8009ecc:	bf00      	nop
 8009ece:	370c      	adds	r7, #12
 8009ed0:	46bd      	mov	sp, r7
 8009ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ed6:	4770      	bx	lr

08009ed8 <_ZN7desenet8MultiPDU18updateHeaderLengthEv>:
 * @param   none
 *
 * @return  void
*/
void MultiPDU::updateHeaderLength()
{
 8009ed8:	b580      	push	{r7, lr}
 8009eda:	b082      	sub	sp, #8
 8009edc:	af00      	add	r7, sp, #0
 8009ede:	6078      	str	r0, [r7, #4]
    setLength(Frame::HEADER_SIZE + currentDataByteIdx + Frame::FOOTER_SIZE);
 8009ee0:	687a      	ldr	r2, [r7, #4]
 8009ee2:	687b      	ldr	r3, [r7, #4]
 8009ee4:	7f5b      	ldrb	r3, [r3, #29]
 8009ee6:	3305      	adds	r3, #5
 8009ee8:	4619      	mov	r1, r3
 8009eea:	4610      	mov	r0, r2
 8009eec:	f7fe ff9c 	bl	8008e28 <_ZN7desenet5Frame9setLengthEj>
}
 8009ef0:	bf00      	nop
 8009ef2:	3708      	adds	r7, #8
 8009ef4:	46bd      	mov	sp, r7
 8009ef6:	bd80      	pop	{r7, pc}

08009ef8 <_ZN7desenet8MultiPDU26postProcessingAdditionEPDUEh>:
 * @param   length      the number of bytes written to the MPDU frame
 *
 * @return  void
*/
void MultiPDU::postProcessingAdditionEPDU(uint8_t length)
{
 8009ef8:	b580      	push	{r7, lr}
 8009efa:	b082      	sub	sp, #8
 8009efc:	af00      	add	r7, sp, #0
 8009efe:	6078      	str	r0, [r7, #4]
 8009f00:	460b      	mov	r3, r1
 8009f02:	70fb      	strb	r3, [r7, #3]
    ePDUcnt++;
 8009f04:	687b      	ldr	r3, [r7, #4]
 8009f06:	7f1b      	ldrb	r3, [r3, #28]
 8009f08:	3301      	adds	r3, #1
 8009f0a:	b2da      	uxtb	r2, r3
 8009f0c:	687b      	ldr	r3, [r7, #4]
 8009f0e:	771a      	strb	r2, [r3, #28]
    currentDataByteIdx += length;       // update byte index with written byte length BEFORE calling updateHeaderLength()
 8009f10:	687b      	ldr	r3, [r7, #4]
 8009f12:	7f5a      	ldrb	r2, [r3, #29]
 8009f14:	78fb      	ldrb	r3, [r7, #3]
 8009f16:	4413      	add	r3, r2
 8009f18:	b2da      	uxtb	r2, r3
 8009f1a:	687b      	ldr	r3, [r7, #4]
 8009f1c:	775a      	strb	r2, [r3, #29]
    updateEPDUcnt();
 8009f1e:	6878      	ldr	r0, [r7, #4]
 8009f20:	f7ff ffc9 	bl	8009eb6 <_ZN7desenet8MultiPDU13updateEPDUcntEv>
    updateHeaderLength();
 8009f24:	6878      	ldr	r0, [r7, #4]
 8009f26:	f7ff ffd7 	bl	8009ed8 <_ZN7desenet8MultiPDU18updateHeaderLengthEv>
}
 8009f2a:	bf00      	nop
 8009f2c:	3708      	adds	r7, #8
 8009f2e:	46bd      	mov	sp, r7
 8009f30:	bd80      	pop	{r7, pc}

08009f32 <_ZN7desenet8MultiPDU5clearEv>:
 * @param   none
 *
 * @return  void
*/
void MultiPDU::clear()
{
 8009f32:	b580      	push	{r7, lr}
 8009f34:	b082      	sub	sp, #8
 8009f36:	af00      	add	r7, sp, #0
 8009f38:	6078      	str	r0, [r7, #4]
    // reset count and length variables
    ePDUcnt = 0;
 8009f3a:	687b      	ldr	r3, [r7, #4]
 8009f3c:	2200      	movs	r2, #0
 8009f3e:	771a      	strb	r2, [r3, #28]
    currentDataByteIdx = EMPTY_DATA_LENGTH;     // +1 because we want to start just after the empty length
 8009f40:	687b      	ldr	r3, [r7, #4]
 8009f42:	695b      	ldr	r3, [r3, #20]
 8009f44:	b2da      	uxtb	r2, r3
 8009f46:	687b      	ldr	r3, [r7, #4]
 8009f48:	775a      	strb	r2, [r3, #29]

    // reset the buffer
    updateHeaderLength();
 8009f4a:	6878      	ldr	r0, [r7, #4]
 8009f4c:	f7ff ffc4 	bl	8009ed8 <_ZN7desenet8MultiPDU18updateHeaderLengthEv>
    updateEPDUcnt();
 8009f50:	6878      	ldr	r0, [r7, #4]
 8009f52:	f7ff ffb0 	bl	8009eb6 <_ZN7desenet8MultiPDU13updateEPDUcntEv>

    // clear all data to zero (NOT FORCINGLY NECESSARY!)
    memset(bufferStartAddr + Frame::HEADER_SIZE + EMPTY_DATA_LENGTH + Frame::FOOTER_SIZE, 0, MAX_DATA_LENGTH);
 8009f56:	687b      	ldr	r3, [r7, #4]
 8009f58:	691a      	ldr	r2, [r3, #16]
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	695b      	ldr	r3, [r3, #20]
 8009f5e:	3305      	adds	r3, #5
 8009f60:	18d0      	adds	r0, r2, r3
 8009f62:	687b      	ldr	r3, [r7, #4]
 8009f64:	699b      	ldr	r3, [r3, #24]
 8009f66:	461a      	mov	r2, r3
 8009f68:	2100      	movs	r1, #0
 8009f6a:	f00c faab 	bl	80164c4 <memset>
}
 8009f6e:	bf00      	nop
 8009f70:	3708      	adds	r7, #8
 8009f72:	46bd      	mov	sp, r7
 8009f74:	bd80      	pop	{r7, pc}

08009f76 <_ZN7desenet8MultiPDU18getRemainingLengthEv>:
 * @param   none
 *
 * @return  the remaining length
*/
uint8_t MultiPDU::getRemainingLength()
{
 8009f76:	b480      	push	{r7}
 8009f78:	b083      	sub	sp, #12
 8009f7a:	af00      	add	r7, sp, #0
 8009f7c:	6078      	str	r0, [r7, #4]
    return Frame::Mtu - Frame::HEADER_SIZE - Frame::FOOTER_SIZE - currentDataByteIdx;
 8009f7e:	687b      	ldr	r3, [r7, #4]
 8009f80:	7f5b      	ldrb	r3, [r3, #29]
 8009f82:	f1c3 0320 	rsb	r3, r3, #32
 8009f86:	b2db      	uxtb	r3, r3
}
 8009f88:	4618      	mov	r0, r3
 8009f8a:	370c      	adds	r7, #12
 8009f8c:	46bd      	mov	sp, r7
 8009f8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f92:	4770      	bx	lr

08009f94 <_ZN7desenet8MultiPDU13getValidStartEv>:
 * @param   none
 *
 * @return  the pointer to the start index
*/
uint8_t* MultiPDU::getValidStart()
{
 8009f94:	b480      	push	{r7}
 8009f96:	b083      	sub	sp, #12
 8009f98:	af00      	add	r7, sp, #0
 8009f9a:	6078      	str	r0, [r7, #4]
    return bufferStartAddr + Frame::HEADER_SIZE + currentDataByteIdx + 1 + Frame::FOOTER_SIZE;  // + 1 due to definition of position (effective start of write operation)
 8009f9c:	687b      	ldr	r3, [r7, #4]
 8009f9e:	691a      	ldr	r2, [r3, #16]
 8009fa0:	687b      	ldr	r3, [r7, #4]
 8009fa2:	7f5b      	ldrb	r3, [r3, #29]
 8009fa4:	3306      	adds	r3, #6
 8009fa6:	4413      	add	r3, r2
}
 8009fa8:	4618      	mov	r0, r3
 8009faa:	370c      	adds	r7, #12
 8009fac:	46bd      	mov	sp, r7
 8009fae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009fb2:	4770      	bx	lr

08009fb4 <_Z41__static_initialization_and_destruction_0ii>:
 8009fb4:	b580      	push	{r7, lr}
 8009fb6:	b088      	sub	sp, #32
 8009fb8:	af00      	add	r7, sp, #0
 8009fba:	6078      	str	r0, [r7, #4]
 8009fbc:	6039      	str	r1, [r7, #0]
 8009fbe:	687b      	ldr	r3, [r7, #4]
 8009fc0:	2b01      	cmp	r3, #1
 8009fc2:	d122      	bne.n	800a00a <_Z41__static_initialization_and_destruction_0ii+0x56>
 8009fc4:	683b      	ldr	r3, [r7, #0]
 8009fc6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009fca:	4293      	cmp	r3, r2
 8009fcc:	d11d      	bne.n	800a00a <_Z41__static_initialization_and_destruction_0ii+0x56>
 8009fce:	4b18      	ldr	r3, [pc, #96]	; (800a030 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8009fd0:	681b      	ldr	r3, [r3, #0]
 8009fd2:	613b      	str	r3, [r7, #16]
 8009fd4:	f107 0310 	add.w	r3, r7, #16
 8009fd8:	60bb      	str	r3, [r7, #8]
 8009fda:	2304      	movs	r3, #4
 8009fdc:	60fb      	str	r3, [r7, #12]
 8009fde:	f107 0308 	add.w	r3, r7, #8
 8009fe2:	e893 0006 	ldmia.w	r3, {r1, r2}
 8009fe6:	4813      	ldr	r0, [pc, #76]	; (800a034 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8009fe8:	f7fc fea4 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8009fec:	4b12      	ldr	r3, [pc, #72]	; (800a038 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8009fee:	681b      	ldr	r3, [r3, #0]
 8009ff0:	61fb      	str	r3, [r7, #28]
 8009ff2:	f107 031c 	add.w	r3, r7, #28
 8009ff6:	617b      	str	r3, [r7, #20]
 8009ff8:	2304      	movs	r3, #4
 8009ffa:	61bb      	str	r3, [r7, #24]
 8009ffc:	f107 0314 	add.w	r3, r7, #20
 800a000:	e893 0006 	ldmia.w	r3, {r1, r2}
 800a004:	480d      	ldr	r0, [pc, #52]	; (800a03c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800a006:	f7fc fe95 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800a00a:	687b      	ldr	r3, [r7, #4]
 800a00c:	2b00      	cmp	r3, #0
 800a00e:	d10a      	bne.n	800a026 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800a010:	683b      	ldr	r3, [r7, #0]
 800a012:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a016:	4293      	cmp	r3, r2
 800a018:	d105      	bne.n	800a026 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800a01a:	4808      	ldr	r0, [pc, #32]	; (800a03c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800a01c:	f7fc ffd4 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800a020:	4804      	ldr	r0, [pc, #16]	; (800a034 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800a022:	f7fc ffd1 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800a026:	bf00      	nop
 800a028:	3720      	adds	r7, #32
 800a02a:	46bd      	mov	sp, r7
 800a02c:	bd80      	pop	{r7, pc}
 800a02e:	bf00      	nop
 800a030:	080186d0 	.word	0x080186d0
 800a034:	200018e0 	.word	0x200018e0
 800a038:	080186d4 	.word	0x080186d4
 800a03c:	200018e8 	.word	0x200018e8

0800a040 <_GLOBAL__sub_I__ZN7desenet8MultiPDUC2Ev>:
 800a040:	b580      	push	{r7, lr}
 800a042:	af00      	add	r7, sp, #0
 800a044:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800a048:	2001      	movs	r0, #1
 800a04a:	f7ff ffb3 	bl	8009fb4 <_Z41__static_initialization_and_destruction_0ii>
 800a04e:	bd80      	pop	{r7, pc}

0800a050 <_GLOBAL__sub_D__ZN7desenet8MultiPDUC2Ev>:
 800a050:	b580      	push	{r7, lr}
 800a052:	af00      	add	r7, sp, #0
 800a054:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800a058:	2000      	movs	r0, #0
 800a05a:	f7ff ffab 	bl	8009fb4 <_Z41__static_initialization_and_destruction_0ii>
 800a05e:	bd80      	pop	{r7, pc}

0800a060 <_ZN7desenet22NetworkInterfaceDriver10DescriptorC1Ev>:
#include "networkinterfacedriver.h"

using std::vector;
using std::string;

desenet::NetworkInterfaceDriver::Descriptor::Descriptor()
 800a060:	b580      	push	{r7, lr}
 800a062:	b084      	sub	sp, #16
 800a064:	af00      	add	r7, sp, #0
 800a066:	6078      	str	r0, [r7, #4]
 800a068:	4a09      	ldr	r2, [pc, #36]	; (800a090 <_ZN7desenet22NetworkInterfaceDriver10DescriptorC1Ev+0x30>)
 800a06a:	687b      	ldr	r3, [r7, #4]
 800a06c:	601a      	str	r2, [r3, #0]
{
    _descriptors().push_back(this);
 800a06e:	f000 f83f 	bl	800a0f0 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv>
 800a072:	4602      	mov	r2, r0
 800a074:	687b      	ldr	r3, [r7, #4]
 800a076:	60fb      	str	r3, [r7, #12]
 800a078:	f107 030c 	add.w	r3, r7, #12
 800a07c:	4619      	mov	r1, r3
 800a07e:	4610      	mov	r0, r2
 800a080:	f000 f864 	bl	800a14c <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE9push_backEOS3_>
}
 800a084:	687b      	ldr	r3, [r7, #4]
 800a086:	4618      	mov	r0, r3
 800a088:	3710      	adds	r7, #16
 800a08a:	46bd      	mov	sp, r7
 800a08c:	bd80      	pop	{r7, pc}
 800a08e:	bf00      	nop
 800a090:	0801b9ec 	.word	0x0801b9ec

0800a094 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_Vector_implD1Ev>:
	  _M_copy_data(__x);
	  __x._M_copy_data(__tmp);
	}
      };

      struct _Vector_impl
 800a094:	b580      	push	{r7, lr}
 800a096:	b082      	sub	sp, #8
 800a098:	af00      	add	r7, sp, #0
 800a09a:	6078      	str	r0, [r7, #4]
 800a09c:	6878      	ldr	r0, [r7, #4]
 800a09e:	f000 f876 	bl	800a18e <_ZNSaIPN7desenet22NetworkInterfaceDriver10DescriptorEED1Ev>
 800a0a2:	687b      	ldr	r3, [r7, #4]
 800a0a4:	4618      	mov	r0, r3
 800a0a6:	3708      	adds	r7, #8
 800a0a8:	46bd      	mov	sp, r7
 800a0aa:	bd80      	pop	{r7, pc}

0800a0ac <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EEC1Ev>:
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Tp_allocator()); }

#if __cplusplus >= 201103L
      _Vector_base() = default;
 800a0ac:	b580      	push	{r7, lr}
 800a0ae:	b082      	sub	sp, #8
 800a0b0:	af00      	add	r7, sp, #0
 800a0b2:	6078      	str	r0, [r7, #4]
 800a0b4:	687b      	ldr	r3, [r7, #4]
 800a0b6:	4618      	mov	r0, r3
 800a0b8:	f000 f859 	bl	800a16e <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_Vector_implC1Ev>
 800a0bc:	687b      	ldr	r3, [r7, #4]
 800a0be:	4618      	mov	r0, r3
 800a0c0:	3708      	adds	r7, #8
 800a0c2:	46bd      	mov	sp, r7
 800a0c4:	bd80      	pop	{r7, pc}

0800a0c6 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EEC1Ev>:

      /**
       *  @brief  Creates a %vector with no elements.
       */
#if __cplusplus >= 201103L
      vector() = default;
 800a0c6:	b580      	push	{r7, lr}
 800a0c8:	b082      	sub	sp, #8
 800a0ca:	af00      	add	r7, sp, #0
 800a0cc:	6078      	str	r0, [r7, #4]
 800a0ce:	687b      	ldr	r3, [r7, #4]
 800a0d0:	4618      	mov	r0, r3
 800a0d2:	f7ff ffeb 	bl	800a0ac <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EEC1Ev>
 800a0d6:	687b      	ldr	r3, [r7, #4]
 800a0d8:	4618      	mov	r0, r3
 800a0da:	3708      	adds	r7, #8
 800a0dc:	46bd      	mov	sp, r7
 800a0de:	bd80      	pop	{r7, pc}

0800a0e0 <__tcf_0>:
{
}

vector<desenet::NetworkInterfaceDriver::Descriptor *> &desenet::NetworkInterfaceDriver::_descriptors()
{
    static vector<Descriptor *> __descriptors;
 800a0e0:	b580      	push	{r7, lr}
 800a0e2:	af00      	add	r7, sp, #0
 800a0e4:	4801      	ldr	r0, [pc, #4]	; (800a0ec <__tcf_0+0xc>)
 800a0e6:	f000 f877 	bl	800a1d8 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EED1Ev>
 800a0ea:	bd80      	pop	{r7, pc}
 800a0ec:	200018f0 	.word	0x200018f0

0800a0f0 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv>:
{
 800a0f0:	b580      	push	{r7, lr}
 800a0f2:	af00      	add	r7, sp, #0
    static vector<Descriptor *> __descriptors;
 800a0f4:	4b12      	ldr	r3, [pc, #72]	; (800a140 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x50>)
 800a0f6:	781b      	ldrb	r3, [r3, #0]
 800a0f8:	f3bf 8f5b 	dmb	ish
 800a0fc:	b2db      	uxtb	r3, r3
 800a0fe:	f003 0301 	and.w	r3, r3, #1
 800a102:	2b00      	cmp	r3, #0
 800a104:	bf0c      	ite	eq
 800a106:	2301      	moveq	r3, #1
 800a108:	2300      	movne	r3, #0
 800a10a:	b2db      	uxtb	r3, r3
 800a10c:	2b00      	cmp	r3, #0
 800a10e:	d013      	beq.n	800a138 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x48>
 800a110:	480b      	ldr	r0, [pc, #44]	; (800a140 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x50>)
 800a112:	f00c f84f 	bl	80161b4 <__cxa_guard_acquire>
 800a116:	4603      	mov	r3, r0
 800a118:	2b00      	cmp	r3, #0
 800a11a:	bf14      	ite	ne
 800a11c:	2301      	movne	r3, #1
 800a11e:	2300      	moveq	r3, #0
 800a120:	b2db      	uxtb	r3, r3
 800a122:	2b00      	cmp	r3, #0
 800a124:	d008      	beq.n	800a138 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x48>
 800a126:	4807      	ldr	r0, [pc, #28]	; (800a144 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x54>)
 800a128:	f7ff ffcd 	bl	800a0c6 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EEC1Ev>
 800a12c:	4806      	ldr	r0, [pc, #24]	; (800a148 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x58>)
 800a12e:	f00c f94f 	bl	80163d0 <atexit>
 800a132:	4803      	ldr	r0, [pc, #12]	; (800a140 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x50>)
 800a134:	f00c f84a 	bl	80161cc <__cxa_guard_release>
    return __descriptors;
 800a138:	4b02      	ldr	r3, [pc, #8]	; (800a144 <_ZN7desenet22NetworkInterfaceDriver12_descriptorsEv+0x54>)
}
 800a13a:	4618      	mov	r0, r3
 800a13c:	bd80      	pop	{r7, pc}
 800a13e:	bf00      	nop
 800a140:	200018fc 	.word	0x200018fc
 800a144:	200018f0 	.word	0x200018f0
 800a148:	0800a0e1 	.word	0x0800a0e1

0800a14c <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE9push_backEOS3_>:
	  _M_realloc_insert(end(), __x);
      }

#if __cplusplus >= 201103L
      void
      push_back(value_type&& __x)
 800a14c:	b580      	push	{r7, lr}
 800a14e:	b082      	sub	sp, #8
 800a150:	af00      	add	r7, sp, #0
 800a152:	6078      	str	r0, [r7, #4]
 800a154:	6039      	str	r1, [r7, #0]
      { emplace_back(std::move(__x)); }
 800a156:	6838      	ldr	r0, [r7, #0]
 800a158:	f000 f859 	bl	800a20e <_ZSt4moveIRPN7desenet22NetworkInterfaceDriver10DescriptorEEONSt16remove_referenceIT_E4typeEOS6_>
 800a15c:	4603      	mov	r3, r0
 800a15e:	4619      	mov	r1, r3
 800a160:	6878      	ldr	r0, [r7, #4]
 800a162:	f000 f85f 	bl	800a224 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12emplace_backIJS3_EEEvDpOT_>
 800a166:	bf00      	nop
 800a168:	3708      	adds	r7, #8
 800a16a:	46bd      	mov	sp, r7
 800a16c:	bd80      	pop	{r7, pc}

0800a16e <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_Vector_implC1Ev>:
	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
 800a16e:	b580      	push	{r7, lr}
 800a170:	b082      	sub	sp, #8
 800a172:	af00      	add	r7, sp, #0
 800a174:	6078      	str	r0, [r7, #4]
	: _Tp_alloc_type()
 800a176:	6878      	ldr	r0, [r7, #4]
 800a178:	f000 f882 	bl	800a280 <_ZNSaIPN7desenet22NetworkInterfaceDriver10DescriptorEEC1Ev>
 800a17c:	687b      	ldr	r3, [r7, #4]
 800a17e:	4618      	mov	r0, r3
 800a180:	f000 f88a 	bl	800a298 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_Vector_impl_dataC1Ev>
	{ }
 800a184:	687b      	ldr	r3, [r7, #4]
 800a186:	4618      	mov	r0, r3
 800a188:	3708      	adds	r7, #8
 800a18a:	46bd      	mov	sp, r7
 800a18c:	bd80      	pop	{r7, pc}

0800a18e <_ZNSaIPN7desenet22NetworkInterfaceDriver10DescriptorEED1Ev>:
 800a18e:	b580      	push	{r7, lr}
 800a190:	b082      	sub	sp, #8
 800a192:	af00      	add	r7, sp, #0
 800a194:	6078      	str	r0, [r7, #4]
 800a196:	6878      	ldr	r0, [r7, #4]
 800a198:	f000 f892 	bl	800a2c0 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEED1Ev>
 800a19c:	687b      	ldr	r3, [r7, #4]
 800a19e:	4618      	mov	r0, r3
 800a1a0:	3708      	adds	r7, #8
 800a1a2:	46bd      	mov	sp, r7
 800a1a4:	bd80      	pop	{r7, pc}

0800a1a6 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EED1Ev>:
      ~_Vector_base() _GLIBCXX_NOEXCEPT
 800a1a6:	b580      	push	{r7, lr}
 800a1a8:	b082      	sub	sp, #8
 800a1aa:	af00      	add	r7, sp, #0
 800a1ac:	6078      	str	r0, [r7, #4]
	_M_deallocate(_M_impl._M_start,
 800a1ae:	687b      	ldr	r3, [r7, #4]
 800a1b0:	6819      	ldr	r1, [r3, #0]
		      _M_impl._M_end_of_storage - _M_impl._M_start);
 800a1b2:	687b      	ldr	r3, [r7, #4]
 800a1b4:	689a      	ldr	r2, [r3, #8]
 800a1b6:	687b      	ldr	r3, [r7, #4]
 800a1b8:	681b      	ldr	r3, [r3, #0]
 800a1ba:	1ad3      	subs	r3, r2, r3
 800a1bc:	109b      	asrs	r3, r3, #2
	_M_deallocate(_M_impl._M_start,
 800a1be:	461a      	mov	r2, r3
 800a1c0:	6878      	ldr	r0, [r7, #4]
 800a1c2:	f000 f888 	bl	800a2d6 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE13_M_deallocateEPS3_j>
      }
 800a1c6:	687b      	ldr	r3, [r7, #4]
 800a1c8:	4618      	mov	r0, r3
 800a1ca:	f7ff ff63 	bl	800a094 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_Vector_implD1Ev>
 800a1ce:	687b      	ldr	r3, [r7, #4]
 800a1d0:	4618      	mov	r0, r3
 800a1d2:	3708      	adds	r7, #8
 800a1d4:	46bd      	mov	sp, r7
 800a1d6:	bd80      	pop	{r7, pc}

0800a1d8 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EED1Ev>:
      ~vector() _GLIBCXX_NOEXCEPT
 800a1d8:	b5b0      	push	{r4, r5, r7, lr}
 800a1da:	b082      	sub	sp, #8
 800a1dc:	af00      	add	r7, sp, #0
 800a1de:	6078      	str	r0, [r7, #4]
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 800a1e0:	687b      	ldr	r3, [r7, #4]
 800a1e2:	681c      	ldr	r4, [r3, #0]
 800a1e4:	687b      	ldr	r3, [r7, #4]
 800a1e6:	685d      	ldr	r5, [r3, #4]
		      _M_get_Tp_allocator());
 800a1e8:	687b      	ldr	r3, [r7, #4]
 800a1ea:	4618      	mov	r0, r3
 800a1ec:	f000 f886 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a1f0:	4603      	mov	r3, r0
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 800a1f2:	461a      	mov	r2, r3
 800a1f4:	4629      	mov	r1, r5
 800a1f6:	4620      	mov	r0, r4
 800a1f8:	f000 f88b 	bl	800a312 <_ZSt8_DestroyIPPN7desenet22NetworkInterfaceDriver10DescriptorES3_EvT_S5_RSaIT0_E>
      }
 800a1fc:	687b      	ldr	r3, [r7, #4]
 800a1fe:	4618      	mov	r0, r3
 800a200:	f7ff ffd1 	bl	800a1a6 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EED1Ev>
 800a204:	687b      	ldr	r3, [r7, #4]
 800a206:	4618      	mov	r0, r3
 800a208:	3708      	adds	r7, #8
 800a20a:	46bd      	mov	sp, r7
 800a20c:	bdb0      	pop	{r4, r5, r7, pc}

0800a20e <_ZSt4moveIRPN7desenet22NetworkInterfaceDriver10DescriptorEEONSt16remove_referenceIT_E4typeEOS6_>:
    move(_Tp&& __t) noexcept
 800a20e:	b480      	push	{r7}
 800a210:	b083      	sub	sp, #12
 800a212:	af00      	add	r7, sp, #0
 800a214:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800a216:	687b      	ldr	r3, [r7, #4]
 800a218:	4618      	mov	r0, r3
 800a21a:	370c      	adds	r7, #12
 800a21c:	46bd      	mov	sp, r7
 800a21e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a222:	4770      	bx	lr

0800a224 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12emplace_backIJS3_EEEvDpOT_>:
#if __cplusplus > 201402L
      typename vector<_Tp, _Alloc>::reference
#else
      void
#endif
      vector<_Tp, _Alloc>::
 800a224:	b5b0      	push	{r4, r5, r7, lr}
 800a226:	b082      	sub	sp, #8
 800a228:	af00      	add	r7, sp, #0
 800a22a:	6078      	str	r0, [r7, #4]
 800a22c:	6039      	str	r1, [r7, #0]
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 800a22e:	687b      	ldr	r3, [r7, #4]
 800a230:	685a      	ldr	r2, [r3, #4]
 800a232:	687b      	ldr	r3, [r7, #4]
 800a234:	689b      	ldr	r3, [r3, #8]
 800a236:	429a      	cmp	r2, r3
 800a238:	d011      	beq.n	800a25e <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12emplace_backIJS3_EEEvDpOT_+0x3a>
	  {
	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
 800a23a:	687c      	ldr	r4, [r7, #4]
 800a23c:	687b      	ldr	r3, [r7, #4]
 800a23e:	685d      	ldr	r5, [r3, #4]
 800a240:	6838      	ldr	r0, [r7, #0]
 800a242:	f000 f88f 	bl	800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>
 800a246:	4603      	mov	r3, r0
 800a248:	461a      	mov	r2, r3
 800a24a:	4629      	mov	r1, r5
 800a24c:	4620      	mov	r0, r4
 800a24e:	f000 f894 	bl	800a37a <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE9constructIS3_JS3_EEEvRS4_PT_DpOT0_>
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
 800a252:	687b      	ldr	r3, [r7, #4]
 800a254:	685b      	ldr	r3, [r3, #4]
 800a256:	1d1a      	adds	r2, r3, #4
 800a258:	687b      	ldr	r3, [r7, #4]
 800a25a:	605a      	str	r2, [r3, #4]
	else
	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
#if __cplusplus > 201402L
	return back();
#endif
      }
 800a25c:	e00c      	b.n	800a278 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12emplace_backIJS3_EEEvDpOT_+0x54>
	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
 800a25e:	6878      	ldr	r0, [r7, #4]
 800a260:	f000 f89e 	bl	800a3a0 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE3endEv>
 800a264:	4604      	mov	r4, r0
 800a266:	6838      	ldr	r0, [r7, #0]
 800a268:	f000 f87c 	bl	800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>
 800a26c:	4603      	mov	r3, r0
 800a26e:	461a      	mov	r2, r3
 800a270:	4621      	mov	r1, r4
 800a272:	6878      	ldr	r0, [r7, #4]
 800a274:	f000 f8bc 	bl	800a3f0 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_>
      }
 800a278:	bf00      	nop
 800a27a:	3708      	adds	r7, #8
 800a27c:	46bd      	mov	sp, r7
 800a27e:	bdb0      	pop	{r4, r5, r7, pc}

0800a280 <_ZNSaIPN7desenet22NetworkInterfaceDriver10DescriptorEEC1Ev>:
      allocator() _GLIBCXX_NOTHROW { }
 800a280:	b580      	push	{r7, lr}
 800a282:	b082      	sub	sp, #8
 800a284:	af00      	add	r7, sp, #0
 800a286:	6078      	str	r0, [r7, #4]
 800a288:	6878      	ldr	r0, [r7, #4]
 800a28a:	f000 f96d 	bl	800a568 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEEC1Ev>
 800a28e:	687b      	ldr	r3, [r7, #4]
 800a290:	4618      	mov	r0, r3
 800a292:	3708      	adds	r7, #8
 800a294:	46bd      	mov	sp, r7
 800a296:	bd80      	pop	{r7, pc}

0800a298 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_Vector_impl_dataC1Ev>:
	_Vector_impl_data() _GLIBCXX_NOEXCEPT
 800a298:	b480      	push	{r7}
 800a29a:	b083      	sub	sp, #12
 800a29c:	af00      	add	r7, sp, #0
 800a29e:	6078      	str	r0, [r7, #4]
	: _M_start(), _M_finish(), _M_end_of_storage()
 800a2a0:	687b      	ldr	r3, [r7, #4]
 800a2a2:	2200      	movs	r2, #0
 800a2a4:	601a      	str	r2, [r3, #0]
 800a2a6:	687b      	ldr	r3, [r7, #4]
 800a2a8:	2200      	movs	r2, #0
 800a2aa:	605a      	str	r2, [r3, #4]
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	2200      	movs	r2, #0
 800a2b0:	609a      	str	r2, [r3, #8]
	{ }
 800a2b2:	687b      	ldr	r3, [r7, #4]
 800a2b4:	4618      	mov	r0, r3
 800a2b6:	370c      	adds	r7, #12
 800a2b8:	46bd      	mov	sp, r7
 800a2ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a2be:	4770      	bx	lr

0800a2c0 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 800a2c0:	b480      	push	{r7}
 800a2c2:	b083      	sub	sp, #12
 800a2c4:	af00      	add	r7, sp, #0
 800a2c6:	6078      	str	r0, [r7, #4]
 800a2c8:	687b      	ldr	r3, [r7, #4]
 800a2ca:	4618      	mov	r0, r3
 800a2cc:	370c      	adds	r7, #12
 800a2ce:	46bd      	mov	sp, r7
 800a2d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a2d4:	4770      	bx	lr

0800a2d6 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE13_M_deallocateEPS3_j>:
      _M_deallocate(pointer __p, size_t __n)
 800a2d6:	b580      	push	{r7, lr}
 800a2d8:	b084      	sub	sp, #16
 800a2da:	af00      	add	r7, sp, #0
 800a2dc:	60f8      	str	r0, [r7, #12]
 800a2de:	60b9      	str	r1, [r7, #8]
 800a2e0:	607a      	str	r2, [r7, #4]
	if (__p)
 800a2e2:	68bb      	ldr	r3, [r7, #8]
 800a2e4:	2b00      	cmp	r3, #0
 800a2e6:	d005      	beq.n	800a2f4 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE13_M_deallocateEPS3_j+0x1e>
	  _Tr::deallocate(_M_impl, __p, __n);
 800a2e8:	68fb      	ldr	r3, [r7, #12]
 800a2ea:	687a      	ldr	r2, [r7, #4]
 800a2ec:	68b9      	ldr	r1, [r7, #8]
 800a2ee:	4618      	mov	r0, r3
 800a2f0:	f000 f945 	bl	800a57e <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE10deallocateERS4_PS3_j>
      }
 800a2f4:	bf00      	nop
 800a2f6:	3710      	adds	r7, #16
 800a2f8:	46bd      	mov	sp, r7
 800a2fa:	bd80      	pop	{r7, pc}

0800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>:
      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
 800a2fc:	b480      	push	{r7}
 800a2fe:	b083      	sub	sp, #12
 800a300:	af00      	add	r7, sp, #0
 800a302:	6078      	str	r0, [r7, #4]
      { return this->_M_impl; }
 800a304:	687b      	ldr	r3, [r7, #4]
 800a306:	4618      	mov	r0, r3
 800a308:	370c      	adds	r7, #12
 800a30a:	46bd      	mov	sp, r7
 800a30c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a310:	4770      	bx	lr

0800a312 <_ZSt8_DestroyIPPN7desenet22NetworkInterfaceDriver10DescriptorES3_EvT_S5_RSaIT0_E>:
#endif
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
 800a312:	b580      	push	{r7, lr}
 800a314:	b084      	sub	sp, #16
 800a316:	af00      	add	r7, sp, #0
 800a318:	60f8      	str	r0, [r7, #12]
 800a31a:	60b9      	str	r1, [r7, #8]
 800a31c:	607a      	str	r2, [r7, #4]
	     allocator<_Tp>&)
    {
      _Destroy(__first, __last);
 800a31e:	68b9      	ldr	r1, [r7, #8]
 800a320:	68f8      	ldr	r0, [r7, #12]
 800a322:	f000 f93b 	bl	800a59c <_ZSt8_DestroyIPPN7desenet22NetworkInterfaceDriver10DescriptorEEvT_S5_>
    }
 800a326:	bf00      	nop
 800a328:	3710      	adds	r7, #16
 800a32a:	46bd      	mov	sp, r7
 800a32c:	bd80      	pop	{r7, pc}

0800a32e <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE4sizeEv>:
      size() const _GLIBCXX_NOEXCEPT
 800a32e:	b480      	push	{r7}
 800a330:	b083      	sub	sp, #12
 800a332:	af00      	add	r7, sp, #0
 800a334:	6078      	str	r0, [r7, #4]
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
 800a336:	687b      	ldr	r3, [r7, #4]
 800a338:	685a      	ldr	r2, [r3, #4]
 800a33a:	687b      	ldr	r3, [r7, #4]
 800a33c:	681b      	ldr	r3, [r3, #0]
 800a33e:	1ad3      	subs	r3, r2, r3
 800a340:	109b      	asrs	r3, r3, #2
 800a342:	4618      	mov	r0, r3
 800a344:	370c      	adds	r7, #12
 800a346:	46bd      	mov	sp, r7
 800a348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a34c:	4770      	bx	lr

0800a34e <_ZNKSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>:
      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
 800a34e:	b480      	push	{r7}
 800a350:	b083      	sub	sp, #12
 800a352:	af00      	add	r7, sp, #0
 800a354:	6078      	str	r0, [r7, #4]
      { return this->_M_impl; }
 800a356:	687b      	ldr	r3, [r7, #4]
 800a358:	4618      	mov	r0, r3
 800a35a:	370c      	adds	r7, #12
 800a35c:	46bd      	mov	sp, r7
 800a35e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a362:	4770      	bx	lr

0800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800a364:	b480      	push	{r7}
 800a366:	b083      	sub	sp, #12
 800a368:	af00      	add	r7, sp, #0
 800a36a:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800a36c:	687b      	ldr	r3, [r7, #4]
 800a36e:	4618      	mov	r0, r3
 800a370:	370c      	adds	r7, #12
 800a372:	46bd      	mov	sp, r7
 800a374:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a378:	4770      	bx	lr

0800a37a <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE9constructIS3_JS3_EEEvRS4_PT_DpOT0_>:
	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
 800a37a:	b580      	push	{r7, lr}
 800a37c:	b084      	sub	sp, #16
 800a37e:	af00      	add	r7, sp, #0
 800a380:	60f8      	str	r0, [r7, #12]
 800a382:	60b9      	str	r1, [r7, #8]
 800a384:	607a      	str	r2, [r7, #4]
	  __a.construct(__p, std::forward<_Args>(__args)...);
 800a386:	6878      	ldr	r0, [r7, #4]
 800a388:	f7ff ffec 	bl	800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>
 800a38c:	4603      	mov	r3, r0
 800a38e:	461a      	mov	r2, r3
 800a390:	68b9      	ldr	r1, [r7, #8]
 800a392:	68f8      	ldr	r0, [r7, #12]
 800a394:	f000 f90f 	bl	800a5b6 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE9constructIS4_JS4_EEEvPT_DpOT0_>
	}
 800a398:	bf00      	nop
 800a39a:	3710      	adds	r7, #16
 800a39c:	46bd      	mov	sp, r7
 800a39e:	bd80      	pop	{r7, pc}

0800a3a0 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE3endEv>:
      end() _GLIBCXX_NOEXCEPT
 800a3a0:	b580      	push	{r7, lr}
 800a3a2:	b084      	sub	sp, #16
 800a3a4:	af00      	add	r7, sp, #0
 800a3a6:	6078      	str	r0, [r7, #4]
      { return iterator(this->_M_impl._M_finish); }
 800a3a8:	687b      	ldr	r3, [r7, #4]
 800a3aa:	1d1a      	adds	r2, r3, #4
 800a3ac:	f107 030c 	add.w	r3, r7, #12
 800a3b0:	4611      	mov	r1, r2
 800a3b2:	4618      	mov	r0, r3
 800a3b4:	f000 f915 	bl	800a5e2 <_ZN9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEEC1ERKS5_>
 800a3b8:	68fb      	ldr	r3, [r7, #12]
 800a3ba:	4618      	mov	r0, r3
 800a3bc:	3710      	adds	r7, #16
 800a3be:	46bd      	mov	sp, r7
 800a3c0:	bd80      	pop	{r7, pc}

0800a3c2 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE15_S_use_relocateEv>:
      _S_use_relocate()
 800a3c2:	b580      	push	{r7, lr}
 800a3c4:	b082      	sub	sp, #8
 800a3c6:	af00      	add	r7, sp, #0
	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
 800a3c8:	4618      	mov	r0, r3
 800a3ca:	f000 f805 	bl	800a3d8 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_S_nothrow_relocateESt17integral_constantIbLb1EE>
 800a3ce:	4603      	mov	r3, r0
      }
 800a3d0:	4618      	mov	r0, r3
 800a3d2:	3708      	adds	r7, #8
 800a3d4:	46bd      	mov	sp, r7
 800a3d6:	bd80      	pop	{r7, pc}

0800a3d8 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_S_nothrow_relocateESt17integral_constantIbLb1EE>:
      _S_nothrow_relocate(true_type)
 800a3d8:	b480      	push	{r7}
 800a3da:	b083      	sub	sp, #12
 800a3dc:	af00      	add	r7, sp, #0
 800a3de:	7138      	strb	r0, [r7, #4]
					  std::declval<_Tp_alloc_type&>()));
 800a3e0:	2301      	movs	r3, #1
      }
 800a3e2:	4618      	mov	r0, r3
 800a3e4:	370c      	adds	r7, #12
 800a3e6:	46bd      	mov	sp, r7
 800a3e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3ec:	4770      	bx	lr
	...

0800a3f0 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
 800a3f0:	b5b0      	push	{r4, r5, r7, lr}
 800a3f2:	b08c      	sub	sp, #48	; 0x30
 800a3f4:	af00      	add	r7, sp, #0
 800a3f6:	60f8      	str	r0, [r7, #12]
 800a3f8:	60b9      	str	r1, [r7, #8]
 800a3fa:	607a      	str	r2, [r7, #4]
    vector<_Tp, _Alloc>::
    _M_realloc_insert(iterator __position, const _Tp& __x)
#endif
    {
      const size_type __len =
	_M_check_len(size_type(1), "vector::_M_realloc_insert");
 800a3fc:	4a59      	ldr	r2, [pc, #356]	; (800a564 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_+0x174>)
 800a3fe:	2101      	movs	r1, #1
 800a400:	68f8      	ldr	r0, [r7, #12]
 800a402:	f000 f8fe 	bl	800a602 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc>
 800a406:	62b8      	str	r0, [r7, #40]	; 0x28
      pointer __old_start = this->_M_impl._M_start;
 800a408:	68fb      	ldr	r3, [r7, #12]
 800a40a:	681b      	ldr	r3, [r3, #0]
 800a40c:	627b      	str	r3, [r7, #36]	; 0x24
      pointer __old_finish = this->_M_impl._M_finish;
 800a40e:	68fb      	ldr	r3, [r7, #12]
 800a410:	685b      	ldr	r3, [r3, #4]
 800a412:	623b      	str	r3, [r7, #32]
      const size_type __elems_before = __position - begin();
 800a414:	68f8      	ldr	r0, [r7, #12]
 800a416:	f000 f93b 	bl	800a690 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE5beginEv>
 800a41a:	4603      	mov	r3, r0
 800a41c:	617b      	str	r3, [r7, #20]
 800a41e:	f107 0214 	add.w	r2, r7, #20
 800a422:	f107 0308 	add.w	r3, r7, #8
 800a426:	4611      	mov	r1, r2
 800a428:	4618      	mov	r0, r3
 800a42a:	f000 f941 	bl	800a6b0 <_ZN9__gnu_cxxmiIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEEENS_17__normal_iteratorIT_T0_E15difference_typeERKSC_SF_>
 800a42e:	4603      	mov	r3, r0
 800a430:	61fb      	str	r3, [r7, #28]
      pointer __new_start(this->_M_allocate(__len));
 800a432:	68fb      	ldr	r3, [r7, #12]
 800a434:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800a436:	4618      	mov	r0, r3
 800a438:	f000 f94f 	bl	800a6da <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_M_allocateEj>
 800a43c:	61b8      	str	r0, [r7, #24]
      pointer __new_finish(__new_start);
 800a43e:	69bb      	ldr	r3, [r7, #24]
 800a440:	62fb      	str	r3, [r7, #44]	; 0x2c
	  // The order of the three operations is dictated by the C++11
	  // case, where the moves could alter a new element belonging
	  // to the existing vector.  This is an issue only for callers
	  // taking the element by lvalue ref (see last bullet of C++11
	  // [res.on.arguments]).
	  _Alloc_traits::construct(this->_M_impl,
 800a442:	68fc      	ldr	r4, [r7, #12]
				   __new_start + __elems_before,
 800a444:	69fb      	ldr	r3, [r7, #28]
 800a446:	009b      	lsls	r3, r3, #2
	  _Alloc_traits::construct(this->_M_impl,
 800a448:	69ba      	ldr	r2, [r7, #24]
 800a44a:	18d5      	adds	r5, r2, r3
 800a44c:	6878      	ldr	r0, [r7, #4]
 800a44e:	f7ff ff89 	bl	800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>
 800a452:	4603      	mov	r3, r0
 800a454:	461a      	mov	r2, r3
 800a456:	4629      	mov	r1, r5
 800a458:	4620      	mov	r0, r4
 800a45a:	f7ff ff8e 	bl	800a37a <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE9constructIS3_JS3_EEEvRS4_PT_DpOT0_>
#if __cplusplus >= 201103L
				   std::forward<_Args>(__args)...);
#else
				   __x);
#endif
	  __new_finish = pointer();
 800a45e:	2300      	movs	r3, #0
 800a460:	62fb      	str	r3, [r7, #44]	; 0x2c

#if __cplusplus >= 201103L
	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
 800a462:	f7ff ffae 	bl	800a3c2 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE15_S_use_relocateEv>
 800a466:	4603      	mov	r3, r0
 800a468:	2b00      	cmp	r3, #0
 800a46a:	d027      	beq.n	800a4bc <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_+0xcc>
	    {
	      __new_finish = _S_relocate(__old_start, __position.base(),
 800a46c:	f107 0308 	add.w	r3, r7, #8
 800a470:	4618      	mov	r0, r3
 800a472:	f000 f95a 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a476:	4603      	mov	r3, r0
 800a478:	681c      	ldr	r4, [r3, #0]
					 __new_start, _M_get_Tp_allocator());
 800a47a:	68fb      	ldr	r3, [r7, #12]
 800a47c:	4618      	mov	r0, r3
 800a47e:	f7ff ff3d 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a482:	4603      	mov	r3, r0
	      __new_finish = _S_relocate(__old_start, __position.base(),
 800a484:	69ba      	ldr	r2, [r7, #24]
 800a486:	4621      	mov	r1, r4
 800a488:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800a48a:	f000 f93a 	bl	800a702 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_S_relocateEPS3_S6_S6_RS4_>
 800a48e:	62f8      	str	r0, [r7, #44]	; 0x2c

	      ++__new_finish;
 800a490:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a492:	3304      	adds	r3, #4
 800a494:	62fb      	str	r3, [r7, #44]	; 0x2c

	      __new_finish = _S_relocate(__position.base(), __old_finish,
 800a496:	f107 0308 	add.w	r3, r7, #8
 800a49a:	4618      	mov	r0, r3
 800a49c:	f000 f945 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a4a0:	4603      	mov	r3, r0
 800a4a2:	681c      	ldr	r4, [r3, #0]
					 __new_finish, _M_get_Tp_allocator());
 800a4a4:	68fb      	ldr	r3, [r7, #12]
 800a4a6:	4618      	mov	r0, r3
 800a4a8:	f7ff ff28 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a4ac:	4603      	mov	r3, r0
	      __new_finish = _S_relocate(__position.base(), __old_finish,
 800a4ae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a4b0:	6a39      	ldr	r1, [r7, #32]
 800a4b2:	4620      	mov	r0, r4
 800a4b4:	f000 f925 	bl	800a702 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_S_relocateEPS3_S6_S6_RS4_>
 800a4b8:	62f8      	str	r0, [r7, #44]	; 0x2c
 800a4ba:	e026      	b.n	800a50a <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_+0x11a>
	  else
#endif
	    {
	      __new_finish
		= std::__uninitialized_move_if_noexcept_a
		(__old_start, __position.base(),
 800a4bc:	f107 0308 	add.w	r3, r7, #8
 800a4c0:	4618      	mov	r0, r3
 800a4c2:	f000 f932 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a4c6:	4603      	mov	r3, r0
 800a4c8:	681c      	ldr	r4, [r3, #0]
		 __new_start, _M_get_Tp_allocator());
 800a4ca:	68fb      	ldr	r3, [r7, #12]
 800a4cc:	4618      	mov	r0, r3
 800a4ce:	f7ff ff15 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a4d2:	4603      	mov	r3, r0
		(__old_start, __position.base(),
 800a4d4:	69ba      	ldr	r2, [r7, #24]
 800a4d6:	4621      	mov	r1, r4
 800a4d8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800a4da:	f000 f931 	bl	800a740 <_ZSt34__uninitialized_move_if_noexcept_aIPPN7desenet22NetworkInterfaceDriver10DescriptorES4_SaIS3_EET0_T_S7_S6_RT1_>
 800a4de:	62f8      	str	r0, [r7, #44]	; 0x2c

	      ++__new_finish;
 800a4e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a4e2:	3304      	adds	r3, #4
 800a4e4:	62fb      	str	r3, [r7, #44]	; 0x2c

	      __new_finish
		= std::__uninitialized_move_if_noexcept_a
		(__position.base(), __old_finish,
 800a4e6:	f107 0308 	add.w	r3, r7, #8
 800a4ea:	4618      	mov	r0, r3
 800a4ec:	f000 f91d 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a4f0:	4603      	mov	r3, r0
 800a4f2:	681c      	ldr	r4, [r3, #0]
		 __new_finish, _M_get_Tp_allocator());
 800a4f4:	68fb      	ldr	r3, [r7, #12]
 800a4f6:	4618      	mov	r0, r3
 800a4f8:	f7ff ff00 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a4fc:	4603      	mov	r3, r0
		(__position.base(), __old_finish,
 800a4fe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a500:	6a39      	ldr	r1, [r7, #32]
 800a502:	4620      	mov	r0, r4
 800a504:	f000 f91c 	bl	800a740 <_ZSt34__uninitialized_move_if_noexcept_aIPPN7desenet22NetworkInterfaceDriver10DescriptorES4_SaIS3_EET0_T_S7_S6_RT1_>
 800a508:	62f8      	str	r0, [r7, #44]	; 0x2c
	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	  _M_deallocate(__new_start, __len);
	  __throw_exception_again;
	}
#if __cplusplus >= 201103L
      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
 800a50a:	f7ff ff5a 	bl	800a3c2 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE15_S_use_relocateEv>
 800a50e:	4603      	mov	r3, r0
 800a510:	f083 0301 	eor.w	r3, r3, #1
 800a514:	b2db      	uxtb	r3, r3
 800a516:	2b00      	cmp	r3, #0
 800a518:	d009      	beq.n	800a52e <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE17_M_realloc_insertIJS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_+0x13e>
#endif
	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
 800a51a:	68fb      	ldr	r3, [r7, #12]
 800a51c:	4618      	mov	r0, r3
 800a51e:	f7ff feed 	bl	800a2fc <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a522:	4603      	mov	r3, r0
 800a524:	461a      	mov	r2, r3
 800a526:	6a39      	ldr	r1, [r7, #32]
 800a528:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800a52a:	f7ff fef2 	bl	800a312 <_ZSt8_DestroyIPPN7desenet22NetworkInterfaceDriver10DescriptorES3_EvT_S5_RSaIT0_E>
      _GLIBCXX_ASAN_ANNOTATE_REINIT;
      _M_deallocate(__old_start,
 800a52e:	68f8      	ldr	r0, [r7, #12]
		    this->_M_impl._M_end_of_storage - __old_start);
 800a530:	68fb      	ldr	r3, [r7, #12]
 800a532:	689a      	ldr	r2, [r3, #8]
 800a534:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a536:	1ad3      	subs	r3, r2, r3
 800a538:	109b      	asrs	r3, r3, #2
      _M_deallocate(__old_start,
 800a53a:	461a      	mov	r2, r3
 800a53c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800a53e:	f7ff feca 	bl	800a2d6 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE13_M_deallocateEPS3_j>
      this->_M_impl._M_start = __new_start;
 800a542:	68fb      	ldr	r3, [r7, #12]
 800a544:	69ba      	ldr	r2, [r7, #24]
 800a546:	601a      	str	r2, [r3, #0]
      this->_M_impl._M_finish = __new_finish;
 800a548:	68fb      	ldr	r3, [r7, #12]
 800a54a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a54c:	605a      	str	r2, [r3, #4]
      this->_M_impl._M_end_of_storage = __new_start + __len;
 800a54e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a550:	009b      	lsls	r3, r3, #2
 800a552:	69ba      	ldr	r2, [r7, #24]
 800a554:	441a      	add	r2, r3
 800a556:	68fb      	ldr	r3, [r7, #12]
 800a558:	609a      	str	r2, [r3, #8]
    }
 800a55a:	bf00      	nop
 800a55c:	3730      	adds	r7, #48	; 0x30
 800a55e:	46bd      	mov	sp, r7
 800a560:	bdb0      	pop	{r4, r5, r7, pc}
 800a562:	bf00      	nop
 800a564:	080186d8 	.word	0x080186d8

0800a568 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 800a568:	b480      	push	{r7}
 800a56a:	b083      	sub	sp, #12
 800a56c:	af00      	add	r7, sp, #0
 800a56e:	6078      	str	r0, [r7, #4]
 800a570:	687b      	ldr	r3, [r7, #4]
 800a572:	4618      	mov	r0, r3
 800a574:	370c      	adds	r7, #12
 800a576:	46bd      	mov	sp, r7
 800a578:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a57c:	4770      	bx	lr

0800a57e <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE10deallocateERS4_PS3_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 800a57e:	b580      	push	{r7, lr}
 800a580:	b084      	sub	sp, #16
 800a582:	af00      	add	r7, sp, #0
 800a584:	60f8      	str	r0, [r7, #12]
 800a586:	60b9      	str	r1, [r7, #8]
 800a588:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 800a58a:	687a      	ldr	r2, [r7, #4]
 800a58c:	68b9      	ldr	r1, [r7, #8]
 800a58e:	68f8      	ldr	r0, [r7, #12]
 800a590:	f000 f8ef 	bl	800a772 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE10deallocateEPS4_j>
 800a594:	bf00      	nop
 800a596:	3710      	adds	r7, #16
 800a598:	46bd      	mov	sp, r7
 800a59a:	bd80      	pop	{r7, pc}

0800a59c <_ZSt8_DestroyIPPN7desenet22NetworkInterfaceDriver10DescriptorEEvT_S5_>:
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   */
  template<typename _ForwardIterator>
    _GLIBCXX20_CONSTEXPR inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
 800a59c:	b580      	push	{r7, lr}
 800a59e:	b082      	sub	sp, #8
 800a5a0:	af00      	add	r7, sp, #0
 800a5a2:	6078      	str	r0, [r7, #4]
 800a5a4:	6039      	str	r1, [r7, #0]
#if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
      if (std::is_constant_evaluated())
	return _Destroy_aux<false>::__destroy(__first, __last);
#endif
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
	__destroy(__first, __last);
 800a5a6:	6839      	ldr	r1, [r7, #0]
 800a5a8:	6878      	ldr	r0, [r7, #4]
 800a5aa:	f000 f8f2 	bl	800a792 <_ZNSt12_Destroy_auxILb1EE9__destroyIPPN7desenet22NetworkInterfaceDriver10DescriptorEEEvT_S7_>
    }
 800a5ae:	bf00      	nop
 800a5b0:	3708      	adds	r7, #8
 800a5b2:	46bd      	mov	sp, r7
 800a5b4:	bd80      	pop	{r7, pc}

0800a5b6 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE9constructIS4_JS4_EEEvPT_DpOT0_>:
	construct(_Up* __p, _Args&&... __args)
 800a5b6:	b590      	push	{r4, r7, lr}
 800a5b8:	b085      	sub	sp, #20
 800a5ba:	af00      	add	r7, sp, #0
 800a5bc:	60f8      	str	r0, [r7, #12]
 800a5be:	60b9      	str	r1, [r7, #8]
 800a5c0:	607a      	str	r2, [r7, #4]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 800a5c2:	6878      	ldr	r0, [r7, #4]
 800a5c4:	f7ff fece 	bl	800a364 <_ZSt7forwardIPN7desenet22NetworkInterfaceDriver10DescriptorEEOT_RNSt16remove_referenceIS4_E4typeE>
 800a5c8:	4603      	mov	r3, r0
 800a5ca:	681c      	ldr	r4, [r3, #0]
 800a5cc:	68bb      	ldr	r3, [r7, #8]
 800a5ce:	4619      	mov	r1, r3
 800a5d0:	2004      	movs	r0, #4
 800a5d2:	f7fd f899 	bl	8007708 <_ZnwjPv>
 800a5d6:	4603      	mov	r3, r0
 800a5d8:	601c      	str	r4, [r3, #0]
 800a5da:	bf00      	nop
 800a5dc:	3714      	adds	r7, #20
 800a5de:	46bd      	mov	sp, r7
 800a5e0:	bd90      	pop	{r4, r7, pc}

0800a5e2 <_ZN9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEEC1ERKS5_>:

      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }

      explicit _GLIBCXX20_CONSTEXPR
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
 800a5e2:	b480      	push	{r7}
 800a5e4:	b083      	sub	sp, #12
 800a5e6:	af00      	add	r7, sp, #0
 800a5e8:	6078      	str	r0, [r7, #4]
 800a5ea:	6039      	str	r1, [r7, #0]
      : _M_current(__i) { }
 800a5ec:	683b      	ldr	r3, [r7, #0]
 800a5ee:	681a      	ldr	r2, [r3, #0]
 800a5f0:	687b      	ldr	r3, [r7, #4]
 800a5f2:	601a      	str	r2, [r3, #0]
 800a5f4:	687b      	ldr	r3, [r7, #4]
 800a5f6:	4618      	mov	r0, r3
 800a5f8:	370c      	adds	r7, #12
 800a5fa:	46bd      	mov	sp, r7
 800a5fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a600:	4770      	bx	lr

0800a602 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc>:
      { return _M_insert_rval(__position, std::move(__v)); }
#endif

      // Called by _M_fill_insert, _M_insert_aux etc.
      size_type
      _M_check_len(size_type __n, const char* __s) const
 800a602:	b590      	push	{r4, r7, lr}
 800a604:	b087      	sub	sp, #28
 800a606:	af00      	add	r7, sp, #0
 800a608:	60f8      	str	r0, [r7, #12]
 800a60a:	60b9      	str	r1, [r7, #8]
 800a60c:	607a      	str	r2, [r7, #4]
      {
	if (max_size() - size() < __n)
 800a60e:	68f8      	ldr	r0, [r7, #12]
 800a610:	f000 f8ca 	bl	800a7a8 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE8max_sizeEv>
 800a614:	4604      	mov	r4, r0
 800a616:	68f8      	ldr	r0, [r7, #12]
 800a618:	f7ff fe89 	bl	800a32e <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE4sizeEv>
 800a61c:	4603      	mov	r3, r0
 800a61e:	1ae2      	subs	r2, r4, r3
 800a620:	68bb      	ldr	r3, [r7, #8]
 800a622:	429a      	cmp	r2, r3
 800a624:	bf34      	ite	cc
 800a626:	2301      	movcc	r3, #1
 800a628:	2300      	movcs	r3, #0
 800a62a:	b2db      	uxtb	r3, r3
 800a62c:	2b00      	cmp	r3, #0
 800a62e:	d002      	beq.n	800a636 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc+0x34>
	  __throw_length_error(__N(__s));
 800a630:	6878      	ldr	r0, [r7, #4]
 800a632:	f00b fdf8 	bl	8016226 <_ZSt20__throw_length_errorPKc>

	const size_type __len = size() + (std::max)(size(), __n);
 800a636:	68f8      	ldr	r0, [r7, #12]
 800a638:	f7ff fe79 	bl	800a32e <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE4sizeEv>
 800a63c:	4604      	mov	r4, r0
 800a63e:	68f8      	ldr	r0, [r7, #12]
 800a640:	f7ff fe75 	bl	800a32e <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE4sizeEv>
 800a644:	4603      	mov	r3, r0
 800a646:	613b      	str	r3, [r7, #16]
 800a648:	f107 0208 	add.w	r2, r7, #8
 800a64c:	f107 0310 	add.w	r3, r7, #16
 800a650:	4611      	mov	r1, r2
 800a652:	4618      	mov	r0, r3
 800a654:	f000 f8b9 	bl	800a7ca <_ZSt3maxIjERKT_S2_S2_>
 800a658:	4603      	mov	r3, r0
 800a65a:	681b      	ldr	r3, [r3, #0]
 800a65c:	4423      	add	r3, r4
 800a65e:	617b      	str	r3, [r7, #20]
	return (__len < size() || __len > max_size()) ? max_size() : __len;
 800a660:	68f8      	ldr	r0, [r7, #12]
 800a662:	f7ff fe64 	bl	800a32e <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE4sizeEv>
 800a666:	4602      	mov	r2, r0
 800a668:	697b      	ldr	r3, [r7, #20]
 800a66a:	4293      	cmp	r3, r2
 800a66c:	d306      	bcc.n	800a67c <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc+0x7a>
 800a66e:	68f8      	ldr	r0, [r7, #12]
 800a670:	f000 f89a 	bl	800a7a8 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE8max_sizeEv>
 800a674:	4602      	mov	r2, r0
 800a676:	697b      	ldr	r3, [r7, #20]
 800a678:	4293      	cmp	r3, r2
 800a67a:	d904      	bls.n	800a686 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc+0x84>
 800a67c:	68f8      	ldr	r0, [r7, #12]
 800a67e:	f000 f893 	bl	800a7a8 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE8max_sizeEv>
 800a682:	4603      	mov	r3, r0
 800a684:	e000      	b.n	800a688 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE12_M_check_lenEjPKc+0x86>
 800a686:	697b      	ldr	r3, [r7, #20]
      }
 800a688:	4618      	mov	r0, r3
 800a68a:	371c      	adds	r7, #28
 800a68c:	46bd      	mov	sp, r7
 800a68e:	bd90      	pop	{r4, r7, pc}

0800a690 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE5beginEv>:
      begin() _GLIBCXX_NOEXCEPT
 800a690:	b580      	push	{r7, lr}
 800a692:	b084      	sub	sp, #16
 800a694:	af00      	add	r7, sp, #0
 800a696:	6078      	str	r0, [r7, #4]
      { return iterator(this->_M_impl._M_start); }
 800a698:	687a      	ldr	r2, [r7, #4]
 800a69a:	f107 030c 	add.w	r3, r7, #12
 800a69e:	4611      	mov	r1, r2
 800a6a0:	4618      	mov	r0, r3
 800a6a2:	f7ff ff9e 	bl	800a5e2 <_ZN9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEEC1ERKS5_>
 800a6a6:	68fb      	ldr	r3, [r7, #12]
 800a6a8:	4618      	mov	r0, r3
 800a6aa:	3710      	adds	r7, #16
 800a6ac:	46bd      	mov	sp, r7
 800a6ae:	bd80      	pop	{r7, pc}

0800a6b0 <_ZN9__gnu_cxxmiIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEEENS_17__normal_iteratorIT_T0_E15difference_typeERKSC_SF_>:
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    _GLIBCXX20_CONSTEXPR
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
 800a6b0:	b590      	push	{r4, r7, lr}
 800a6b2:	b083      	sub	sp, #12
 800a6b4:	af00      	add	r7, sp, #0
 800a6b6:	6078      	str	r0, [r7, #4]
 800a6b8:	6039      	str	r1, [r7, #0]
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() - __rhs.base(); }
 800a6ba:	6878      	ldr	r0, [r7, #4]
 800a6bc:	f000 f835 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a6c0:	4603      	mov	r3, r0
 800a6c2:	681c      	ldr	r4, [r3, #0]
 800a6c4:	6838      	ldr	r0, [r7, #0]
 800a6c6:	f000 f830 	bl	800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>
 800a6ca:	4603      	mov	r3, r0
 800a6cc:	681b      	ldr	r3, [r3, #0]
 800a6ce:	1ae3      	subs	r3, r4, r3
 800a6d0:	109b      	asrs	r3, r3, #2
 800a6d2:	4618      	mov	r0, r3
 800a6d4:	370c      	adds	r7, #12
 800a6d6:	46bd      	mov	sp, r7
 800a6d8:	bd90      	pop	{r4, r7, pc}

0800a6da <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_M_allocateEj>:
      _M_allocate(size_t __n)
 800a6da:	b580      	push	{r7, lr}
 800a6dc:	b082      	sub	sp, #8
 800a6de:	af00      	add	r7, sp, #0
 800a6e0:	6078      	str	r0, [r7, #4]
 800a6e2:	6039      	str	r1, [r7, #0]
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
 800a6e4:	683b      	ldr	r3, [r7, #0]
 800a6e6:	2b00      	cmp	r3, #0
 800a6e8:	d006      	beq.n	800a6f8 <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_M_allocateEj+0x1e>
 800a6ea:	687b      	ldr	r3, [r7, #4]
 800a6ec:	6839      	ldr	r1, [r7, #0]
 800a6ee:	4618      	mov	r0, r3
 800a6f0:	f000 f87f 	bl	800a7f2 <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE8allocateERS4_j>
 800a6f4:	4603      	mov	r3, r0
 800a6f6:	e000      	b.n	800a6fa <_ZNSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_M_allocateEj+0x20>
 800a6f8:	2300      	movs	r3, #0
      }
 800a6fa:	4618      	mov	r0, r3
 800a6fc:	3708      	adds	r7, #8
 800a6fe:	46bd      	mov	sp, r7
 800a700:	bd80      	pop	{r7, pc}

0800a702 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_S_relocateEPS3_S6_S6_RS4_>:
      _S_relocate(pointer __first, pointer __last, pointer __result,
 800a702:	b590      	push	{r4, r7, lr}
 800a704:	b087      	sub	sp, #28
 800a706:	af02      	add	r7, sp, #8
 800a708:	60f8      	str	r0, [r7, #12]
 800a70a:	60b9      	str	r1, [r7, #8]
 800a70c:	607a      	str	r2, [r7, #4]
 800a70e:	603b      	str	r3, [r7, #0]
	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
 800a710:	f88d 4000 	strb.w	r4, [sp]
 800a714:	683b      	ldr	r3, [r7, #0]
 800a716:	687a      	ldr	r2, [r7, #4]
 800a718:	68b9      	ldr	r1, [r7, #8]
 800a71a:	68f8      	ldr	r0, [r7, #12]
 800a71c:	f000 f878 	bl	800a810 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE14_S_do_relocateEPS3_S6_S6_RS4_St17integral_constantIbLb1EE>
 800a720:	4603      	mov	r3, r0
      }
 800a722:	4618      	mov	r0, r3
 800a724:	3714      	adds	r7, #20
 800a726:	46bd      	mov	sp, r7
 800a728:	bd90      	pop	{r4, r7, pc}

0800a72a <_ZNK9__gnu_cxx17__normal_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorESt6vectorIS4_SaIS4_EEE4baseEv>:
      base() const _GLIBCXX_NOEXCEPT
 800a72a:	b480      	push	{r7}
 800a72c:	b083      	sub	sp, #12
 800a72e:	af00      	add	r7, sp, #0
 800a730:	6078      	str	r0, [r7, #4]
      { return _M_current; }
 800a732:	687b      	ldr	r3, [r7, #4]
 800a734:	4618      	mov	r0, r3
 800a736:	370c      	adds	r7, #12
 800a738:	46bd      	mov	sp, r7
 800a73a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a73e:	4770      	bx	lr

0800a740 <_ZSt34__uninitialized_move_if_noexcept_aIPPN7desenet22NetworkInterfaceDriver10DescriptorES4_SaIS3_EET0_T_S7_S6_RT1_>:
    }

  template<typename _InputIterator, typename _ForwardIterator,
	   typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
 800a740:	b590      	push	{r4, r7, lr}
 800a742:	b085      	sub	sp, #20
 800a744:	af00      	add	r7, sp, #0
 800a746:	60f8      	str	r0, [r7, #12]
 800a748:	60b9      	str	r1, [r7, #8]
 800a74a:	607a      	str	r2, [r7, #4]
 800a74c:	603b      	str	r3, [r7, #0]
				       _InputIterator __last,
				       _ForwardIterator __result,
				       _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
 800a74e:	68f8      	ldr	r0, [r7, #12]
 800a750:	f000 f870 	bl	800a834 <_ZSt32__make_move_if_noexcept_iteratorIPN7desenet22NetworkInterfaceDriver10DescriptorESt13move_iteratorIPS3_EET0_PT_>
 800a754:	4604      	mov	r4, r0
 800a756:	68b8      	ldr	r0, [r7, #8]
 800a758:	f000 f86c 	bl	800a834 <_ZSt32__make_move_if_noexcept_iteratorIPN7desenet22NetworkInterfaceDriver10DescriptorESt13move_iteratorIPS3_EET0_PT_>
 800a75c:	4601      	mov	r1, r0
 800a75e:	683b      	ldr	r3, [r7, #0]
 800a760:	687a      	ldr	r2, [r7, #4]
 800a762:	4620      	mov	r0, r4
 800a764:	f000 f875 	bl	800a852 <_ZSt22__uninitialized_copy_aISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_S4_ET0_T_S8_S7_RSaIT1_E>
 800a768:	4603      	mov	r3, r0
	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
    }
 800a76a:	4618      	mov	r0, r3
 800a76c:	3714      	adds	r7, #20
 800a76e:	46bd      	mov	sp, r7
 800a770:	bd90      	pop	{r4, r7, pc}

0800a772 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE10deallocateEPS4_j>:
      deallocate(_Tp* __p, size_type __t)
 800a772:	b580      	push	{r7, lr}
 800a774:	b084      	sub	sp, #16
 800a776:	af00      	add	r7, sp, #0
 800a778:	60f8      	str	r0, [r7, #12]
 800a77a:	60b9      	str	r1, [r7, #8]
 800a77c:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 800a77e:	687b      	ldr	r3, [r7, #4]
 800a780:	009b      	lsls	r3, r3, #2
 800a782:	4619      	mov	r1, r3
 800a784:	68b8      	ldr	r0, [r7, #8]
 800a786:	f00b fd11 	bl	80161ac <_ZdlPvj>
      }
 800a78a:	bf00      	nop
 800a78c:	3710      	adds	r7, #16
 800a78e:	46bd      	mov	sp, r7
 800a790:	bd80      	pop	{r7, pc}

0800a792 <_ZNSt12_Destroy_auxILb1EE9__destroyIPPN7desenet22NetworkInterfaceDriver10DescriptorEEEvT_S7_>:
        __destroy(_ForwardIterator, _ForwardIterator) { }
 800a792:	b480      	push	{r7}
 800a794:	b083      	sub	sp, #12
 800a796:	af00      	add	r7, sp, #0
 800a798:	6078      	str	r0, [r7, #4]
 800a79a:	6039      	str	r1, [r7, #0]
 800a79c:	bf00      	nop
 800a79e:	370c      	adds	r7, #12
 800a7a0:	46bd      	mov	sp, r7
 800a7a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7a6:	4770      	bx	lr

0800a7a8 <_ZNKSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE8max_sizeEv>:
      max_size() const _GLIBCXX_NOEXCEPT
 800a7a8:	b580      	push	{r7, lr}
 800a7aa:	b082      	sub	sp, #8
 800a7ac:	af00      	add	r7, sp, #0
 800a7ae:	6078      	str	r0, [r7, #4]
      { return _S_max_size(_M_get_Tp_allocator()); }
 800a7b0:	687b      	ldr	r3, [r7, #4]
 800a7b2:	4618      	mov	r0, r3
 800a7b4:	f7ff fdcb 	bl	800a34e <_ZNKSt12_Vector_baseIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE19_M_get_Tp_allocatorEv>
 800a7b8:	4603      	mov	r3, r0
 800a7ba:	4618      	mov	r0, r3
 800a7bc:	f000 f85a 	bl	800a874 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_S_max_sizeERKS4_>
 800a7c0:	4603      	mov	r3, r0
 800a7c2:	4618      	mov	r0, r3
 800a7c4:	3708      	adds	r7, #8
 800a7c6:	46bd      	mov	sp, r7
 800a7c8:	bd80      	pop	{r7, pc}

0800a7ca <_ZSt3maxIjERKT_S2_S2_>:
    max(const _Tp& __a, const _Tp& __b)
 800a7ca:	b480      	push	{r7}
 800a7cc:	b083      	sub	sp, #12
 800a7ce:	af00      	add	r7, sp, #0
 800a7d0:	6078      	str	r0, [r7, #4]
 800a7d2:	6039      	str	r1, [r7, #0]
      if (__a < __b)
 800a7d4:	687b      	ldr	r3, [r7, #4]
 800a7d6:	681a      	ldr	r2, [r3, #0]
 800a7d8:	683b      	ldr	r3, [r7, #0]
 800a7da:	681b      	ldr	r3, [r3, #0]
 800a7dc:	429a      	cmp	r2, r3
 800a7de:	d201      	bcs.n	800a7e4 <_ZSt3maxIjERKT_S2_S2_+0x1a>
	return __b;
 800a7e0:	683b      	ldr	r3, [r7, #0]
 800a7e2:	e000      	b.n	800a7e6 <_ZSt3maxIjERKT_S2_S2_+0x1c>
      return __a;
 800a7e4:	687b      	ldr	r3, [r7, #4]
    }
 800a7e6:	4618      	mov	r0, r3
 800a7e8:	370c      	adds	r7, #12
 800a7ea:	46bd      	mov	sp, r7
 800a7ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7f0:	4770      	bx	lr

0800a7f2 <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE8allocateERS4_j>:
      allocate(allocator_type& __a, size_type __n)
 800a7f2:	b580      	push	{r7, lr}
 800a7f4:	b082      	sub	sp, #8
 800a7f6:	af00      	add	r7, sp, #0
 800a7f8:	6078      	str	r0, [r7, #4]
 800a7fa:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 800a7fc:	2200      	movs	r2, #0
 800a7fe:	6839      	ldr	r1, [r7, #0]
 800a800:	6878      	ldr	r0, [r7, #4]
 800a802:	f000 f851 	bl	800a8a8 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE8allocateEjPKv>
 800a806:	4603      	mov	r3, r0
 800a808:	4618      	mov	r0, r3
 800a80a:	3708      	adds	r7, #8
 800a80c:	46bd      	mov	sp, r7
 800a80e:	bd80      	pop	{r7, pc}

0800a810 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE14_S_do_relocateEPS3_S6_S6_RS4_St17integral_constantIbLb1EE>:
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
 800a810:	b580      	push	{r7, lr}
 800a812:	b084      	sub	sp, #16
 800a814:	af00      	add	r7, sp, #0
 800a816:	60f8      	str	r0, [r7, #12]
 800a818:	60b9      	str	r1, [r7, #8]
 800a81a:	607a      	str	r2, [r7, #4]
 800a81c:	603b      	str	r3, [r7, #0]
	return std::__relocate_a(__first, __last, __result, __alloc);
 800a81e:	683b      	ldr	r3, [r7, #0]
 800a820:	687a      	ldr	r2, [r7, #4]
 800a822:	68b9      	ldr	r1, [r7, #8]
 800a824:	68f8      	ldr	r0, [r7, #12]
 800a826:	f000 f85d 	bl	800a8e4 <_ZSt12__relocate_aIPPN7desenet22NetworkInterfaceDriver10DescriptorES4_SaIS3_EET0_T_S7_S6_RT1_>
 800a82a:	4603      	mov	r3, r0
      }
 800a82c:	4618      	mov	r0, r3
 800a82e:	3710      	adds	r7, #16
 800a830:	46bd      	mov	sp, r7
 800a832:	bd80      	pop	{r7, pc}

0800a834 <_ZSt32__make_move_if_noexcept_iteratorIPN7desenet22NetworkInterfaceDriver10DescriptorESt13move_iteratorIPS3_EET0_PT_>:
  // returning a constant iterator when we don't want to move.
  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
			   const _Tp*, move_iterator<_Tp*>>::type>
    inline _GLIBCXX17_CONSTEXPR _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
 800a834:	b580      	push	{r7, lr}
 800a836:	b084      	sub	sp, #16
 800a838:	af00      	add	r7, sp, #0
 800a83a:	6078      	str	r0, [r7, #4]
    { return _ReturnType(__i); }
 800a83c:	f107 030c 	add.w	r3, r7, #12
 800a840:	6879      	ldr	r1, [r7, #4]
 800a842:	4618      	mov	r0, r3
 800a844:	f000 f86b 	bl	800a91e <_ZNSt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEEC1ES4_>
 800a848:	68fb      	ldr	r3, [r7, #12]
 800a84a:	4618      	mov	r0, r3
 800a84c:	3710      	adds	r7, #16
 800a84e:	46bd      	mov	sp, r7
 800a850:	bd80      	pop	{r7, pc}

0800a852 <_ZSt22__uninitialized_copy_aISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_S4_ET0_T_S8_S7_RSaIT1_E>:
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
 800a852:	b580      	push	{r7, lr}
 800a854:	b084      	sub	sp, #16
 800a856:	af00      	add	r7, sp, #0
 800a858:	60f8      	str	r0, [r7, #12]
 800a85a:	60b9      	str	r1, [r7, #8]
 800a85c:	607a      	str	r2, [r7, #4]
 800a85e:	603b      	str	r3, [r7, #0]
    { return std::uninitialized_copy(__first, __last, __result); }
 800a860:	687a      	ldr	r2, [r7, #4]
 800a862:	68b9      	ldr	r1, [r7, #8]
 800a864:	68f8      	ldr	r0, [r7, #12]
 800a866:	f000 f86c 	bl	800a942 <_ZSt18uninitialized_copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_ET0_T_S8_S7_>
 800a86a:	4603      	mov	r3, r0
 800a86c:	4618      	mov	r0, r3
 800a86e:	3710      	adds	r7, #16
 800a870:	46bd      	mov	sp, r7
 800a872:	bd80      	pop	{r7, pc}

0800a874 <_ZNSt6vectorIPN7desenet22NetworkInterfaceDriver10DescriptorESaIS3_EE11_S_max_sizeERKS4_>:
	      __N("cannot create std::vector larger than max_size()"));
	return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
 800a874:	b580      	push	{r7, lr}
 800a876:	b084      	sub	sp, #16
 800a878:	af00      	add	r7, sp, #0
 800a87a:	6078      	str	r0, [r7, #4]
      {
	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
	// (even if std::allocator_traits::max_size says we can).
	const size_t __diffmax
 800a87c:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
 800a880:	60fb      	str	r3, [r7, #12]
	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
	const size_t __allocmax = _Alloc_traits::max_size(__a);
 800a882:	6878      	ldr	r0, [r7, #4]
 800a884:	f000 f86f 	bl	800a966 <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE8max_sizeERKS4_>
 800a888:	4603      	mov	r3, r0
 800a88a:	60bb      	str	r3, [r7, #8]
	return (std::min)(__diffmax, __allocmax);
 800a88c:	f107 0208 	add.w	r2, r7, #8
 800a890:	f107 030c 	add.w	r3, r7, #12
 800a894:	4611      	mov	r1, r2
 800a896:	4618      	mov	r0, r3
 800a898:	f000 f871 	bl	800a97e <_ZSt3minIjERKT_S2_S2_>
 800a89c:	4603      	mov	r3, r0
 800a89e:	681b      	ldr	r3, [r3, #0]
      }
 800a8a0:	4618      	mov	r0, r3
 800a8a2:	3710      	adds	r7, #16
 800a8a4:	46bd      	mov	sp, r7
 800a8a6:	bd80      	pop	{r7, pc}

0800a8a8 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 800a8a8:	b580      	push	{r7, lr}
 800a8aa:	b084      	sub	sp, #16
 800a8ac:	af00      	add	r7, sp, #0
 800a8ae:	60f8      	str	r0, [r7, #12]
 800a8b0:	60b9      	str	r1, [r7, #8]
 800a8b2:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 800a8b4:	68f8      	ldr	r0, [r7, #12]
 800a8b6:	f000 f876 	bl	800a9a6 <_ZNK9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE11_M_max_sizeEv>
 800a8ba:	4602      	mov	r2, r0
 800a8bc:	68bb      	ldr	r3, [r7, #8]
 800a8be:	4293      	cmp	r3, r2
 800a8c0:	bf8c      	ite	hi
 800a8c2:	2301      	movhi	r3, #1
 800a8c4:	2300      	movls	r3, #0
 800a8c6:	b2db      	uxtb	r3, r3
 800a8c8:	2b00      	cmp	r3, #0
 800a8ca:	d001      	beq.n	800a8d0 <_ZN9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 800a8cc:	f00b fca5 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 800a8d0:	68bb      	ldr	r3, [r7, #8]
 800a8d2:	009b      	lsls	r3, r3, #2
 800a8d4:	4618      	mov	r0, r3
 800a8d6:	f00b fc7c 	bl	80161d2 <_Znwj>
 800a8da:	4603      	mov	r3, r0
      }
 800a8dc:	4618      	mov	r0, r3
 800a8de:	3710      	adds	r7, #16
 800a8e0:	46bd      	mov	sp, r7
 800a8e2:	bd80      	pop	{r7, pc}

0800a8e4 <_ZSt12__relocate_aIPPN7desenet22NetworkInterfaceDriver10DescriptorES4_SaIS3_EET0_T_S7_S6_RT1_>:
    }

  template <typename _InputIterator, typename _ForwardIterator,
	    typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
 800a8e4:	b5b0      	push	{r4, r5, r7, lr}
 800a8e6:	b084      	sub	sp, #16
 800a8e8:	af00      	add	r7, sp, #0
 800a8ea:	60f8      	str	r0, [r7, #12]
 800a8ec:	60b9      	str	r1, [r7, #8]
 800a8ee:	607a      	str	r2, [r7, #4]
 800a8f0:	603b      	str	r3, [r7, #0]
		 _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
				     std::__niter_base(__last),
				     std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
 800a8f2:	68f8      	ldr	r0, [r7, #12]
 800a8f4:	f000 f863 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800a8f8:	4604      	mov	r4, r0
 800a8fa:	68b8      	ldr	r0, [r7, #8]
 800a8fc:	f000 f85f 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800a900:	4605      	mov	r5, r0
 800a902:	6878      	ldr	r0, [r7, #4]
 800a904:	f000 f85b 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800a908:	4602      	mov	r2, r0
 800a90a:	683b      	ldr	r3, [r7, #0]
 800a90c:	4629      	mov	r1, r5
 800a90e:	4620      	mov	r0, r4
 800a910:	f000 f860 	bl	800a9d4 <_ZSt14__relocate_a_1IPN7desenet22NetworkInterfaceDriver10DescriptorES3_ENSt9enable_ifIXsrSt24__is_bitwise_relocatableIT_vE5valueEPS6_E4typeES8_S8_S8_RSaIT0_E>
 800a914:	4603      	mov	r3, r0
			    std::__niter_base(__last),
			    std::__niter_base(__result), __alloc);
    }
 800a916:	4618      	mov	r0, r3
 800a918:	3710      	adds	r7, #16
 800a91a:	46bd      	mov	sp, r7
 800a91c:	bdb0      	pop	{r4, r5, r7, pc}

0800a91e <_ZNSt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEEC1ES4_>:
      move_iterator(iterator_type __i)
 800a91e:	b580      	push	{r7, lr}
 800a920:	b082      	sub	sp, #8
 800a922:	af00      	add	r7, sp, #0
 800a924:	6078      	str	r0, [r7, #4]
 800a926:	6039      	str	r1, [r7, #0]
      : _M_current(std::move(__i)) { }
 800a928:	463b      	mov	r3, r7
 800a92a:	4618      	mov	r0, r3
 800a92c:	f000 f870 	bl	800aa10 <_ZSt4moveIRPPN7desenet22NetworkInterfaceDriver10DescriptorEEONSt16remove_referenceIT_E4typeEOS7_>
 800a930:	4603      	mov	r3, r0
 800a932:	681a      	ldr	r2, [r3, #0]
 800a934:	687b      	ldr	r3, [r7, #4]
 800a936:	601a      	str	r2, [r3, #0]
 800a938:	687b      	ldr	r3, [r7, #4]
 800a93a:	4618      	mov	r0, r3
 800a93c:	3708      	adds	r7, #8
 800a93e:	46bd      	mov	sp, r7
 800a940:	bd80      	pop	{r7, pc}

0800a942 <_ZSt18uninitialized_copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_ET0_T_S8_S7_>:
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
 800a942:	b580      	push	{r7, lr}
 800a944:	b086      	sub	sp, #24
 800a946:	af00      	add	r7, sp, #0
 800a948:	60f8      	str	r0, [r7, #12]
 800a94a:	60b9      	str	r1, [r7, #8]
 800a94c:	607a      	str	r2, [r7, #4]
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
 800a94e:	2301      	movs	r3, #1
 800a950:	75fb      	strb	r3, [r7, #23]
	__uninit_copy(__first, __last, __result);
 800a952:	687a      	ldr	r2, [r7, #4]
 800a954:	68b9      	ldr	r1, [r7, #8]
 800a956:	68f8      	ldr	r0, [r7, #12]
 800a958:	f000 f865 	bl	800aa26 <_ZNSt20__uninitialized_copyILb1EE13__uninit_copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES7_EET0_T_SA_S9_>
 800a95c:	4603      	mov	r3, r0
    }
 800a95e:	4618      	mov	r0, r3
 800a960:	3718      	adds	r7, #24
 800a962:	46bd      	mov	sp, r7
 800a964:	bd80      	pop	{r7, pc}

0800a966 <_ZNSt16allocator_traitsISaIPN7desenet22NetworkInterfaceDriver10DescriptorEEE8max_sizeERKS4_>:
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
 800a966:	b580      	push	{r7, lr}
 800a968:	b082      	sub	sp, #8
 800a96a:	af00      	add	r7, sp, #0
 800a96c:	6078      	str	r0, [r7, #4]
	return __a.max_size();
 800a96e:	6878      	ldr	r0, [r7, #4]
 800a970:	f000 f875 	bl	800aa5e <_ZNK9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE8max_sizeEv>
 800a974:	4603      	mov	r3, r0
      }
 800a976:	4618      	mov	r0, r3
 800a978:	3708      	adds	r7, #8
 800a97a:	46bd      	mov	sp, r7
 800a97c:	bd80      	pop	{r7, pc}

0800a97e <_ZSt3minIjERKT_S2_S2_>:
    min(const _Tp& __a, const _Tp& __b)
 800a97e:	b480      	push	{r7}
 800a980:	b083      	sub	sp, #12
 800a982:	af00      	add	r7, sp, #0
 800a984:	6078      	str	r0, [r7, #4]
 800a986:	6039      	str	r1, [r7, #0]
      if (__b < __a)
 800a988:	683b      	ldr	r3, [r7, #0]
 800a98a:	681a      	ldr	r2, [r3, #0]
 800a98c:	687b      	ldr	r3, [r7, #4]
 800a98e:	681b      	ldr	r3, [r3, #0]
 800a990:	429a      	cmp	r2, r3
 800a992:	d201      	bcs.n	800a998 <_ZSt3minIjERKT_S2_S2_+0x1a>
	return __b;
 800a994:	683b      	ldr	r3, [r7, #0]
 800a996:	e000      	b.n	800a99a <_ZSt3minIjERKT_S2_S2_+0x1c>
      return __a;
 800a998:	687b      	ldr	r3, [r7, #4]
    }
 800a99a:	4618      	mov	r0, r3
 800a99c:	370c      	adds	r7, #12
 800a99e:	46bd      	mov	sp, r7
 800a9a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9a4:	4770      	bx	lr

0800a9a6 <_ZNK9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 800a9a6:	b480      	push	{r7}
 800a9a8:	b083      	sub	sp, #12
 800a9aa:	af00      	add	r7, sp, #0
 800a9ac:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 800a9ae:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
      }
 800a9b2:	4618      	mov	r0, r3
 800a9b4:	370c      	adds	r7, #12
 800a9b6:	46bd      	mov	sp, r7
 800a9b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9bc:	4770      	bx	lr

0800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>:
    __niter_base(_Iterator __it)
 800a9be:	b480      	push	{r7}
 800a9c0:	b083      	sub	sp, #12
 800a9c2:	af00      	add	r7, sp, #0
 800a9c4:	6078      	str	r0, [r7, #4]
    { return __it; }
 800a9c6:	687b      	ldr	r3, [r7, #4]
 800a9c8:	4618      	mov	r0, r3
 800a9ca:	370c      	adds	r7, #12
 800a9cc:	46bd      	mov	sp, r7
 800a9ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9d2:	4770      	bx	lr

0800a9d4 <_ZSt14__relocate_a_1IPN7desenet22NetworkInterfaceDriver10DescriptorES3_ENSt9enable_ifIXsrSt24__is_bitwise_relocatableIT_vE5valueEPS6_E4typeES8_S8_S8_RSaIT0_E>:
    __relocate_a_1(_Tp* __first, _Tp* __last,
 800a9d4:	b580      	push	{r7, lr}
 800a9d6:	b086      	sub	sp, #24
 800a9d8:	af00      	add	r7, sp, #0
 800a9da:	60f8      	str	r0, [r7, #12]
 800a9dc:	60b9      	str	r1, [r7, #8]
 800a9de:	607a      	str	r2, [r7, #4]
 800a9e0:	603b      	str	r3, [r7, #0]
      ptrdiff_t __count = __last - __first;
 800a9e2:	68ba      	ldr	r2, [r7, #8]
 800a9e4:	68fb      	ldr	r3, [r7, #12]
 800a9e6:	1ad3      	subs	r3, r2, r3
 800a9e8:	109b      	asrs	r3, r3, #2
 800a9ea:	617b      	str	r3, [r7, #20]
      if (__count > 0)
 800a9ec:	697b      	ldr	r3, [r7, #20]
 800a9ee:	2b00      	cmp	r3, #0
 800a9f0:	dd06      	ble.n	800aa00 <_ZSt14__relocate_a_1IPN7desenet22NetworkInterfaceDriver10DescriptorES3_ENSt9enable_ifIXsrSt24__is_bitwise_relocatableIT_vE5valueEPS6_E4typeES8_S8_S8_RSaIT0_E+0x2c>
	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
 800a9f2:	697b      	ldr	r3, [r7, #20]
 800a9f4:	009b      	lsls	r3, r3, #2
 800a9f6:	461a      	mov	r2, r3
 800a9f8:	68f9      	ldr	r1, [r7, #12]
 800a9fa:	6878      	ldr	r0, [r7, #4]
 800a9fc:	f00b fd48 	bl	8016490 <memmove>
      return __result + __count;
 800aa00:	697b      	ldr	r3, [r7, #20]
 800aa02:	009b      	lsls	r3, r3, #2
 800aa04:	687a      	ldr	r2, [r7, #4]
 800aa06:	4413      	add	r3, r2
    }
 800aa08:	4618      	mov	r0, r3
 800aa0a:	3718      	adds	r7, #24
 800aa0c:	46bd      	mov	sp, r7
 800aa0e:	bd80      	pop	{r7, pc}

0800aa10 <_ZSt4moveIRPPN7desenet22NetworkInterfaceDriver10DescriptorEEONSt16remove_referenceIT_E4typeEOS7_>:
    move(_Tp&& __t) noexcept
 800aa10:	b480      	push	{r7}
 800aa12:	b083      	sub	sp, #12
 800aa14:	af00      	add	r7, sp, #0
 800aa16:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800aa18:	687b      	ldr	r3, [r7, #4]
 800aa1a:	4618      	mov	r0, r3
 800aa1c:	370c      	adds	r7, #12
 800aa1e:	46bd      	mov	sp, r7
 800aa20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa24:	4770      	bx	lr

0800aa26 <_ZNSt20__uninitialized_copyILb1EE13__uninit_copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES7_EET0_T_SA_S9_>:
        __uninit_copy(_InputIterator __first, _InputIterator __last,
 800aa26:	b580      	push	{r7, lr}
 800aa28:	b084      	sub	sp, #16
 800aa2a:	af00      	add	r7, sp, #0
 800aa2c:	60f8      	str	r0, [r7, #12]
 800aa2e:	60b9      	str	r1, [r7, #8]
 800aa30:	607a      	str	r2, [r7, #4]
        { return std::copy(__first, __last, __result); }
 800aa32:	687a      	ldr	r2, [r7, #4]
 800aa34:	68b9      	ldr	r1, [r7, #8]
 800aa36:	68f8      	ldr	r0, [r7, #12]
 800aa38:	f000 f81d 	bl	800aa76 <_ZSt4copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_ET0_T_S8_S7_>
 800aa3c:	4603      	mov	r3, r0
 800aa3e:	4618      	mov	r0, r3
 800aa40:	3710      	adds	r7, #16
 800aa42:	46bd      	mov	sp, r7
 800aa44:	bd80      	pop	{r7, pc}

0800aa46 <_ZSt12__niter_wrapIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_RKS5_S5_>:
    __niter_wrap(const _Iterator&, _Iterator __res)
 800aa46:	b480      	push	{r7}
 800aa48:	b083      	sub	sp, #12
 800aa4a:	af00      	add	r7, sp, #0
 800aa4c:	6078      	str	r0, [r7, #4]
 800aa4e:	6039      	str	r1, [r7, #0]
    { return __res; }
 800aa50:	683b      	ldr	r3, [r7, #0]
 800aa52:	4618      	mov	r0, r3
 800aa54:	370c      	adds	r7, #12
 800aa56:	46bd      	mov	sp, r7
 800aa58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa5c:	4770      	bx	lr

0800aa5e <_ZNK9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE8max_sizeEv>:
      max_size() const _GLIBCXX_USE_NOEXCEPT
 800aa5e:	b580      	push	{r7, lr}
 800aa60:	b082      	sub	sp, #8
 800aa62:	af00      	add	r7, sp, #0
 800aa64:	6078      	str	r0, [r7, #4]
      { return _M_max_size(); }
 800aa66:	6878      	ldr	r0, [r7, #4]
 800aa68:	f7ff ff9d 	bl	800a9a6 <_ZNK9__gnu_cxx13new_allocatorIPN7desenet22NetworkInterfaceDriver10DescriptorEE11_M_max_sizeEv>
 800aa6c:	4603      	mov	r3, r0
 800aa6e:	4618      	mov	r0, r3
 800aa70:	3708      	adds	r7, #8
 800aa72:	46bd      	mov	sp, r7
 800aa74:	bd80      	pop	{r7, pc}

0800aa76 <_ZSt4copyISt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEES5_ET0_T_S8_S7_>:
    copy(_II __first, _II __last, _OI __result)
 800aa76:	b590      	push	{r4, r7, lr}
 800aa78:	b085      	sub	sp, #20
 800aa7a:	af00      	add	r7, sp, #0
 800aa7c:	60f8      	str	r0, [r7, #12]
 800aa7e:	60b9      	str	r1, [r7, #8]
 800aa80:	607a      	str	r2, [r7, #4]
	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 800aa82:	68f8      	ldr	r0, [r7, #12]
 800aa84:	f000 f80f 	bl	800aaa6 <_ZSt12__miter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEEDTcl12__miter_basecldtfp_4baseEEESt13move_iteratorIT_E>
 800aa88:	4604      	mov	r4, r0
 800aa8a:	68b8      	ldr	r0, [r7, #8]
 800aa8c:	f000 f80b 	bl	800aaa6 <_ZSt12__miter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEEDTcl12__miter_basecldtfp_4baseEEESt13move_iteratorIT_E>
 800aa90:	4603      	mov	r3, r0
 800aa92:	687a      	ldr	r2, [r7, #4]
 800aa94:	4619      	mov	r1, r3
 800aa96:	4620      	mov	r0, r4
 800aa98:	f000 f816 	bl	800aac8 <_ZSt13__copy_move_aILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>
 800aa9c:	4603      	mov	r3, r0
    }
 800aa9e:	4618      	mov	r0, r3
 800aaa0:	3714      	adds	r7, #20
 800aaa2:	46bd      	mov	sp, r7
 800aaa4:	bd90      	pop	{r4, r7, pc}

0800aaa6 <_ZSt12__miter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEEDTcl12__miter_basecldtfp_4baseEEESt13move_iteratorIT_E>:
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
 800aaa6:	b580      	push	{r7, lr}
 800aaa8:	b082      	sub	sp, #8
 800aaaa:	af00      	add	r7, sp, #0
 800aaac:	6078      	str	r0, [r7, #4]
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
 800aaae:	1d3b      	adds	r3, r7, #4
 800aab0:	4618      	mov	r0, r3
 800aab2:	f000 f82c 	bl	800ab0e <_ZNKSt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEE4baseEv>
 800aab6:	4603      	mov	r3, r0
 800aab8:	4618      	mov	r0, r3
 800aaba:	f000 f834 	bl	800ab26 <_ZSt12__miter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800aabe:	4603      	mov	r3, r0
 800aac0:	4618      	mov	r0, r3
 800aac2:	3708      	adds	r7, #8
 800aac4:	46bd      	mov	sp, r7
 800aac6:	bd80      	pop	{r7, pc}

0800aac8 <_ZSt13__copy_move_aILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>:
    __copy_move_a(_II __first, _II __last, _OI __result)
 800aac8:	b5b0      	push	{r4, r5, r7, lr}
 800aaca:	b084      	sub	sp, #16
 800aacc:	af00      	add	r7, sp, #0
 800aace:	60f8      	str	r0, [r7, #12]
 800aad0:	60b9      	str	r1, [r7, #8]
 800aad2:	607a      	str	r2, [r7, #4]
      return std::__niter_wrap(__result,
 800aad4:	68f8      	ldr	r0, [r7, #12]
 800aad6:	f7ff ff72 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800aada:	4604      	mov	r4, r0
 800aadc:	68b8      	ldr	r0, [r7, #8]
 800aade:	f7ff ff6e 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800aae2:	4605      	mov	r5, r0
 800aae4:	687b      	ldr	r3, [r7, #4]
 800aae6:	4618      	mov	r0, r3
 800aae8:	f7ff ff69 	bl	800a9be <_ZSt12__niter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>
 800aaec:	4603      	mov	r3, r0
 800aaee:	461a      	mov	r2, r3
 800aaf0:	4629      	mov	r1, r5
 800aaf2:	4620      	mov	r0, r4
 800aaf4:	f000 f822 	bl	800ab3c <_ZSt14__copy_move_a1ILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>
 800aaf8:	4602      	mov	r2, r0
 800aafa:	1d3b      	adds	r3, r7, #4
 800aafc:	4611      	mov	r1, r2
 800aafe:	4618      	mov	r0, r3
 800ab00:	f7ff ffa1 	bl	800aa46 <_ZSt12__niter_wrapIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_RKS5_S5_>
 800ab04:	4603      	mov	r3, r0
    }
 800ab06:	4618      	mov	r0, r3
 800ab08:	3710      	adds	r7, #16
 800ab0a:	46bd      	mov	sp, r7
 800ab0c:	bdb0      	pop	{r4, r5, r7, pc}

0800ab0e <_ZNKSt13move_iteratorIPPN7desenet22NetworkInterfaceDriver10DescriptorEE4baseEv>:
      base() const
 800ab0e:	b480      	push	{r7}
 800ab10:	b083      	sub	sp, #12
 800ab12:	af00      	add	r7, sp, #0
 800ab14:	6078      	str	r0, [r7, #4]
      { return _M_current; }
 800ab16:	687b      	ldr	r3, [r7, #4]
 800ab18:	681b      	ldr	r3, [r3, #0]
 800ab1a:	4618      	mov	r0, r3
 800ab1c:	370c      	adds	r7, #12
 800ab1e:	46bd      	mov	sp, r7
 800ab20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab24:	4770      	bx	lr

0800ab26 <_ZSt12__miter_baseIPPN7desenet22NetworkInterfaceDriver10DescriptorEET_S5_>:
    __miter_base(_Iterator __it)
 800ab26:	b480      	push	{r7}
 800ab28:	b083      	sub	sp, #12
 800ab2a:	af00      	add	r7, sp, #0
 800ab2c:	6078      	str	r0, [r7, #4]
    { return __it; }
 800ab2e:	687b      	ldr	r3, [r7, #4]
 800ab30:	4618      	mov	r0, r3
 800ab32:	370c      	adds	r7, #12
 800ab34:	46bd      	mov	sp, r7
 800ab36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab3a:	4770      	bx	lr

0800ab3c <_ZSt14__copy_move_a1ILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>:
    __copy_move_a1(_II __first, _II __last, _OI __result)
 800ab3c:	b580      	push	{r7, lr}
 800ab3e:	b084      	sub	sp, #16
 800ab40:	af00      	add	r7, sp, #0
 800ab42:	60f8      	str	r0, [r7, #12]
 800ab44:	60b9      	str	r1, [r7, #8]
 800ab46:	607a      	str	r2, [r7, #4]
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
 800ab48:	687a      	ldr	r2, [r7, #4]
 800ab4a:	68b9      	ldr	r1, [r7, #8]
 800ab4c:	68f8      	ldr	r0, [r7, #12]
 800ab4e:	f000 f805 	bl	800ab5c <_ZSt14__copy_move_a2ILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>
 800ab52:	4603      	mov	r3, r0
 800ab54:	4618      	mov	r0, r3
 800ab56:	3710      	adds	r7, #16
 800ab58:	46bd      	mov	sp, r7
 800ab5a:	bd80      	pop	{r7, pc}

0800ab5c <_ZSt14__copy_move_a2ILb1EPPN7desenet22NetworkInterfaceDriver10DescriptorES4_ET1_T0_S6_S5_>:
    __copy_move_a2(_II __first, _II __last, _OI __result)
 800ab5c:	b580      	push	{r7, lr}
 800ab5e:	b084      	sub	sp, #16
 800ab60:	af00      	add	r7, sp, #0
 800ab62:	60f8      	str	r0, [r7, #12]
 800ab64:	60b9      	str	r1, [r7, #8]
 800ab66:	607a      	str	r2, [r7, #4]
			      _Category>::__copy_m(__first, __last, __result);
 800ab68:	687a      	ldr	r2, [r7, #4]
 800ab6a:	68b9      	ldr	r1, [r7, #8]
 800ab6c:	68f8      	ldr	r0, [r7, #12]
 800ab6e:	f000 f805 	bl	800ab7c <_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIPN7desenet22NetworkInterfaceDriver10DescriptorEEEPT_PKS7_SA_S8_>
 800ab72:	4603      	mov	r3, r0
    }
 800ab74:	4618      	mov	r0, r3
 800ab76:	3710      	adds	r7, #16
 800ab78:	46bd      	mov	sp, r7
 800ab7a:	bd80      	pop	{r7, pc}

0800ab7c <_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIPN7desenet22NetworkInterfaceDriver10DescriptorEEEPT_PKS7_SA_S8_>:
	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 800ab7c:	b580      	push	{r7, lr}
 800ab7e:	b086      	sub	sp, #24
 800ab80:	af00      	add	r7, sp, #0
 800ab82:	60f8      	str	r0, [r7, #12]
 800ab84:	60b9      	str	r1, [r7, #8]
 800ab86:	607a      	str	r2, [r7, #4]
	  const ptrdiff_t _Num = __last - __first;
 800ab88:	68ba      	ldr	r2, [r7, #8]
 800ab8a:	68fb      	ldr	r3, [r7, #12]
 800ab8c:	1ad3      	subs	r3, r2, r3
 800ab8e:	109b      	asrs	r3, r3, #2
 800ab90:	617b      	str	r3, [r7, #20]
	  if (_Num)
 800ab92:	697b      	ldr	r3, [r7, #20]
 800ab94:	2b00      	cmp	r3, #0
 800ab96:	d006      	beq.n	800aba6 <_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIPN7desenet22NetworkInterfaceDriver10DescriptorEEEPT_PKS7_SA_S8_+0x2a>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
 800ab98:	697b      	ldr	r3, [r7, #20]
 800ab9a:	009b      	lsls	r3, r3, #2
 800ab9c:	461a      	mov	r2, r3
 800ab9e:	68f9      	ldr	r1, [r7, #12]
 800aba0:	6878      	ldr	r0, [r7, #4]
 800aba2:	f00b fc75 	bl	8016490 <memmove>
	  return __result + _Num;
 800aba6:	697b      	ldr	r3, [r7, #20]
 800aba8:	009b      	lsls	r3, r3, #2
 800abaa:	687a      	ldr	r2, [r7, #4]
 800abac:	4413      	add	r3, r2
	}
 800abae:	4618      	mov	r0, r3
 800abb0:	3718      	adds	r7, #24
 800abb2:	46bd      	mov	sp, r7
 800abb4:	bd80      	pop	{r7, pc}

0800abb6 <_ZN7desenet19NetworkTimeProvider18currentNetworkTimeEv>:

namespace desenet {

//static
NetworkTime NetworkTimeProvider::currentNetworkTime()
{
 800abb6:	b590      	push	{r4, r7, lr}
 800abb8:	b083      	sub	sp, #12
 800abba:	af00      	add	r7, sp, #0
	const TTime currentTime = TTime::currentTime();
 800abbc:	463b      	mov	r3, r7
 800abbe:	4618      	mov	r0, r3
 800abc0:	f7fd fe64 	bl	800888c <_ZN5TTime11currentTimeEv>

	// Get the actual time and count milliseconds since midnight.
	return currentTime.getMds();
 800abc4:	463b      	mov	r3, r7
 800abc6:	4618      	mov	r0, r3
 800abc8:	f7fd fe74 	bl	80088b4 <_ZNK5TTime6getMdsEv>
 800abcc:	4604      	mov	r4, r0
 800abce:	bf00      	nop
	const TTime currentTime = TTime::currentTime();
 800abd0:	463b      	mov	r3, r7
 800abd2:	4618      	mov	r0, r3
 800abd4:	f7fd fe4f 	bl	8008876 <_ZN5TTimeD1Ev>
	return currentTime.getMds();
 800abd8:	4623      	mov	r3, r4
}
 800abda:	4618      	mov	r0, r3
 800abdc:	370c      	adds	r7, #12
 800abde:	46bd      	mov	sp, r7
 800abe0:	bd90      	pop	{r4, r7, pc}

0800abe2 <_ZN7desenet6sensor19AbstractApplication13svSyncRequestEv>:
*********************************************************************************************************/

// Default implementations.

void AbstractApplication::svSyncRequest()
{
 800abe2:	b580      	push	{r7, lr}
 800abe4:	b082      	sub	sp, #8
 800abe6:	af00      	add	r7, sp, #0
 800abe8:	6078      	str	r0, [r7, #4]
    // Register application using the network entity
    NetworkEntity::instance().svSyncRequest(this);
 800abea:	f000 fc45 	bl	800b478 <_ZN7desenet6sensor13NetworkEntity8instanceEv>
 800abee:	4603      	mov	r3, r0
 800abf0:	6879      	ldr	r1, [r7, #4]
 800abf2:	4618      	mov	r0, r3
 800abf4:	f000 fddb 	bl	800b7ae <_ZN7desenet6sensor13NetworkEntity13svSyncRequestEPNS0_19AbstractApplicationE>
/***Net::instance().entity().svSyncRequest(this);****/   // possible as well !
}
 800abf8:	bf00      	nop
 800abfa:	3708      	adds	r7, #8
 800abfc:	46bd      	mov	sp, r7
 800abfe:	bd80      	pop	{r7, pc}

0800ac00 <_ZN7desenet6sensor19AbstractApplication16svPublishRequestEh>:

// limited with 16 sample slots => add new inscription to list only when this method reutrns true!
bool AbstractApplication::svPublishRequest(SvGroup group)
{
 800ac00:	b580      	push	{r7, lr}
 800ac02:	b082      	sub	sp, #8
 800ac04:	af00      	add	r7, sp, #0
 800ac06:	6078      	str	r0, [r7, #4]
 800ac08:	460b      	mov	r3, r1
 800ac0a:	70fb      	strb	r3, [r7, #3]
    // Register application for the provided group using the network entity
    return NetworkEntity::instance().svPublishRequest(this, group);
 800ac0c:	f000 fc34 	bl	800b478 <_ZN7desenet6sensor13NetworkEntity8instanceEv>
 800ac10:	78fb      	ldrb	r3, [r7, #3]
 800ac12:	461a      	mov	r2, r3
 800ac14:	6879      	ldr	r1, [r7, #4]
 800ac16:	f000 fdda 	bl	800b7ce <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh>
 800ac1a:	4603      	mov	r3, r0
}
 800ac1c:	4618      	mov	r0, r3
 800ac1e:	3708      	adds	r7, #8
 800ac20:	46bd      	mov	sp, r7
 800ac22:	bd80      	pop	{r7, pc}

0800ac24 <_ZN7desenet6sensor19AbstractApplication16evPublishRequestEtRKN3hei12SharedBufferIhEE>:

void AbstractApplication::evPublishRequest(EvId id, const SharedByteBuffer & evData)
{
 800ac24:	b580      	push	{r7, lr}
 800ac26:	b082      	sub	sp, #8
 800ac28:	af00      	add	r7, sp, #0
 800ac2a:	4603      	mov	r3, r0
 800ac2c:	6039      	str	r1, [r7, #0]
 800ac2e:	80fb      	strh	r3, [r7, #6]
    // Publish event data
    NetworkEntity::instance().evPublishRequest(id, evData);
 800ac30:	f000 fc22 	bl	800b478 <_ZN7desenet6sensor13NetworkEntity8instanceEv>
 800ac34:	88fb      	ldrh	r3, [r7, #6]
 800ac36:	683a      	ldr	r2, [r7, #0]
 800ac38:	4619      	mov	r1, r3
 800ac3a:	f000 fe01 	bl	800b840 <_ZN7desenet6sensor13NetworkEntity16evPublishRequestEtRKN3hei12SharedBufferIhEE>
}
 800ac3e:	bf00      	nop
 800ac40:	3708      	adds	r7, #8
 800ac42:	46bd      	mov	sp, r7
 800ac44:	bd80      	pop	{r7, pc}

0800ac46 <_ZN7desenet6sensor19AbstractApplication16svSyncIndicationEm>:

/**
 * Default callback method for syncs
 */
void AbstractApplication::svSyncIndication(desenet::NetworkTime)
{
 800ac46:	b480      	push	{r7}
 800ac48:	b083      	sub	sp, #12
 800ac4a:	af00      	add	r7, sp, #0
 800ac4c:	6078      	str	r0, [r7, #4]
 800ac4e:	6039      	str	r1, [r7, #0]
    // due to polymorphism never landing here! --> it is desired to call svSyncIndication() of Accelerometer!
}
 800ac50:	bf00      	nop
 800ac52:	370c      	adds	r7, #12
 800ac54:	46bd      	mov	sp, r7
 800ac56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac5a:	4770      	bx	lr

0800ac5c <_ZN7desenet6sensor19AbstractApplication19svPublishIndicationEhRN3hei12SharedBufferIhEE>:

/**
 * Default callback method for SV publishes
 */
SharedByteBuffer::sizeType AbstractApplication::svPublishIndication(SvGroup, SharedByteBuffer &)
{
 800ac5c:	b480      	push	{r7}
 800ac5e:	b085      	sub	sp, #20
 800ac60:	af00      	add	r7, sp, #0
 800ac62:	60f8      	str	r0, [r7, #12]
 800ac64:	460b      	mov	r3, r1
 800ac66:	607a      	str	r2, [r7, #4]
 800ac68:	72fb      	strb	r3, [r7, #11]
    return 0;
 800ac6a:	2300      	movs	r3, #0
}
 800ac6c:	4618      	mov	r0, r3
 800ac6e:	3714      	adds	r7, #20
 800ac70:	46bd      	mov	sp, r7
 800ac72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac76:	4770      	bx	lr

0800ac78 <_Z41__static_initialization_and_destruction_0ii>:
 800ac78:	b580      	push	{r7, lr}
 800ac7a:	b088      	sub	sp, #32
 800ac7c:	af00      	add	r7, sp, #0
 800ac7e:	6078      	str	r0, [r7, #4]
 800ac80:	6039      	str	r1, [r7, #0]
 800ac82:	687b      	ldr	r3, [r7, #4]
 800ac84:	2b01      	cmp	r3, #1
 800ac86:	d122      	bne.n	800acce <_Z41__static_initialization_and_destruction_0ii+0x56>
 800ac88:	683b      	ldr	r3, [r7, #0]
 800ac8a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ac8e:	4293      	cmp	r3, r2
 800ac90:	d11d      	bne.n	800acce <_Z41__static_initialization_and_destruction_0ii+0x56>
 800ac92:	4b18      	ldr	r3, [pc, #96]	; (800acf4 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800ac94:	681b      	ldr	r3, [r3, #0]
 800ac96:	613b      	str	r3, [r7, #16]
 800ac98:	f107 0310 	add.w	r3, r7, #16
 800ac9c:	60bb      	str	r3, [r7, #8]
 800ac9e:	2304      	movs	r3, #4
 800aca0:	60fb      	str	r3, [r7, #12]
 800aca2:	f107 0308 	add.w	r3, r7, #8
 800aca6:	e893 0006 	ldmia.w	r3, {r1, r2}
 800acaa:	4813      	ldr	r0, [pc, #76]	; (800acf8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800acac:	f7fc f842 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800acb0:	4b12      	ldr	r3, [pc, #72]	; (800acfc <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800acb2:	681b      	ldr	r3, [r3, #0]
 800acb4:	61fb      	str	r3, [r7, #28]
 800acb6:	f107 031c 	add.w	r3, r7, #28
 800acba:	617b      	str	r3, [r7, #20]
 800acbc:	2304      	movs	r3, #4
 800acbe:	61bb      	str	r3, [r7, #24]
 800acc0:	f107 0314 	add.w	r3, r7, #20
 800acc4:	e893 0006 	ldmia.w	r3, {r1, r2}
 800acc8:	480d      	ldr	r0, [pc, #52]	; (800ad00 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800acca:	f7fc f833 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	2b00      	cmp	r3, #0
 800acd2:	d10a      	bne.n	800acea <_Z41__static_initialization_and_destruction_0ii+0x72>
 800acd4:	683b      	ldr	r3, [r7, #0]
 800acd6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800acda:	4293      	cmp	r3, r2
 800acdc:	d105      	bne.n	800acea <_Z41__static_initialization_and_destruction_0ii+0x72>
 800acde:	4808      	ldr	r0, [pc, #32]	; (800ad00 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800ace0:	f7fc f972 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800ace4:	4804      	ldr	r0, [pc, #16]	; (800acf8 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800ace6:	f7fc f96f 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800acea:	bf00      	nop
 800acec:	3720      	adds	r7, #32
 800acee:	46bd      	mov	sp, r7
 800acf0:	bd80      	pop	{r7, pc}
 800acf2:	bf00      	nop
 800acf4:	080187dc 	.word	0x080187dc
 800acf8:	20001900 	.word	0x20001900
 800acfc:	080187e0 	.word	0x080187e0
 800ad00:	20001908 	.word	0x20001908

0800ad04 <_GLOBAL__sub_I__ZN7desenet6sensor19AbstractApplication13svSyncRequestEv>:
 800ad04:	b580      	push	{r7, lr}
 800ad06:	af00      	add	r7, sp, #0
 800ad08:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ad0c:	2001      	movs	r0, #1
 800ad0e:	f7ff ffb3 	bl	800ac78 <_Z41__static_initialization_and_destruction_0ii>
 800ad12:	bd80      	pop	{r7, pc}

0800ad14 <_GLOBAL__sub_D__ZN7desenet6sensor19AbstractApplication13svSyncRequestEv>:
 800ad14:	b580      	push	{r7, lr}
 800ad16:	af00      	add	r7, sp, #0
 800ad18:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ad1c:	2000      	movs	r0, #0
 800ad1e:	f7ff ffab 	bl	800ac78 <_Z41__static_initialization_and_destruction_0ii>
 800ad22:	bd80      	pop	{r7, pc}

0800ad24 <_ZN7desenet6sensor3NetC1Ev>:
namespace desenet {
namespace sensor {

Net * Net::_pInstance(nullptr);		// Instantiation of static attribute

Net::Net()
 800ad24:	b580      	push	{r7, lr}
 800ad26:	b082      	sub	sp, #8
 800ad28:	af00      	add	r7, sp, #0
 800ad2a:	6078      	str	r0, [r7, #4]
 : _pNetworkInterfaceDriver(nullptr)
 800ad2c:	4a11      	ldr	r2, [pc, #68]	; (800ad74 <_ZN7desenet6sensor3NetC1Ev+0x50>)
 800ad2e:	687b      	ldr	r3, [r7, #4]
 800ad30:	601a      	str	r2, [r3, #0]
 800ad32:	687b      	ldr	r3, [r7, #4]
 800ad34:	3304      	adds	r3, #4
 800ad36:	4618      	mov	r0, r3
 800ad38:	f000 fa1a 	bl	800b170 <_ZN7desenet6sensor13NetworkEntityC1Ev>
 800ad3c:	687b      	ldr	r3, [r7, #4]
 800ad3e:	2200      	movs	r2, #0
 800ad40:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 800ad44:	687b      	ldr	r3, [r7, #4]
 800ad46:	338c      	adds	r3, #140	; 0x8c
 800ad48:	4618      	mov	r0, r3
 800ad4a:	f008 f82d 	bl	8012da8 <_ZN7desenet15TimeSlotManagerC1Ev>
{
    assert(!_pInstance);		// Only one instance allowed
 800ad4e:	4b0a      	ldr	r3, [pc, #40]	; (800ad78 <_ZN7desenet6sensor3NetC1Ev+0x54>)
 800ad50:	681b      	ldr	r3, [r3, #0]
 800ad52:	2b00      	cmp	r3, #0
 800ad54:	d005      	beq.n	800ad62 <_ZN7desenet6sensor3NetC1Ev+0x3e>
 800ad56:	4b09      	ldr	r3, [pc, #36]	; (800ad7c <_ZN7desenet6sensor3NetC1Ev+0x58>)
 800ad58:	4a09      	ldr	r2, [pc, #36]	; (800ad80 <_ZN7desenet6sensor3NetC1Ev+0x5c>)
 800ad5a:	210f      	movs	r1, #15
 800ad5c:	4809      	ldr	r0, [pc, #36]	; (800ad84 <_ZN7desenet6sensor3NetC1Ev+0x60>)
 800ad5e:	f00b fb19 	bl	8016394 <__assert_func>
    _pInstance = this;
 800ad62:	4a05      	ldr	r2, [pc, #20]	; (800ad78 <_ZN7desenet6sensor3NetC1Ev+0x54>)
 800ad64:	687b      	ldr	r3, [r7, #4]
 800ad66:	6013      	str	r3, [r2, #0]
}
 800ad68:	687b      	ldr	r3, [r7, #4]
 800ad6a:	4618      	mov	r0, r3
 800ad6c:	3708      	adds	r7, #8
 800ad6e:	46bd      	mov	sp, r7
 800ad70:	bd80      	pop	{r7, pc}
 800ad72:	bf00      	nop
 800ad74:	0801ba20 	.word	0x0801ba20
 800ad78:	20001920 	.word	0x20001920
 800ad7c:	080187e4 	.word	0x080187e4
 800ad80:	080187f0 	.word	0x080187f0
 800ad84:	0801880c 	.word	0x0801880c

0800ad88 <_ZN7desenet6sensor3NetD1Ev>:

Net::~Net()
 800ad88:	b580      	push	{r7, lr}
 800ad8a:	b082      	sub	sp, #8
 800ad8c:	af00      	add	r7, sp, #0
 800ad8e:	6078      	str	r0, [r7, #4]
 800ad90:	4a08      	ldr	r2, [pc, #32]	; (800adb4 <_ZN7desenet6sensor3NetD1Ev+0x2c>)
 800ad92:	687b      	ldr	r3, [r7, #4]
 800ad94:	601a      	str	r2, [r3, #0]
 800ad96:	687b      	ldr	r3, [r7, #4]
 800ad98:	338c      	adds	r3, #140	; 0x8c
 800ad9a:	4618      	mov	r0, r3
 800ad9c:	f008 f856 	bl	8012e4c <_ZN7desenet15TimeSlotManagerD1Ev>
 800ada0:	687b      	ldr	r3, [r7, #4]
 800ada2:	3304      	adds	r3, #4
 800ada4:	4618      	mov	r0, r3
 800ada6:	f000 fa1f 	bl	800b1e8 <_ZN7desenet6sensor13NetworkEntityD1Ev>
{
}
 800adaa:	687b      	ldr	r3, [r7, #4]
 800adac:	4618      	mov	r0, r3
 800adae:	3708      	adds	r7, #8
 800adb0:	46bd      	mov	sp, r7
 800adb2:	bd80      	pop	{r7, pc}
 800adb4:	0801ba20 	.word	0x0801ba20

0800adb8 <_ZN7desenet6sensor3NetD0Ev>:
Net::~Net()
 800adb8:	b580      	push	{r7, lr}
 800adba:	b082      	sub	sp, #8
 800adbc:	af00      	add	r7, sp, #0
 800adbe:	6078      	str	r0, [r7, #4]
}
 800adc0:	6878      	ldr	r0, [r7, #4]
 800adc2:	f7ff ffe1 	bl	800ad88 <_ZN7desenet6sensor3NetD1Ev>
 800adc6:	21ac      	movs	r1, #172	; 0xac
 800adc8:	6878      	ldr	r0, [r7, #4]
 800adca:	f00b f9ef 	bl	80161ac <_ZdlPvj>
 800adce:	687b      	ldr	r3, [r7, #4]
 800add0:	4618      	mov	r0, r3
 800add2:	3708      	adds	r7, #8
 800add4:	46bd      	mov	sp, r7
 800add6:	bd80      	pop	{r7, pc}

0800add8 <_ZN7desenet6sensor3Net10initializeERKh>:

void Net::initialize(const desenet::SlotNumber & slotNumber)
{
 800add8:	b590      	push	{r4, r7, lr}
 800adda:	b08f      	sub	sp, #60	; 0x3c
 800addc:	af00      	add	r7, sp, #0
 800adde:	6078      	str	r0, [r7, #4]
 800ade0:	6039      	str	r1, [r7, #0]
    char sensorName[16];

    _networkEntity.initialize();
 800ade2:	687b      	ldr	r3, [r7, #4]
 800ade4:	3304      	adds	r3, #4
 800ade6:	4618      	mov	r0, r3
 800ade8:	f000 fa2c 	bl	800b244 <_ZN7desenet6sensor13NetworkEntity10initializeEv>
    _timeSlotManager.initialize(slotNumber);
 800adec:	687b      	ldr	r3, [r7, #4]
 800adee:	338c      	adds	r3, #140	; 0x8c
 800adf0:	6839      	ldr	r1, [r7, #0]
 800adf2:	4618      	mov	r0, r3
 800adf4:	f008 f85e 	bl	8012eb4 <_ZN7desenet15TimeSlotManager10initializeERKh>

    snprintf(sensorName, 16, "Sensor %d", slotNumber);
 800adf8:	683b      	ldr	r3, [r7, #0]
 800adfa:	781b      	ldrb	r3, [r3, #0]
 800adfc:	f107 000c 	add.w	r0, r7, #12
 800ae00:	4a22      	ldr	r2, [pc, #136]	; (800ae8c <_ZN7desenet6sensor3Net10initializeERKh+0xb4>)
 800ae02:	2110      	movs	r1, #16
 800ae04:	f00b ff88 	bl	8016d18 <sniprintf>

    _pNetworkInterfaceDriver = instanciateNic(*(uint32_t *)SENSOR_ADDRESS.data(), sensorName);
 800ae08:	4821      	ldr	r0, [pc, #132]	; (800ae90 <_ZN7desenet6sensor3Net10initializeERKh+0xb8>)
 800ae0a:	f7fe fa15 	bl	8009238 <_ZNK3phy7AddressILj4EE4dataEv>
 800ae0e:	4603      	mov	r3, r0
 800ae10:	681c      	ldr	r4, [r3, #0]
 800ae12:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800ae16:	4618      	mov	r0, r3
 800ae18:	f00b f9f1 	bl	80161fe <_ZNSaIcEC1Ev>
 800ae1c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800ae20:	f107 010c 	add.w	r1, r7, #12
 800ae24:	f107 031c 	add.w	r3, r7, #28
 800ae28:	4618      	mov	r0, r3
 800ae2a:	f00b fa79 	bl	8016320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_>
 800ae2e:	f107 031c 	add.w	r3, r7, #28
 800ae32:	4619      	mov	r1, r3
 800ae34:	4620      	mov	r0, r4
 800ae36:	f007 fc13 	bl	8012660 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>
 800ae3a:	4602      	mov	r2, r0
 800ae3c:	687b      	ldr	r3, [r7, #4]
 800ae3e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 800ae42:	f107 031c 	add.w	r3, r7, #28
 800ae46:	4618      	mov	r0, r3
 800ae48:	f00b fa33 	bl	80162b2 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev>
 800ae4c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800ae50:	4618      	mov	r0, r3
 800ae52:	f00b f9d5 	bl	8016200 <_ZNSaIcED1Ev>
    _pNetworkInterfaceDriver->initialize();
 800ae56:	687b      	ldr	r3, [r7, #4]
 800ae58:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800ae5c:	687b      	ldr	r3, [r7, #4]
 800ae5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ae62:	681b      	ldr	r3, [r3, #0]
 800ae64:	330c      	adds	r3, #12
 800ae66:	681b      	ldr	r3, [r3, #0]
 800ae68:	4610      	mov	r0, r2
 800ae6a:	4798      	blx	r3

    _networkEntity.initializeRelations(_timeSlotManager, *_pNetworkInterfaceDriver);
 800ae6c:	687b      	ldr	r3, [r7, #4]
 800ae6e:	1d18      	adds	r0, r3, #4
 800ae70:	687b      	ldr	r3, [r7, #4]
 800ae72:	f103 018c 	add.w	r1, r3, #140	; 0x8c
 800ae76:	687b      	ldr	r3, [r7, #4]
 800ae78:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ae7c:	461a      	mov	r2, r3
 800ae7e:	f000 fa93 	bl	800b3a8 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE>

    // TODO: Add additional initialization code here
}
 800ae82:	bf00      	nop
 800ae84:	373c      	adds	r7, #60	; 0x3c
 800ae86:	46bd      	mov	sp, r7
 800ae88:	bd90      	pop	{r4, r7, pc}
 800ae8a:	bf00      	nop
 800ae8c:	08018884 	.word	0x08018884
 800ae90:	20001918 	.word	0x20001918

0800ae94 <_ZN7desenet6sensor3Net5startEv>:

void Net::start()
{
 800ae94:	b580      	push	{r7, lr}
 800ae96:	b082      	sub	sp, #8
 800ae98:	af00      	add	r7, sp, #0
 800ae9a:	6078      	str	r0, [r7, #4]
    _timeSlotManager.start();
 800ae9c:	687b      	ldr	r3, [r7, #4]
 800ae9e:	338c      	adds	r3, #140	; 0x8c
 800aea0:	4618      	mov	r0, r3
 800aea2:	f008 f84e 	bl	8012f42 <_ZN7desenet15TimeSlotManager5startEv>
}
 800aea6:	bf00      	nop
 800aea8:	3708      	adds	r7, #8
 800aeaa:	46bd      	mov	sp, r7
 800aeac:	bd80      	pop	{r7, pc}
	...

0800aeb0 <_Z41__static_initialization_and_destruction_0ii>:
    assert(_pInstance);
    return *_pInstance;
}

} // sensor
} // desenet
 800aeb0:	b580      	push	{r7, lr}
 800aeb2:	b088      	sub	sp, #32
 800aeb4:	af00      	add	r7, sp, #0
 800aeb6:	6078      	str	r0, [r7, #4]
 800aeb8:	6039      	str	r1, [r7, #0]
 800aeba:	687b      	ldr	r3, [r7, #4]
 800aebc:	2b01      	cmp	r3, #1
 800aebe:	d122      	bne.n	800af06 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800aec0:	683b      	ldr	r3, [r7, #0]
 800aec2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800aec6:	4293      	cmp	r3, r2
 800aec8:	d11d      	bne.n	800af06 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800aeca:	4b18      	ldr	r3, [pc, #96]	; (800af2c <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800aecc:	681b      	ldr	r3, [r3, #0]
 800aece:	613b      	str	r3, [r7, #16]
 800aed0:	f107 0310 	add.w	r3, r7, #16
 800aed4:	60bb      	str	r3, [r7, #8]
 800aed6:	2304      	movs	r3, #4
 800aed8:	60fb      	str	r3, [r7, #12]
 800aeda:	f107 0308 	add.w	r3, r7, #8
 800aede:	e893 0006 	ldmia.w	r3, {r1, r2}
 800aee2:	4813      	ldr	r0, [pc, #76]	; (800af30 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800aee4:	f7fb ff26 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800aee8:	4b12      	ldr	r3, [pc, #72]	; (800af34 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800aeea:	681b      	ldr	r3, [r3, #0]
 800aeec:	61fb      	str	r3, [r7, #28]
 800aeee:	f107 031c 	add.w	r3, r7, #28
 800aef2:	617b      	str	r3, [r7, #20]
 800aef4:	2304      	movs	r3, #4
 800aef6:	61bb      	str	r3, [r7, #24]
 800aef8:	f107 0314 	add.w	r3, r7, #20
 800aefc:	e893 0006 	ldmia.w	r3, {r1, r2}
 800af00:	480d      	ldr	r0, [pc, #52]	; (800af38 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800af02:	f7fb ff17 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800af06:	687b      	ldr	r3, [r7, #4]
 800af08:	2b00      	cmp	r3, #0
 800af0a:	d10a      	bne.n	800af22 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800af0c:	683b      	ldr	r3, [r7, #0]
 800af0e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800af12:	4293      	cmp	r3, r2
 800af14:	d105      	bne.n	800af22 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800af16:	4808      	ldr	r0, [pc, #32]	; (800af38 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800af18:	f7fc f856 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800af1c:	4804      	ldr	r0, [pc, #16]	; (800af30 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800af1e:	f7fc f853 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800af22:	bf00      	nop
 800af24:	3720      	adds	r7, #32
 800af26:	46bd      	mov	sp, r7
 800af28:	bd80      	pop	{r7, pc}
 800af2a:	bf00      	nop
 800af2c:	080189c4 	.word	0x080189c4
 800af30:	20001910 	.word	0x20001910
 800af34:	080189c8 	.word	0x080189c8
 800af38:	20001918 	.word	0x20001918

0800af3c <_GLOBAL__sub_I__ZN7desenet6sensor3Net10_pInstanceE>:
 800af3c:	b580      	push	{r7, lr}
 800af3e:	af00      	add	r7, sp, #0
 800af40:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800af44:	2001      	movs	r0, #1
 800af46:	f7ff ffb3 	bl	800aeb0 <_Z41__static_initialization_and_destruction_0ii>
 800af4a:	bd80      	pop	{r7, pc}

0800af4c <_GLOBAL__sub_D__ZN7desenet6sensor3Net10_pInstanceE>:
 800af4c:	b580      	push	{r7, lr}
 800af4e:	af00      	add	r7, sp, #0
 800af50:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800af54:	2000      	movs	r0, #0
 800af56:	f7ff ffab 	bl	800aeb0 <_Z41__static_initialization_and_destruction_0ii>
 800af5a:	bd80      	pop	{r7, pc}

0800af5c <_ZNSt8__detail17_List_node_headerC1Ev>:
    {
#if _GLIBCXX_USE_CXX11_ABI
      std::size_t _M_size;
#endif

      _List_node_header() _GLIBCXX_NOEXCEPT
 800af5c:	b580      	push	{r7, lr}
 800af5e:	b082      	sub	sp, #8
 800af60:	af00      	add	r7, sp, #0
 800af62:	6078      	str	r0, [r7, #4]
      { _M_init(); }
 800af64:	6878      	ldr	r0, [r7, #4]
 800af66:	f000 f805 	bl	800af74 <_ZNSt8__detail17_List_node_header7_M_initEv>
 800af6a:	687b      	ldr	r3, [r7, #4]
 800af6c:	4618      	mov	r0, r3
 800af6e:	3708      	adds	r7, #8
 800af70:	46bd      	mov	sp, r7
 800af72:	bd80      	pop	{r7, pc}

0800af74 <_ZNSt8__detail17_List_node_header7_M_initEv>:
	  }
      }
#endif

      void
      _M_init() _GLIBCXX_NOEXCEPT
 800af74:	b480      	push	{r7}
 800af76:	b083      	sub	sp, #12
 800af78:	af00      	add	r7, sp, #0
 800af7a:	6078      	str	r0, [r7, #4]
      {
	this->_M_next = this->_M_prev = this;
 800af7c:	687a      	ldr	r2, [r7, #4]
 800af7e:	687b      	ldr	r3, [r7, #4]
 800af80:	605a      	str	r2, [r3, #4]
 800af82:	687b      	ldr	r3, [r7, #4]
 800af84:	685a      	ldr	r2, [r3, #4]
 800af86:	687b      	ldr	r3, [r7, #4]
 800af88:	601a      	str	r2, [r3, #0]
#if _GLIBCXX_USE_CXX11_ABI
	this->_M_size = 0;
 800af8a:	687b      	ldr	r3, [r7, #4]
 800af8c:	2200      	movs	r2, #0
 800af8e:	609a      	str	r2, [r3, #8]
#endif
      }
 800af90:	bf00      	nop
 800af92:	370c      	adds	r7, #12
 800af94:	46bd      	mov	sp, r7
 800af96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af9a:	4770      	bx	lr

0800af9c <_ZNSt12_Base_bitsetILj1EE11_S_whichbitEj>:
      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
 800af9c:	b480      	push	{r7}
 800af9e:	b083      	sub	sp, #12
 800afa0:	af00      	add	r7, sp, #0
 800afa2:	6078      	str	r0, [r7, #4]
      {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 800afa4:	687b      	ldr	r3, [r7, #4]
 800afa6:	f003 031f 	and.w	r3, r3, #31
 800afaa:	4618      	mov	r0, r3
 800afac:	370c      	adds	r7, #12
 800afae:	46bd      	mov	sp, r7
 800afb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afb4:	4770      	bx	lr

0800afb6 <_ZNSt12_Base_bitsetILj1EE10_S_maskbitEj>:
      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
 800afb6:	b580      	push	{r7, lr}
 800afb8:	b082      	sub	sp, #8
 800afba:	af00      	add	r7, sp, #0
 800afbc:	6078      	str	r0, [r7, #4]
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 800afbe:	6878      	ldr	r0, [r7, #4]
 800afc0:	f7ff ffec 	bl	800af9c <_ZNSt12_Base_bitsetILj1EE11_S_whichbitEj>
 800afc4:	4603      	mov	r3, r0
 800afc6:	2201      	movs	r2, #1
 800afc8:	fa02 f303 	lsl.w	r3, r2, r3
 800afcc:	4618      	mov	r0, r3
 800afce:	3708      	adds	r7, #8
 800afd0:	46bd      	mov	sp, r7
 800afd2:	bd80      	pop	{r7, pc}

0800afd4 <_ZNSt12_Base_bitsetILj1EE10_M_getwordEj>:
      _M_getword(size_t) _GLIBCXX_NOEXCEPT
 800afd4:	b480      	push	{r7}
 800afd6:	b083      	sub	sp, #12
 800afd8:	af00      	add	r7, sp, #0
 800afda:	6078      	str	r0, [r7, #4]
 800afdc:	6039      	str	r1, [r7, #0]
      { return _M_w; }
 800afde:	687b      	ldr	r3, [r7, #4]
 800afe0:	4618      	mov	r0, r3
 800afe2:	370c      	adds	r7, #12
 800afe4:	46bd      	mov	sp, r7
 800afe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afea:	4770      	bx	lr

0800afec <_ZNSt9_Any_data9_M_accessEv>:
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void*       _M_access()       { return &_M_pod_data[0]; }
 800afec:	b480      	push	{r7}
 800afee:	b083      	sub	sp, #12
 800aff0:	af00      	add	r7, sp, #0
 800aff2:	6078      	str	r0, [r7, #4]
 800aff4:	687b      	ldr	r3, [r7, #4]
 800aff6:	4618      	mov	r0, r3
 800aff8:	370c      	adds	r7, #12
 800affa:	46bd      	mov	sp, r7
 800affc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b000:	4770      	bx	lr

0800b002 <_ZNKSt9_Any_data9_M_accessEv>:
    const void* _M_access() const { return &_M_pod_data[0]; }
 800b002:	b480      	push	{r7}
 800b004:	b083      	sub	sp, #12
 800b006:	af00      	add	r7, sp, #0
 800b008:	6078      	str	r0, [r7, #4]
 800b00a:	687b      	ldr	r3, [r7, #4]
 800b00c:	4618      	mov	r0, r3
 800b00e:	370c      	adds	r7, #12
 800b010:	46bd      	mov	sp, r7
 800b012:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b016:	4770      	bx	lr

0800b018 <_ZNSt14_Function_baseC1Ev>:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }
 800b018:	b480      	push	{r7}
 800b01a:	b083      	sub	sp, #12
 800b01c:	af00      	add	r7, sp, #0
 800b01e:	6078      	str	r0, [r7, #4]
 800b020:	687b      	ldr	r3, [r7, #4]
 800b022:	2200      	movs	r2, #0
 800b024:	609a      	str	r2, [r3, #8]
 800b026:	687b      	ldr	r3, [r7, #4]
 800b028:	4618      	mov	r0, r3
 800b02a:	370c      	adds	r7, #12
 800b02c:	46bd      	mov	sp, r7
 800b02e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b032:	4770      	bx	lr

0800b034 <_ZNSt14_Function_baseD1Ev>:

    ~_Function_base()
 800b034:	b580      	push	{r7, lr}
 800b036:	b082      	sub	sp, #8
 800b038:	af00      	add	r7, sp, #0
 800b03a:	6078      	str	r0, [r7, #4]
    {
      if (_M_manager)
 800b03c:	687b      	ldr	r3, [r7, #4]
 800b03e:	689b      	ldr	r3, [r3, #8]
 800b040:	2b00      	cmp	r3, #0
 800b042:	d005      	beq.n	800b050 <_ZNSt14_Function_baseD1Ev+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 800b044:	687b      	ldr	r3, [r7, #4]
 800b046:	689b      	ldr	r3, [r3, #8]
 800b048:	6878      	ldr	r0, [r7, #4]
 800b04a:	6879      	ldr	r1, [r7, #4]
 800b04c:	2203      	movs	r2, #3
 800b04e:	4798      	blx	r3
    }
 800b050:	687b      	ldr	r3, [r7, #4]
 800b052:	4618      	mov	r0, r3
 800b054:	3708      	adds	r7, #8
 800b056:	46bd      	mov	sp, r7
 800b058:	bd80      	pop	{r7, pc}

0800b05a <_ZN7desenet6sensor13NetworkEntity12EventElementC1EtRKN3hei12SharedBufferIhEE>:
    /**
     * @brief Holds event information.
     */
    struct EventElement
    {
        EventElement(EvId id, const SharedByteBuffer & data)
 800b05a:	b580      	push	{r7, lr}
 800b05c:	b084      	sub	sp, #16
 800b05e:	af00      	add	r7, sp, #0
 800b060:	60f8      	str	r0, [r7, #12]
 800b062:	460b      	mov	r3, r1
 800b064:	607a      	str	r2, [r7, #4]
 800b066:	817b      	strh	r3, [r7, #10]
         : id(id), data(data)
 800b068:	68fb      	ldr	r3, [r7, #12]
 800b06a:	897a      	ldrh	r2, [r7, #10]
 800b06c:	801a      	strh	r2, [r3, #0]
 800b06e:	68fb      	ldr	r3, [r7, #12]
 800b070:	3304      	adds	r3, #4
 800b072:	6879      	ldr	r1, [r7, #4]
 800b074:	4618      	mov	r0, r3
 800b076:	f7fd fd2c 	bl	8008ad2 <_ZN3hei12SharedBufferIhEC1ERKS1_>
        {}
 800b07a:	68fb      	ldr	r3, [r7, #12]
 800b07c:	4618      	mov	r0, r3
 800b07e:	3710      	adds	r7, #16
 800b080:	46bd      	mov	sp, r7
 800b082:	bd80      	pop	{r7, pc}

0800b084 <_ZN16ITimeSlotManager8ObserverC1Ev>:
	};

	/**
	 * @brief Interface to be implemented by the TimeSlotManager observer
	 */
	class Observer
 800b084:	b480      	push	{r7}
 800b086:	b083      	sub	sp, #12
 800b088:	af00      	add	r7, sp, #0
 800b08a:	6078      	str	r0, [r7, #4]
 800b08c:	4a04      	ldr	r2, [pc, #16]	; (800b0a0 <_ZN16ITimeSlotManager8ObserverC1Ev+0x1c>)
 800b08e:	687b      	ldr	r3, [r7, #4]
 800b090:	601a      	str	r2, [r3, #0]
 800b092:	687b      	ldr	r3, [r7, #4]
 800b094:	4618      	mov	r0, r3
 800b096:	370c      	adds	r7, #12
 800b098:	46bd      	mov	sp, r7
 800b09a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b09e:	4770      	bx	lr
 800b0a0:	0801ba44 	.word	0x0801ba44

0800b0a4 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE10_List_implD1Ev>:
	  }
	return __n;
      }
#endif

      struct _List_impl
 800b0a4:	b580      	push	{r7, lr}
 800b0a6:	b082      	sub	sp, #8
 800b0a8:	af00      	add	r7, sp, #0
 800b0aa:	6078      	str	r0, [r7, #4]
 800b0ac:	6878      	ldr	r0, [r7, #4]
 800b0ae:	f000 fc54 	bl	800b95a <_ZNSaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEED1Ev>
 800b0b2:	687b      	ldr	r3, [r7, #4]
 800b0b4:	4618      	mov	r0, r3
 800b0b6:	3708      	adds	r7, #8
 800b0b8:	46bd      	mov	sp, r7
 800b0ba:	bd80      	pop	{r7, pc}

0800b0bc <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EEC1Ev>:
      const _Node_alloc_type&
      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
      { return _M_impl; }

#if __cplusplus >= 201103L
      _List_base() = default;
 800b0bc:	b580      	push	{r7, lr}
 800b0be:	b082      	sub	sp, #8
 800b0c0:	af00      	add	r7, sp, #0
 800b0c2:	6078      	str	r0, [r7, #4]
 800b0c4:	687b      	ldr	r3, [r7, #4]
 800b0c6:	4618      	mov	r0, r3
 800b0c8:	f000 fc37 	bl	800b93a <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE10_List_implC1Ev>
 800b0cc:	687b      	ldr	r3, [r7, #4]
 800b0ce:	4618      	mov	r0, r3
 800b0d0:	3708      	adds	r7, #8
 800b0d2:	46bd      	mov	sp, r7
 800b0d4:	bd80      	pop	{r7, pc}

0800b0d6 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EEC1Ev>:

      /**
       *  @brief  Creates a %list with no elements.
       */
#if __cplusplus >= 201103L
      list() = default;
 800b0d6:	b580      	push	{r7, lr}
 800b0d8:	b082      	sub	sp, #8
 800b0da:	af00      	add	r7, sp, #0
 800b0dc:	6078      	str	r0, [r7, #4]
 800b0de:	687b      	ldr	r3, [r7, #4]
 800b0e0:	4618      	mov	r0, r3
 800b0e2:	f7ff ffeb 	bl	800b0bc <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EEC1Ev>
 800b0e6:	687b      	ldr	r3, [r7, #4]
 800b0e8:	4618      	mov	r0, r3
 800b0ea:	3708      	adds	r7, #8
 800b0ec:	46bd      	mov	sp, r7
 800b0ee:	bd80      	pop	{r7, pc}

0800b0f0 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EED1Ev>:
       *  things.  The _Base dtor only erases the elements, and note
       *  that if the elements themselves are pointers, the pointed-to
       *  memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */
      ~list() = default;
 800b0f0:	b580      	push	{r7, lr}
 800b0f2:	b082      	sub	sp, #8
 800b0f4:	af00      	add	r7, sp, #0
 800b0f6:	6078      	str	r0, [r7, #4]
 800b0f8:	687b      	ldr	r3, [r7, #4]
 800b0fa:	4618      	mov	r0, r3
 800b0fc:	f000 fc39 	bl	800b972 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EED1Ev>
 800b100:	687b      	ldr	r3, [r7, #4]
 800b102:	4618      	mov	r0, r3
 800b104:	3708      	adds	r7, #8
 800b106:	46bd      	mov	sp, r7
 800b108:	bd80      	pop	{r7, pc}

0800b10a <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE10_List_implD1Ev>:
      struct _List_impl
 800b10a:	b580      	push	{r7, lr}
 800b10c:	b082      	sub	sp, #8
 800b10e:	af00      	add	r7, sp, #0
 800b110:	6078      	str	r0, [r7, #4]
 800b112:	6878      	ldr	r0, [r7, #4]
 800b114:	f000 fc4d 	bl	800b9b2 <_ZNSaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEED1Ev>
 800b118:	687b      	ldr	r3, [r7, #4]
 800b11a:	4618      	mov	r0, r3
 800b11c:	3708      	adds	r7, #8
 800b11e:	46bd      	mov	sp, r7
 800b120:	bd80      	pop	{r7, pc}

0800b122 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EEC1Ev>:
      _List_base() = default;
 800b122:	b580      	push	{r7, lr}
 800b124:	b082      	sub	sp, #8
 800b126:	af00      	add	r7, sp, #0
 800b128:	6078      	str	r0, [r7, #4]
 800b12a:	687b      	ldr	r3, [r7, #4]
 800b12c:	4618      	mov	r0, r3
 800b12e:	f000 fc30 	bl	800b992 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE10_List_implC1Ev>
 800b132:	687b      	ldr	r3, [r7, #4]
 800b134:	4618      	mov	r0, r3
 800b136:	3708      	adds	r7, #8
 800b138:	46bd      	mov	sp, r7
 800b13a:	bd80      	pop	{r7, pc}

0800b13c <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EEC1Ev>:
      list() = default;
 800b13c:	b580      	push	{r7, lr}
 800b13e:	b082      	sub	sp, #8
 800b140:	af00      	add	r7, sp, #0
 800b142:	6078      	str	r0, [r7, #4]
 800b144:	687b      	ldr	r3, [r7, #4]
 800b146:	4618      	mov	r0, r3
 800b148:	f7ff ffeb 	bl	800b122 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EEC1Ev>
 800b14c:	687b      	ldr	r3, [r7, #4]
 800b14e:	4618      	mov	r0, r3
 800b150:	3708      	adds	r7, #8
 800b152:	46bd      	mov	sp, r7
 800b154:	bd80      	pop	{r7, pc}

0800b156 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EED1Ev>:
      ~list() = default;
 800b156:	b580      	push	{r7, lr}
 800b158:	b082      	sub	sp, #8
 800b15a:	af00      	add	r7, sp, #0
 800b15c:	6078      	str	r0, [r7, #4]
 800b15e:	687b      	ldr	r3, [r7, #4]
 800b160:	4618      	mov	r0, r3
 800b162:	f000 fc32 	bl	800b9ca <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EED1Ev>
 800b166:	687b      	ldr	r3, [r7, #4]
 800b168:	4618      	mov	r0, r3
 800b16a:	3708      	adds	r7, #8
 800b16c:	46bd      	mov	sp, r7
 800b16e:	bd80      	pop	{r7, pc}

0800b170 <_ZN7desenet6sensor13NetworkEntityC1Ev>:

using desenet::sensor::NetworkEntity;

NetworkEntity * NetworkEntity::_pInstance(nullptr);		// Instantiation of static attribute

NetworkEntity::NetworkEntity()
 800b170:	b580      	push	{r7, lr}
 800b172:	b082      	sub	sp, #8
 800b174:	af00      	add	r7, sp, #0
 800b176:	6078      	str	r0, [r7, #4]
 : _pTimeSlotManager(nullptr),
   _pTransceiver(nullptr)
 800b178:	687b      	ldr	r3, [r7, #4]
 800b17a:	4618      	mov	r0, r3
 800b17c:	f7ff ff82 	bl	800b084 <_ZN16ITimeSlotManager8ObserverC1Ev>
 800b180:	4a14      	ldr	r2, [pc, #80]	; (800b1d4 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x64>)
 800b182:	687b      	ldr	r3, [r7, #4]
 800b184:	601a      	str	r2, [r3, #0]
 800b186:	687b      	ldr	r3, [r7, #4]
 800b188:	2200      	movs	r2, #0
 800b18a:	605a      	str	r2, [r3, #4]
 800b18c:	687b      	ldr	r3, [r7, #4]
 800b18e:	2200      	movs	r2, #0
 800b190:	609a      	str	r2, [r3, #8]
 800b192:	687b      	ldr	r3, [r7, #4]
 800b194:	330c      	adds	r3, #12
 800b196:	4618      	mov	r0, r3
 800b198:	f7ff ff9d 	bl	800b0d6 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EEC1Ev>
 800b19c:	687b      	ldr	r3, [r7, #4]
 800b19e:	3358      	adds	r3, #88	; 0x58
 800b1a0:	4618      	mov	r0, r3
 800b1a2:	f7ff ffcb 	bl	800b13c <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EEC1Ev>
 800b1a6:	687b      	ldr	r3, [r7, #4]
 800b1a8:	3364      	adds	r3, #100	; 0x64
 800b1aa:	4618      	mov	r0, r3
 800b1ac:	f7fe fdac 	bl	8009d08 <_ZN7desenet8MultiPDUC1Ev>
{
    assert(!_pInstance);		// Only one instance allowed
 800b1b0:	4b09      	ldr	r3, [pc, #36]	; (800b1d8 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x68>)
 800b1b2:	681b      	ldr	r3, [r3, #0]
 800b1b4:	2b00      	cmp	r3, #0
 800b1b6:	d005      	beq.n	800b1c4 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x54>
 800b1b8:	4b08      	ldr	r3, [pc, #32]	; (800b1dc <_ZN7desenet6sensor13NetworkEntityC1Ev+0x6c>)
 800b1ba:	4a09      	ldr	r2, [pc, #36]	; (800b1e0 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x70>)
 800b1bc:	211f      	movs	r1, #31
 800b1be:	4809      	ldr	r0, [pc, #36]	; (800b1e4 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x74>)
 800b1c0:	f00b f8e8 	bl	8016394 <__assert_func>
    _pInstance = this;
 800b1c4:	4a04      	ldr	r2, [pc, #16]	; (800b1d8 <_ZN7desenet6sensor13NetworkEntityC1Ev+0x68>)
 800b1c6:	687b      	ldr	r3, [r7, #4]
 800b1c8:	6013      	str	r3, [r2, #0]
}
 800b1ca:	687b      	ldr	r3, [r7, #4]
 800b1cc:	4618      	mov	r0, r3
 800b1ce:	3708      	adds	r7, #8
 800b1d0:	46bd      	mov	sp, r7
 800b1d2:	bd80      	pop	{r7, pc}
 800b1d4:	0801ba30 	.word	0x0801ba30
 800b1d8:	20001934 	.word	0x20001934
 800b1dc:	08018aac 	.word	0x08018aac
 800b1e0:	08018ab8 	.word	0x08018ab8
 800b1e4:	08018ae8 	.word	0x08018ae8

0800b1e8 <_ZN7desenet6sensor13NetworkEntityD1Ev>:

NetworkEntity::~NetworkEntity()
 800b1e8:	b580      	push	{r7, lr}
 800b1ea:	b082      	sub	sp, #8
 800b1ec:	af00      	add	r7, sp, #0
 800b1ee:	6078      	str	r0, [r7, #4]
 800b1f0:	4a0b      	ldr	r2, [pc, #44]	; (800b220 <_ZN7desenet6sensor13NetworkEntityD1Ev+0x38>)
 800b1f2:	687b      	ldr	r3, [r7, #4]
 800b1f4:	601a      	str	r2, [r3, #0]
 800b1f6:	687b      	ldr	r3, [r7, #4]
 800b1f8:	3364      	adds	r3, #100	; 0x64
 800b1fa:	4618      	mov	r0, r3
 800b1fc:	f7fe fdc6 	bl	8009d8c <_ZN7desenet8MultiPDUD1Ev>
 800b200:	687b      	ldr	r3, [r7, #4]
 800b202:	3358      	adds	r3, #88	; 0x58
 800b204:	4618      	mov	r0, r3
 800b206:	f7ff ffa6 	bl	800b156 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EED1Ev>
 800b20a:	687b      	ldr	r3, [r7, #4]
 800b20c:	330c      	adds	r3, #12
 800b20e:	4618      	mov	r0, r3
 800b210:	f7ff ff6e 	bl	800b0f0 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EED1Ev>
{
}
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	4618      	mov	r0, r3
 800b218:	3708      	adds	r7, #8
 800b21a:	46bd      	mov	sp, r7
 800b21c:	bd80      	pop	{r7, pc}
 800b21e:	bf00      	nop
 800b220:	0801ba30 	.word	0x0801ba30

0800b224 <_ZN7desenet6sensor13NetworkEntityD0Ev>:
NetworkEntity::~NetworkEntity()
 800b224:	b580      	push	{r7, lr}
 800b226:	b082      	sub	sp, #8
 800b228:	af00      	add	r7, sp, #0
 800b22a:	6078      	str	r0, [r7, #4]
}
 800b22c:	6878      	ldr	r0, [r7, #4]
 800b22e:	f7ff ffdb 	bl	800b1e8 <_ZN7desenet6sensor13NetworkEntityD1Ev>
 800b232:	2184      	movs	r1, #132	; 0x84
 800b234:	6878      	ldr	r0, [r7, #4]
 800b236:	f00a ffb9 	bl	80161ac <_ZdlPvj>
 800b23a:	687b      	ldr	r3, [r7, #4]
 800b23c:	4618      	mov	r0, r3
 800b23e:	3708      	adds	r7, #8
 800b240:	46bd      	mov	sp, r7
 800b242:	bd80      	pop	{r7, pc}

0800b244 <_ZN7desenet6sensor13NetworkEntity10initializeEv>:

void NetworkEntity::initialize()
{
 800b244:	b480      	push	{r7}
 800b246:	b083      	sub	sp, #12
 800b248:	af00      	add	r7, sp, #0
 800b24a:	6078      	str	r0, [r7, #4]
}
 800b24c:	bf00      	nop
 800b24e:	370c      	adds	r7, #12
 800b250:	46bd      	mov	sp, r7
 800b252:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b256:	4770      	bx	lr

0800b258 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>:
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
 800b258:	b580      	push	{r7, lr}
 800b25a:	b082      	sub	sp, #8
 800b25c:	af00      	add	r7, sp, #0
 800b25e:	6078      	str	r0, [r7, #4]
 800b260:	6039      	str	r1, [r7, #0]
 800b262:	683b      	ldr	r3, [r7, #0]
 800b264:	681a      	ldr	r2, [r3, #0]
 800b266:	687b      	ldr	r3, [r7, #4]
 800b268:	601a      	str	r2, [r3, #0]
 800b26a:	687b      	ldr	r3, [r7, #4]
 800b26c:	1d1a      	adds	r2, r3, #4
 800b26e:	683b      	ldr	r3, [r7, #0]
 800b270:	3304      	adds	r3, #4
 800b272:	4619      	mov	r1, r3
 800b274:	4610      	mov	r0, r2
 800b276:	f000 fbb8 	bl	800b9ea <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
 800b27a:	687b      	ldr	r3, [r7, #4]
 800b27c:	4618      	mov	r0, r3
 800b27e:	3708      	adds	r7, #8
 800b280:	46bd      	mov	sp, r7
 800b282:	bd80      	pop	{r7, pc}

0800b284 <_ZNSt10shared_ptrIhEaSERKS0_>:
      shared_ptr& operator=(const shared_ptr&) noexcept = default;
 800b284:	b580      	push	{r7, lr}
 800b286:	b082      	sub	sp, #8
 800b288:	af00      	add	r7, sp, #0
 800b28a:	6078      	str	r0, [r7, #4]
 800b28c:	6039      	str	r1, [r7, #0]
 800b28e:	687b      	ldr	r3, [r7, #4]
 800b290:	683a      	ldr	r2, [r7, #0]
 800b292:	4611      	mov	r1, r2
 800b294:	4618      	mov	r0, r3
 800b296:	f7ff ffdf 	bl	800b258 <_ZNSt12__shared_ptrIhLN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
 800b29a:	687b      	ldr	r3, [r7, #4]
 800b29c:	4618      	mov	r0, r3
 800b29e:	3708      	adds	r7, #8
 800b2a0:	46bd      	mov	sp, r7
 800b2a2:	bd80      	pop	{r7, pc}

0800b2a4 <_ZN3hei12SharedBufferIhEaSERKS1_>:
    class SharedBuffer {
 800b2a4:	b580      	push	{r7, lr}
 800b2a6:	b082      	sub	sp, #8
 800b2a8:	af00      	add	r7, sp, #0
 800b2aa:	6078      	str	r0, [r7, #4]
 800b2ac:	6039      	str	r1, [r7, #0]
 800b2ae:	687b      	ldr	r3, [r7, #4]
 800b2b0:	683a      	ldr	r2, [r7, #0]
 800b2b2:	4611      	mov	r1, r2
 800b2b4:	4618      	mov	r0, r3
 800b2b6:	f7ff ffe5 	bl	800b284 <_ZNSt10shared_ptrIhEaSERKS0_>
 800b2ba:	683b      	ldr	r3, [r7, #0]
 800b2bc:	689a      	ldr	r2, [r3, #8]
 800b2be:	687b      	ldr	r3, [r7, #4]
 800b2c0:	609a      	str	r2, [r3, #8]
 800b2c2:	687b      	ldr	r3, [r7, #4]
 800b2c4:	4618      	mov	r0, r3
 800b2c6:	3708      	adds	r7, #8
 800b2c8:	46bd      	mov	sp, r7
 800b2ca:	bd80      	pop	{r7, pc}

0800b2cc <_ZN7desenet5FrameaSERKS0_>:
 800b2cc:	b580      	push	{r7, lr}
 800b2ce:	b082      	sub	sp, #8
 800b2d0:	af00      	add	r7, sp, #0
 800b2d2:	6078      	str	r0, [r7, #4]
 800b2d4:	6039      	str	r1, [r7, #0]
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	683a      	ldr	r2, [r7, #0]
 800b2da:	4611      	mov	r1, r2
 800b2dc:	4618      	mov	r0, r3
 800b2de:	f7ff ffe1 	bl	800b2a4 <_ZN3hei12SharedBufferIhEaSERKS1_>
 800b2e2:	683b      	ldr	r3, [r7, #0]
 800b2e4:	68da      	ldr	r2, [r3, #12]
 800b2e6:	687b      	ldr	r3, [r7, #4]
 800b2e8:	60da      	str	r2, [r3, #12]
 800b2ea:	687b      	ldr	r3, [r7, #4]
 800b2ec:	4618      	mov	r0, r3
 800b2ee:	3708      	adds	r7, #8
 800b2f0:	46bd      	mov	sp, r7
 800b2f2:	bd80      	pop	{r7, pc}

0800b2f4 <_ZN7desenet8MultiPDUaSERKS0_>:
#include "frame.h"
#include "platform-config.h"

namespace desenet
{
    class MultiPDU: public Frame
 800b2f4:	b580      	push	{r7, lr}
 800b2f6:	b082      	sub	sp, #8
 800b2f8:	af00      	add	r7, sp, #0
 800b2fa:	6078      	str	r0, [r7, #4]
 800b2fc:	6039      	str	r1, [r7, #0]
 800b2fe:	687b      	ldr	r3, [r7, #4]
 800b300:	683a      	ldr	r2, [r7, #0]
 800b302:	4611      	mov	r1, r2
 800b304:	4618      	mov	r0, r3
 800b306:	f7ff ffe1 	bl	800b2cc <_ZN7desenet5FrameaSERKS0_>
 800b30a:	683b      	ldr	r3, [r7, #0]
 800b30c:	691a      	ldr	r2, [r3, #16]
 800b30e:	687b      	ldr	r3, [r7, #4]
 800b310:	611a      	str	r2, [r3, #16]
 800b312:	683b      	ldr	r3, [r7, #0]
 800b314:	695a      	ldr	r2, [r3, #20]
 800b316:	687b      	ldr	r3, [r7, #4]
 800b318:	615a      	str	r2, [r3, #20]
 800b31a:	683b      	ldr	r3, [r7, #0]
 800b31c:	699a      	ldr	r2, [r3, #24]
 800b31e:	687b      	ldr	r3, [r7, #4]
 800b320:	619a      	str	r2, [r3, #24]
 800b322:	683b      	ldr	r3, [r7, #0]
 800b324:	7f1a      	ldrb	r2, [r3, #28]
 800b326:	687b      	ldr	r3, [r7, #4]
 800b328:	771a      	strb	r2, [r3, #28]
 800b32a:	683b      	ldr	r3, [r7, #0]
 800b32c:	7f5a      	ldrb	r2, [r3, #29]
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	775a      	strb	r2, [r3, #29]
 800b332:	687b      	ldr	r3, [r7, #4]
 800b334:	4618      	mov	r0, r3
 800b336:	3708      	adds	r7, #8
 800b338:	46bd      	mov	sp, r7
 800b33a:	bd80      	pop	{r7, pc}

0800b33c <_ZNSt5tupleIJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1EOS9_>:
	noexcept(__nothrow_constructible<_UElements...>())
	: _Inherited(std::forward<_UElements>(__elements)...) {	}

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;
 800b33c:	b580      	push	{r7, lr}
 800b33e:	b082      	sub	sp, #8
 800b340:	af00      	add	r7, sp, #0
 800b342:	6078      	str	r0, [r7, #4]
 800b344:	6039      	str	r1, [r7, #0]
 800b346:	687b      	ldr	r3, [r7, #4]
 800b348:	683a      	ldr	r2, [r7, #0]
 800b34a:	4611      	mov	r1, r2
 800b34c:	4618      	mov	r0, r3
 800b34e:	f000 fb9e 	bl	800ba8e <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1EOS9_>
 800b352:	687b      	ldr	r3, [r7, #4]
 800b354:	4618      	mov	r0, r3
 800b356:	3708      	adds	r7, #8
 800b358:	46bd      	mov	sp, r7
 800b35a:	bd80      	pop	{r7, pc}

0800b35c <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEC1EOSG_>:
	_Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
      _Bind(_Bind&&) = default;
 800b35c:	b580      	push	{r7, lr}
 800b35e:	b082      	sub	sp, #8
 800b360:	af00      	add	r7, sp, #0
 800b362:	6078      	str	r0, [r7, #4]
 800b364:	6039      	str	r1, [r7, #0]
 800b366:	687b      	ldr	r3, [r7, #4]
 800b368:	683a      	ldr	r2, [r7, #0]
 800b36a:	e892 0003 	ldmia.w	r2, {r0, r1}
 800b36e:	e883 0003 	stmia.w	r3, {r0, r1}
 800b372:	687b      	ldr	r3, [r7, #4]
 800b374:	f103 0208 	add.w	r2, r3, #8
 800b378:	683b      	ldr	r3, [r7, #0]
 800b37a:	3308      	adds	r3, #8
 800b37c:	4619      	mov	r1, r3
 800b37e:	4610      	mov	r0, r2
 800b380:	f7ff ffdc 	bl	800b33c <_ZNSt5tupleIJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1EOS9_>
 800b384:	687b      	ldr	r3, [r7, #4]
 800b386:	4618      	mov	r0, r3
 800b388:	3708      	adds	r7, #8
 800b38a:	46bd      	mov	sp, r7
 800b38c:	bd80      	pop	{r7, pc}

0800b38e <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEED1Ev>:
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 800b38e:	b580      	push	{r7, lr}
 800b390:	b082      	sub	sp, #8
 800b392:	af00      	add	r7, sp, #0
 800b394:	6078      	str	r0, [r7, #4]
 800b396:	687b      	ldr	r3, [r7, #4]
 800b398:	4618      	mov	r0, r3
 800b39a:	f7ff fe4b 	bl	800b034 <_ZNSt14_Function_baseD1Ev>
 800b39e:	687b      	ldr	r3, [r7, #4]
 800b3a0:	4618      	mov	r0, r3
 800b3a2:	3708      	adds	r7, #8
 800b3a4:	46bd      	mov	sp, r7
 800b3a6:	bd80      	pop	{r7, pc}

0800b3a8 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE>:

void NetworkEntity::initializeRelations(ITimeSlotManager & timeSlotManager, NetworkInterfaceDriver & transceiver)
{
 800b3a8:	b590      	push	{r4, r7, lr}
 800b3aa:	b09d      	sub	sp, #116	; 0x74
 800b3ac:	af04      	add	r7, sp, #16
 800b3ae:	60f8      	str	r0, [r7, #12]
 800b3b0:	60b9      	str	r1, [r7, #8]
 800b3b2:	607a      	str	r2, [r7, #4]
    _pTimeSlotManager = &timeSlotManager;
 800b3b4:	68fb      	ldr	r3, [r7, #12]
 800b3b6:	68ba      	ldr	r2, [r7, #8]
 800b3b8:	605a      	str	r2, [r3, #4]
    _pTransceiver = &transceiver;
 800b3ba:	68fb      	ldr	r3, [r7, #12]
 800b3bc:	687a      	ldr	r2, [r7, #4]
 800b3be:	609a      	str	r2, [r3, #8]

    // TODO: Add additional initialization code here
    mPDU = MultiPDU();
 800b3c0:	68fb      	ldr	r3, [r7, #12]
 800b3c2:	f103 0464 	add.w	r4, r3, #100	; 0x64
 800b3c6:	f107 0310 	add.w	r3, r7, #16
 800b3ca:	4618      	mov	r0, r3
 800b3cc:	f7fe fc9c 	bl	8009d08 <_ZN7desenet8MultiPDUC1Ev>
 800b3d0:	f107 0310 	add.w	r3, r7, #16
 800b3d4:	4619      	mov	r1, r3
 800b3d6:	4620      	mov	r0, r4
 800b3d8:	f7ff ff8c 	bl	800b2f4 <_ZN7desenet8MultiPDUaSERKS0_>
 800b3dc:	f107 0310 	add.w	r3, r7, #16
 800b3e0:	4618      	mov	r0, r3
 800b3e2:	f7fe fcd3 	bl	8009d8c <_ZN7desenet8MultiPDUD1Ev>
    timeSlotManager.initializeRelations(*this);     // initialize the TimeSlotMAnager class so that there inside the _pObserver is initialized with (*this), because NetworkEntity IS ans observer
 800b3e6:	68bb      	ldr	r3, [r7, #8]
 800b3e8:	681b      	ldr	r3, [r3, #0]
 800b3ea:	3304      	adds	r3, #4
 800b3ec:	681b      	ldr	r3, [r3, #0]
 800b3ee:	68fa      	ldr	r2, [r7, #12]
 800b3f0:	4611      	mov	r1, r2
 800b3f2:	68b8      	ldr	r0, [r7, #8]
 800b3f4:	4798      	blx	r3

     // Set the receive callback between transceiver and network. Bind this pointer to member function
    transceiver.setReceptionHandler(std::bind(&NetworkEntity::onReceive, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4));
 800b3f6:	687b      	ldr	r3, [r7, #4]
 800b3f8:	681b      	ldr	r3, [r3, #0]
 800b3fa:	331c      	adds	r3, #28
 800b3fc:	681c      	ldr	r4, [r3, #0]
 800b3fe:	4b19      	ldr	r3, [pc, #100]	; (800b464 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE+0xbc>)
 800b400:	657b      	str	r3, [r7, #84]	; 0x54
 800b402:	2300      	movs	r3, #0
 800b404:	65bb      	str	r3, [r7, #88]	; 0x58
 800b406:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800b40a:	f107 0254 	add.w	r2, r7, #84	; 0x54
 800b40e:	e892 0003 	ldmia.w	r2, {r0, r1}
 800b412:	e883 0003 	stmia.w	r3, {r0, r1}
 800b416:	68fb      	ldr	r3, [r7, #12]
 800b418:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b41a:	f107 0040 	add.w	r0, r7, #64	; 0x40
 800b41e:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 800b422:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800b426:	4b10      	ldr	r3, [pc, #64]	; (800b468 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE+0xc0>)
 800b428:	9302      	str	r3, [sp, #8]
 800b42a:	4b10      	ldr	r3, [pc, #64]	; (800b46c <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE+0xc4>)
 800b42c:	9301      	str	r3, [sp, #4]
 800b42e:	4b10      	ldr	r3, [pc, #64]	; (800b470 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE+0xc8>)
 800b430:	9300      	str	r3, [sp, #0]
 800b432:	4b10      	ldr	r3, [pc, #64]	; (800b474 <_ZN7desenet6sensor13NetworkEntity19initializeRelationsER16ITimeSlotManagerRNS_22NetworkInterfaceDriverE+0xcc>)
 800b434:	f000 fafd 	bl	800ba32 <_ZSt4bindIMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEJPS2_RKSt12_PlaceholderILi1EERKSA_ILi2EERKSA_ILi3EERKSA_ILi4EEEENSt12_Bind_helperIXsrSt5__or_IJSt11is_integralINSt5decayIT_E4typeEESt7is_enumIST_EEE5valueESR_JDpT0_EE4typeEOSR_DpOSY_>
 800b438:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800b43c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b440:	4611      	mov	r1, r2
 800b442:	4618      	mov	r0, r3
 800b444:	f000 fb46 	bl	800bad4 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ISt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPSA_St12_PlaceholderILi1EESE_ILi2EESE_ILi3EESE_ILi4EEEEvvEET_>
 800b448:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b44c:	4619      	mov	r1, r3
 800b44e:	6878      	ldr	r0, [r7, #4]
 800b450:	47a0      	blx	r4
 800b452:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b456:	4618      	mov	r0, r3
 800b458:	f7ff ff99 	bl	800b38e <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEED1Ev>
}
 800b45c:	bf00      	nop
 800b45e:	3764      	adds	r7, #100	; 0x64
 800b460:	46bd      	mov	sp, r7
 800b462:	bd90      	pop	{r4, r7, pc}
 800b464:	0800b4a9 	.word	0x0800b4a9
 800b468:	0801dd17 	.word	0x0801dd17
 800b46c:	0801dd16 	.word	0x0801dd16
 800b470:	0801dd15 	.word	0x0801dd15
 800b474:	0801dd14 	.word	0x0801dd14

0800b478 <_ZN7desenet6sensor13NetworkEntity8instanceEv>:
 * This method does not automatically create an instance if there is none created so far.
 * It is up the the developer to create an instance of this class prior to access the instance() method.
 */
//static
NetworkEntity & NetworkEntity::instance()
{
 800b478:	b580      	push	{r7, lr}
 800b47a:	af00      	add	r7, sp, #0
    assert(_pInstance);
 800b47c:	4b06      	ldr	r3, [pc, #24]	; (800b498 <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x20>)
 800b47e:	681b      	ldr	r3, [r3, #0]
 800b480:	2b00      	cmp	r3, #0
 800b482:	d105      	bne.n	800b490 <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x18>
 800b484:	4b05      	ldr	r3, [pc, #20]	; (800b49c <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x24>)
 800b486:	4a06      	ldr	r2, [pc, #24]	; (800b4a0 <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x28>)
 800b488:	213f      	movs	r1, #63	; 0x3f
 800b48a:	4806      	ldr	r0, [pc, #24]	; (800b4a4 <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x2c>)
 800b48c:	f00a ff82 	bl	8016394 <__assert_func>
    return *_pInstance;
 800b490:	4b01      	ldr	r3, [pc, #4]	; (800b498 <_ZN7desenet6sensor13NetworkEntity8instanceEv+0x20>)
 800b492:	681b      	ldr	r3, [r3, #0]
}
 800b494:	4618      	mov	r0, r3
 800b496:	bd80      	pop	{r7, pc}
 800b498:	20001934 	.word	0x20001934
 800b49c:	08018b68 	.word	0x08018b68
 800b4a0:	08018b74 	.word	0x08018b74
 800b4a4:	08018ae8 	.word	0x08018ae8

0800b4a8 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj>:

/**
 * Called by the NetworkInterfaceDriver (layer below) after reception of a new frame
 */
void NetworkEntity::onReceive(NetworkInterfaceDriver & driver, const uint32_t receptionTime, const uint8_t * const buffer, size_t length)
{
 800b4a8:	b5b0      	push	{r4, r5, r7, lr}
 800b4aa:	b098      	sub	sp, #96	; 0x60
 800b4ac:	af00      	add	r7, sp, #0
 800b4ae:	60f8      	str	r0, [r7, #12]
 800b4b0:	60b9      	str	r1, [r7, #8]
 800b4b2:	607a      	str	r2, [r7, #4]
 800b4b4:	603b      	str	r3, [r7, #0]
    (void)(driver);
    (void)(receptionTime);
    Frame frame = Frame::useBuffer(buffer, length);
 800b4b6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800b4ba:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800b4bc:	6839      	ldr	r1, [r7, #0]
 800b4be:	4618      	mov	r0, r3
 800b4c0:	f7fd fc76 	bl	8008db0 <_ZN7desenet5Frame9useBufferEPKhj>

    // check that received frame is a Beacon
    if(frame.type() == FrameType::Beacon)
 800b4c4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800b4c8:	4618      	mov	r0, r3
 800b4ca:	f7fd fd24 	bl	8008f16 <_ZNK7desenet5Frame4typeEv>
 800b4ce:	4603      	mov	r3, r0
 800b4d0:	2b01      	cmp	r3, #1
 800b4d2:	bf0c      	ite	eq
 800b4d4:	2301      	moveq	r3, #1
 800b4d6:	2300      	movne	r3, #0
 800b4d8:	b2db      	uxtb	r3, r3
 800b4da:	2b00      	cmp	r3, #0
 800b4dc:	f000 814b 	beq.w	800b776 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x2ce>
    {
        /******************************/
        /* STEP 1 : create new beacon */
        /******************************/
        Beacon* pBcon = new Beacon(frame);
 800b4e0:	2010      	movs	r0, #16
 800b4e2:	f00a fe76 	bl	80161d2 <_Znwj>
 800b4e6:	4603      	mov	r3, r0
 800b4e8:	461c      	mov	r4, r3
 800b4ea:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800b4ee:	4619      	mov	r1, r3
 800b4f0:	4620      	mov	r0, r4
 800b4f2:	f7fd fb16 	bl	8008b22 <_ZN7desenet6BeaconC1ERKNS_5FrameE>
 800b4f6:	65bc      	str	r4, [r7, #88]	; 0x58

        /***************************************/
        /* STEP 2 : start timer for time slots */
        /***************************************/
        _pTimeSlotManager->onBeaconReceived(pBcon->slotDuration());
 800b4f8:	68fb      	ldr	r3, [r7, #12]
 800b4fa:	685d      	ldr	r5, [r3, #4]
 800b4fc:	68fb      	ldr	r3, [r7, #12]
 800b4fe:	685b      	ldr	r3, [r3, #4]
 800b500:	681b      	ldr	r3, [r3, #0]
 800b502:	3314      	adds	r3, #20
 800b504:	681c      	ldr	r4, [r3, #0]
 800b506:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800b508:	f7fd fb1a 	bl	8008b40 <_ZN7desenet6Beacon12slotDurationEv>
 800b50c:	4603      	mov	r3, r0
 800b50e:	877b      	strh	r3, [r7, #58]	; 0x3a
 800b510:	f107 033a 	add.w	r3, r7, #58	; 0x3a
 800b514:	4619      	mov	r1, r3
 800b516:	4628      	mov	r0, r5
 800b518:	47a0      	blx	r4

        /************************************/
        /* STEP 3 : notify all applications */
        /************************************/
        for(auto list_elm = appSyncList.begin(); list_elm != appSyncList.end(); list_elm++)     // parse a list acc. to example on cplusplus.com
 800b51a:	68fb      	ldr	r3, [r7, #12]
 800b51c:	330c      	adds	r3, #12
 800b51e:	4618      	mov	r0, r3
 800b520:	f000 fb00 	bl	800bb24 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE5beginEv>
 800b524:	4603      	mov	r3, r0
 800b526:	627b      	str	r3, [r7, #36]	; 0x24
 800b528:	68fb      	ldr	r3, [r7, #12]
 800b52a:	330c      	adds	r3, #12
 800b52c:	4618      	mov	r0, r3
 800b52e:	f000 fb0a 	bl	800bb46 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE3endEv>
 800b532:	4603      	mov	r3, r0
 800b534:	63fb      	str	r3, [r7, #60]	; 0x3c
 800b536:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800b53a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b53e:	4611      	mov	r1, r2
 800b540:	4618      	mov	r0, r3
 800b542:	f000 fb10 	bl	800bb66 <_ZStneRKSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEES6_>
 800b546:	4603      	mov	r3, r0
 800b548:	2b00      	cmp	r3, #0
 800b54a:	d013      	beq.n	800b574 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0xcc>
        {
            (*list_elm)->svSyncIndication(receptionTime);
 800b54c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b550:	4618      	mov	r0, r3
 800b552:	f000 fb30 	bl	800bbb6 <_ZNKSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEdeEv>
 800b556:	4603      	mov	r3, r0
 800b558:	681b      	ldr	r3, [r3, #0]
 800b55a:	681a      	ldr	r2, [r3, #0]
 800b55c:	3208      	adds	r2, #8
 800b55e:	6812      	ldr	r2, [r2, #0]
 800b560:	6879      	ldr	r1, [r7, #4]
 800b562:	4618      	mov	r0, r3
 800b564:	4790      	blx	r2
        for(auto list_elm = appSyncList.begin(); list_elm != appSyncList.end(); list_elm++)     // parse a list acc. to example on cplusplus.com
 800b566:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b56a:	2100      	movs	r1, #0
 800b56c:	4618      	mov	r0, r3
 800b56e:	f000 fb0e 	bl	800bb8e <_ZNSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEppEi>
 800b572:	e7d9      	b.n	800b528 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x80>
        }

        /*************************************************/
        /* STEP 4 : publish request for all applications */
        /*************************************************/
        mPDU.clear();
 800b574:	68fb      	ldr	r3, [r7, #12]
 800b576:	3364      	adds	r3, #100	; 0x64
 800b578:	4618      	mov	r0, r3
 800b57a:	f7fe fcda 	bl	8009f32 <_ZN7desenet8MultiPDU5clearEv>
        size_t writtenByteLength = 0;
 800b57e:	2300      	movs	r3, #0
 800b580:	657b      	str	r3, [r7, #84]	; 0x54
        for(SvGroup idx = 0; idx < MAX_GROUP_NBR; idx++)
 800b582:	2300      	movs	r3, #0
 800b584:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800b588:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b58c:	2b0f      	cmp	r3, #15
 800b58e:	d876      	bhi.n	800b67e <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x1d6>
        {
            if((appPubArray[idx] != nullptr) && pBcon->svGroupMask()[idx])              // check if groupNbr (idx) is not a nullpointer and if Beacon wants to receive data from this group (idx)
 800b590:	2500      	movs	r5, #0
 800b592:	68fb      	ldr	r3, [r7, #12]
 800b594:	3318      	adds	r3, #24
 800b596:	f897 205f 	ldrb.w	r2, [r7, #95]	; 0x5f
 800b59a:	4611      	mov	r1, r2
 800b59c:	4618      	mov	r0, r3
 800b59e:	f000 fb18 	bl	800bbd2 <_ZNSt5arrayIPN7desenet6sensor19AbstractApplicationELj16EEixEj>
 800b5a2:	4603      	mov	r3, r0
 800b5a4:	681b      	ldr	r3, [r3, #0]
 800b5a6:	2b00      	cmp	r3, #0
 800b5a8:	d018      	beq.n	800b5dc <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x134>
 800b5aa:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800b5ac:	f7fd fada 	bl	8008b64 <_ZNK7desenet6Beacon11svGroupMaskEv>
 800b5b0:	4603      	mov	r3, r0
 800b5b2:	64bb      	str	r3, [r7, #72]	; 0x48
 800b5b4:	f897 205f 	ldrb.w	r2, [r7, #95]	; 0x5f
 800b5b8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800b5bc:	f107 0148 	add.w	r1, r7, #72	; 0x48
 800b5c0:	4618      	mov	r0, r3
 800b5c2:	f000 fb15 	bl	800bbf0 <_ZNSt6bitsetILj16EEixEj>
 800b5c6:	2501      	movs	r5, #1
 800b5c8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800b5cc:	4618      	mov	r0, r3
 800b5ce:	f000 fb29 	bl	800bc24 <_ZNKSt6bitsetILj16EE9referencecvbEv>
 800b5d2:	4603      	mov	r3, r0
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d001      	beq.n	800b5dc <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x134>
 800b5d8:	2401      	movs	r4, #1
 800b5da:	e000      	b.n	800b5de <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x136>
 800b5dc:	2400      	movs	r4, #0
 800b5de:	2d00      	cmp	r5, #0
 800b5e0:	d004      	beq.n	800b5ec <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x144>
 800b5e2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800b5e6:	4618      	mov	r0, r3
 800b5e8:	f000 fb11 	bl	800bc0e <_ZNSt6bitsetILj16EE9referenceD1Ev>
 800b5ec:	2c00      	cmp	r4, #0
 800b5ee:	d040      	beq.n	800b672 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x1ca>
            {
                SharedByteBuffer buffer = SharedByteBuffer::proxy(mPDU.getValidStart(), mPDU.getRemainingLength());     // this buffer uses the remaining part of the MPDU frame
 800b5f0:	68fb      	ldr	r3, [r7, #12]
 800b5f2:	3364      	adds	r3, #100	; 0x64
 800b5f4:	4618      	mov	r0, r3
 800b5f6:	f7fe fccd 	bl	8009f94 <_ZN7desenet8MultiPDU13getValidStartEv>
 800b5fa:	4604      	mov	r4, r0
 800b5fc:	68fb      	ldr	r3, [r7, #12]
 800b5fe:	3364      	adds	r3, #100	; 0x64
 800b600:	4618      	mov	r0, r3
 800b602:	f7fe fcb8 	bl	8009f76 <_ZN7desenet8MultiPDU18getRemainingLengthEv>
 800b606:	4603      	mov	r3, r0
 800b608:	461a      	mov	r2, r3
 800b60a:	f107 0318 	add.w	r3, r7, #24
 800b60e:	4621      	mov	r1, r4
 800b610:	4618      	mov	r0, r3
 800b612:	f7fd fd6e 	bl	80090f2 <_ZN3hei12SharedBufferIhE5proxyEPhj>
                writtenByteLength = appPubArray[idx]->svPublishIndication(idx, buffer);                                 // returns the written byte length (if not succesful: returns 0)
 800b616:	68fb      	ldr	r3, [r7, #12]
 800b618:	3318      	adds	r3, #24
 800b61a:	f897 205f 	ldrb.w	r2, [r7, #95]	; 0x5f
 800b61e:	4611      	mov	r1, r2
 800b620:	4618      	mov	r0, r3
 800b622:	f000 fad6 	bl	800bbd2 <_ZNSt5arrayIPN7desenet6sensor19AbstractApplicationELj16EEixEj>
 800b626:	4603      	mov	r3, r0
 800b628:	681b      	ldr	r3, [r3, #0]
 800b62a:	681a      	ldr	r2, [r3, #0]
 800b62c:	320c      	adds	r2, #12
 800b62e:	6814      	ldr	r4, [r2, #0]
 800b630:	f107 0218 	add.w	r2, r7, #24
 800b634:	f897 105f 	ldrb.w	r1, [r7, #95]	; 0x5f
 800b638:	4618      	mov	r0, r3
 800b63a:	47a0      	blx	r4
 800b63c:	6578      	str	r0, [r7, #84]	; 0x54
                if(writtenByteLength > 0)
 800b63e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b640:	2b00      	cmp	r3, #0
 800b642:	d011      	beq.n	800b668 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x1c0>
                {
                    mPDU.addEPDUheader(SV_EPDU_TYPE, idx, writtenByteLength);           // here the currentDataByteIndex is 2 because of clear() above
 800b644:	68fb      	ldr	r3, [r7, #12]
 800b646:	f103 0064 	add.w	r0, r3, #100	; 0x64
 800b64a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b64c:	b2db      	uxtb	r3, r3
 800b64e:	f897 205f 	ldrb.w	r2, [r7, #95]	; 0x5f
 800b652:	2100      	movs	r1, #0
 800b654:	f7fe fba7 	bl	8009da6 <_ZN7desenet8MultiPDU13addEPDUheaderEhhh>
                    mPDU.postProcessingAdditionEPDU(writtenByteLength);                 // update all counters and data byte index with written byte length
 800b658:	68fb      	ldr	r3, [r7, #12]
 800b65a:	3364      	adds	r3, #100	; 0x64
 800b65c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800b65e:	b2d2      	uxtb	r2, r2
 800b660:	4611      	mov	r1, r2
 800b662:	4618      	mov	r0, r3
 800b664:	f7fe fc48 	bl	8009ef8 <_ZN7desenet8MultiPDU26postProcessingAdditionEPDUEh>
                SharedByteBuffer buffer = SharedByteBuffer::proxy(mPDU.getValidStart(), mPDU.getRemainingLength());     // this buffer uses the remaining part of the MPDU frame
 800b668:	f107 0318 	add.w	r3, r7, #24
 800b66c:	4618      	mov	r0, r3
 800b66e:	f7fc f8d2 	bl	8007816 <_ZN3hei12SharedBufferIhED1Ev>
        for(SvGroup idx = 0; idx < MAX_GROUP_NBR; idx++)
 800b672:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b676:	3301      	adds	r3, #1
 800b678:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800b67c:	e784      	b.n	800b588 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0xe0>
        }

        /*******************************************/
        /* STEP 5 : try to insert events into MPDU */
        /*******************************************/
        uint8_t addedElmCnt = 0;
 800b67e:	2300      	movs	r3, #0
 800b680:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
        for(auto list_elm = evList.begin(); list_elm != evList.end(); list_elm++)   // parse the event buffer
 800b684:	68fb      	ldr	r3, [r7, #12]
 800b686:	3358      	adds	r3, #88	; 0x58
 800b688:	4618      	mov	r0, r3
 800b68a:	f000 fae2 	bl	800bc52 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5beginEv>
 800b68e:	4603      	mov	r3, r0
 800b690:	617b      	str	r3, [r7, #20]
 800b692:	68fb      	ldr	r3, [r7, #12]
 800b694:	3358      	adds	r3, #88	; 0x58
 800b696:	4618      	mov	r0, r3
 800b698:	f000 faec 	bl	800bc74 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE3endEv>
 800b69c:	4603      	mov	r3, r0
 800b69e:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b6a0:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800b6a4:	f107 0314 	add.w	r3, r7, #20
 800b6a8:	4611      	mov	r1, r2
 800b6aa:	4618      	mov	r0, r3
 800b6ac:	f000 faf2 	bl	800bc94 <_ZStneRKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEES6_>
 800b6b0:	4603      	mov	r3, r0
 800b6b2:	2b00      	cmp	r3, #0
 800b6b4:	d055      	beq.n	800b762 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x2ba>
        {
            uint8_t evSize = (list_elm->data).length();
 800b6b6:	f107 0314 	add.w	r3, r7, #20
 800b6ba:	4618      	mov	r0, r3
 800b6bc:	f000 fb12 	bl	800bce4 <_ZNKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEptEv>
 800b6c0:	4603      	mov	r3, r0
 800b6c2:	3304      	adds	r3, #4
 800b6c4:	4618      	mov	r0, r3
 800b6c6:	f7fd fcfd 	bl	80090c4 <_ZNK3hei12SharedBufferIhE6lengthEv>
 800b6ca:	4603      	mov	r3, r0
 800b6cc:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
            if((evSize <= mPDU.getRemainingLength() - 1) && (evSize > 0))           // -1 due to EPDU header
 800b6d0:	68fb      	ldr	r3, [r7, #12]
 800b6d2:	3364      	adds	r3, #100	; 0x64
 800b6d4:	4618      	mov	r0, r3
 800b6d6:	f7fe fc4e 	bl	8009f76 <_ZN7desenet8MultiPDU18getRemainingLengthEv>
 800b6da:	4603      	mov	r3, r0
 800b6dc:	461a      	mov	r2, r3
 800b6de:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b6e2:	4293      	cmp	r3, r2
 800b6e4:	d205      	bcs.n	800b6f2 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x24a>
 800b6e6:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b6ea:	2b00      	cmp	r3, #0
 800b6ec:	d001      	beq.n	800b6f2 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x24a>
 800b6ee:	2301      	movs	r3, #1
 800b6f0:	e000      	b.n	800b6f4 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x24c>
 800b6f2:	2300      	movs	r3, #0
 800b6f4:	2b00      	cmp	r3, #0
 800b6f6:	d033      	beq.n	800b760 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x2b8>
            {
                mPDU.addEPDUheader(EV_EPDU_TYPE, list_elm->id, evSize);
 800b6f8:	68fb      	ldr	r3, [r7, #12]
 800b6fa:	f103 0464 	add.w	r4, r3, #100	; 0x64
 800b6fe:	f107 0314 	add.w	r3, r7, #20
 800b702:	4618      	mov	r0, r3
 800b704:	f000 faee 	bl	800bce4 <_ZNKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEptEv>
 800b708:	4603      	mov	r3, r0
 800b70a:	881a      	ldrh	r2, [r3, #0]
 800b70c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b710:	2101      	movs	r1, #1
 800b712:	4620      	mov	r0, r4
 800b714:	f7fe fb80 	bl	8009e18 <_ZN7desenet8MultiPDU13addEPDUheaderEhth>
                mPDU.insertEventEPDU(list_elm->data, evSize);
 800b718:	68fb      	ldr	r3, [r7, #12]
 800b71a:	f103 0464 	add.w	r4, r3, #100	; 0x64
 800b71e:	f107 0314 	add.w	r3, r7, #20
 800b722:	4618      	mov	r0, r3
 800b724:	f000 fade 	bl	800bce4 <_ZNKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEptEv>
 800b728:	4603      	mov	r3, r0
 800b72a:	3304      	adds	r3, #4
 800b72c:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 800b730:	4619      	mov	r1, r3
 800b732:	4620      	mov	r0, r4
 800b734:	f7fe fba9 	bl	8009e8a <_ZN7desenet8MultiPDU15insertEventEPDUERKN3hei12SharedBufferIhEEh>
                mPDU.postProcessingAdditionEPDU(evSize);                            // update all counters and data byte index with written byte length
 800b738:	68fb      	ldr	r3, [r7, #12]
 800b73a:	3364      	adds	r3, #100	; 0x64
 800b73c:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 800b740:	4611      	mov	r1, r2
 800b742:	4618      	mov	r0, r3
 800b744:	f7fe fbd8 	bl	8009ef8 <_ZN7desenet8MultiPDU26postProcessingAdditionEPDUEh>
                addedElmCnt++;
 800b748:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800b74c:	3301      	adds	r3, #1
 800b74e:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
        for(auto list_elm = evList.begin(); list_elm != evList.end(); list_elm++)   // parse the event buffer
 800b752:	f107 0314 	add.w	r3, r7, #20
 800b756:	2100      	movs	r1, #0
 800b758:	4618      	mov	r0, r3
 800b75a:	f000 faaf 	bl	800bcbc <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEppEi>
 800b75e:	e798      	b.n	800b692 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x1ea>
            }
            else break;         // avoid unnessecary for loop iterations
 800b760:	bf00      	nop
        }
        if(addedElmCnt > 0)
 800b762:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800b766:	2b00      	cmp	r3, #0
 800b768:	d005      	beq.n	800b776 <_ZN7desenet6sensor13NetworkEntity9onReceiveERNS_22NetworkInterfaceDriverEmPKhj+0x2ce>
        {
            evList_pop_front_multi(addedElmCnt);    // remove the added elements from the event list
 800b76a:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800b76e:	4619      	mov	r1, r3
 800b770:	68f8      	ldr	r0, [r7, #12]
 800b772:	f000 f8ab 	bl	800b8cc <_ZN7desenet6sensor13NetworkEntity22evList_pop_front_multiEh>
        }
    }

    ledController().flashLed(0);    // this flashes the LED on the simulated board
 800b776:	68f8      	ldr	r0, [r7, #12]
 800b778:	f000 f80e 	bl	800b798 <_ZNK7desenet6sensor13NetworkEntity13ledControllerEv>
 800b77c:	4603      	mov	r3, r0
 800b77e:	2100      	movs	r1, #0
 800b780:	4618      	mov	r0, r3
 800b782:	f003 feaf 	bl	800f4e4 <_ZN5board13LedController8flashLedEt>
    Frame frame = Frame::useBuffer(buffer, length);
 800b786:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800b78a:	4618      	mov	r0, r3
 800b78c:	f7fe faaf 	bl	8009cee <_ZN7desenet5FrameD1Ev>
}
 800b790:	bf00      	nop
 800b792:	3760      	adds	r7, #96	; 0x60
 800b794:	46bd      	mov	sp, r7
 800b796:	bdb0      	pop	{r4, r5, r7, pc}

0800b798 <_ZNK7desenet6sensor13NetworkEntity13ledControllerEv>:

board::LedController & NetworkEntity::ledController() const
{
 800b798:	b580      	push	{r7, lr}
 800b79a:	b082      	sub	sp, #8
 800b79c:	af00      	add	r7, sp, #0
 800b79e:	6078      	str	r0, [r7, #4]
    return board::LedController::instance();
 800b7a0:	f003 fe22 	bl	800f3e8 <_ZN5board13LedController8instanceEv>
 800b7a4:	4603      	mov	r3, r0
}
 800b7a6:	4618      	mov	r0, r3
 800b7a8:	3708      	adds	r7, #8
 800b7aa:	46bd      	mov	sp, r7
 800b7ac:	bd80      	pop	{r7, pc}

0800b7ae <_ZN7desenet6sensor13NetworkEntity13svSyncRequestEPNS0_19AbstractApplicationE>:
 * @param   pAbsApp     the pointer to the AbstractApplication
 *
 * @return  void
 */
void NetworkEntity::svSyncRequest(AbstractApplication* pAbsApp)
{
 800b7ae:	b580      	push	{r7, lr}
 800b7b0:	b082      	sub	sp, #8
 800b7b2:	af00      	add	r7, sp, #0
 800b7b4:	6078      	str	r0, [r7, #4]
 800b7b6:	6039      	str	r1, [r7, #0]
    appSyncList.push_back(pAbsApp);
 800b7b8:	687b      	ldr	r3, [r7, #4]
 800b7ba:	330c      	adds	r3, #12
 800b7bc:	463a      	mov	r2, r7
 800b7be:	4611      	mov	r1, r2
 800b7c0:	4618      	mov	r0, r3
 800b7c2:	f000 fa9d 	bl	800bd00 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE9push_backERKS4_>
}
 800b7c6:	bf00      	nop
 800b7c8:	3708      	adds	r7, #8
 800b7ca:	46bd      	mov	sp, r7
 800b7cc:	bd80      	pop	{r7, pc}

0800b7ce <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh>:
 * @param   group
 *
 * @return  true if the publish request was succesful, false otherwise
 */
bool NetworkEntity::svPublishRequest(AbstractApplication* pAbsApp, SvGroup group)
{
 800b7ce:	b580      	push	{r7, lr}
 800b7d0:	b084      	sub	sp, #16
 800b7d2:	af00      	add	r7, sp, #0
 800b7d4:	60f8      	str	r0, [r7, #12]
 800b7d6:	60b9      	str	r1, [r7, #8]
 800b7d8:	4613      	mov	r3, r2
 800b7da:	71fb      	strb	r3, [r7, #7]
    if((group < MAX_GROUP_NBR) && (appPubArray[group] == nullptr))
 800b7dc:	79fb      	ldrb	r3, [r7, #7]
 800b7de:	2b0f      	cmp	r3, #15
 800b7e0:	d80c      	bhi.n	800b7fc <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh+0x2e>
 800b7e2:	68fb      	ldr	r3, [r7, #12]
 800b7e4:	3318      	adds	r3, #24
 800b7e6:	79fa      	ldrb	r2, [r7, #7]
 800b7e8:	4611      	mov	r1, r2
 800b7ea:	4618      	mov	r0, r3
 800b7ec:	f000 f9f1 	bl	800bbd2 <_ZNSt5arrayIPN7desenet6sensor19AbstractApplicationELj16EEixEj>
 800b7f0:	4603      	mov	r3, r0
 800b7f2:	681b      	ldr	r3, [r3, #0]
 800b7f4:	2b00      	cmp	r3, #0
 800b7f6:	d101      	bne.n	800b7fc <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh+0x2e>
 800b7f8:	2301      	movs	r3, #1
 800b7fa:	e000      	b.n	800b7fe <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh+0x30>
 800b7fc:	2300      	movs	r3, #0
 800b7fe:	2b00      	cmp	r3, #0
 800b800:	d00b      	beq.n	800b81a <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh+0x4c>
    {
        appPubArray[group] = pAbsApp;
 800b802:	68fb      	ldr	r3, [r7, #12]
 800b804:	3318      	adds	r3, #24
 800b806:	79fa      	ldrb	r2, [r7, #7]
 800b808:	4611      	mov	r1, r2
 800b80a:	4618      	mov	r0, r3
 800b80c:	f000 f9e1 	bl	800bbd2 <_ZNSt5arrayIPN7desenet6sensor19AbstractApplicationELj16EEixEj>
 800b810:	4602      	mov	r2, r0
 800b812:	68bb      	ldr	r3, [r7, #8]
 800b814:	6013      	str	r3, [r2, #0]
        return true;
 800b816:	2301      	movs	r3, #1
 800b818:	e000      	b.n	800b81c <_ZN7desenet6sensor13NetworkEntity16svPublishRequestEPNS0_19AbstractApplicationEh+0x4e>
    }
    else
    {
        return false;
 800b81a:	2300      	movs	r3, #0
    }
}
 800b81c:	4618      	mov	r0, r3
 800b81e:	3710      	adds	r7, #16
 800b820:	46bd      	mov	sp, r7
 800b822:	bd80      	pop	{r7, pc}

0800b824 <_ZN7desenet6sensor13NetworkEntity12EventElementD1Ev>:
    struct EventElement
 800b824:	b580      	push	{r7, lr}
 800b826:	b082      	sub	sp, #8
 800b828:	af00      	add	r7, sp, #0
 800b82a:	6078      	str	r0, [r7, #4]
 800b82c:	687b      	ldr	r3, [r7, #4]
 800b82e:	3304      	adds	r3, #4
 800b830:	4618      	mov	r0, r3
 800b832:	f7fb fff0 	bl	8007816 <_ZN3hei12SharedBufferIhED1Ev>
 800b836:	687b      	ldr	r3, [r7, #4]
 800b838:	4618      	mov	r0, r3
 800b83a:	3708      	adds	r7, #8
 800b83c:	46bd      	mov	sp, r7
 800b83e:	bd80      	pop	{r7, pc}

0800b840 <_ZN7desenet6sensor13NetworkEntity16evPublishRequestEtRKN3hei12SharedBufferIhEE>:
 * @param   evData      the reference to the buffer containing the event data
 *
 * @return  void
 */
void NetworkEntity::evPublishRequest(EvId id, const SharedByteBuffer & evData)
{
 800b840:	b580      	push	{r7, lr}
 800b842:	b088      	sub	sp, #32
 800b844:	af00      	add	r7, sp, #0
 800b846:	60f8      	str	r0, [r7, #12]
 800b848:	460b      	mov	r3, r1
 800b84a:	607a      	str	r2, [r7, #4]
 800b84c:	817b      	strh	r3, [r7, #10]
    EventElement evElm = EventElement(id, evData);      // create new EventElement
 800b84e:	8979      	ldrh	r1, [r7, #10]
 800b850:	f107 0310 	add.w	r3, r7, #16
 800b854:	687a      	ldr	r2, [r7, #4]
 800b856:	4618      	mov	r0, r3
 800b858:	f7ff fbff 	bl	800b05a <_ZN7desenet6sensor13NetworkEntity12EventElementC1EtRKN3hei12SharedBufferIhEE>
    evList.push_back(evElm);                            // add EventElement to end of list
 800b85c:	68fb      	ldr	r3, [r7, #12]
 800b85e:	3358      	adds	r3, #88	; 0x58
 800b860:	f107 0210 	add.w	r2, r7, #16
 800b864:	4611      	mov	r1, r2
 800b866:	4618      	mov	r0, r3
 800b868:	f000 fa5c 	bl	800bd24 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE9push_backERKS4_>
    if(evList.size() > MAX_EVELM_NBR)
 800b86c:	68fb      	ldr	r3, [r7, #12]
 800b86e:	3358      	adds	r3, #88	; 0x58
 800b870:	4618      	mov	r0, r3
 800b872:	f000 fa69 	bl	800bd48 <_ZNKSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE4sizeEv>
 800b876:	4603      	mov	r3, r0
 800b878:	2b1e      	cmp	r3, #30
 800b87a:	bf8c      	ite	hi
 800b87c:	2301      	movhi	r3, #1
 800b87e:	2300      	movls	r3, #0
 800b880:	b2db      	uxtb	r3, r3
 800b882:	2b00      	cmp	r3, #0
 800b884:	d003      	beq.n	800b88e <_ZN7desenet6sensor13NetworkEntity16evPublishRequestEtRKN3hei12SharedBufferIhEE+0x4e>
    {
        evList_pop_front_multi(CUTOFF_EVELM_NBR);       // remove oldest CUTOFF_EVELM_NBR elements
 800b886:	2104      	movs	r1, #4
 800b888:	68f8      	ldr	r0, [r7, #12]
 800b88a:	f000 f81f 	bl	800b8cc <_ZN7desenet6sensor13NetworkEntity22evList_pop_front_multiEh>
    EventElement evElm = EventElement(id, evData);      // create new EventElement
 800b88e:	f107 0310 	add.w	r3, r7, #16
 800b892:	4618      	mov	r0, r3
 800b894:	f7ff ffc6 	bl	800b824 <_ZN7desenet6sensor13NetworkEntity12EventElementD1Ev>
    }
}
 800b898:	bf00      	nop
 800b89a:	3720      	adds	r7, #32
 800b89c:	46bd      	mov	sp, r7
 800b89e:	bd80      	pop	{r7, pc}

0800b8a0 <_ZN7desenet6sensor13NetworkEntity16onTimeSlotSignalERK16ITimeSlotManagerRKNS2_3SIGE>:
 * @param   signal              the signal received from the time slot manager
 *
 * @return  void
 */
void NetworkEntity::onTimeSlotSignal(const ITimeSlotManager & timeSlotManager, const ITimeSlotManager::SIG & signal)
{
 800b8a0:	b580      	push	{r7, lr}
 800b8a2:	b084      	sub	sp, #16
 800b8a4:	af00      	add	r7, sp, #0
 800b8a6:	60f8      	str	r0, [r7, #12]
 800b8a8:	60b9      	str	r1, [r7, #8]
 800b8aa:	607a      	str	r2, [r7, #4]
    if(signal == ITimeSlotManager::OWN_SLOT_START)
 800b8ac:	687b      	ldr	r3, [r7, #4]
 800b8ae:	781b      	ldrb	r3, [r3, #0]
 800b8b0:	2b02      	cmp	r3, #2
 800b8b2:	d107      	bne.n	800b8c4 <_ZN7desenet6sensor13NetworkEntity16onTimeSlotSignalERK16ITimeSlotManagerRKNS2_3SIGE+0x24>
    {
        (*_pTransceiver) << mPDU;   // send MPDU to transceiver
 800b8b4:	68fb      	ldr	r3, [r7, #12]
 800b8b6:	689a      	ldr	r2, [r3, #8]
 800b8b8:	68fb      	ldr	r3, [r7, #12]
 800b8ba:	3364      	adds	r3, #100	; 0x64
 800b8bc:	4619      	mov	r1, r3
 800b8be:	4610      	mov	r0, r2
 800b8c0:	f7fd fbd6 	bl	8009070 <_ZN7desenetlsERNS_22NetworkInterfaceDriverERKNS_5FrameE>
    }
}
 800b8c4:	bf00      	nop
 800b8c6:	3710      	adds	r7, #16
 800b8c8:	46bd      	mov	sp, r7
 800b8ca:	bd80      	pop	{r7, pc}

0800b8cc <_ZN7desenet6sensor13NetworkEntity22evList_pop_front_multiEh>:
 * @param   elmNbr      the desired number of elements to erase at the front
 *
 * @return  void
 */
void NetworkEntity::evList_pop_front_multi(uint8_t elmNbr)
{
 800b8cc:	b590      	push	{r4, r7, lr}
 800b8ce:	b087      	sub	sp, #28
 800b8d0:	af00      	add	r7, sp, #0
 800b8d2:	6078      	str	r0, [r7, #4]
 800b8d4:	460b      	mov	r3, r1
 800b8d6:	70fb      	strb	r3, [r7, #3]
    auto cutoff_idx = evList.begin();
 800b8d8:	687b      	ldr	r3, [r7, #4]
 800b8da:	3358      	adds	r3, #88	; 0x58
 800b8dc:	4618      	mov	r0, r3
 800b8de:	f000 f9b8 	bl	800bc52 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5beginEv>
 800b8e2:	4603      	mov	r3, r0
 800b8e4:	60bb      	str	r3, [r7, #8]
    std::advance(cutoff_idx, elmNbr);           // go to desired index
 800b8e6:	78fa      	ldrb	r2, [r7, #3]
 800b8e8:	f107 0308 	add.w	r3, r7, #8
 800b8ec:	4611      	mov	r1, r2
 800b8ee:	4618      	mov	r0, r3
 800b8f0:	f000 fa36 	bl	800bd60 <_ZSt7advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEhEvRT_T0_>
    evList.erase(evList.begin(),cutoff_idx);    // erase all elements from start to desired index
 800b8f4:	687b      	ldr	r3, [r7, #4]
 800b8f6:	f103 0458 	add.w	r4, r3, #88	; 0x58
 800b8fa:	687b      	ldr	r3, [r7, #4]
 800b8fc:	3358      	adds	r3, #88	; 0x58
 800b8fe:	4618      	mov	r0, r3
 800b900:	f000 f9a7 	bl	800bc52 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5beginEv>
 800b904:	4603      	mov	r3, r0
 800b906:	613b      	str	r3, [r7, #16]
 800b908:	f107 0210 	add.w	r2, r7, #16
 800b90c:	f107 030c 	add.w	r3, r7, #12
 800b910:	4611      	mov	r1, r2
 800b912:	4618      	mov	r0, r3
 800b914:	f000 fa38 	bl	800bd88 <_ZNSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1ERKSt14_List_iteratorIS3_E>
 800b918:	f107 0208 	add.w	r2, r7, #8
 800b91c:	f107 0314 	add.w	r3, r7, #20
 800b920:	4611      	mov	r1, r2
 800b922:	4618      	mov	r0, r3
 800b924:	f000 fa30 	bl	800bd88 <_ZNSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1ERKSt14_List_iteratorIS3_E>
 800b928:	697a      	ldr	r2, [r7, #20]
 800b92a:	68f9      	ldr	r1, [r7, #12]
 800b92c:	4620      	mov	r0, r4
 800b92e:	f000 fa3b 	bl	800bda8 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_ES8_>
}
 800b932:	bf00      	nop
 800b934:	371c      	adds	r7, #28
 800b936:	46bd      	mov	sp, r7
 800b938:	bd90      	pop	{r4, r7, pc}

0800b93a <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE10_List_implC1Ev>:
	_List_impl() _GLIBCXX_NOEXCEPT_IF(
 800b93a:	b580      	push	{r7, lr}
 800b93c:	b082      	sub	sp, #8
 800b93e:	af00      	add	r7, sp, #0
 800b940:	6078      	str	r0, [r7, #4]
	: _Node_alloc_type()
 800b942:	6878      	ldr	r0, [r7, #4]
 800b944:	f000 fa5a 	bl	800bdfc <_ZNSaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEC1Ev>
 800b948:	687b      	ldr	r3, [r7, #4]
 800b94a:	4618      	mov	r0, r3
 800b94c:	f7ff fb06 	bl	800af5c <_ZNSt8__detail17_List_node_headerC1Ev>
	{ }
 800b950:	687b      	ldr	r3, [r7, #4]
 800b952:	4618      	mov	r0, r3
 800b954:	3708      	adds	r7, #8
 800b956:	46bd      	mov	sp, r7
 800b958:	bd80      	pop	{r7, pc}

0800b95a <_ZNSaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 800b95a:	b580      	push	{r7, lr}
 800b95c:	b082      	sub	sp, #8
 800b95e:	af00      	add	r7, sp, #0
 800b960:	6078      	str	r0, [r7, #4]
 800b962:	6878      	ldr	r0, [r7, #4]
 800b964:	f000 fa56 	bl	800be14 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEED1Ev>
 800b968:	687b      	ldr	r3, [r7, #4]
 800b96a:	4618      	mov	r0, r3
 800b96c:	3708      	adds	r7, #8
 800b96e:	46bd      	mov	sp, r7
 800b970:	bd80      	pop	{r7, pc}

0800b972 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EED1Ev>:
      ~_List_base() _GLIBCXX_NOEXCEPT
 800b972:	b580      	push	{r7, lr}
 800b974:	b082      	sub	sp, #8
 800b976:	af00      	add	r7, sp, #0
 800b978:	6078      	str	r0, [r7, #4]
      { _M_clear(); }
 800b97a:	6878      	ldr	r0, [r7, #4]
 800b97c:	f000 fa55 	bl	800be2a <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE8_M_clearEv>
 800b980:	687b      	ldr	r3, [r7, #4]
 800b982:	4618      	mov	r0, r3
 800b984:	f7ff fb8e 	bl	800b0a4 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE10_List_implD1Ev>
 800b988:	687b      	ldr	r3, [r7, #4]
 800b98a:	4618      	mov	r0, r3
 800b98c:	3708      	adds	r7, #8
 800b98e:	46bd      	mov	sp, r7
 800b990:	bd80      	pop	{r7, pc}

0800b992 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE10_List_implC1Ev>:
	_List_impl() _GLIBCXX_NOEXCEPT_IF(
 800b992:	b580      	push	{r7, lr}
 800b994:	b082      	sub	sp, #8
 800b996:	af00      	add	r7, sp, #0
 800b998:	6078      	str	r0, [r7, #4]
	: _Node_alloc_type()
 800b99a:	6878      	ldr	r0, [r7, #4]
 800b99c:	f000 fa6a 	bl	800be74 <_ZNSaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEC1Ev>
 800b9a0:	687b      	ldr	r3, [r7, #4]
 800b9a2:	4618      	mov	r0, r3
 800b9a4:	f7ff fada 	bl	800af5c <_ZNSt8__detail17_List_node_headerC1Ev>
	{ }
 800b9a8:	687b      	ldr	r3, [r7, #4]
 800b9aa:	4618      	mov	r0, r3
 800b9ac:	3708      	adds	r7, #8
 800b9ae:	46bd      	mov	sp, r7
 800b9b0:	bd80      	pop	{r7, pc}

0800b9b2 <_ZNSaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEED1Ev>:
 800b9b2:	b580      	push	{r7, lr}
 800b9b4:	b082      	sub	sp, #8
 800b9b6:	af00      	add	r7, sp, #0
 800b9b8:	6078      	str	r0, [r7, #4]
 800b9ba:	6878      	ldr	r0, [r7, #4]
 800b9bc:	f000 fa66 	bl	800be8c <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEED1Ev>
 800b9c0:	687b      	ldr	r3, [r7, #4]
 800b9c2:	4618      	mov	r0, r3
 800b9c4:	3708      	adds	r7, #8
 800b9c6:	46bd      	mov	sp, r7
 800b9c8:	bd80      	pop	{r7, pc}

0800b9ca <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EED1Ev>:
      ~_List_base() _GLIBCXX_NOEXCEPT
 800b9ca:	b580      	push	{r7, lr}
 800b9cc:	b082      	sub	sp, #8
 800b9ce:	af00      	add	r7, sp, #0
 800b9d0:	6078      	str	r0, [r7, #4]
      { _M_clear(); }
 800b9d2:	6878      	ldr	r0, [r7, #4]
 800b9d4:	f000 fa65 	bl	800bea2 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_clearEv>
 800b9d8:	687b      	ldr	r3, [r7, #4]
 800b9da:	4618      	mov	r0, r3
 800b9dc:	f7ff fb95 	bl	800b10a <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE10_List_implD1Ev>
 800b9e0:	687b      	ldr	r3, [r7, #4]
 800b9e2:	4618      	mov	r0, r3
 800b9e4:	3708      	adds	r7, #8
 800b9e6:	46bd      	mov	sp, r7
 800b9e8:	bd80      	pop	{r7, pc}

0800b9ea <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>:
      operator=(const __shared_count& __r) noexcept
 800b9ea:	b580      	push	{r7, lr}
 800b9ec:	b084      	sub	sp, #16
 800b9ee:	af00      	add	r7, sp, #0
 800b9f0:	6078      	str	r0, [r7, #4]
 800b9f2:	6039      	str	r1, [r7, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 800b9f4:	683b      	ldr	r3, [r7, #0]
 800b9f6:	681b      	ldr	r3, [r3, #0]
 800b9f8:	60fb      	str	r3, [r7, #12]
	if (__tmp != _M_pi)
 800b9fa:	687b      	ldr	r3, [r7, #4]
 800b9fc:	681b      	ldr	r3, [r3, #0]
 800b9fe:	68fa      	ldr	r2, [r7, #12]
 800ba00:	429a      	cmp	r2, r3
 800ba02:	d011      	beq.n	800ba28 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x3e>
	    if (__tmp != 0)
 800ba04:	68fb      	ldr	r3, [r7, #12]
 800ba06:	2b00      	cmp	r3, #0
 800ba08:	d002      	beq.n	800ba10 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x26>
	      __tmp->_M_add_ref_copy();
 800ba0a:	68f8      	ldr	r0, [r7, #12]
 800ba0c:	f7fd f812 	bl	8008a34 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE15_M_add_ref_copyEv>
	    if (_M_pi != 0)
 800ba10:	687b      	ldr	r3, [r7, #4]
 800ba12:	681b      	ldr	r3, [r3, #0]
 800ba14:	2b00      	cmp	r3, #0
 800ba16:	d004      	beq.n	800ba22 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x38>
	      _M_pi->_M_release();
 800ba18:	687b      	ldr	r3, [r7, #4]
 800ba1a:	681b      	ldr	r3, [r3, #0]
 800ba1c:	4618      	mov	r0, r3
 800ba1e:	f7fb fe7f 	bl	8007720 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
	    _M_pi = __tmp;
 800ba22:	687b      	ldr	r3, [r7, #4]
 800ba24:	68fa      	ldr	r2, [r7, #12]
 800ba26:	601a      	str	r2, [r3, #0]
	return *this;
 800ba28:	687b      	ldr	r3, [r7, #4]
      }
 800ba2a:	4618      	mov	r0, r3
 800ba2c:	3710      	adds	r7, #16
 800ba2e:	46bd      	mov	sp, r7
 800ba30:	bd80      	pop	{r7, pc}

0800ba32 <_ZSt4bindIMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEJPS2_RKSt12_PlaceholderILi1EERKSA_ILi2EERKSA_ILi3EERKSA_ILi4EEEENSt12_Bind_helperIXsrSt5__or_IJSt11is_integralINSt5decayIT_E4typeEESt7is_enumIST_EEE5valueESR_JDpT0_EE4typeEOSR_DpOSY_>:
   *  @ingroup binders
   */
  template<typename _Func, typename... _BoundArgs>
    inline _GLIBCXX20_CONSTEXPR typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
 800ba32:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ba36:	b089      	sub	sp, #36	; 0x24
 800ba38:	af04      	add	r7, sp, #16
 800ba3a:	60f8      	str	r0, [r7, #12]
 800ba3c:	60b9      	str	r1, [r7, #8]
 800ba3e:	607a      	str	r2, [r7, #4]
 800ba40:	603b      	str	r3, [r7, #0]
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
					  std::forward<_BoundArgs>(__args)...);
 800ba42:	68b8      	ldr	r0, [r7, #8]
 800ba44:	f000 fa52 	bl	800beec <_ZSt7forwardIMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEOT_RNSt16remove_referenceIS9_E4typeE>
 800ba48:	4606      	mov	r6, r0
 800ba4a:	6878      	ldr	r0, [r7, #4]
 800ba4c:	f000 fa59 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800ba50:	4680      	mov	r8, r0
 800ba52:	6838      	ldr	r0, [r7, #0]
 800ba54:	f000 fa60 	bl	800bf18 <_ZSt7forwardIRKSt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800ba58:	4681      	mov	r9, r0
 800ba5a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ba5c:	f000 fa67 	bl	800bf2e <_ZSt7forwardIRKSt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800ba60:	4604      	mov	r4, r0
 800ba62:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ba64:	f000 fa6e 	bl	800bf44 <_ZSt7forwardIRKSt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800ba68:	4605      	mov	r5, r0
 800ba6a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800ba6c:	f000 fa75 	bl	800bf5a <_ZSt7forwardIRKSt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800ba70:	4603      	mov	r3, r0
 800ba72:	9302      	str	r3, [sp, #8]
 800ba74:	9501      	str	r5, [sp, #4]
 800ba76:	9400      	str	r4, [sp, #0]
 800ba78:	464b      	mov	r3, r9
 800ba7a:	4642      	mov	r2, r8
 800ba7c:	4631      	mov	r1, r6
 800ba7e:	68f8      	ldr	r0, [r7, #12]
 800ba80:	f000 fa76 	bl	800bf70 <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEC1IJS9_RKSB_RKSC_RKSD_RKSE_EEEOS8_DpOT_>
    }
 800ba84:	68f8      	ldr	r0, [r7, #12]
 800ba86:	3714      	adds	r7, #20
 800ba88:	46bd      	mov	sp, r7
 800ba8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800ba8e <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1EOS9_>:
      _Tuple_impl(_Tuple_impl&& __in)
 800ba8e:	b590      	push	{r4, r7, lr}
 800ba90:	b083      	sub	sp, #12
 800ba92:	af00      	add	r7, sp, #0
 800ba94:	6078      	str	r0, [r7, #4]
 800ba96:	6039      	str	r1, [r7, #0]
      : _Inherited(std::move(_M_tail(__in))),
 800ba98:	6838      	ldr	r0, [r7, #0]
 800ba9a:	f000 fa9f 	bl	800bfdc <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEE7_M_tailERS9_>
 800ba9e:	4603      	mov	r3, r0
 800baa0:	4618      	mov	r0, r3
 800baa2:	f000 faa6 	bl	800bff2 <_ZSt4moveIRSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES1_ILi2EES1_ILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS9_>
 800baa6:	4603      	mov	r3, r0
	_Base(std::forward<_Head>(_M_head(__in))) { }
 800baa8:	4619      	mov	r1, r3
 800baaa:	6878      	ldr	r0, [r7, #4]
 800baac:	f000 fab9 	bl	800c022 <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEEC1EOS5_>
 800bab0:	687c      	ldr	r4, [r7, #4]
 800bab2:	6838      	ldr	r0, [r7, #0]
 800bab4:	f000 faa8 	bl	800c008 <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEE7_M_headERS9_>
 800bab8:	4603      	mov	r3, r0
 800baba:	4618      	mov	r0, r3
 800babc:	f000 fa21 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bac0:	4603      	mov	r3, r0
 800bac2:	4619      	mov	r1, r3
 800bac4:	4620      	mov	r0, r4
 800bac6:	f000 face 	bl	800c066 <_ZNSt10_Head_baseILj0EPN7desenet6sensor13NetworkEntityELb0EEC1IS3_EEOT_>
 800baca:	687b      	ldr	r3, [r7, #4]
 800bacc:	4618      	mov	r0, r3
 800bace:	370c      	adds	r7, #12
 800bad0:	46bd      	mov	sp, r7
 800bad2:	bd90      	pop	{r4, r7, pc}

0800bad4 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ISt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPSA_St12_PlaceholderILi1EESE_ILi2EESE_ILi3EESE_ILi4EEEEvvEET_>:
	}
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
 800bad4:	b590      	push	{r4, r7, lr}
 800bad6:	b083      	sub	sp, #12
 800bad8:	af00      	add	r7, sp, #0
 800bada:	6078      	str	r0, [r7, #4]
 800badc:	6039      	str	r1, [r7, #0]
      function(_Functor __f)
      : _Function_base()
 800bade:	687b      	ldr	r3, [r7, #4]
 800bae0:	4618      	mov	r0, r3
 800bae2:	f7ff fa99 	bl	800b018 <_ZNSt14_Function_baseC1Ev>
      {
	typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
 800bae6:	6838      	ldr	r0, [r7, #0]
 800bae8:	f000 face 	bl	800c088 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE21_M_not_empty_functionISI_EEbRKT_>
 800baec:	4603      	mov	r3, r0
 800baee:	2b00      	cmp	r3, #0
 800baf0:	d00e      	beq.n	800bb10 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ISt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPSA_St12_PlaceholderILi1EESE_ILi2EESE_ILi3EESE_ILi4EEEEvvEET_+0x3c>
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
 800baf2:	687c      	ldr	r4, [r7, #4]
 800baf4:	6838      	ldr	r0, [r7, #0]
 800baf6:	f000 fad2 	bl	800c09e <_ZSt4moveIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEONSt16remove_referenceIT_E4typeEOSK_>
 800bafa:	4603      	mov	r3, r0
 800bafc:	4619      	mov	r1, r3
 800bafe:	4620      	mov	r0, r4
 800bb00:	f000 fad8 	bl	800c0b4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE15_M_init_functorERSt9_Any_dataOSI_>
	    _M_invoker = &_My_handler::_M_invoke;
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	4a05      	ldr	r2, [pc, #20]	; (800bb1c <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ISt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPSA_St12_PlaceholderILi1EESE_ILi2EESE_ILi3EESE_ILi4EEEEvvEET_+0x48>)
 800bb08:	60da      	str	r2, [r3, #12]
	    _M_manager = &_My_handler::_M_manager;
 800bb0a:	687b      	ldr	r3, [r7, #4]
 800bb0c:	4a04      	ldr	r2, [pc, #16]	; (800bb20 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ISt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPSA_St12_PlaceholderILi1EESE_ILi2EESE_ILi3EESE_ILi4EEEEvvEET_+0x4c>)
 800bb0e:	609a      	str	r2, [r3, #8]
	  }
      }
 800bb10:	687b      	ldr	r3, [r7, #4]
 800bb12:	4618      	mov	r0, r3
 800bb14:	370c      	adds	r7, #12
 800bb16:	46bd      	mov	sp, r7
 800bb18:	bd90      	pop	{r4, r7, pc}
 800bb1a:	bf00      	nop
 800bb1c:	0800c0d9 	.word	0x0800c0d9
 800bb20:	0800c129 	.word	0x0800c129

0800bb24 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE5beginEv>:
      /**
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
 800bb24:	b580      	push	{r7, lr}
 800bb26:	b084      	sub	sp, #16
 800bb28:	af00      	add	r7, sp, #0
 800bb2a:	6078      	str	r0, [r7, #4]
      { return iterator(this->_M_impl._M_node._M_next); }
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	681a      	ldr	r2, [r3, #0]
 800bb30:	f107 030c 	add.w	r3, r7, #12
 800bb34:	4611      	mov	r1, r2
 800bb36:	4618      	mov	r0, r3
 800bb38:	f000 fb15 	bl	800c166 <_ZNSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEC1EPNSt8__detail15_List_node_baseE>
 800bb3c:	68fb      	ldr	r3, [r7, #12]
 800bb3e:	4618      	mov	r0, r3
 800bb40:	3710      	adds	r7, #16
 800bb42:	46bd      	mov	sp, r7
 800bb44:	bd80      	pop	{r7, pc}

0800bb46 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE3endEv>:
       *  Returns a read/write iterator that points one past the last
       *  element in the %list.  Iteration is done in ordinary element
       *  order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
 800bb46:	b580      	push	{r7, lr}
 800bb48:	b084      	sub	sp, #16
 800bb4a:	af00      	add	r7, sp, #0
 800bb4c:	6078      	str	r0, [r7, #4]
      { return iterator(&this->_M_impl._M_node); }
 800bb4e:	687a      	ldr	r2, [r7, #4]
 800bb50:	f107 030c 	add.w	r3, r7, #12
 800bb54:	4611      	mov	r1, r2
 800bb56:	4618      	mov	r0, r3
 800bb58:	f000 fb05 	bl	800c166 <_ZNSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEC1EPNSt8__detail15_List_node_baseE>
 800bb5c:	68fb      	ldr	r3, [r7, #12]
 800bb5e:	4618      	mov	r0, r3
 800bb60:	3710      	adds	r7, #16
 800bb62:	46bd      	mov	sp, r7
 800bb64:	bd80      	pop	{r7, pc}

0800bb66 <_ZStneRKSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEES6_>:
      operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 800bb66:	b480      	push	{r7}
 800bb68:	b083      	sub	sp, #12
 800bb6a:	af00      	add	r7, sp, #0
 800bb6c:	6078      	str	r0, [r7, #4]
 800bb6e:	6039      	str	r1, [r7, #0]
      { return __x._M_node != __y._M_node; }
 800bb70:	687b      	ldr	r3, [r7, #4]
 800bb72:	681a      	ldr	r2, [r3, #0]
 800bb74:	683b      	ldr	r3, [r7, #0]
 800bb76:	681b      	ldr	r3, [r3, #0]
 800bb78:	429a      	cmp	r2, r3
 800bb7a:	bf14      	ite	ne
 800bb7c:	2301      	movne	r3, #1
 800bb7e:	2300      	moveq	r3, #0
 800bb80:	b2db      	uxtb	r3, r3
 800bb82:	4618      	mov	r0, r3
 800bb84:	370c      	adds	r7, #12
 800bb86:	46bd      	mov	sp, r7
 800bb88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb8c:	4770      	bx	lr

0800bb8e <_ZNSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEppEi>:
      operator++(int) _GLIBCXX_NOEXCEPT
 800bb8e:	b480      	push	{r7}
 800bb90:	b085      	sub	sp, #20
 800bb92:	af00      	add	r7, sp, #0
 800bb94:	6078      	str	r0, [r7, #4]
 800bb96:	6039      	str	r1, [r7, #0]
	_Self __tmp = *this;
 800bb98:	687b      	ldr	r3, [r7, #4]
 800bb9a:	681b      	ldr	r3, [r3, #0]
 800bb9c:	60fb      	str	r3, [r7, #12]
	_M_node = _M_node->_M_next;
 800bb9e:	687b      	ldr	r3, [r7, #4]
 800bba0:	681b      	ldr	r3, [r3, #0]
 800bba2:	681a      	ldr	r2, [r3, #0]
 800bba4:	687b      	ldr	r3, [r7, #4]
 800bba6:	601a      	str	r2, [r3, #0]
	return __tmp;
 800bba8:	68fb      	ldr	r3, [r7, #12]
      }
 800bbaa:	4618      	mov	r0, r3
 800bbac:	3714      	adds	r7, #20
 800bbae:	46bd      	mov	sp, r7
 800bbb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbb4:	4770      	bx	lr

0800bbb6 <_ZNKSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEdeEv>:
      operator*() const _GLIBCXX_NOEXCEPT
 800bbb6:	b580      	push	{r7, lr}
 800bbb8:	b082      	sub	sp, #8
 800bbba:	af00      	add	r7, sp, #0
 800bbbc:	6078      	str	r0, [r7, #4]
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }
 800bbbe:	687b      	ldr	r3, [r7, #4]
 800bbc0:	681b      	ldr	r3, [r3, #0]
 800bbc2:	4618      	mov	r0, r3
 800bbc4:	f000 fade 	bl	800c184 <_ZNSt10_List_nodeIPN7desenet6sensor19AbstractApplicationEE9_M_valptrEv>
 800bbc8:	4603      	mov	r3, r0
 800bbca:	4618      	mov	r0, r3
 800bbcc:	3708      	adds	r7, #8
 800bbce:	46bd      	mov	sp, r7
 800bbd0:	bd80      	pop	{r7, pc}

0800bbd2 <_ZNSt5arrayIPN7desenet6sensor19AbstractApplicationELj16EEixEj>:
      _GLIBCXX_NODISCARD constexpr bool
      empty() const noexcept { return size() == 0; }

      // Element access.
      _GLIBCXX17_CONSTEXPR reference
      operator[](size_type __n) noexcept
 800bbd2:	b580      	push	{r7, lr}
 800bbd4:	b082      	sub	sp, #8
 800bbd6:	af00      	add	r7, sp, #0
 800bbd8:	6078      	str	r0, [r7, #4]
 800bbda:	6039      	str	r1, [r7, #0]
      { return _AT_Type::_S_ref(_M_elems, __n); }
 800bbdc:	687b      	ldr	r3, [r7, #4]
 800bbde:	6839      	ldr	r1, [r7, #0]
 800bbe0:	4618      	mov	r0, r3
 800bbe2:	f000 fadd 	bl	800c1a0 <_ZNSt14__array_traitsIPN7desenet6sensor19AbstractApplicationELj16EE6_S_refERA16_KS3_j>
 800bbe6:	4603      	mov	r3, r0
 800bbe8:	4618      	mov	r0, r3
 800bbea:	3708      	adds	r7, #8
 800bbec:	46bd      	mov	sp, r7
 800bbee:	bd80      	pop	{r7, pc}

0800bbf0 <_ZNSt6bitsetILj16EEixEj>:
       *  required by that DR's resolution.  -pme
       *  The DR has since been changed:  range-checking is a precondition
       *  (users' responsibility), and these functions must not throw.  -pme
       */
      reference
      operator[](size_t __position)
 800bbf0:	b580      	push	{r7, lr}
 800bbf2:	b084      	sub	sp, #16
 800bbf4:	af00      	add	r7, sp, #0
 800bbf6:	60f8      	str	r0, [r7, #12]
 800bbf8:	60b9      	str	r1, [r7, #8]
 800bbfa:	607a      	str	r2, [r7, #4]
      { return reference(*this, __position); }
 800bbfc:	687a      	ldr	r2, [r7, #4]
 800bbfe:	68b9      	ldr	r1, [r7, #8]
 800bc00:	68f8      	ldr	r0, [r7, #12]
 800bc02:	f000 fadc 	bl	800c1be <_ZNSt6bitsetILj16EE9referenceC1ERS0_j>
 800bc06:	68f8      	ldr	r0, [r7, #12]
 800bc08:	3710      	adds	r7, #16
 800bc0a:	46bd      	mov	sp, r7
 800bc0c:	bd80      	pop	{r7, pc}

0800bc0e <_ZNSt6bitsetILj16EE9referenceD1Ev>:
	~reference() _GLIBCXX_NOEXCEPT
 800bc0e:	b480      	push	{r7}
 800bc10:	b083      	sub	sp, #12
 800bc12:	af00      	add	r7, sp, #0
 800bc14:	6078      	str	r0, [r7, #4]
	{ }
 800bc16:	687b      	ldr	r3, [r7, #4]
 800bc18:	4618      	mov	r0, r3
 800bc1a:	370c      	adds	r7, #12
 800bc1c:	46bd      	mov	sp, r7
 800bc1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc22:	4770      	bx	lr

0800bc24 <_ZNKSt6bitsetILj16EE9referencecvbEv>:
	operator bool() const _GLIBCXX_NOEXCEPT
 800bc24:	b590      	push	{r4, r7, lr}
 800bc26:	b083      	sub	sp, #12
 800bc28:	af00      	add	r7, sp, #0
 800bc2a:	6078      	str	r0, [r7, #4]
	{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
 800bc2c:	687b      	ldr	r3, [r7, #4]
 800bc2e:	681b      	ldr	r3, [r3, #0]
 800bc30:	681c      	ldr	r4, [r3, #0]
 800bc32:	687b      	ldr	r3, [r7, #4]
 800bc34:	685b      	ldr	r3, [r3, #4]
 800bc36:	4618      	mov	r0, r3
 800bc38:	f7ff f9bd 	bl	800afb6 <_ZNSt12_Base_bitsetILj1EE10_S_maskbitEj>
 800bc3c:	4603      	mov	r3, r0
 800bc3e:	4023      	ands	r3, r4
 800bc40:	2b00      	cmp	r3, #0
 800bc42:	bf14      	ite	ne
 800bc44:	2301      	movne	r3, #1
 800bc46:	2300      	moveq	r3, #0
 800bc48:	b2db      	uxtb	r3, r3
 800bc4a:	4618      	mov	r0, r3
 800bc4c:	370c      	adds	r7, #12
 800bc4e:	46bd      	mov	sp, r7
 800bc50:	bd90      	pop	{r4, r7, pc}

0800bc52 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5beginEv>:
      begin() _GLIBCXX_NOEXCEPT
 800bc52:	b580      	push	{r7, lr}
 800bc54:	b084      	sub	sp, #16
 800bc56:	af00      	add	r7, sp, #0
 800bc58:	6078      	str	r0, [r7, #4]
      { return iterator(this->_M_impl._M_node._M_next); }
 800bc5a:	687b      	ldr	r3, [r7, #4]
 800bc5c:	681a      	ldr	r2, [r3, #0]
 800bc5e:	f107 030c 	add.w	r3, r7, #12
 800bc62:	4611      	mov	r1, r2
 800bc64:	4618      	mov	r0, r3
 800bc66:	f000 fac3 	bl	800c1f0 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1EPNSt8__detail15_List_node_baseE>
 800bc6a:	68fb      	ldr	r3, [r7, #12]
 800bc6c:	4618      	mov	r0, r3
 800bc6e:	3710      	adds	r7, #16
 800bc70:	46bd      	mov	sp, r7
 800bc72:	bd80      	pop	{r7, pc}

0800bc74 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE3endEv>:
      end() _GLIBCXX_NOEXCEPT
 800bc74:	b580      	push	{r7, lr}
 800bc76:	b084      	sub	sp, #16
 800bc78:	af00      	add	r7, sp, #0
 800bc7a:	6078      	str	r0, [r7, #4]
      { return iterator(&this->_M_impl._M_node); }
 800bc7c:	687a      	ldr	r2, [r7, #4]
 800bc7e:	f107 030c 	add.w	r3, r7, #12
 800bc82:	4611      	mov	r1, r2
 800bc84:	4618      	mov	r0, r3
 800bc86:	f000 fab3 	bl	800c1f0 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1EPNSt8__detail15_List_node_baseE>
 800bc8a:	68fb      	ldr	r3, [r7, #12]
 800bc8c:	4618      	mov	r0, r3
 800bc8e:	3710      	adds	r7, #16
 800bc90:	46bd      	mov	sp, r7
 800bc92:	bd80      	pop	{r7, pc}

0800bc94 <_ZStneRKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEES6_>:
      operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 800bc94:	b480      	push	{r7}
 800bc96:	b083      	sub	sp, #12
 800bc98:	af00      	add	r7, sp, #0
 800bc9a:	6078      	str	r0, [r7, #4]
 800bc9c:	6039      	str	r1, [r7, #0]
      { return __x._M_node != __y._M_node; }
 800bc9e:	687b      	ldr	r3, [r7, #4]
 800bca0:	681a      	ldr	r2, [r3, #0]
 800bca2:	683b      	ldr	r3, [r7, #0]
 800bca4:	681b      	ldr	r3, [r3, #0]
 800bca6:	429a      	cmp	r2, r3
 800bca8:	bf14      	ite	ne
 800bcaa:	2301      	movne	r3, #1
 800bcac:	2300      	moveq	r3, #0
 800bcae:	b2db      	uxtb	r3, r3
 800bcb0:	4618      	mov	r0, r3
 800bcb2:	370c      	adds	r7, #12
 800bcb4:	46bd      	mov	sp, r7
 800bcb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcba:	4770      	bx	lr

0800bcbc <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEppEi>:
      operator++(int) _GLIBCXX_NOEXCEPT
 800bcbc:	b480      	push	{r7}
 800bcbe:	b085      	sub	sp, #20
 800bcc0:	af00      	add	r7, sp, #0
 800bcc2:	6078      	str	r0, [r7, #4]
 800bcc4:	6039      	str	r1, [r7, #0]
	_Self __tmp = *this;
 800bcc6:	687b      	ldr	r3, [r7, #4]
 800bcc8:	681b      	ldr	r3, [r3, #0]
 800bcca:	60fb      	str	r3, [r7, #12]
	_M_node = _M_node->_M_next;
 800bccc:	687b      	ldr	r3, [r7, #4]
 800bcce:	681b      	ldr	r3, [r3, #0]
 800bcd0:	681a      	ldr	r2, [r3, #0]
 800bcd2:	687b      	ldr	r3, [r7, #4]
 800bcd4:	601a      	str	r2, [r3, #0]
	return __tmp;
 800bcd6:	68fb      	ldr	r3, [r7, #12]
      }
 800bcd8:	4618      	mov	r0, r3
 800bcda:	3714      	adds	r7, #20
 800bcdc:	46bd      	mov	sp, r7
 800bcde:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bce2:	4770      	bx	lr

0800bce4 <_ZNKSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEptEv>:
      operator->() const _GLIBCXX_NOEXCEPT
 800bce4:	b580      	push	{r7, lr}
 800bce6:	b082      	sub	sp, #8
 800bce8:	af00      	add	r7, sp, #0
 800bcea:	6078      	str	r0, [r7, #4]
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }
 800bcec:	687b      	ldr	r3, [r7, #4]
 800bcee:	681b      	ldr	r3, [r3, #0]
 800bcf0:	4618      	mov	r0, r3
 800bcf2:	f000 fa8c 	bl	800c20e <_ZNSt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEE9_M_valptrEv>
 800bcf6:	4603      	mov	r3, r0
 800bcf8:	4618      	mov	r0, r3
 800bcfa:	3708      	adds	r7, #8
 800bcfc:	46bd      	mov	sp, r7
 800bcfe:	bd80      	pop	{r7, pc}

0800bd00 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE9push_backERKS4_>:
       *  it.  Due to the nature of a %list this operation can be done
       *  in constant time, and does not invalidate iterators and
       *  references.
       */
      void
      push_back(const value_type& __x)
 800bd00:	b580      	push	{r7, lr}
 800bd02:	b082      	sub	sp, #8
 800bd04:	af00      	add	r7, sp, #0
 800bd06:	6078      	str	r0, [r7, #4]
 800bd08:	6039      	str	r1, [r7, #0]
      { this->_M_insert(end(), __x); }
 800bd0a:	6878      	ldr	r0, [r7, #4]
 800bd0c:	f7ff ff1b 	bl	800bb46 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE3endEv>
 800bd10:	4603      	mov	r3, r0
 800bd12:	683a      	ldr	r2, [r7, #0]
 800bd14:	4619      	mov	r1, r3
 800bd16:	6878      	ldr	r0, [r7, #4]
 800bd18:	f000 fa87 	bl	800c22a <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE9_M_insertIJRKS4_EEEvSt14_List_iteratorIS4_EDpOT_>
 800bd1c:	bf00      	nop
 800bd1e:	3708      	adds	r7, #8
 800bd20:	46bd      	mov	sp, r7
 800bd22:	bd80      	pop	{r7, pc}

0800bd24 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE9push_backERKS4_>:
      push_back(const value_type& __x)
 800bd24:	b580      	push	{r7, lr}
 800bd26:	b082      	sub	sp, #8
 800bd28:	af00      	add	r7, sp, #0
 800bd2a:	6078      	str	r0, [r7, #4]
 800bd2c:	6039      	str	r1, [r7, #0]
      { this->_M_insert(end(), __x); }
 800bd2e:	6878      	ldr	r0, [r7, #4]
 800bd30:	f7ff ffa0 	bl	800bc74 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE3endEv>
 800bd34:	4603      	mov	r3, r0
 800bd36:	683a      	ldr	r2, [r7, #0]
 800bd38:	4619      	mov	r1, r3
 800bd3a:	6878      	ldr	r0, [r7, #4]
 800bd3c:	f000 fa93 	bl	800c266 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE9_M_insertIJRKS4_EEEvSt14_List_iteratorIS4_EDpOT_>
 800bd40:	bf00      	nop
 800bd42:	3708      	adds	r7, #8
 800bd44:	46bd      	mov	sp, r7
 800bd46:	bd80      	pop	{r7, pc}

0800bd48 <_ZNKSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE4sizeEv>:
      size() const _GLIBCXX_NOEXCEPT
 800bd48:	b580      	push	{r7, lr}
 800bd4a:	b082      	sub	sp, #8
 800bd4c:	af00      	add	r7, sp, #0
 800bd4e:	6078      	str	r0, [r7, #4]
      { return _M_node_count(); }
 800bd50:	6878      	ldr	r0, [r7, #4]
 800bd52:	f000 faa6 	bl	800c2a2 <_ZNKSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE13_M_node_countEv>
 800bd56:	4603      	mov	r3, r0
 800bd58:	4618      	mov	r0, r3
 800bd5a:	3708      	adds	r7, #8
 800bd5c:	46bd      	mov	sp, r7
 800bd5e:	bd80      	pop	{r7, pc}

0800bd60 <_ZSt7advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEhEvRT_T0_>:
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator, typename _Distance>
    inline _GLIBCXX17_CONSTEXPR void
    advance(_InputIterator& __i, _Distance __n)
 800bd60:	b590      	push	{r4, r7, lr}
 800bd62:	b085      	sub	sp, #20
 800bd64:	af00      	add	r7, sp, #0
 800bd66:	6078      	str	r0, [r7, #4]
 800bd68:	460b      	mov	r3, r1
 800bd6a:	70fb      	strb	r3, [r7, #3]
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
 800bd6c:	78fb      	ldrb	r3, [r7, #3]
 800bd6e:	60fb      	str	r3, [r7, #12]
      std::__advance(__i, __d, std::__iterator_category(__i));
 800bd70:	6878      	ldr	r0, [r7, #4]
 800bd72:	f000 faa3 	bl	800c2bc <_ZSt19__iterator_categoryISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEENSt15iterator_traitsIT_E17iterator_categoryERKS7_>
 800bd76:	4622      	mov	r2, r4
 800bd78:	68f9      	ldr	r1, [r7, #12]
 800bd7a:	6878      	ldr	r0, [r7, #4]
 800bd7c:	f000 faa9 	bl	800c2d2 <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag>
    }
 800bd80:	bf00      	nop
 800bd82:	3714      	adds	r7, #20
 800bd84:	46bd      	mov	sp, r7
 800bd86:	bd90      	pop	{r4, r7, pc}

0800bd88 <_ZNSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1ERKSt14_List_iteratorIS3_E>:
      _List_const_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
 800bd88:	b480      	push	{r7}
 800bd8a:	b083      	sub	sp, #12
 800bd8c:	af00      	add	r7, sp, #0
 800bd8e:	6078      	str	r0, [r7, #4]
 800bd90:	6039      	str	r1, [r7, #0]
      : _M_node(__x._M_node) { }
 800bd92:	683b      	ldr	r3, [r7, #0]
 800bd94:	681a      	ldr	r2, [r3, #0]
 800bd96:	687b      	ldr	r3, [r7, #4]
 800bd98:	601a      	str	r2, [r3, #0]
 800bd9a:	687b      	ldr	r3, [r7, #4]
 800bd9c:	4618      	mov	r0, r3
 800bd9e:	370c      	adds	r7, #12
 800bda0:	46bd      	mov	sp, r7
 800bda2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bda6:	4770      	bx	lr

0800bda8 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_ES8_>:
       *  pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __first, const_iterator __last) noexcept
 800bda8:	b580      	push	{r7, lr}
 800bdaa:	b086      	sub	sp, #24
 800bdac:	af00      	add	r7, sp, #0
 800bdae:	60f8      	str	r0, [r7, #12]
 800bdb0:	60b9      	str	r1, [r7, #8]
 800bdb2:	607a      	str	r2, [r7, #4]
#else
      erase(iterator __first, iterator __last)
#endif
      {
	while (__first != __last)
 800bdb4:	1d3a      	adds	r2, r7, #4
 800bdb6:	f107 0308 	add.w	r3, r7, #8
 800bdba:	4611      	mov	r1, r2
 800bdbc:	4618      	mov	r0, r3
 800bdbe:	f000 fab1 	bl	800c324 <_ZStneRKSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEES6_>
 800bdc2:	4603      	mov	r3, r0
 800bdc4:	2b00      	cmp	r3, #0
 800bdc6:	d010      	beq.n	800bdea <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_ES8_+0x42>
	  __first = erase(__first);
 800bdc8:	68b9      	ldr	r1, [r7, #8]
 800bdca:	68f8      	ldr	r0, [r7, #12]
 800bdcc:	f000 fabe 	bl	800c34c <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_E>
 800bdd0:	4603      	mov	r3, r0
 800bdd2:	617b      	str	r3, [r7, #20]
 800bdd4:	f107 0214 	add.w	r2, r7, #20
 800bdd8:	f107 0310 	add.w	r3, r7, #16
 800bddc:	4611      	mov	r1, r2
 800bdde:	4618      	mov	r0, r3
 800bde0:	f7ff ffd2 	bl	800bd88 <_ZNSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1ERKSt14_List_iteratorIS3_E>
 800bde4:	693b      	ldr	r3, [r7, #16]
 800bde6:	60bb      	str	r3, [r7, #8]
	while (__first != __last)
 800bde8:	e7e4      	b.n	800bdb4 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_ES8_+0xc>
	return __last._M_const_cast();
 800bdea:	1d3b      	adds	r3, r7, #4
 800bdec:	4618      	mov	r0, r3
 800bdee:	f000 fac8 	bl	800c382 <_ZNKSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEE13_M_const_castEv>
 800bdf2:	4603      	mov	r3, r0
      }
 800bdf4:	4618      	mov	r0, r3
 800bdf6:	3718      	adds	r7, #24
 800bdf8:	46bd      	mov	sp, r7
 800bdfa:	bd80      	pop	{r7, pc}

0800bdfc <_ZNSaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEC1Ev>:
      allocator() _GLIBCXX_NOTHROW { }
 800bdfc:	b580      	push	{r7, lr}
 800bdfe:	b082      	sub	sp, #8
 800be00:	af00      	add	r7, sp, #0
 800be02:	6078      	str	r0, [r7, #4]
 800be04:	6878      	ldr	r0, [r7, #4]
 800be06:	f000 facd 	bl	800c3a4 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEC1Ev>
 800be0a:	687b      	ldr	r3, [r7, #4]
 800be0c:	4618      	mov	r0, r3
 800be0e:	3708      	adds	r7, #8
 800be10:	46bd      	mov	sp, r7
 800be12:	bd80      	pop	{r7, pc}

0800be14 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 800be14:	b480      	push	{r7}
 800be16:	b083      	sub	sp, #12
 800be18:	af00      	add	r7, sp, #0
 800be1a:	6078      	str	r0, [r7, #4]
 800be1c:	687b      	ldr	r3, [r7, #4]
 800be1e:	4618      	mov	r0, r3
 800be20:	370c      	adds	r7, #12
 800be22:	46bd      	mov	sp, r7
 800be24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be28:	4770      	bx	lr

0800be2a <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE8_M_clearEv>:
_GLIBCXX_BEGIN_NAMESPACE_VERSION
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
 800be2a:	b580      	push	{r7, lr}
 800be2c:	b086      	sub	sp, #24
 800be2e:	af00      	add	r7, sp, #0
 800be30:	6078      	str	r0, [r7, #4]
    _M_clear() _GLIBCXX_NOEXCEPT
    {
      typedef _List_node<_Tp>  _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
 800be32:	687b      	ldr	r3, [r7, #4]
 800be34:	681b      	ldr	r3, [r3, #0]
 800be36:	617b      	str	r3, [r7, #20]
      while (__cur != &_M_impl._M_node)
 800be38:	687b      	ldr	r3, [r7, #4]
 800be3a:	697a      	ldr	r2, [r7, #20]
 800be3c:	429a      	cmp	r2, r3
 800be3e:	d015      	beq.n	800be6c <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE8_M_clearEv+0x42>
	{
	  _Node* __tmp = static_cast<_Node*>(__cur);
 800be40:	697b      	ldr	r3, [r7, #20]
 800be42:	613b      	str	r3, [r7, #16]
	  __cur = __tmp->_M_next;
 800be44:	693b      	ldr	r3, [r7, #16]
 800be46:	681b      	ldr	r3, [r3, #0]
 800be48:	617b      	str	r3, [r7, #20]
	  _Tp* __val = __tmp->_M_valptr();
 800be4a:	6938      	ldr	r0, [r7, #16]
 800be4c:	f000 f99a 	bl	800c184 <_ZNSt10_List_nodeIPN7desenet6sensor19AbstractApplicationEE9_M_valptrEv>
 800be50:	60f8      	str	r0, [r7, #12]
#if __cplusplus >= 201103L
	  _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);
 800be52:	6878      	ldr	r0, [r7, #4]
 800be54:	f000 fab1 	bl	800c3ba <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE21_M_get_Node_allocatorEv>
 800be58:	4603      	mov	r3, r0
 800be5a:	68f9      	ldr	r1, [r7, #12]
 800be5c:	4618      	mov	r0, r3
 800be5e:	f000 fab7 	bl	800c3d0 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE7destroyIS4_EEvRS6_PT_>
#else
	  _Tp_alloc_type(_M_get_Node_allocator()).destroy(__val);
#endif
	  _M_put_node(__tmp);
 800be62:	6939      	ldr	r1, [r7, #16]
 800be64:	6878      	ldr	r0, [r7, #4]
 800be66:	f000 fac0 	bl	800c3ea <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_put_nodeEPSt10_List_nodeIS4_E>
      while (__cur != &_M_impl._M_node)
 800be6a:	e7e5      	b.n	800be38 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE8_M_clearEv+0xe>
	}
    }
 800be6c:	bf00      	nop
 800be6e:	3718      	adds	r7, #24
 800be70:	46bd      	mov	sp, r7
 800be72:	bd80      	pop	{r7, pc}

0800be74 <_ZNSaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEC1Ev>:
 800be74:	b580      	push	{r7, lr}
 800be76:	b082      	sub	sp, #8
 800be78:	af00      	add	r7, sp, #0
 800be7a:	6078      	str	r0, [r7, #4]
 800be7c:	6878      	ldr	r0, [r7, #4]
 800be7e:	f000 fac3 	bl	800c408 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEC1Ev>
 800be82:	687b      	ldr	r3, [r7, #4]
 800be84:	4618      	mov	r0, r3
 800be86:	3708      	adds	r7, #8
 800be88:	46bd      	mov	sp, r7
 800be8a:	bd80      	pop	{r7, pc}

0800be8c <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEED1Ev>:
 800be8c:	b480      	push	{r7}
 800be8e:	b083      	sub	sp, #12
 800be90:	af00      	add	r7, sp, #0
 800be92:	6078      	str	r0, [r7, #4]
 800be94:	687b      	ldr	r3, [r7, #4]
 800be96:	4618      	mov	r0, r3
 800be98:	370c      	adds	r7, #12
 800be9a:	46bd      	mov	sp, r7
 800be9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bea0:	4770      	bx	lr

0800bea2 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_clearEv>:
    _List_base<_Tp, _Alloc>::
 800bea2:	b580      	push	{r7, lr}
 800bea4:	b086      	sub	sp, #24
 800bea6:	af00      	add	r7, sp, #0
 800bea8:	6078      	str	r0, [r7, #4]
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
 800beaa:	687b      	ldr	r3, [r7, #4]
 800beac:	681b      	ldr	r3, [r3, #0]
 800beae:	617b      	str	r3, [r7, #20]
      while (__cur != &_M_impl._M_node)
 800beb0:	687b      	ldr	r3, [r7, #4]
 800beb2:	697a      	ldr	r2, [r7, #20]
 800beb4:	429a      	cmp	r2, r3
 800beb6:	d015      	beq.n	800bee4 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_clearEv+0x42>
	  _Node* __tmp = static_cast<_Node*>(__cur);
 800beb8:	697b      	ldr	r3, [r7, #20]
 800beba:	613b      	str	r3, [r7, #16]
	  __cur = __tmp->_M_next;
 800bebc:	693b      	ldr	r3, [r7, #16]
 800bebe:	681b      	ldr	r3, [r3, #0]
 800bec0:	617b      	str	r3, [r7, #20]
	  _Tp* __val = __tmp->_M_valptr();
 800bec2:	6938      	ldr	r0, [r7, #16]
 800bec4:	f000 f9a3 	bl	800c20e <_ZNSt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEE9_M_valptrEv>
 800bec8:	60f8      	str	r0, [r7, #12]
	  _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);
 800beca:	6878      	ldr	r0, [r7, #4]
 800becc:	f000 faa7 	bl	800c41e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE21_M_get_Node_allocatorEv>
 800bed0:	4603      	mov	r3, r0
 800bed2:	68f9      	ldr	r1, [r7, #12]
 800bed4:	4618      	mov	r0, r3
 800bed6:	f000 faad 	bl	800c434 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE7destroyIS4_EEvRS6_PT_>
	  _M_put_node(__tmp);
 800beda:	6939      	ldr	r1, [r7, #16]
 800bedc:	6878      	ldr	r0, [r7, #4]
 800bede:	f000 fab6 	bl	800c44e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_put_nodeEPSt10_List_nodeIS4_E>
      while (__cur != &_M_impl._M_node)
 800bee2:	e7e5      	b.n	800beb0 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_clearEv+0xe>
    }
 800bee4:	bf00      	nop
 800bee6:	3718      	adds	r7, #24
 800bee8:	46bd      	mov	sp, r7
 800beea:	bd80      	pop	{r7, pc}

0800beec <_ZSt7forwardIMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEOT_RNSt16remove_referenceIS9_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800beec:	b480      	push	{r7}
 800beee:	b083      	sub	sp, #12
 800bef0:	af00      	add	r7, sp, #0
 800bef2:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bef4:	687b      	ldr	r3, [r7, #4]
 800bef6:	4618      	mov	r0, r3
 800bef8:	370c      	adds	r7, #12
 800befa:	46bd      	mov	sp, r7
 800befc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf00:	4770      	bx	lr

0800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800bf02:	b480      	push	{r7}
 800bf04:	b083      	sub	sp, #12
 800bf06:	af00      	add	r7, sp, #0
 800bf08:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bf0a:	687b      	ldr	r3, [r7, #4]
 800bf0c:	4618      	mov	r0, r3
 800bf0e:	370c      	adds	r7, #12
 800bf10:	46bd      	mov	sp, r7
 800bf12:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf16:	4770      	bx	lr

0800bf18 <_ZSt7forwardIRKSt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800bf18:	b480      	push	{r7}
 800bf1a:	b083      	sub	sp, #12
 800bf1c:	af00      	add	r7, sp, #0
 800bf1e:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bf20:	687b      	ldr	r3, [r7, #4]
 800bf22:	4618      	mov	r0, r3
 800bf24:	370c      	adds	r7, #12
 800bf26:	46bd      	mov	sp, r7
 800bf28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf2c:	4770      	bx	lr

0800bf2e <_ZSt7forwardIRKSt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800bf2e:	b480      	push	{r7}
 800bf30:	b083      	sub	sp, #12
 800bf32:	af00      	add	r7, sp, #0
 800bf34:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bf36:	687b      	ldr	r3, [r7, #4]
 800bf38:	4618      	mov	r0, r3
 800bf3a:	370c      	adds	r7, #12
 800bf3c:	46bd      	mov	sp, r7
 800bf3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf42:	4770      	bx	lr

0800bf44 <_ZSt7forwardIRKSt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800bf44:	b480      	push	{r7}
 800bf46:	b083      	sub	sp, #12
 800bf48:	af00      	add	r7, sp, #0
 800bf4a:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bf4c:	687b      	ldr	r3, [r7, #4]
 800bf4e:	4618      	mov	r0, r3
 800bf50:	370c      	adds	r7, #12
 800bf52:	46bd      	mov	sp, r7
 800bf54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf58:	4770      	bx	lr

0800bf5a <_ZSt7forwardIRKSt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800bf5a:	b480      	push	{r7}
 800bf5c:	b083      	sub	sp, #12
 800bf5e:	af00      	add	r7, sp, #0
 800bf60:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	4618      	mov	r0, r3
 800bf66:	370c      	adds	r7, #12
 800bf68:	46bd      	mov	sp, r7
 800bf6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf6e:	4770      	bx	lr

0800bf70 <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEC1IJS9_RKSB_RKSC_RKSD_RKSE_EEEOS8_DpOT_>:
	_Bind(_Functor&& __f, _Args&&... __args)
 800bf70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bf74:	b087      	sub	sp, #28
 800bf76:	af02      	add	r7, sp, #8
 800bf78:	60f8      	str	r0, [r7, #12]
 800bf7a:	60b9      	str	r1, [r7, #8]
 800bf7c:	607a      	str	r2, [r7, #4]
 800bf7e:	603b      	str	r3, [r7, #0]
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 800bf80:	68b8      	ldr	r0, [r7, #8]
 800bf82:	f000 fa73 	bl	800c46c <_ZSt4moveIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEONSt16remove_referenceIT_E4typeEOSB_>
 800bf86:	4602      	mov	r2, r0
 800bf88:	68fb      	ldr	r3, [r7, #12]
 800bf8a:	e892 0003 	ldmia.w	r2, {r0, r1}
 800bf8e:	e883 0003 	stmia.w	r3, {r0, r1}
 800bf92:	68fb      	ldr	r3, [r7, #12]
 800bf94:	f103 0408 	add.w	r4, r3, #8
 800bf98:	6878      	ldr	r0, [r7, #4]
 800bf9a:	f7ff ffb2 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bf9e:	4606      	mov	r6, r0
 800bfa0:	6838      	ldr	r0, [r7, #0]
 800bfa2:	f7ff ffb9 	bl	800bf18 <_ZSt7forwardIRKSt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bfa6:	4680      	mov	r8, r0
 800bfa8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800bfaa:	f7ff ffc0 	bl	800bf2e <_ZSt7forwardIRKSt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bfae:	4681      	mov	r9, r0
 800bfb0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800bfb2:	f7ff ffc7 	bl	800bf44 <_ZSt7forwardIRKSt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bfb6:	4605      	mov	r5, r0
 800bfb8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800bfba:	f7ff ffce 	bl	800bf5a <_ZSt7forwardIRKSt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800bfbe:	4603      	mov	r3, r0
 800bfc0:	9301      	str	r3, [sp, #4]
 800bfc2:	9500      	str	r5, [sp, #0]
 800bfc4:	464b      	mov	r3, r9
 800bfc6:	4642      	mov	r2, r8
 800bfc8:	4631      	mov	r1, r6
 800bfca:	4620      	mov	r0, r4
 800bfcc:	f000 fa59 	bl	800c482 <_ZNSt5tupleIJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1IJS3_RKS5_RKS6_RKS7_RKS8_ELb1ELb1EEEDpOT_>
	{ }
 800bfd0:	68fb      	ldr	r3, [r7, #12]
 800bfd2:	4618      	mov	r0, r3
 800bfd4:	3714      	adds	r7, #20
 800bfd6:	46bd      	mov	sp, r7
 800bfd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800bfdc <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEE7_M_tailERS9_>:
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
 800bfdc:	b480      	push	{r7}
 800bfde:	b083      	sub	sp, #12
 800bfe0:	af00      	add	r7, sp, #0
 800bfe2:	6078      	str	r0, [r7, #4]
 800bfe4:	687b      	ldr	r3, [r7, #4]
 800bfe6:	4618      	mov	r0, r3
 800bfe8:	370c      	adds	r7, #12
 800bfea:	46bd      	mov	sp, r7
 800bfec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bff0:	4770      	bx	lr

0800bff2 <_ZSt4moveIRSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES1_ILi2EES1_ILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS9_>:
    move(_Tp&& __t) noexcept
 800bff2:	b480      	push	{r7}
 800bff4:	b083      	sub	sp, #12
 800bff6:	af00      	add	r7, sp, #0
 800bff8:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800bffa:	687b      	ldr	r3, [r7, #4]
 800bffc:	4618      	mov	r0, r3
 800bffe:	370c      	adds	r7, #12
 800c000:	46bd      	mov	sp, r7
 800c002:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c006:	4770      	bx	lr

0800c008 <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEE7_M_headERS9_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800c008:	b580      	push	{r7, lr}
 800c00a:	b082      	sub	sp, #8
 800c00c:	af00      	add	r7, sp, #0
 800c00e:	6078      	str	r0, [r7, #4]
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	4618      	mov	r0, r3
 800c014:	f000 fa60 	bl	800c4d8 <_ZNSt10_Head_baseILj0EPN7desenet6sensor13NetworkEntityELb0EE7_M_headERS4_>
 800c018:	4603      	mov	r3, r0
 800c01a:	4618      	mov	r0, r3
 800c01c:	3708      	adds	r7, #8
 800c01e:	46bd      	mov	sp, r7
 800c020:	bd80      	pop	{r7, pc}

0800c022 <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEEC1EOS5_>:
      _Tuple_impl(_Tuple_impl&& __in)
 800c022:	b580      	push	{r7, lr}
 800c024:	b082      	sub	sp, #8
 800c026:	af00      	add	r7, sp, #0
 800c028:	6078      	str	r0, [r7, #4]
 800c02a:	6039      	str	r1, [r7, #0]
      : _Inherited(std::move(_M_tail(__in))),
 800c02c:	6838      	ldr	r0, [r7, #0]
 800c02e:	f000 fa5e 	bl	800c4ee <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEE7_M_tailERS5_>
 800c032:	4603      	mov	r3, r0
 800c034:	4618      	mov	r0, r3
 800c036:	f000 fa65 	bl	800c504 <_ZSt4moveIRSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES1_ILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS8_>
 800c03a:	4603      	mov	r3, r0
	_Base(std::forward<_Head>(_M_head(__in))) { }
 800c03c:	4619      	mov	r1, r3
 800c03e:	6878      	ldr	r0, [r7, #4]
 800c040:	f000 fa82 	bl	800c548 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEEC1EOS4_>
 800c044:	6838      	ldr	r0, [r7, #0]
 800c046:	f000 fa68 	bl	800c51a <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS5_>
 800c04a:	4603      	mov	r3, r0
 800c04c:	4618      	mov	r0, r3
 800c04e:	f000 fa70 	bl	800c532 <_ZSt7forwardISt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800c052:	4603      	mov	r3, r0
 800c054:	4619      	mov	r1, r3
 800c056:	6878      	ldr	r0, [r7, #4]
 800c058:	f000 fa98 	bl	800c58c <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EEC1IS1_EEOT_>
 800c05c:	687b      	ldr	r3, [r7, #4]
 800c05e:	4618      	mov	r0, r3
 800c060:	3708      	adds	r7, #8
 800c062:	46bd      	mov	sp, r7
 800c064:	bd80      	pop	{r7, pc}

0800c066 <_ZNSt10_Head_baseILj0EPN7desenet6sensor13NetworkEntityELb0EEC1IS3_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800c066:	b580      	push	{r7, lr}
 800c068:	b082      	sub	sp, #8
 800c06a:	af00      	add	r7, sp, #0
 800c06c:	6078      	str	r0, [r7, #4]
 800c06e:	6039      	str	r1, [r7, #0]
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 800c070:	6838      	ldr	r0, [r7, #0]
 800c072:	f7ff ff46 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c076:	4603      	mov	r3, r0
 800c078:	681a      	ldr	r2, [r3, #0]
 800c07a:	687b      	ldr	r3, [r7, #4]
 800c07c:	601a      	str	r2, [r3, #0]
 800c07e:	687b      	ldr	r3, [r7, #4]
 800c080:	4618      	mov	r0, r3
 800c082:	3708      	adds	r7, #8
 800c084:	46bd      	mov	sp, r7
 800c086:	bd80      	pop	{r7, pc}

0800c088 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE21_M_not_empty_functionISI_EEbRKT_>:
	  _M_not_empty_function(const _Tp&)
 800c088:	b480      	push	{r7}
 800c08a:	b083      	sub	sp, #12
 800c08c:	af00      	add	r7, sp, #0
 800c08e:	6078      	str	r0, [r7, #4]
	  { return true; }
 800c090:	2301      	movs	r3, #1
 800c092:	4618      	mov	r0, r3
 800c094:	370c      	adds	r7, #12
 800c096:	46bd      	mov	sp, r7
 800c098:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c09c:	4770      	bx	lr

0800c09e <_ZSt4moveIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEONSt16remove_referenceIT_E4typeEOSK_>:
    move(_Tp&& __t) noexcept
 800c09e:	b480      	push	{r7}
 800c0a0:	b083      	sub	sp, #12
 800c0a2:	af00      	add	r7, sp, #0
 800c0a4:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	4618      	mov	r0, r3
 800c0aa:	370c      	adds	r7, #12
 800c0ac:	46bd      	mov	sp, r7
 800c0ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0b2:	4770      	bx	lr

0800c0b4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE15_M_init_functorERSt9_Any_dataOSI_>:
	_M_init_functor(_Any_data& __functor, _Functor&& __f)
 800c0b4:	b590      	push	{r4, r7, lr}
 800c0b6:	b083      	sub	sp, #12
 800c0b8:	af00      	add	r7, sp, #0
 800c0ba:	6078      	str	r0, [r7, #4]
 800c0bc:	6039      	str	r1, [r7, #0]
	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
 800c0be:	6838      	ldr	r0, [r7, #0]
 800c0c0:	f7ff ffed 	bl	800c09e <_ZSt4moveIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEONSt16remove_referenceIT_E4typeEOSK_>
 800c0c4:	4603      	mov	r3, r0
 800c0c6:	4622      	mov	r2, r4
 800c0c8:	4619      	mov	r1, r3
 800c0ca:	6878      	ldr	r0, [r7, #4]
 800c0cc:	f000 fa6b 	bl	800c5a6 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE15_M_init_functorERSt9_Any_dataOSI_St17integral_constantIbLb0EE>
 800c0d0:	bf00      	nop
 800c0d2:	370c      	adds	r7, #12
 800c0d4:	46bd      	mov	sp, r7
 800c0d6:	bd90      	pop	{r4, r7, pc}

0800c0d8 <_ZNSt17_Function_handlerIFvRN7desenet22NetworkInterfaceDriverEmPKhjESt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPS8_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE9_M_invokeERKSt9_Any_dataS2_OmOS4_Oj>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 800c0d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c0dc:	b086      	sub	sp, #24
 800c0de:	af02      	add	r7, sp, #8
 800c0e0:	60f8      	str	r0, [r7, #12]
 800c0e2:	60b9      	str	r1, [r7, #8]
 800c0e4:	607a      	str	r2, [r7, #4]
 800c0e6:	603b      	str	r3, [r7, #0]
	return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
 800c0e8:	68f8      	ldr	r0, [r7, #12]
 800c0ea:	f000 fa78 	bl	800c5de <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE14_M_get_pointerERKSt9_Any_data>
 800c0ee:	4604      	mov	r4, r0
 800c0f0:	68b8      	ldr	r0, [r7, #8]
 800c0f2:	f000 fa81 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800c0f6:	4605      	mov	r5, r0
 800c0f8:	6878      	ldr	r0, [r7, #4]
 800c0fa:	f000 fa88 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800c0fe:	4606      	mov	r6, r0
 800c100:	6838      	ldr	r0, [r7, #0]
 800c102:	f000 fa8f 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800c106:	4680      	mov	r8, r0
 800c108:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800c10a:	f000 fa96 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800c10e:	4603      	mov	r3, r0
 800c110:	9300      	str	r3, [sp, #0]
 800c112:	4643      	mov	r3, r8
 800c114:	4632      	mov	r2, r6
 800c116:	4629      	mov	r1, r5
 800c118:	4620      	mov	r0, r4
 800c11a:	f000 fa99 	bl	800c650 <_ZSt10__invoke_rIvRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEJS5_mS7_jEENSt9enable_ifIXsrSt6__and_IJSt7is_voidIT_ESt14__is_invocableIT0_JDpT1_EEEE5valueESM_E4typeEOSP_DpOSQ_>
				     std::forward<_ArgTypes>(__args)...);
 800c11e:	bf00      	nop
      }
 800c120:	3710      	adds	r7, #16
 800c122:	46bd      	mov	sp, r7
 800c124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800c128 <_ZNSt17_Function_handlerIFvRN7desenet22NetworkInterfaceDriverEmPKhjESt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPS8_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation>:
      _M_manager(_Any_data& __dest, const _Any_data& __source,
 800c128:	b590      	push	{r4, r7, lr}
 800c12a:	b085      	sub	sp, #20
 800c12c:	af00      	add	r7, sp, #0
 800c12e:	60f8      	str	r0, [r7, #12]
 800c130:	60b9      	str	r1, [r7, #8]
 800c132:	4613      	mov	r3, r2
 800c134:	71fb      	strb	r3, [r7, #7]
	switch (__op)
 800c136:	79fb      	ldrb	r3, [r7, #7]
 800c138:	2b01      	cmp	r3, #1
 800c13a:	d109      	bne.n	800c150 <_ZNSt17_Function_handlerIFvRN7desenet22NetworkInterfaceDriverEmPKhjESt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPS8_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x28>
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
 800c13c:	68f8      	ldr	r0, [r7, #12]
 800c13e:	f000 fab0 	bl	800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>
 800c142:	4604      	mov	r4, r0
 800c144:	68b8      	ldr	r0, [r7, #8]
 800c146:	f000 fa4a 	bl	800c5de <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE14_M_get_pointerERKSt9_Any_data>
 800c14a:	4603      	mov	r3, r0
 800c14c:	6023      	str	r3, [r4, #0]
	    break;
 800c14e:	e005      	b.n	800c15c <_ZNSt17_Function_handlerIFvRN7desenet22NetworkInterfaceDriverEmPKhjESt5_BindIFMNS0_6sensor13NetworkEntityEFvS2_mS4_jEPS8_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x34>
	    _Base::_M_manager(__dest, __source, __op);
 800c150:	79fb      	ldrb	r3, [r7, #7]
 800c152:	461a      	mov	r2, r3
 800c154:	68b9      	ldr	r1, [r7, #8]
 800c156:	68f8      	ldr	r0, [r7, #12]
 800c158:	f000 faaf 	bl	800c6ba <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation>
	return false;
 800c15c:	2300      	movs	r3, #0
      }
 800c15e:	4618      	mov	r0, r3
 800c160:	3714      	adds	r7, #20
 800c162:	46bd      	mov	sp, r7
 800c164:	bd90      	pop	{r4, r7, pc}

0800c166 <_ZNSt14_List_iteratorIPN7desenet6sensor19AbstractApplicationEEC1EPNSt8__detail15_List_node_baseE>:
      _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
 800c166:	b480      	push	{r7}
 800c168:	b083      	sub	sp, #12
 800c16a:	af00      	add	r7, sp, #0
 800c16c:	6078      	str	r0, [r7, #4]
 800c16e:	6039      	str	r1, [r7, #0]
      : _M_node(__x) { }
 800c170:	687b      	ldr	r3, [r7, #4]
 800c172:	683a      	ldr	r2, [r7, #0]
 800c174:	601a      	str	r2, [r3, #0]
 800c176:	687b      	ldr	r3, [r7, #4]
 800c178:	4618      	mov	r0, r3
 800c17a:	370c      	adds	r7, #12
 800c17c:	46bd      	mov	sp, r7
 800c17e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c182:	4770      	bx	lr

0800c184 <_ZNSt10_List_nodeIPN7desenet6sensor19AbstractApplicationEE9_M_valptrEv>:
      _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
 800c184:	b580      	push	{r7, lr}
 800c186:	b082      	sub	sp, #8
 800c188:	af00      	add	r7, sp, #0
 800c18a:	6078      	str	r0, [r7, #4]
 800c18c:	687b      	ldr	r3, [r7, #4]
 800c18e:	3308      	adds	r3, #8
 800c190:	4618      	mov	r0, r3
 800c192:	f000 fabd 	bl	800c710 <_ZN9__gnu_cxx16__aligned_membufIPN7desenet6sensor19AbstractApplicationEE6_M_ptrEv>
 800c196:	4603      	mov	r3, r0
 800c198:	4618      	mov	r0, r3
 800c19a:	3708      	adds	r7, #8
 800c19c:	46bd      	mov	sp, r7
 800c19e:	bd80      	pop	{r7, pc}

0800c1a0 <_ZNSt14__array_traitsIPN7desenet6sensor19AbstractApplicationELj16EE6_S_refERA16_KS3_j>:
      _S_ref(const _Type& __t, std::size_t __n) noexcept
 800c1a0:	b480      	push	{r7}
 800c1a2:	b083      	sub	sp, #12
 800c1a4:	af00      	add	r7, sp, #0
 800c1a6:	6078      	str	r0, [r7, #4]
 800c1a8:	6039      	str	r1, [r7, #0]
      { return const_cast<_Tp&>(__t[__n]); }
 800c1aa:	683b      	ldr	r3, [r7, #0]
 800c1ac:	009b      	lsls	r3, r3, #2
 800c1ae:	687a      	ldr	r2, [r7, #4]
 800c1b0:	4413      	add	r3, r2
 800c1b2:	4618      	mov	r0, r3
 800c1b4:	370c      	adds	r7, #12
 800c1b6:	46bd      	mov	sp, r7
 800c1b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1bc:	4770      	bx	lr

0800c1be <_ZNSt6bitsetILj16EE9referenceC1ERS0_j>:
	reference(bitset& __b, size_t __pos) _GLIBCXX_NOEXCEPT
 800c1be:	b580      	push	{r7, lr}
 800c1c0:	b084      	sub	sp, #16
 800c1c2:	af00      	add	r7, sp, #0
 800c1c4:	60f8      	str	r0, [r7, #12]
 800c1c6:	60b9      	str	r1, [r7, #8]
 800c1c8:	607a      	str	r2, [r7, #4]
	  _M_wp = &__b._M_getword(__pos);
 800c1ca:	68bb      	ldr	r3, [r7, #8]
 800c1cc:	6879      	ldr	r1, [r7, #4]
 800c1ce:	4618      	mov	r0, r3
 800c1d0:	f7fe ff00 	bl	800afd4 <_ZNSt12_Base_bitsetILj1EE10_M_getwordEj>
 800c1d4:	4602      	mov	r2, r0
 800c1d6:	68fb      	ldr	r3, [r7, #12]
 800c1d8:	601a      	str	r2, [r3, #0]
	  _M_bpos = _Base::_S_whichbit(__pos);
 800c1da:	6878      	ldr	r0, [r7, #4]
 800c1dc:	f7fe fede 	bl	800af9c <_ZNSt12_Base_bitsetILj1EE11_S_whichbitEj>
 800c1e0:	4602      	mov	r2, r0
 800c1e2:	68fb      	ldr	r3, [r7, #12]
 800c1e4:	605a      	str	r2, [r3, #4]
	}
 800c1e6:	68fb      	ldr	r3, [r7, #12]
 800c1e8:	4618      	mov	r0, r3
 800c1ea:	3710      	adds	r7, #16
 800c1ec:	46bd      	mov	sp, r7
 800c1ee:	bd80      	pop	{r7, pc}

0800c1f0 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1EPNSt8__detail15_List_node_baseE>:
      _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
 800c1f0:	b480      	push	{r7}
 800c1f2:	b083      	sub	sp, #12
 800c1f4:	af00      	add	r7, sp, #0
 800c1f6:	6078      	str	r0, [r7, #4]
 800c1f8:	6039      	str	r1, [r7, #0]
      : _M_node(__x) { }
 800c1fa:	687b      	ldr	r3, [r7, #4]
 800c1fc:	683a      	ldr	r2, [r7, #0]
 800c1fe:	601a      	str	r2, [r3, #0]
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	4618      	mov	r0, r3
 800c204:	370c      	adds	r7, #12
 800c206:	46bd      	mov	sp, r7
 800c208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c20c:	4770      	bx	lr

0800c20e <_ZNSt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEE9_M_valptrEv>:
      _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
 800c20e:	b580      	push	{r7, lr}
 800c210:	b082      	sub	sp, #8
 800c212:	af00      	add	r7, sp, #0
 800c214:	6078      	str	r0, [r7, #4]
 800c216:	687b      	ldr	r3, [r7, #4]
 800c218:	3308      	adds	r3, #8
 800c21a:	4618      	mov	r0, r3
 800c21c:	f000 fa84 	bl	800c728 <_ZN9__gnu_cxx16__aligned_membufIN7desenet6sensor13NetworkEntity12EventElementEE6_M_ptrEv>
 800c220:	4603      	mov	r3, r0
 800c222:	4618      	mov	r0, r3
 800c224:	3708      	adds	r7, #8
 800c226:	46bd      	mov	sp, r7
 800c228:	bd80      	pop	{r7, pc}

0800c22a <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE9_M_insertIJRKS4_EEEvSt14_List_iteratorIS4_EDpOT_>:
	this->_M_inc_size(1);
      }
#else
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
 800c22a:	b580      	push	{r7, lr}
 800c22c:	b086      	sub	sp, #24
 800c22e:	af00      	add	r7, sp, #0
 800c230:	60f8      	str	r0, [r7, #12]
 800c232:	60b9      	str	r1, [r7, #8]
 800c234:	607a      	str	r2, [r7, #4]
       {
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 800c236:	6878      	ldr	r0, [r7, #4]
 800c238:	f000 fa82 	bl	800c740 <_ZSt7forwardIRKPN7desenet6sensor19AbstractApplicationEEOT_RNSt16remove_referenceIS6_E4typeE>
 800c23c:	4603      	mov	r3, r0
 800c23e:	4619      	mov	r1, r3
 800c240:	68f8      	ldr	r0, [r7, #12]
 800c242:	f000 fa88 	bl	800c756 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE14_M_create_nodeIJRKS4_EEEPSt10_List_nodeIS4_EDpOT_>
 800c246:	6178      	str	r0, [r7, #20]
	 __tmp->_M_hook(__position._M_node);
 800c248:	697b      	ldr	r3, [r7, #20]
 800c24a:	68ba      	ldr	r2, [r7, #8]
 800c24c:	4611      	mov	r1, r2
 800c24e:	4618      	mov	r0, r3
 800c250:	f009 ffd7 	bl	8016202 <_ZNSt8__detail15_List_node_base7_M_hookEPS0_>
	 this->_M_inc_size(1);
 800c254:	68fb      	ldr	r3, [r7, #12]
 800c256:	2101      	movs	r1, #1
 800c258:	4618      	mov	r0, r3
 800c25a:	f000 fab0 	bl	800c7be <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_inc_sizeEj>
       }
 800c25e:	bf00      	nop
 800c260:	3718      	adds	r7, #24
 800c262:	46bd      	mov	sp, r7
 800c264:	bd80      	pop	{r7, pc}

0800c266 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE9_M_insertIJRKS4_EEEvSt14_List_iteratorIS4_EDpOT_>:
       _M_insert(iterator __position, _Args&&... __args)
 800c266:	b580      	push	{r7, lr}
 800c268:	b086      	sub	sp, #24
 800c26a:	af00      	add	r7, sp, #0
 800c26c:	60f8      	str	r0, [r7, #12]
 800c26e:	60b9      	str	r1, [r7, #8]
 800c270:	607a      	str	r2, [r7, #4]
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 800c272:	6878      	ldr	r0, [r7, #4]
 800c274:	f000 fab4 	bl	800c7e0 <_ZSt7forwardIRKN7desenet6sensor13NetworkEntity12EventElementEEOT_RNSt16remove_referenceIS6_E4typeE>
 800c278:	4603      	mov	r3, r0
 800c27a:	4619      	mov	r1, r3
 800c27c:	68f8      	ldr	r0, [r7, #12]
 800c27e:	f000 faba 	bl	800c7f6 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE14_M_create_nodeIJRKS4_EEEPSt10_List_nodeIS4_EDpOT_>
 800c282:	6178      	str	r0, [r7, #20]
	 __tmp->_M_hook(__position._M_node);
 800c284:	697b      	ldr	r3, [r7, #20]
 800c286:	68ba      	ldr	r2, [r7, #8]
 800c288:	4611      	mov	r1, r2
 800c28a:	4618      	mov	r0, r3
 800c28c:	f009 ffb9 	bl	8016202 <_ZNSt8__detail15_List_node_base7_M_hookEPS0_>
	 this->_M_inc_size(1);
 800c290:	68fb      	ldr	r3, [r7, #12]
 800c292:	2101      	movs	r1, #1
 800c294:	4618      	mov	r0, r3
 800c296:	f000 fae2 	bl	800c85e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_inc_sizeEj>
       }
 800c29a:	bf00      	nop
 800c29c:	3718      	adds	r7, #24
 800c29e:	46bd      	mov	sp, r7
 800c2a0:	bd80      	pop	{r7, pc}

0800c2a2 <_ZNKSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE13_M_node_countEv>:
      _M_node_count() const
 800c2a2:	b580      	push	{r7, lr}
 800c2a4:	b082      	sub	sp, #8
 800c2a6:	af00      	add	r7, sp, #0
 800c2a8:	6078      	str	r0, [r7, #4]
      { return this->_M_get_size(); }
 800c2aa:	687b      	ldr	r3, [r7, #4]
 800c2ac:	4618      	mov	r0, r3
 800c2ae:	f000 fae7 	bl	800c880 <_ZNKSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_get_sizeEv>
 800c2b2:	4603      	mov	r3, r0
 800c2b4:	4618      	mov	r0, r3
 800c2b6:	3708      	adds	r7, #8
 800c2b8:	46bd      	mov	sp, r7
 800c2ba:	bd80      	pop	{r7, pc}

0800c2bc <_ZSt19__iterator_categoryISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEENSt15iterator_traitsIT_E17iterator_categoryERKS7_>:
   *  sugar for internal library use only.
  */
  template<typename _Iter>
    inline _GLIBCXX_CONSTEXPR
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
 800c2bc:	b480      	push	{r7}
 800c2be:	b083      	sub	sp, #12
 800c2c0:	af00      	add	r7, sp, #0
 800c2c2:	6078      	str	r0, [r7, #4]
    { return typename iterator_traits<_Iter>::iterator_category(); }
 800c2c4:	bf00      	nop
 800c2c6:	4618      	mov	r0, r3
 800c2c8:	370c      	adds	r7, #12
 800c2ca:	46bd      	mov	sp, r7
 800c2cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2d0:	4770      	bx	lr

0800c2d2 <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag>:
    __advance(_BidirectionalIterator& __i, _Distance __n,
 800c2d2:	b580      	push	{r7, lr}
 800c2d4:	b084      	sub	sp, #16
 800c2d6:	af00      	add	r7, sp, #0
 800c2d8:	60f8      	str	r0, [r7, #12]
 800c2da:	60b9      	str	r1, [r7, #8]
 800c2dc:	713a      	strb	r2, [r7, #4]
      if (__n > 0)
 800c2de:	68bb      	ldr	r3, [r7, #8]
 800c2e0:	2b00      	cmp	r3, #0
 800c2e2:	dd0d      	ble.n	800c300 <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag+0x2e>
        while (__n--)
 800c2e4:	68bb      	ldr	r3, [r7, #8]
 800c2e6:	1e5a      	subs	r2, r3, #1
 800c2e8:	60ba      	str	r2, [r7, #8]
 800c2ea:	2b00      	cmp	r3, #0
 800c2ec:	bf14      	ite	ne
 800c2ee:	2301      	movne	r3, #1
 800c2f0:	2300      	moveq	r3, #0
 800c2f2:	b2db      	uxtb	r3, r3
 800c2f4:	2b00      	cmp	r3, #0
 800c2f6:	d011      	beq.n	800c31c <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag+0x4a>
	  ++__i;
 800c2f8:	68f8      	ldr	r0, [r7, #12]
 800c2fa:	f000 facd 	bl	800c898 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEppEv>
        while (__n--)
 800c2fe:	e7f1      	b.n	800c2e4 <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag+0x12>
        while (__n++)
 800c300:	68bb      	ldr	r3, [r7, #8]
 800c302:	1c5a      	adds	r2, r3, #1
 800c304:	60ba      	str	r2, [r7, #8]
 800c306:	2b00      	cmp	r3, #0
 800c308:	bf14      	ite	ne
 800c30a:	2301      	movne	r3, #1
 800c30c:	2300      	moveq	r3, #0
 800c30e:	b2db      	uxtb	r3, r3
 800c310:	2b00      	cmp	r3, #0
 800c312:	d003      	beq.n	800c31c <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag+0x4a>
	  --__i;
 800c314:	68f8      	ldr	r0, [r7, #12]
 800c316:	f000 facf 	bl	800c8b8 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEmmEv>
        while (__n++)
 800c31a:	e7f1      	b.n	800c300 <_ZSt9__advanceISt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEiEvRT_T0_St26bidirectional_iterator_tag+0x2e>
    }
 800c31c:	bf00      	nop
 800c31e:	3710      	adds	r7, #16
 800c320:	46bd      	mov	sp, r7
 800c322:	bd80      	pop	{r7, pc}

0800c324 <_ZStneRKSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEES6_>:
      operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 800c324:	b480      	push	{r7}
 800c326:	b083      	sub	sp, #12
 800c328:	af00      	add	r7, sp, #0
 800c32a:	6078      	str	r0, [r7, #4]
 800c32c:	6039      	str	r1, [r7, #0]
      { return __x._M_node != __y._M_node; }
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	681a      	ldr	r2, [r3, #0]
 800c332:	683b      	ldr	r3, [r7, #0]
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	429a      	cmp	r2, r3
 800c338:	bf14      	ite	ne
 800c33a:	2301      	movne	r3, #1
 800c33c:	2300      	moveq	r3, #0
 800c33e:	b2db      	uxtb	r3, r3
 800c340:	4618      	mov	r0, r3
 800c342:	370c      	adds	r7, #12
 800c344:	46bd      	mov	sp, r7
 800c346:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c34a:	4770      	bx	lr

0800c34c <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE5eraseESt20_List_const_iteratorIS4_E>:
      }
#endif

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
 800c34c:	b580      	push	{r7, lr}
 800c34e:	b084      	sub	sp, #16
 800c350:	af00      	add	r7, sp, #0
 800c352:	6078      	str	r0, [r7, #4]
 800c354:	6039      	str	r1, [r7, #0]
    erase(const_iterator __position) noexcept
#else
    erase(iterator __position)
#endif
    {
      iterator __ret = iterator(__position._M_node->_M_next);
 800c356:	683b      	ldr	r3, [r7, #0]
 800c358:	681a      	ldr	r2, [r3, #0]
 800c35a:	f107 030c 	add.w	r3, r7, #12
 800c35e:	4611      	mov	r1, r2
 800c360:	4618      	mov	r0, r3
 800c362:	f7ff ff45 	bl	800c1f0 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1EPNSt8__detail15_List_node_baseE>
      _M_erase(__position._M_const_cast());
 800c366:	463b      	mov	r3, r7
 800c368:	4618      	mov	r0, r3
 800c36a:	f000 f80a 	bl	800c382 <_ZNKSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEE13_M_const_castEv>
 800c36e:	4603      	mov	r3, r0
 800c370:	4619      	mov	r1, r3
 800c372:	6878      	ldr	r0, [r7, #4]
 800c374:	f000 fab0 	bl	800c8d8 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_eraseESt14_List_iteratorIS4_E>
      return __ret;
 800c378:	68fb      	ldr	r3, [r7, #12]
    }
 800c37a:	4618      	mov	r0, r3
 800c37c:	3710      	adds	r7, #16
 800c37e:	46bd      	mov	sp, r7
 800c380:	bd80      	pop	{r7, pc}

0800c382 <_ZNKSt20_List_const_iteratorIN7desenet6sensor13NetworkEntity12EventElementEE13_M_const_castEv>:
      _M_const_cast() const _GLIBCXX_NOEXCEPT
 800c382:	b580      	push	{r7, lr}
 800c384:	b084      	sub	sp, #16
 800c386:	af00      	add	r7, sp, #0
 800c388:	6078      	str	r0, [r7, #4]
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }
 800c38a:	687b      	ldr	r3, [r7, #4]
 800c38c:	681a      	ldr	r2, [r3, #0]
 800c38e:	f107 030c 	add.w	r3, r7, #12
 800c392:	4611      	mov	r1, r2
 800c394:	4618      	mov	r0, r3
 800c396:	f7ff ff2b 	bl	800c1f0 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEC1EPNSt8__detail15_List_node_baseE>
 800c39a:	68fb      	ldr	r3, [r7, #12]
 800c39c:	4618      	mov	r0, r3
 800c39e:	3710      	adds	r7, #16
 800c3a0:	46bd      	mov	sp, r7
 800c3a2:	bd80      	pop	{r7, pc}

0800c3a4 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 800c3a4:	b480      	push	{r7}
 800c3a6:	b083      	sub	sp, #12
 800c3a8:	af00      	add	r7, sp, #0
 800c3aa:	6078      	str	r0, [r7, #4]
 800c3ac:	687b      	ldr	r3, [r7, #4]
 800c3ae:	4618      	mov	r0, r3
 800c3b0:	370c      	adds	r7, #12
 800c3b2:	46bd      	mov	sp, r7
 800c3b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3b8:	4770      	bx	lr

0800c3ba <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE21_M_get_Node_allocatorEv>:
      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
 800c3ba:	b480      	push	{r7}
 800c3bc:	b083      	sub	sp, #12
 800c3be:	af00      	add	r7, sp, #0
 800c3c0:	6078      	str	r0, [r7, #4]
      { return _M_impl; }
 800c3c2:	687b      	ldr	r3, [r7, #4]
 800c3c4:	4618      	mov	r0, r3
 800c3c6:	370c      	adds	r7, #12
 800c3c8:	46bd      	mov	sp, r7
 800c3ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3ce:	4770      	bx	lr

0800c3d0 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE7destroyIS4_EEvRS6_PT_>:
	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 800c3d0:	b580      	push	{r7, lr}
 800c3d2:	b082      	sub	sp, #8
 800c3d4:	af00      	add	r7, sp, #0
 800c3d6:	6078      	str	r0, [r7, #4]
 800c3d8:	6039      	str	r1, [r7, #0]
	  __a.destroy(__p);
 800c3da:	6839      	ldr	r1, [r7, #0]
 800c3dc:	6878      	ldr	r0, [r7, #4]
 800c3de:	f000 faa1 	bl	800c924 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE7destroyIS5_EEvPT_>
	}
 800c3e2:	bf00      	nop
 800c3e4:	3708      	adds	r7, #8
 800c3e6:	46bd      	mov	sp, r7
 800c3e8:	bd80      	pop	{r7, pc}

0800c3ea <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_put_nodeEPSt10_List_nodeIS4_E>:
      _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT
 800c3ea:	b580      	push	{r7, lr}
 800c3ec:	b082      	sub	sp, #8
 800c3ee:	af00      	add	r7, sp, #0
 800c3f0:	6078      	str	r0, [r7, #4]
 800c3f2:	6039      	str	r1, [r7, #0]
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }
 800c3f4:	687b      	ldr	r3, [r7, #4]
 800c3f6:	2201      	movs	r2, #1
 800c3f8:	6839      	ldr	r1, [r7, #0]
 800c3fa:	4618      	mov	r0, r3
 800c3fc:	f000 fa9d 	bl	800c93a <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE10deallocateERS6_PS5_j>
 800c400:	bf00      	nop
 800c402:	3708      	adds	r7, #8
 800c404:	46bd      	mov	sp, r7
 800c406:	bd80      	pop	{r7, pc}

0800c408 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEC1Ev>:
 800c408:	b480      	push	{r7}
 800c40a:	b083      	sub	sp, #12
 800c40c:	af00      	add	r7, sp, #0
 800c40e:	6078      	str	r0, [r7, #4]
 800c410:	687b      	ldr	r3, [r7, #4]
 800c412:	4618      	mov	r0, r3
 800c414:	370c      	adds	r7, #12
 800c416:	46bd      	mov	sp, r7
 800c418:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c41c:	4770      	bx	lr

0800c41e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE21_M_get_Node_allocatorEv>:
      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
 800c41e:	b480      	push	{r7}
 800c420:	b083      	sub	sp, #12
 800c422:	af00      	add	r7, sp, #0
 800c424:	6078      	str	r0, [r7, #4]
      { return _M_impl; }
 800c426:	687b      	ldr	r3, [r7, #4]
 800c428:	4618      	mov	r0, r3
 800c42a:	370c      	adds	r7, #12
 800c42c:	46bd      	mov	sp, r7
 800c42e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c432:	4770      	bx	lr

0800c434 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE7destroyIS4_EEvRS6_PT_>:
	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 800c434:	b580      	push	{r7, lr}
 800c436:	b082      	sub	sp, #8
 800c438:	af00      	add	r7, sp, #0
 800c43a:	6078      	str	r0, [r7, #4]
 800c43c:	6039      	str	r1, [r7, #0]
	  __a.destroy(__p);
 800c43e:	6839      	ldr	r1, [r7, #0]
 800c440:	6878      	ldr	r0, [r7, #4]
 800c442:	f000 fa89 	bl	800c958 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE7destroyIS5_EEvPT_>
	}
 800c446:	bf00      	nop
 800c448:	3708      	adds	r7, #8
 800c44a:	46bd      	mov	sp, r7
 800c44c:	bd80      	pop	{r7, pc}

0800c44e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_put_nodeEPSt10_List_nodeIS4_E>:
      _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT
 800c44e:	b580      	push	{r7, lr}
 800c450:	b082      	sub	sp, #8
 800c452:	af00      	add	r7, sp, #0
 800c454:	6078      	str	r0, [r7, #4]
 800c456:	6039      	str	r1, [r7, #0]
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }
 800c458:	687b      	ldr	r3, [r7, #4]
 800c45a:	2201      	movs	r2, #1
 800c45c:	6839      	ldr	r1, [r7, #0]
 800c45e:	4618      	mov	r0, r3
 800c460:	f000 fa86 	bl	800c970 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE10deallocateERS6_PS5_j>
 800c464:	bf00      	nop
 800c466:	3708      	adds	r7, #8
 800c468:	46bd      	mov	sp, r7
 800c46a:	bd80      	pop	{r7, pc}

0800c46c <_ZSt4moveIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEONSt16remove_referenceIT_E4typeEOSB_>:
    move(_Tp&& __t) noexcept
 800c46c:	b480      	push	{r7}
 800c46e:	b083      	sub	sp, #12
 800c470:	af00      	add	r7, sp, #0
 800c472:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800c474:	687b      	ldr	r3, [r7, #4]
 800c476:	4618      	mov	r0, r3
 800c478:	370c      	adds	r7, #12
 800c47a:	46bd      	mov	sp, r7
 800c47c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c480:	4770      	bx	lr

0800c482 <_ZNSt5tupleIJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1IJS3_RKS5_RKS6_RKS7_RKS8_ELb1ELb1EEEDpOT_>:
	tuple(_UElements&&... __elements)
 800c482:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c486:	b087      	sub	sp, #28
 800c488:	af02      	add	r7, sp, #8
 800c48a:	60f8      	str	r0, [r7, #12]
 800c48c:	60b9      	str	r1, [r7, #8]
 800c48e:	607a      	str	r2, [r7, #4]
 800c490:	603b      	str	r3, [r7, #0]
	: _Inherited(std::forward<_UElements>(__elements)...) { }
 800c492:	68fc      	ldr	r4, [r7, #12]
 800c494:	68b8      	ldr	r0, [r7, #8]
 800c496:	f7ff fd34 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c49a:	4606      	mov	r6, r0
 800c49c:	6878      	ldr	r0, [r7, #4]
 800c49e:	f7ff fd3b 	bl	800bf18 <_ZSt7forwardIRKSt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c4a2:	4680      	mov	r8, r0
 800c4a4:	6838      	ldr	r0, [r7, #0]
 800c4a6:	f7ff fd42 	bl	800bf2e <_ZSt7forwardIRKSt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c4aa:	4681      	mov	r9, r0
 800c4ac:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800c4ae:	f7ff fd49 	bl	800bf44 <_ZSt7forwardIRKSt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c4b2:	4605      	mov	r5, r0
 800c4b4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800c4b6:	f7ff fd50 	bl	800bf5a <_ZSt7forwardIRKSt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c4ba:	4603      	mov	r3, r0
 800c4bc:	9301      	str	r3, [sp, #4]
 800c4be:	9500      	str	r5, [sp, #0]
 800c4c0:	464b      	mov	r3, r9
 800c4c2:	4642      	mov	r2, r8
 800c4c4:	4631      	mov	r1, r6
 800c4c6:	4620      	mov	r0, r4
 800c4c8:	f000 fa61 	bl	800c98e <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1IS3_JRKS5_RKS6_RKS7_RKS8_EvEEOT_DpOT0_>
 800c4cc:	68fb      	ldr	r3, [r7, #12]
 800c4ce:	4618      	mov	r0, r3
 800c4d0:	3714      	adds	r7, #20
 800c4d2:	46bd      	mov	sp, r7
 800c4d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800c4d8 <_ZNSt10_Head_baseILj0EPN7desenet6sensor13NetworkEntityELb0EE7_M_headERS4_>:
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 800c4d8:	b480      	push	{r7}
 800c4da:	b083      	sub	sp, #12
 800c4dc:	af00      	add	r7, sp, #0
 800c4de:	6078      	str	r0, [r7, #4]
 800c4e0:	687b      	ldr	r3, [r7, #4]
 800c4e2:	4618      	mov	r0, r3
 800c4e4:	370c      	adds	r7, #12
 800c4e6:	46bd      	mov	sp, r7
 800c4e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4ec:	4770      	bx	lr

0800c4ee <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEE7_M_tailERS5_>:
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
 800c4ee:	b480      	push	{r7}
 800c4f0:	b083      	sub	sp, #12
 800c4f2:	af00      	add	r7, sp, #0
 800c4f4:	6078      	str	r0, [r7, #4]
 800c4f6:	687b      	ldr	r3, [r7, #4]
 800c4f8:	4618      	mov	r0, r3
 800c4fa:	370c      	adds	r7, #12
 800c4fc:	46bd      	mov	sp, r7
 800c4fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c502:	4770      	bx	lr

0800c504 <_ZSt4moveIRSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES1_ILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS8_>:
    move(_Tp&& __t) noexcept
 800c504:	b480      	push	{r7}
 800c506:	b083      	sub	sp, #12
 800c508:	af00      	add	r7, sp, #0
 800c50a:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800c50c:	687b      	ldr	r3, [r7, #4]
 800c50e:	4618      	mov	r0, r3
 800c510:	370c      	adds	r7, #12
 800c512:	46bd      	mov	sp, r7
 800c514:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c518:	4770      	bx	lr

0800c51a <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS5_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800c51a:	b580      	push	{r7, lr}
 800c51c:	b082      	sub	sp, #8
 800c51e:	af00      	add	r7, sp, #0
 800c520:	6078      	str	r0, [r7, #4]
 800c522:	6878      	ldr	r0, [r7, #4]
 800c524:	f000 fa5f 	bl	800c9e6 <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EE7_M_headERS2_>
 800c528:	4603      	mov	r3, r0
 800c52a:	4618      	mov	r0, r3
 800c52c:	3708      	adds	r7, #8
 800c52e:	46bd      	mov	sp, r7
 800c530:	bd80      	pop	{r7, pc}

0800c532 <_ZSt7forwardISt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS2_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c532:	b480      	push	{r7}
 800c534:	b083      	sub	sp, #12
 800c536:	af00      	add	r7, sp, #0
 800c538:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c53a:	687b      	ldr	r3, [r7, #4]
 800c53c:	4618      	mov	r0, r3
 800c53e:	370c      	adds	r7, #12
 800c540:	46bd      	mov	sp, r7
 800c542:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c546:	4770      	bx	lr

0800c548 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEEC1EOS4_>:
      _Tuple_impl(_Tuple_impl&& __in)
 800c548:	b580      	push	{r7, lr}
 800c54a:	b082      	sub	sp, #8
 800c54c:	af00      	add	r7, sp, #0
 800c54e:	6078      	str	r0, [r7, #4]
 800c550:	6039      	str	r1, [r7, #0]
      : _Inherited(std::move(_M_tail(__in))),
 800c552:	6838      	ldr	r0, [r7, #0]
 800c554:	f000 fa52 	bl	800c9fc <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEE7_M_tailERS4_>
 800c558:	4603      	mov	r3, r0
 800c55a:	4618      	mov	r0, r3
 800c55c:	f000 fa59 	bl	800ca12 <_ZSt4moveIRSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS7_>
 800c560:	4603      	mov	r3, r0
	_Base(std::forward<_Head>(_M_head(__in))) { }
 800c562:	4619      	mov	r1, r3
 800c564:	6878      	ldr	r0, [r7, #4]
 800c566:	f000 fa76 	bl	800ca56 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEEC1EOS3_>
 800c56a:	6838      	ldr	r0, [r7, #0]
 800c56c:	f000 fa5c 	bl	800ca28 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS4_>
 800c570:	4603      	mov	r3, r0
 800c572:	4618      	mov	r0, r3
 800c574:	f000 fa64 	bl	800ca40 <_ZSt7forwardISt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800c578:	4603      	mov	r3, r0
 800c57a:	4619      	mov	r1, r3
 800c57c:	6878      	ldr	r0, [r7, #4]
 800c57e:	f000 fa8c 	bl	800ca9a <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EEC1IS1_EEOT_>
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	4618      	mov	r0, r3
 800c586:	3708      	adds	r7, #8
 800c588:	46bd      	mov	sp, r7
 800c58a:	bd80      	pop	{r7, pc}

0800c58c <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EEC1IS1_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800c58c:	b580      	push	{r7, lr}
 800c58e:	b082      	sub	sp, #8
 800c590:	af00      	add	r7, sp, #0
 800c592:	6078      	str	r0, [r7, #4]
 800c594:	6039      	str	r1, [r7, #0]
	: _Head(std::forward<_UHead>(__h)) { }
 800c596:	6838      	ldr	r0, [r7, #0]
 800c598:	f7ff ffcb 	bl	800c532 <_ZSt7forwardISt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800c59c:	687b      	ldr	r3, [r7, #4]
 800c59e:	4618      	mov	r0, r3
 800c5a0:	3708      	adds	r7, #8
 800c5a2:	46bd      	mov	sp, r7
 800c5a4:	bd80      	pop	{r7, pc}

0800c5a6 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE15_M_init_functorERSt9_Any_dataOSI_St17integral_constantIbLb0EE>:
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 800c5a6:	b5b0      	push	{r4, r5, r7, lr}
 800c5a8:	b084      	sub	sp, #16
 800c5aa:	af00      	add	r7, sp, #0
 800c5ac:	60f8      	str	r0, [r7, #12]
 800c5ae:	60b9      	str	r1, [r7, #8]
 800c5b0:	713a      	strb	r2, [r7, #4]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 800c5b2:	68b8      	ldr	r0, [r7, #8]
 800c5b4:	f7ff fd73 	bl	800c09e <_ZSt4moveIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEONSt16remove_referenceIT_E4typeEOSK_>
 800c5b8:	4605      	mov	r5, r0
 800c5ba:	200c      	movs	r0, #12
 800c5bc:	f009 fe09 	bl	80161d2 <_Znwj>
 800c5c0:	4603      	mov	r3, r0
 800c5c2:	461c      	mov	r4, r3
 800c5c4:	4629      	mov	r1, r5
 800c5c6:	4620      	mov	r0, r4
 800c5c8:	f7fe fec8 	bl	800b35c <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEC1EOSG_>
 800c5cc:	68f8      	ldr	r0, [r7, #12]
 800c5ce:	f000 f868 	bl	800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>
 800c5d2:	4603      	mov	r3, r0
 800c5d4:	601c      	str	r4, [r3, #0]
 800c5d6:	bf00      	nop
 800c5d8:	3710      	adds	r7, #16
 800c5da:	46bd      	mov	sp, r7
 800c5dc:	bdb0      	pop	{r4, r5, r7, pc}

0800c5de <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE14_M_get_pointerERKSt9_Any_data>:
	_M_get_pointer(const _Any_data& __source)
 800c5de:	b580      	push	{r7, lr}
 800c5e0:	b082      	sub	sp, #8
 800c5e2:	af00      	add	r7, sp, #0
 800c5e4:	6078      	str	r0, [r7, #4]
	    return __source._M_access<_Functor*>();
 800c5e6:	6878      	ldr	r0, [r7, #4]
 800c5e8:	f000 fa64 	bl	800cab4 <_ZNKSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERKT_v>
 800c5ec:	4603      	mov	r3, r0
 800c5ee:	681b      	ldr	r3, [r3, #0]
	}
 800c5f0:	4618      	mov	r0, r3
 800c5f2:	3708      	adds	r7, #8
 800c5f4:	46bd      	mov	sp, r7
 800c5f6:	bd80      	pop	{r7, pc}

0800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c5f8:	b480      	push	{r7}
 800c5fa:	b083      	sub	sp, #12
 800c5fc:	af00      	add	r7, sp, #0
 800c5fe:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c600:	687b      	ldr	r3, [r7, #4]
 800c602:	4618      	mov	r0, r3
 800c604:	370c      	adds	r7, #12
 800c606:	46bd      	mov	sp, r7
 800c608:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c60c:	4770      	bx	lr

0800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c60e:	b480      	push	{r7}
 800c610:	b083      	sub	sp, #12
 800c612:	af00      	add	r7, sp, #0
 800c614:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c616:	687b      	ldr	r3, [r7, #4]
 800c618:	4618      	mov	r0, r3
 800c61a:	370c      	adds	r7, #12
 800c61c:	46bd      	mov	sp, r7
 800c61e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c622:	4770      	bx	lr

0800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c624:	b480      	push	{r7}
 800c626:	b083      	sub	sp, #12
 800c628:	af00      	add	r7, sp, #0
 800c62a:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c62c:	687b      	ldr	r3, [r7, #4]
 800c62e:	4618      	mov	r0, r3
 800c630:	370c      	adds	r7, #12
 800c632:	46bd      	mov	sp, r7
 800c634:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c638:	4770      	bx	lr

0800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c63a:	b480      	push	{r7}
 800c63c:	b083      	sub	sp, #12
 800c63e:	af00      	add	r7, sp, #0
 800c640:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c642:	687b      	ldr	r3, [r7, #4]
 800c644:	4618      	mov	r0, r3
 800c646:	370c      	adds	r7, #12
 800c648:	46bd      	mov	sp, r7
 800c64a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c64e:	4770      	bx	lr

0800c650 <_ZSt10__invoke_rIvRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEJS5_mS7_jEENSt9enable_ifIXsrSt6__and_IJSt7is_voidIT_ESt14__is_invocableIT0_JDpT1_EEEE5valueESM_E4typeEOSP_DpOSQ_>:
    }

  // INVOKE<R> when R is cv void
  template<typename _Res, typename _Callable, typename... _Args>
    _GLIBCXX14_CONSTEXPR __can_invoke_as_void<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
 800c650:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c654:	b087      	sub	sp, #28
 800c656:	af02      	add	r7, sp, #8
 800c658:	60f8      	str	r0, [r7, #12]
 800c65a:	60b9      	str	r1, [r7, #8]
 800c65c:	607a      	str	r2, [r7, #4]
 800c65e:	603b      	str	r3, [r7, #0]
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
 800c660:	68f8      	ldr	r0, [r7, #12]
 800c662:	f000 fa33 	bl	800cacc <_ZSt7forwardIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEOT_RNSt16remove_referenceISJ_E4typeE>
 800c666:	4605      	mov	r5, r0
 800c668:	68b8      	ldr	r0, [r7, #8]
 800c66a:	f7ff ffc5 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800c66e:	4606      	mov	r6, r0
 800c670:	6878      	ldr	r0, [r7, #4]
 800c672:	f7ff ffcc 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800c676:	4680      	mov	r8, r0
 800c678:	6838      	ldr	r0, [r7, #0]
 800c67a:	f7ff ffd3 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800c67e:	4604      	mov	r4, r0
 800c680:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800c682:	f7ff ffda 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800c686:	4603      	mov	r3, r0
 800c688:	9301      	str	r3, [sp, #4]
 800c68a:	9400      	str	r4, [sp, #0]
 800c68c:	4643      	mov	r3, r8
 800c68e:	4632      	mov	r2, r6
 800c690:	4629      	mov	r1, r5
 800c692:	4648      	mov	r0, r9
 800c694:	f000 fa25 	bl	800cae2 <_ZSt13__invoke_implIvRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEJS5_mS7_jEET_St14__invoke_otherOT0_DpOT1_>
				 std::forward<_Args>(__args)...);
    }
 800c698:	bf00      	nop
 800c69a:	3714      	adds	r7, #20
 800c69c:	46bd      	mov	sp, r7
 800c69e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>:
      _M_access()
 800c6a2:	b580      	push	{r7, lr}
 800c6a4:	b082      	sub	sp, #8
 800c6a6:	af00      	add	r7, sp, #0
 800c6a8:	6078      	str	r0, [r7, #4]
      { return *static_cast<_Tp*>(_M_access()); }
 800c6aa:	6878      	ldr	r0, [r7, #4]
 800c6ac:	f7fe fc9e 	bl	800afec <_ZNSt9_Any_data9_M_accessEv>
 800c6b0:	4603      	mov	r3, r0
 800c6b2:	4618      	mov	r0, r3
 800c6b4:	3708      	adds	r7, #8
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	bd80      	pop	{r7, pc}

0800c6ba <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation>:
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 800c6ba:	b5b0      	push	{r4, r5, r7, lr}
 800c6bc:	b084      	sub	sp, #16
 800c6be:	af00      	add	r7, sp, #0
 800c6c0:	60f8      	str	r0, [r7, #12]
 800c6c2:	60b9      	str	r1, [r7, #8]
 800c6c4:	4613      	mov	r3, r2
 800c6c6:	71fb      	strb	r3, [r7, #7]
	  switch (__op)
 800c6c8:	79fb      	ldrb	r3, [r7, #7]
 800c6ca:	2b03      	cmp	r3, #3
 800c6cc:	d016      	beq.n	800c6fc <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x42>
 800c6ce:	2b03      	cmp	r3, #3
 800c6d0:	dc19      	bgt.n	800c706 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x4c>
 800c6d2:	2b01      	cmp	r3, #1
 800c6d4:	d002      	beq.n	800c6dc <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x22>
 800c6d6:	2b02      	cmp	r3, #2
 800c6d8:	d00a      	beq.n	800c6f0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x36>
 800c6da:	e014      	b.n	800c706 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x4c>
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 800c6dc:	68f8      	ldr	r0, [r7, #12]
 800c6de:	f7ff ffe0 	bl	800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>
 800c6e2:	4604      	mov	r4, r0
 800c6e4:	68b8      	ldr	r0, [r7, #8]
 800c6e6:	f7ff ff7a 	bl	800c5de <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE14_M_get_pointerERKSt9_Any_data>
 800c6ea:	4603      	mov	r3, r0
 800c6ec:	6023      	str	r3, [r4, #0]
	      break;
 800c6ee:	e00a      	b.n	800c706 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x4c>
	      _M_clone(__dest, __source, _Local_storage());
 800c6f0:	462a      	mov	r2, r5
 800c6f2:	68b9      	ldr	r1, [r7, #8]
 800c6f4:	68f8      	ldr	r0, [r7, #12]
 800c6f6:	f000 fa1c 	bl	800cb32 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE8_M_cloneERSt9_Any_dataRKSK_St17integral_constantIbLb0EE>
	      break;
 800c6fa:	e004      	b.n	800c706 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_managerERSt9_Any_dataRKSK_St18_Manager_operation+0x4c>
	      _M_destroy(__dest, _Local_storage());
 800c6fc:	4621      	mov	r1, r4
 800c6fe:	68f8      	ldr	r0, [r7, #12]
 800c700:	f000 fa35 	bl	800cb6e <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_destroyERSt9_Any_dataSt17integral_constantIbLb0EE>
	      break;
 800c704:	bf00      	nop
	  return false;
 800c706:	2300      	movs	r3, #0
	}
 800c708:	4618      	mov	r0, r3
 800c70a:	3710      	adds	r7, #16
 800c70c:	46bd      	mov	sp, r7
 800c70e:	bdb0      	pop	{r4, r5, r7, pc}

0800c710 <_ZN9__gnu_cxx16__aligned_membufIPN7desenet6sensor19AbstractApplicationEE6_M_ptrEv>:
      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
 800c710:	b580      	push	{r7, lr}
 800c712:	b082      	sub	sp, #8
 800c714:	af00      	add	r7, sp, #0
 800c716:	6078      	str	r0, [r7, #4]
      { return static_cast<_Tp*>(_M_addr()); }
 800c718:	6878      	ldr	r0, [r7, #4]
 800c71a:	f000 fa3c 	bl	800cb96 <_ZN9__gnu_cxx16__aligned_membufIPN7desenet6sensor19AbstractApplicationEE7_M_addrEv>
 800c71e:	4603      	mov	r3, r0
 800c720:	4618      	mov	r0, r3
 800c722:	3708      	adds	r7, #8
 800c724:	46bd      	mov	sp, r7
 800c726:	bd80      	pop	{r7, pc}

0800c728 <_ZN9__gnu_cxx16__aligned_membufIN7desenet6sensor13NetworkEntity12EventElementEE6_M_ptrEv>:
      _M_ptr() noexcept
 800c728:	b580      	push	{r7, lr}
 800c72a:	b082      	sub	sp, #8
 800c72c:	af00      	add	r7, sp, #0
 800c72e:	6078      	str	r0, [r7, #4]
      { return static_cast<_Tp*>(_M_addr()); }
 800c730:	6878      	ldr	r0, [r7, #4]
 800c732:	f000 fa3b 	bl	800cbac <_ZN9__gnu_cxx16__aligned_membufIN7desenet6sensor13NetworkEntity12EventElementEE7_M_addrEv>
 800c736:	4603      	mov	r3, r0
 800c738:	4618      	mov	r0, r3
 800c73a:	3708      	adds	r7, #8
 800c73c:	46bd      	mov	sp, r7
 800c73e:	bd80      	pop	{r7, pc}

0800c740 <_ZSt7forwardIRKPN7desenet6sensor19AbstractApplicationEEOT_RNSt16remove_referenceIS6_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c740:	b480      	push	{r7}
 800c742:	b083      	sub	sp, #12
 800c744:	af00      	add	r7, sp, #0
 800c746:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c748:	687b      	ldr	r3, [r7, #4]
 800c74a:	4618      	mov	r0, r3
 800c74c:	370c      	adds	r7, #12
 800c74e:	46bd      	mov	sp, r7
 800c750:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c754:	4770      	bx	lr

0800c756 <_ZNSt7__cxx114listIPN7desenet6sensor19AbstractApplicationESaIS4_EE14_M_create_nodeIJRKS4_EEEPSt10_List_nodeIS4_EDpOT_>:
	_M_create_node(_Args&&... __args)
 800c756:	b590      	push	{r4, r7, lr}
 800c758:	b087      	sub	sp, #28
 800c75a:	af00      	add	r7, sp, #0
 800c75c:	6078      	str	r0, [r7, #4]
 800c75e:	6039      	str	r1, [r7, #0]
	  auto __p = this->_M_get_node();
 800c760:	687b      	ldr	r3, [r7, #4]
 800c762:	4618      	mov	r0, r3
 800c764:	f000 fa2d 	bl	800cbc2 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_get_nodeEv>
 800c768:	6178      	str	r0, [r7, #20]
	  auto& __alloc = _M_get_Node_allocator();
 800c76a:	687b      	ldr	r3, [r7, #4]
 800c76c:	4618      	mov	r0, r3
 800c76e:	f7ff fe24 	bl	800c3ba <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE21_M_get_Node_allocatorEv>
 800c772:	6138      	str	r0, [r7, #16]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 800c774:	f107 0308 	add.w	r3, r7, #8
 800c778:	697a      	ldr	r2, [r7, #20]
 800c77a:	6939      	ldr	r1, [r7, #16]
 800c77c:	4618      	mov	r0, r3
 800c77e:	f000 fa2e 	bl	800cbde <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEC1ERS6_PS5_>
	  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
 800c782:	6978      	ldr	r0, [r7, #20]
 800c784:	f7ff fcfe 	bl	800c184 <_ZNSt10_List_nodeIPN7desenet6sensor19AbstractApplicationEE9_M_valptrEv>
 800c788:	4604      	mov	r4, r0
 800c78a:	6838      	ldr	r0, [r7, #0]
 800c78c:	f7ff ffd8 	bl	800c740 <_ZSt7forwardIRKPN7desenet6sensor19AbstractApplicationEEOT_RNSt16remove_referenceIS6_E4typeE>
 800c790:	4603      	mov	r3, r0
 800c792:	461a      	mov	r2, r3
 800c794:	4621      	mov	r1, r4
 800c796:	6938      	ldr	r0, [r7, #16]
 800c798:	f000 fa4a 	bl	800cc30 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE9constructIS4_JRKS4_EEEvRS6_PT_DpOT0_>
	  __guard = nullptr;
 800c79c:	f107 0308 	add.w	r3, r7, #8
 800c7a0:	2100      	movs	r1, #0
 800c7a2:	4618      	mov	r0, r3
 800c7a4:	f000 fa57 	bl	800cc56 <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEaSEDn>
	  return __p;
 800c7a8:	697c      	ldr	r4, [r7, #20]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 800c7aa:	f107 0308 	add.w	r3, r7, #8
 800c7ae:	4618      	mov	r0, r3
 800c7b0:	f000 fa29 	bl	800cc06 <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEED1Ev>
	  return __p;
 800c7b4:	4623      	mov	r3, r4
	}
 800c7b6:	4618      	mov	r0, r3
 800c7b8:	371c      	adds	r7, #28
 800c7ba:	46bd      	mov	sp, r7
 800c7bc:	bd90      	pop	{r4, r7, pc}

0800c7be <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_inc_sizeEj>:
      void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }
 800c7be:	b480      	push	{r7}
 800c7c0:	b083      	sub	sp, #12
 800c7c2:	af00      	add	r7, sp, #0
 800c7c4:	6078      	str	r0, [r7, #4]
 800c7c6:	6039      	str	r1, [r7, #0]
 800c7c8:	687b      	ldr	r3, [r7, #4]
 800c7ca:	689a      	ldr	r2, [r3, #8]
 800c7cc:	683b      	ldr	r3, [r7, #0]
 800c7ce:	441a      	add	r2, r3
 800c7d0:	687b      	ldr	r3, [r7, #4]
 800c7d2:	609a      	str	r2, [r3, #8]
 800c7d4:	bf00      	nop
 800c7d6:	370c      	adds	r7, #12
 800c7d8:	46bd      	mov	sp, r7
 800c7da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7de:	4770      	bx	lr

0800c7e0 <_ZSt7forwardIRKN7desenet6sensor13NetworkEntity12EventElementEEOT_RNSt16remove_referenceIS6_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800c7e0:	b480      	push	{r7}
 800c7e2:	b083      	sub	sp, #12
 800c7e4:	af00      	add	r7, sp, #0
 800c7e6:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800c7e8:	687b      	ldr	r3, [r7, #4]
 800c7ea:	4618      	mov	r0, r3
 800c7ec:	370c      	adds	r7, #12
 800c7ee:	46bd      	mov	sp, r7
 800c7f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7f4:	4770      	bx	lr

0800c7f6 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE14_M_create_nodeIJRKS4_EEEPSt10_List_nodeIS4_EDpOT_>:
	_M_create_node(_Args&&... __args)
 800c7f6:	b590      	push	{r4, r7, lr}
 800c7f8:	b087      	sub	sp, #28
 800c7fa:	af00      	add	r7, sp, #0
 800c7fc:	6078      	str	r0, [r7, #4]
 800c7fe:	6039      	str	r1, [r7, #0]
	  auto __p = this->_M_get_node();
 800c800:	687b      	ldr	r3, [r7, #4]
 800c802:	4618      	mov	r0, r3
 800c804:	f000 fa36 	bl	800cc74 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_get_nodeEv>
 800c808:	6178      	str	r0, [r7, #20]
	  auto& __alloc = _M_get_Node_allocator();
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	4618      	mov	r0, r3
 800c80e:	f7ff fe06 	bl	800c41e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE21_M_get_Node_allocatorEv>
 800c812:	6138      	str	r0, [r7, #16]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 800c814:	f107 0308 	add.w	r3, r7, #8
 800c818:	697a      	ldr	r2, [r7, #20]
 800c81a:	6939      	ldr	r1, [r7, #16]
 800c81c:	4618      	mov	r0, r3
 800c81e:	f000 fa37 	bl	800cc90 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEC1ERS6_PS5_>
	  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
 800c822:	6978      	ldr	r0, [r7, #20]
 800c824:	f7ff fcf3 	bl	800c20e <_ZNSt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEE9_M_valptrEv>
 800c828:	4604      	mov	r4, r0
 800c82a:	6838      	ldr	r0, [r7, #0]
 800c82c:	f7ff ffd8 	bl	800c7e0 <_ZSt7forwardIRKN7desenet6sensor13NetworkEntity12EventElementEEOT_RNSt16remove_referenceIS6_E4typeE>
 800c830:	4603      	mov	r3, r0
 800c832:	461a      	mov	r2, r3
 800c834:	4621      	mov	r1, r4
 800c836:	6938      	ldr	r0, [r7, #16]
 800c838:	f000 fa53 	bl	800cce2 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE9constructIS4_JRKS4_EEEvRS6_PT_DpOT0_>
	  __guard = nullptr;
 800c83c:	f107 0308 	add.w	r3, r7, #8
 800c840:	2100      	movs	r1, #0
 800c842:	4618      	mov	r0, r3
 800c844:	f000 fa60 	bl	800cd08 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEaSEDn>
	  return __p;
 800c848:	697c      	ldr	r4, [r7, #20]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 800c84a:	f107 0308 	add.w	r3, r7, #8
 800c84e:	4618      	mov	r0, r3
 800c850:	f000 fa32 	bl	800ccb8 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEED1Ev>
	  return __p;
 800c854:	4623      	mov	r3, r4
	}
 800c856:	4618      	mov	r0, r3
 800c858:	371c      	adds	r7, #28
 800c85a:	46bd      	mov	sp, r7
 800c85c:	bd90      	pop	{r4, r7, pc}

0800c85e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_inc_sizeEj>:
      void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }
 800c85e:	b480      	push	{r7}
 800c860:	b083      	sub	sp, #12
 800c862:	af00      	add	r7, sp, #0
 800c864:	6078      	str	r0, [r7, #4]
 800c866:	6039      	str	r1, [r7, #0]
 800c868:	687b      	ldr	r3, [r7, #4]
 800c86a:	689a      	ldr	r2, [r3, #8]
 800c86c:	683b      	ldr	r3, [r7, #0]
 800c86e:	441a      	add	r2, r3
 800c870:	687b      	ldr	r3, [r7, #4]
 800c872:	609a      	str	r2, [r3, #8]
 800c874:	bf00      	nop
 800c876:	370c      	adds	r7, #12
 800c878:	46bd      	mov	sp, r7
 800c87a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c87e:	4770      	bx	lr

0800c880 <_ZNKSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_get_sizeEv>:
      size_t _M_get_size() const { return _M_impl._M_node._M_size; }
 800c880:	b480      	push	{r7}
 800c882:	b083      	sub	sp, #12
 800c884:	af00      	add	r7, sp, #0
 800c886:	6078      	str	r0, [r7, #4]
 800c888:	687b      	ldr	r3, [r7, #4]
 800c88a:	689b      	ldr	r3, [r3, #8]
 800c88c:	4618      	mov	r0, r3
 800c88e:	370c      	adds	r7, #12
 800c890:	46bd      	mov	sp, r7
 800c892:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c896:	4770      	bx	lr

0800c898 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEppEv>:
      operator++() _GLIBCXX_NOEXCEPT
 800c898:	b480      	push	{r7}
 800c89a:	b083      	sub	sp, #12
 800c89c:	af00      	add	r7, sp, #0
 800c89e:	6078      	str	r0, [r7, #4]
	_M_node = _M_node->_M_next;
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	681b      	ldr	r3, [r3, #0]
 800c8a4:	681a      	ldr	r2, [r3, #0]
 800c8a6:	687b      	ldr	r3, [r7, #4]
 800c8a8:	601a      	str	r2, [r3, #0]
	return *this;
 800c8aa:	687b      	ldr	r3, [r7, #4]
      }
 800c8ac:	4618      	mov	r0, r3
 800c8ae:	370c      	adds	r7, #12
 800c8b0:	46bd      	mov	sp, r7
 800c8b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8b6:	4770      	bx	lr

0800c8b8 <_ZNSt14_List_iteratorIN7desenet6sensor13NetworkEntity12EventElementEEmmEv>:
      operator--() _GLIBCXX_NOEXCEPT
 800c8b8:	b480      	push	{r7}
 800c8ba:	b083      	sub	sp, #12
 800c8bc:	af00      	add	r7, sp, #0
 800c8be:	6078      	str	r0, [r7, #4]
	_M_node = _M_node->_M_prev;
 800c8c0:	687b      	ldr	r3, [r7, #4]
 800c8c2:	681b      	ldr	r3, [r3, #0]
 800c8c4:	685a      	ldr	r2, [r3, #4]
 800c8c6:	687b      	ldr	r3, [r7, #4]
 800c8c8:	601a      	str	r2, [r3, #0]
	return *this;
 800c8ca:	687b      	ldr	r3, [r7, #4]
      }
 800c8cc:	4618      	mov	r0, r3
 800c8ce:	370c      	adds	r7, #12
 800c8d0:	46bd      	mov	sp, r7
 800c8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8d6:	4770      	bx	lr

0800c8d8 <_ZNSt7__cxx114listIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE8_M_eraseESt14_List_iteratorIS4_E>:
#endif

      // Erases element at position given.
      void
      _M_erase(iterator __position) _GLIBCXX_NOEXCEPT
 800c8d8:	b590      	push	{r4, r7, lr}
 800c8da:	b085      	sub	sp, #20
 800c8dc:	af00      	add	r7, sp, #0
 800c8de:	6078      	str	r0, [r7, #4]
 800c8e0:	6039      	str	r1, [r7, #0]
      {
	this->_M_dec_size(1);
 800c8e2:	687b      	ldr	r3, [r7, #4]
 800c8e4:	2101      	movs	r1, #1
 800c8e6:	4618      	mov	r0, r3
 800c8e8:	f000 fa1d 	bl	800cd26 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_dec_sizeEj>
	__position._M_node->_M_unhook();
 800c8ec:	683b      	ldr	r3, [r7, #0]
 800c8ee:	4618      	mov	r0, r3
 800c8f0:	f009 fc8e 	bl	8016210 <_ZNSt8__detail15_List_node_base9_M_unhookEv>
	_Node* __n = static_cast<_Node*>(__position._M_node);
 800c8f4:	683b      	ldr	r3, [r7, #0]
 800c8f6:	60fb      	str	r3, [r7, #12]
#if __cplusplus >= 201103L
	_Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());
 800c8f8:	687b      	ldr	r3, [r7, #4]
 800c8fa:	4618      	mov	r0, r3
 800c8fc:	f7ff fd8f 	bl	800c41e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE21_M_get_Node_allocatorEv>
 800c900:	4604      	mov	r4, r0
 800c902:	68f8      	ldr	r0, [r7, #12]
 800c904:	f7ff fc83 	bl	800c20e <_ZNSt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEE9_M_valptrEv>
 800c908:	4603      	mov	r3, r0
 800c90a:	4619      	mov	r1, r3
 800c90c:	4620      	mov	r0, r4
 800c90e:	f7ff fd91 	bl	800c434 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE7destroyIS4_EEvRS6_PT_>
#else
	_Tp_alloc_type(_M_get_Node_allocator()).destroy(__n->_M_valptr());
#endif

	_M_put_node(__n);
 800c912:	687b      	ldr	r3, [r7, #4]
 800c914:	68f9      	ldr	r1, [r7, #12]
 800c916:	4618      	mov	r0, r3
 800c918:	f7ff fd99 	bl	800c44e <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_put_nodeEPSt10_List_nodeIS4_E>
      }
 800c91c:	bf00      	nop
 800c91e:	3714      	adds	r7, #20
 800c920:	46bd      	mov	sp, r7
 800c922:	bd90      	pop	{r4, r7, pc}

0800c924 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE7destroyIS5_EEvPT_>:
	destroy(_Up* __p)
 800c924:	b480      	push	{r7}
 800c926:	b083      	sub	sp, #12
 800c928:	af00      	add	r7, sp, #0
 800c92a:	6078      	str	r0, [r7, #4]
 800c92c:	6039      	str	r1, [r7, #0]
	{ __p->~_Up(); }
 800c92e:	bf00      	nop
 800c930:	370c      	adds	r7, #12
 800c932:	46bd      	mov	sp, r7
 800c934:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c938:	4770      	bx	lr

0800c93a <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE10deallocateERS6_PS5_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 800c93a:	b580      	push	{r7, lr}
 800c93c:	b084      	sub	sp, #16
 800c93e:	af00      	add	r7, sp, #0
 800c940:	60f8      	str	r0, [r7, #12]
 800c942:	60b9      	str	r1, [r7, #8]
 800c944:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 800c946:	687a      	ldr	r2, [r7, #4]
 800c948:	68b9      	ldr	r1, [r7, #8]
 800c94a:	68f8      	ldr	r0, [r7, #12]
 800c94c:	f000 f9fc 	bl	800cd48 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE10deallocateEPS6_j>
 800c950:	bf00      	nop
 800c952:	3710      	adds	r7, #16
 800c954:	46bd      	mov	sp, r7
 800c956:	bd80      	pop	{r7, pc}

0800c958 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE7destroyIS5_EEvPT_>:
	destroy(_Up* __p)
 800c958:	b580      	push	{r7, lr}
 800c95a:	b082      	sub	sp, #8
 800c95c:	af00      	add	r7, sp, #0
 800c95e:	6078      	str	r0, [r7, #4]
 800c960:	6039      	str	r1, [r7, #0]
	{ __p->~_Up(); }
 800c962:	6838      	ldr	r0, [r7, #0]
 800c964:	f7fe ff5e 	bl	800b824 <_ZN7desenet6sensor13NetworkEntity12EventElementD1Ev>
 800c968:	bf00      	nop
 800c96a:	3708      	adds	r7, #8
 800c96c:	46bd      	mov	sp, r7
 800c96e:	bd80      	pop	{r7, pc}

0800c970 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE10deallocateERS6_PS5_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 800c970:	b580      	push	{r7, lr}
 800c972:	b084      	sub	sp, #16
 800c974:	af00      	add	r7, sp, #0
 800c976:	60f8      	str	r0, [r7, #12]
 800c978:	60b9      	str	r1, [r7, #8]
 800c97a:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 800c97c:	687a      	ldr	r2, [r7, #4]
 800c97e:	68b9      	ldr	r1, [r7, #8]
 800c980:	68f8      	ldr	r0, [r7, #12]
 800c982:	f000 f9f4 	bl	800cd6e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE10deallocateEPS6_j>
 800c986:	bf00      	nop
 800c988:	3710      	adds	r7, #16
 800c98a:	46bd      	mov	sp, r7
 800c98c:	bd80      	pop	{r7, pc}

0800c98e <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEEC1IS3_JRKS5_RKS6_RKS7_RKS8_EvEEOT_DpOT0_>:
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 800c98e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c990:	b087      	sub	sp, #28
 800c992:	af02      	add	r7, sp, #8
 800c994:	60f8      	str	r0, [r7, #12]
 800c996:	60b9      	str	r1, [r7, #8]
 800c998:	607a      	str	r2, [r7, #4]
 800c99a:	603b      	str	r3, [r7, #0]
	  _Base(std::forward<_UHead>(__head)) { }
 800c99c:	6878      	ldr	r0, [r7, #4]
 800c99e:	f7ff fabb 	bl	800bf18 <_ZSt7forwardIRKSt12_PlaceholderILi1EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c9a2:	4604      	mov	r4, r0
 800c9a4:	6838      	ldr	r0, [r7, #0]
 800c9a6:	f7ff fac2 	bl	800bf2e <_ZSt7forwardIRKSt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c9aa:	4605      	mov	r5, r0
 800c9ac:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800c9ae:	f7ff fac9 	bl	800bf44 <_ZSt7forwardIRKSt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c9b2:	4606      	mov	r6, r0
 800c9b4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c9b6:	f7ff fad0 	bl	800bf5a <_ZSt7forwardIRKSt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c9ba:	4603      	mov	r3, r0
 800c9bc:	9300      	str	r3, [sp, #0]
 800c9be:	4633      	mov	r3, r6
 800c9c0:	462a      	mov	r2, r5
 800c9c2:	4621      	mov	r1, r4
 800c9c4:	68f8      	ldr	r0, [r7, #12]
 800c9c6:	f000 f9e5 	bl	800cd94 <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEEC1ERKS1_RKS2_RKS3_RKS4_>
 800c9ca:	68fc      	ldr	r4, [r7, #12]
 800c9cc:	68b8      	ldr	r0, [r7, #8]
 800c9ce:	f7ff fa98 	bl	800bf02 <_ZSt7forwardIPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS4_E4typeE>
 800c9d2:	4603      	mov	r3, r0
 800c9d4:	4619      	mov	r1, r3
 800c9d6:	4620      	mov	r0, r4
 800c9d8:	f7ff fb45 	bl	800c066 <_ZNSt10_Head_baseILj0EPN7desenet6sensor13NetworkEntityELb0EEC1IS3_EEOT_>
 800c9dc:	68fb      	ldr	r3, [r7, #12]
 800c9de:	4618      	mov	r0, r3
 800c9e0:	3714      	adds	r7, #20
 800c9e2:	46bd      	mov	sp, r7
 800c9e4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800c9e6 <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EE7_M_headERS2_>:
      _M_head(_Head_base& __b) noexcept { return __b; }
 800c9e6:	b480      	push	{r7}
 800c9e8:	b083      	sub	sp, #12
 800c9ea:	af00      	add	r7, sp, #0
 800c9ec:	6078      	str	r0, [r7, #4]
 800c9ee:	687b      	ldr	r3, [r7, #4]
 800c9f0:	4618      	mov	r0, r3
 800c9f2:	370c      	adds	r7, #12
 800c9f4:	46bd      	mov	sp, r7
 800c9f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9fa:	4770      	bx	lr

0800c9fc <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEE7_M_tailERS4_>:
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
 800c9fc:	b480      	push	{r7}
 800c9fe:	b083      	sub	sp, #12
 800ca00:	af00      	add	r7, sp, #0
 800ca02:	6078      	str	r0, [r7, #4]
 800ca04:	687b      	ldr	r3, [r7, #4]
 800ca06:	4618      	mov	r0, r3
 800ca08:	370c      	adds	r7, #12
 800ca0a:	46bd      	mov	sp, r7
 800ca0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca10:	4770      	bx	lr

0800ca12 <_ZSt4moveIRSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES1_ILi4EEEEEONSt16remove_referenceIT_E4typeEOS7_>:
    move(_Tp&& __t) noexcept
 800ca12:	b480      	push	{r7}
 800ca14:	b083      	sub	sp, #12
 800ca16:	af00      	add	r7, sp, #0
 800ca18:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800ca1a:	687b      	ldr	r3, [r7, #4]
 800ca1c:	4618      	mov	r0, r3
 800ca1e:	370c      	adds	r7, #12
 800ca20:	46bd      	mov	sp, r7
 800ca22:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca26:	4770      	bx	lr

0800ca28 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS4_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800ca28:	b580      	push	{r7, lr}
 800ca2a:	b082      	sub	sp, #8
 800ca2c:	af00      	add	r7, sp, #0
 800ca2e:	6078      	str	r0, [r7, #4]
 800ca30:	6878      	ldr	r0, [r7, #4]
 800ca32:	f000 f9c5 	bl	800cdc0 <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EE7_M_headERS2_>
 800ca36:	4603      	mov	r3, r0
 800ca38:	4618      	mov	r0, r3
 800ca3a:	3708      	adds	r7, #8
 800ca3c:	46bd      	mov	sp, r7
 800ca3e:	bd80      	pop	{r7, pc}

0800ca40 <_ZSt7forwardISt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS2_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800ca40:	b480      	push	{r7}
 800ca42:	b083      	sub	sp, #12
 800ca44:	af00      	add	r7, sp, #0
 800ca46:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	4618      	mov	r0, r3
 800ca4c:	370c      	adds	r7, #12
 800ca4e:	46bd      	mov	sp, r7
 800ca50:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca54:	4770      	bx	lr

0800ca56 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEEC1EOS3_>:
      _Tuple_impl(_Tuple_impl&& __in)
 800ca56:	b580      	push	{r7, lr}
 800ca58:	b082      	sub	sp, #8
 800ca5a:	af00      	add	r7, sp, #0
 800ca5c:	6078      	str	r0, [r7, #4]
 800ca5e:	6039      	str	r1, [r7, #0]
      : _Inherited(std::move(_M_tail(__in))),
 800ca60:	6838      	ldr	r0, [r7, #0]
 800ca62:	f000 f9b8 	bl	800cdd6 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEE7_M_tailERS3_>
 800ca66:	4603      	mov	r3, r0
 800ca68:	4618      	mov	r0, r3
 800ca6a:	f000 f9bf 	bl	800cdec <_ZSt4moveIRSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEEONSt16remove_referenceIT_E4typeEOS6_>
 800ca6e:	4603      	mov	r3, r0
	_Base(std::forward<_Head>(_M_head(__in))) { }
 800ca70:	4619      	mov	r1, r3
 800ca72:	6878      	ldr	r0, [r7, #4]
 800ca74:	f000 f9dc 	bl	800ce30 <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEC1EOS2_>
 800ca78:	6838      	ldr	r0, [r7, #0]
 800ca7a:	f000 f9c2 	bl	800ce02 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEE7_M_headERS3_>
 800ca7e:	4603      	mov	r3, r0
 800ca80:	4618      	mov	r0, r3
 800ca82:	f000 f9ca 	bl	800ce1a <_ZSt7forwardISt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800ca86:	4603      	mov	r3, r0
 800ca88:	4619      	mov	r1, r3
 800ca8a:	6878      	ldr	r0, [r7, #4]
 800ca8c:	f000 f9e6 	bl	800ce5c <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EEC1IS1_EEOT_>
 800ca90:	687b      	ldr	r3, [r7, #4]
 800ca92:	4618      	mov	r0, r3
 800ca94:	3708      	adds	r7, #8
 800ca96:	46bd      	mov	sp, r7
 800ca98:	bd80      	pop	{r7, pc}

0800ca9a <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EEC1IS1_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800ca9a:	b580      	push	{r7, lr}
 800ca9c:	b082      	sub	sp, #8
 800ca9e:	af00      	add	r7, sp, #0
 800caa0:	6078      	str	r0, [r7, #4]
 800caa2:	6039      	str	r1, [r7, #0]
	: _Head(std::forward<_UHead>(__h)) { }
 800caa4:	6838      	ldr	r0, [r7, #0]
 800caa6:	f7ff ffcb 	bl	800ca40 <_ZSt7forwardISt12_PlaceholderILi2EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800caaa:	687b      	ldr	r3, [r7, #4]
 800caac:	4618      	mov	r0, r3
 800caae:	3708      	adds	r7, #8
 800cab0:	46bd      	mov	sp, r7
 800cab2:	bd80      	pop	{r7, pc}

0800cab4 <_ZNKSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERKT_v>:
      _M_access() const
 800cab4:	b580      	push	{r7, lr}
 800cab6:	b082      	sub	sp, #8
 800cab8:	af00      	add	r7, sp, #0
 800caba:	6078      	str	r0, [r7, #4]
      { return *static_cast<const _Tp*>(_M_access()); }
 800cabc:	6878      	ldr	r0, [r7, #4]
 800cabe:	f7fe faa0 	bl	800b002 <_ZNKSt9_Any_data9_M_accessEv>
 800cac2:	4603      	mov	r3, r0
 800cac4:	4618      	mov	r0, r3
 800cac6:	3708      	adds	r7, #8
 800cac8:	46bd      	mov	sp, r7
 800caca:	bd80      	pop	{r7, pc}

0800cacc <_ZSt7forwardIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEOT_RNSt16remove_referenceISJ_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800cacc:	b480      	push	{r7}
 800cace:	b083      	sub	sp, #12
 800cad0:	af00      	add	r7, sp, #0
 800cad2:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	4618      	mov	r0, r3
 800cad8:	370c      	adds	r7, #12
 800cada:	46bd      	mov	sp, r7
 800cadc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cae0:	4770      	bx	lr

0800cae2 <_ZSt13__invoke_implIvRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEJS5_mS7_jEET_St14__invoke_otherOT0_DpOT1_>:
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
 800cae2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cae6:	b086      	sub	sp, #24
 800cae8:	af02      	add	r7, sp, #8
 800caea:	7338      	strb	r0, [r7, #12]
 800caec:	60b9      	str	r1, [r7, #8]
 800caee:	607a      	str	r2, [r7, #4]
 800caf0:	603b      	str	r3, [r7, #0]
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 800caf2:	68b8      	ldr	r0, [r7, #8]
 800caf4:	f7ff ffea 	bl	800cacc <_ZSt7forwardIRSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS1_22NetworkInterfaceDriverEmPKhjEPS3_St12_PlaceholderILi1EESB_ILi2EESB_ILi3EESB_ILi4EEEEEOT_RNSt16remove_referenceISJ_E4typeE>
 800caf8:	4604      	mov	r4, r0
 800cafa:	6878      	ldr	r0, [r7, #4]
 800cafc:	f7ff fd7c 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800cb00:	4605      	mov	r5, r0
 800cb02:	6838      	ldr	r0, [r7, #0]
 800cb04:	f7ff fd83 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800cb08:	4606      	mov	r6, r0
 800cb0a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800cb0c:	f7ff fd8a 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800cb10:	4680      	mov	r8, r0
 800cb12:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cb14:	f7ff fd91 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800cb18:	4603      	mov	r3, r0
 800cb1a:	9300      	str	r3, [sp, #0]
 800cb1c:	4643      	mov	r3, r8
 800cb1e:	4632      	mov	r2, r6
 800cb20:	4629      	mov	r1, r5
 800cb22:	4620      	mov	r0, r4
 800cb24:	f000 f9a7 	bl	800ce76 <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEclIJS4_mS6_jEvEET0_DpOT_>
 800cb28:	bf00      	nop
 800cb2a:	3710      	adds	r7, #16
 800cb2c:	46bd      	mov	sp, r7
 800cb2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800cb32 <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE8_M_cloneERSt9_Any_dataRKSK_St17integral_constantIbLb0EE>:
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 800cb32:	b5b0      	push	{r4, r5, r7, lr}
 800cb34:	b084      	sub	sp, #16
 800cb36:	af00      	add	r7, sp, #0
 800cb38:	60f8      	str	r0, [r7, #12]
 800cb3a:	60b9      	str	r1, [r7, #8]
 800cb3c:	713a      	strb	r2, [r7, #4]
	    new _Functor(*__source._M_access<const _Functor*>());
 800cb3e:	68b8      	ldr	r0, [r7, #8]
 800cb40:	f000 f9c5 	bl	800cece <_ZNKSt9_Any_data9_M_accessIPKSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERKT_v>
 800cb44:	4603      	mov	r3, r0
	  __dest._M_access<_Functor*>() =
 800cb46:	681d      	ldr	r5, [r3, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 800cb48:	200c      	movs	r0, #12
 800cb4a:	f009 fb42 	bl	80161d2 <_Znwj>
 800cb4e:	4603      	mov	r3, r0
 800cb50:	461c      	mov	r4, r3
	  __dest._M_access<_Functor*>() =
 800cb52:	4623      	mov	r3, r4
 800cb54:	462a      	mov	r2, r5
 800cb56:	ca07      	ldmia	r2, {r0, r1, r2}
 800cb58:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800cb5c:	68f8      	ldr	r0, [r7, #12]
 800cb5e:	f7ff fda0 	bl	800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>
 800cb62:	4603      	mov	r3, r0
 800cb64:	601c      	str	r4, [r3, #0]
	}
 800cb66:	bf00      	nop
 800cb68:	3710      	adds	r7, #16
 800cb6a:	46bd      	mov	sp, r7
 800cb6c:	bdb0      	pop	{r4, r5, r7, pc}

0800cb6e <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_destroyERSt9_Any_dataSt17integral_constantIbLb0EE>:
	_M_destroy(_Any_data& __victim, false_type)
 800cb6e:	b580      	push	{r7, lr}
 800cb70:	b082      	sub	sp, #8
 800cb72:	af00      	add	r7, sp, #0
 800cb74:	6078      	str	r0, [r7, #4]
 800cb76:	7039      	strb	r1, [r7, #0]
	  delete __victim._M_access<_Functor*>();
 800cb78:	6878      	ldr	r0, [r7, #4]
 800cb7a:	f7ff fd92 	bl	800c6a2 <_ZNSt9_Any_data9_M_accessIPSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERT_v>
 800cb7e:	4603      	mov	r3, r0
 800cb80:	681b      	ldr	r3, [r3, #0]
 800cb82:	2b00      	cmp	r3, #0
 800cb84:	d003      	beq.n	800cb8e <_ZNSt14_Function_base13_Base_managerISt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEE10_M_destroyERSt9_Any_dataSt17integral_constantIbLb0EE+0x20>
 800cb86:	210c      	movs	r1, #12
 800cb88:	4618      	mov	r0, r3
 800cb8a:	f009 fb0f 	bl	80161ac <_ZdlPvj>
	}
 800cb8e:	bf00      	nop
 800cb90:	3708      	adds	r7, #8
 800cb92:	46bd      	mov	sp, r7
 800cb94:	bd80      	pop	{r7, pc}

0800cb96 <_ZN9__gnu_cxx16__aligned_membufIPN7desenet6sensor19AbstractApplicationEE7_M_addrEv>:
      _M_addr() noexcept
 800cb96:	b480      	push	{r7}
 800cb98:	b083      	sub	sp, #12
 800cb9a:	af00      	add	r7, sp, #0
 800cb9c:	6078      	str	r0, [r7, #4]
      { return static_cast<void*>(&_M_storage); }
 800cb9e:	687b      	ldr	r3, [r7, #4]
 800cba0:	4618      	mov	r0, r3
 800cba2:	370c      	adds	r7, #12
 800cba4:	46bd      	mov	sp, r7
 800cba6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbaa:	4770      	bx	lr

0800cbac <_ZN9__gnu_cxx16__aligned_membufIN7desenet6sensor13NetworkEntity12EventElementEE7_M_addrEv>:
      _M_addr() noexcept
 800cbac:	b480      	push	{r7}
 800cbae:	b083      	sub	sp, #12
 800cbb0:	af00      	add	r7, sp, #0
 800cbb2:	6078      	str	r0, [r7, #4]
      { return static_cast<void*>(&_M_storage); }
 800cbb4:	687b      	ldr	r3, [r7, #4]
 800cbb6:	4618      	mov	r0, r3
 800cbb8:	370c      	adds	r7, #12
 800cbba:	46bd      	mov	sp, r7
 800cbbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbc0:	4770      	bx	lr

0800cbc2 <_ZNSt7__cxx1110_List_baseIPN7desenet6sensor19AbstractApplicationESaIS4_EE11_M_get_nodeEv>:
      _M_get_node()
 800cbc2:	b580      	push	{r7, lr}
 800cbc4:	b082      	sub	sp, #8
 800cbc6:	af00      	add	r7, sp, #0
 800cbc8:	6078      	str	r0, [r7, #4]
      { return _Node_alloc_traits::allocate(_M_impl, 1); }
 800cbca:	687b      	ldr	r3, [r7, #4]
 800cbcc:	2101      	movs	r1, #1
 800cbce:	4618      	mov	r0, r3
 800cbd0:	f000 f989 	bl	800cee6 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE8allocateERS6_j>
 800cbd4:	4603      	mov	r3, r0
 800cbd6:	4618      	mov	r0, r3
 800cbd8:	3708      	adds	r7, #8
 800cbda:	46bd      	mov	sp, r7
 800cbdc:	bd80      	pop	{r7, pc}

0800cbde <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEC1ERS6_PS5_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 800cbde:	b580      	push	{r7, lr}
 800cbe0:	b084      	sub	sp, #16
 800cbe2:	af00      	add	r7, sp, #0
 800cbe4:	60f8      	str	r0, [r7, #12]
 800cbe6:	60b9      	str	r1, [r7, #8]
 800cbe8:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 800cbea:	68b8      	ldr	r0, [r7, #8]
 800cbec:	f000 f98a 	bl	800cf04 <_ZSt11__addressofISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEPT_RS7_>
 800cbf0:	4602      	mov	r2, r0
 800cbf2:	68fb      	ldr	r3, [r7, #12]
 800cbf4:	601a      	str	r2, [r3, #0]
 800cbf6:	68fb      	ldr	r3, [r7, #12]
 800cbf8:	687a      	ldr	r2, [r7, #4]
 800cbfa:	605a      	str	r2, [r3, #4]
      { }
 800cbfc:	68fb      	ldr	r3, [r7, #12]
 800cbfe:	4618      	mov	r0, r3
 800cc00:	3710      	adds	r7, #16
 800cc02:	46bd      	mov	sp, r7
 800cc04:	bd80      	pop	{r7, pc}

0800cc06 <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEED1Ev>:
      ~__allocated_ptr()
 800cc06:	b580      	push	{r7, lr}
 800cc08:	b082      	sub	sp, #8
 800cc0a:	af00      	add	r7, sp, #0
 800cc0c:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 800cc0e:	687b      	ldr	r3, [r7, #4]
 800cc10:	685b      	ldr	r3, [r3, #4]
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d007      	beq.n	800cc26 <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 800cc16:	687b      	ldr	r3, [r7, #4]
 800cc18:	6818      	ldr	r0, [r3, #0]
 800cc1a:	687b      	ldr	r3, [r7, #4]
 800cc1c:	685b      	ldr	r3, [r3, #4]
 800cc1e:	2201      	movs	r2, #1
 800cc20:	4619      	mov	r1, r3
 800cc22:	f7ff fe8a 	bl	800c93a <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE10deallocateERS6_PS5_j>
      }
 800cc26:	687b      	ldr	r3, [r7, #4]
 800cc28:	4618      	mov	r0, r3
 800cc2a:	3708      	adds	r7, #8
 800cc2c:	46bd      	mov	sp, r7
 800cc2e:	bd80      	pop	{r7, pc}

0800cc30 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE9constructIS4_JRKS4_EEEvRS6_PT_DpOT0_>:
	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
 800cc30:	b580      	push	{r7, lr}
 800cc32:	b084      	sub	sp, #16
 800cc34:	af00      	add	r7, sp, #0
 800cc36:	60f8      	str	r0, [r7, #12]
 800cc38:	60b9      	str	r1, [r7, #8]
 800cc3a:	607a      	str	r2, [r7, #4]
	  __a.construct(__p, std::forward<_Args>(__args)...);
 800cc3c:	6878      	ldr	r0, [r7, #4]
 800cc3e:	f7ff fd7f 	bl	800c740 <_ZSt7forwardIRKPN7desenet6sensor19AbstractApplicationEEOT_RNSt16remove_referenceIS6_E4typeE>
 800cc42:	4603      	mov	r3, r0
 800cc44:	461a      	mov	r2, r3
 800cc46:	68b9      	ldr	r1, [r7, #8]
 800cc48:	68f8      	ldr	r0, [r7, #12]
 800cc4a:	f000 f966 	bl	800cf1a <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE9constructIS5_JRKS5_EEEvPT_DpOT0_>
	}
 800cc4e:	bf00      	nop
 800cc50:	3710      	adds	r7, #16
 800cc52:	46bd      	mov	sp, r7
 800cc54:	bd80      	pop	{r7, pc}

0800cc56 <_ZNSt15__allocated_ptrISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 800cc56:	b480      	push	{r7}
 800cc58:	b083      	sub	sp, #12
 800cc5a:	af00      	add	r7, sp, #0
 800cc5c:	6078      	str	r0, [r7, #4]
 800cc5e:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	2200      	movs	r2, #0
 800cc64:	605a      	str	r2, [r3, #4]
	return *this;
 800cc66:	687b      	ldr	r3, [r7, #4]
      }
 800cc68:	4618      	mov	r0, r3
 800cc6a:	370c      	adds	r7, #12
 800cc6c:	46bd      	mov	sp, r7
 800cc6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc72:	4770      	bx	lr

0800cc74 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_get_nodeEv>:
      _M_get_node()
 800cc74:	b580      	push	{r7, lr}
 800cc76:	b082      	sub	sp, #8
 800cc78:	af00      	add	r7, sp, #0
 800cc7a:	6078      	str	r0, [r7, #4]
      { return _Node_alloc_traits::allocate(_M_impl, 1); }
 800cc7c:	687b      	ldr	r3, [r7, #4]
 800cc7e:	2101      	movs	r1, #1
 800cc80:	4618      	mov	r0, r3
 800cc82:	f000 f960 	bl	800cf46 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE8allocateERS6_j>
 800cc86:	4603      	mov	r3, r0
 800cc88:	4618      	mov	r0, r3
 800cc8a:	3708      	adds	r7, #8
 800cc8c:	46bd      	mov	sp, r7
 800cc8e:	bd80      	pop	{r7, pc}

0800cc90 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEC1ERS6_PS5_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 800cc90:	b580      	push	{r7, lr}
 800cc92:	b084      	sub	sp, #16
 800cc94:	af00      	add	r7, sp, #0
 800cc96:	60f8      	str	r0, [r7, #12]
 800cc98:	60b9      	str	r1, [r7, #8]
 800cc9a:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 800cc9c:	68b8      	ldr	r0, [r7, #8]
 800cc9e:	f000 f961 	bl	800cf64 <_ZSt11__addressofISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEPT_RS7_>
 800cca2:	4602      	mov	r2, r0
 800cca4:	68fb      	ldr	r3, [r7, #12]
 800cca6:	601a      	str	r2, [r3, #0]
 800cca8:	68fb      	ldr	r3, [r7, #12]
 800ccaa:	687a      	ldr	r2, [r7, #4]
 800ccac:	605a      	str	r2, [r3, #4]
      { }
 800ccae:	68fb      	ldr	r3, [r7, #12]
 800ccb0:	4618      	mov	r0, r3
 800ccb2:	3710      	adds	r7, #16
 800ccb4:	46bd      	mov	sp, r7
 800ccb6:	bd80      	pop	{r7, pc}

0800ccb8 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEED1Ev>:
      ~__allocated_ptr()
 800ccb8:	b580      	push	{r7, lr}
 800ccba:	b082      	sub	sp, #8
 800ccbc:	af00      	add	r7, sp, #0
 800ccbe:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 800ccc0:	687b      	ldr	r3, [r7, #4]
 800ccc2:	685b      	ldr	r3, [r3, #4]
 800ccc4:	2b00      	cmp	r3, #0
 800ccc6:	d007      	beq.n	800ccd8 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 800ccc8:	687b      	ldr	r3, [r7, #4]
 800ccca:	6818      	ldr	r0, [r3, #0]
 800cccc:	687b      	ldr	r3, [r7, #4]
 800ccce:	685b      	ldr	r3, [r3, #4]
 800ccd0:	2201      	movs	r2, #1
 800ccd2:	4619      	mov	r1, r3
 800ccd4:	f7ff fe4c 	bl	800c970 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE10deallocateERS6_PS5_j>
      }
 800ccd8:	687b      	ldr	r3, [r7, #4]
 800ccda:	4618      	mov	r0, r3
 800ccdc:	3708      	adds	r7, #8
 800ccde:	46bd      	mov	sp, r7
 800cce0:	bd80      	pop	{r7, pc}

0800cce2 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE9constructIS4_JRKS4_EEEvRS6_PT_DpOT0_>:
	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
 800cce2:	b580      	push	{r7, lr}
 800cce4:	b084      	sub	sp, #16
 800cce6:	af00      	add	r7, sp, #0
 800cce8:	60f8      	str	r0, [r7, #12]
 800ccea:	60b9      	str	r1, [r7, #8]
 800ccec:	607a      	str	r2, [r7, #4]
	  __a.construct(__p, std::forward<_Args>(__args)...);
 800ccee:	6878      	ldr	r0, [r7, #4]
 800ccf0:	f7ff fd76 	bl	800c7e0 <_ZSt7forwardIRKN7desenet6sensor13NetworkEntity12EventElementEEOT_RNSt16remove_referenceIS6_E4typeE>
 800ccf4:	4603      	mov	r3, r0
 800ccf6:	461a      	mov	r2, r3
 800ccf8:	68b9      	ldr	r1, [r7, #8]
 800ccfa:	68f8      	ldr	r0, [r7, #12]
 800ccfc:	f000 f953 	bl	800cfa6 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE9constructIS5_JRKS5_EEEvPT_DpOT0_>
	}
 800cd00:	bf00      	nop
 800cd02:	3710      	adds	r7, #16
 800cd04:	46bd      	mov	sp, r7
 800cd06:	bd80      	pop	{r7, pc}

0800cd08 <_ZNSt15__allocated_ptrISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 800cd08:	b480      	push	{r7}
 800cd0a:	b083      	sub	sp, #12
 800cd0c:	af00      	add	r7, sp, #0
 800cd0e:	6078      	str	r0, [r7, #4]
 800cd10:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 800cd12:	687b      	ldr	r3, [r7, #4]
 800cd14:	2200      	movs	r2, #0
 800cd16:	605a      	str	r2, [r3, #4]
	return *this;
 800cd18:	687b      	ldr	r3, [r7, #4]
      }
 800cd1a:	4618      	mov	r0, r3
 800cd1c:	370c      	adds	r7, #12
 800cd1e:	46bd      	mov	sp, r7
 800cd20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd24:	4770      	bx	lr

0800cd26 <_ZNSt7__cxx1110_List_baseIN7desenet6sensor13NetworkEntity12EventElementESaIS4_EE11_M_dec_sizeEj>:
      void _M_dec_size(size_t __n) { _M_impl._M_node._M_size -= __n; }
 800cd26:	b480      	push	{r7}
 800cd28:	b083      	sub	sp, #12
 800cd2a:	af00      	add	r7, sp, #0
 800cd2c:	6078      	str	r0, [r7, #4]
 800cd2e:	6039      	str	r1, [r7, #0]
 800cd30:	687b      	ldr	r3, [r7, #4]
 800cd32:	689a      	ldr	r2, [r3, #8]
 800cd34:	683b      	ldr	r3, [r7, #0]
 800cd36:	1ad2      	subs	r2, r2, r3
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	609a      	str	r2, [r3, #8]
 800cd3c:	bf00      	nop
 800cd3e:	370c      	adds	r7, #12
 800cd40:	46bd      	mov	sp, r7
 800cd42:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd46:	4770      	bx	lr

0800cd48 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE10deallocateEPS6_j>:
      deallocate(_Tp* __p, size_type __t)
 800cd48:	b580      	push	{r7, lr}
 800cd4a:	b084      	sub	sp, #16
 800cd4c:	af00      	add	r7, sp, #0
 800cd4e:	60f8      	str	r0, [r7, #12]
 800cd50:	60b9      	str	r1, [r7, #8]
 800cd52:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 800cd54:	687a      	ldr	r2, [r7, #4]
 800cd56:	4613      	mov	r3, r2
 800cd58:	005b      	lsls	r3, r3, #1
 800cd5a:	4413      	add	r3, r2
 800cd5c:	009b      	lsls	r3, r3, #2
 800cd5e:	4619      	mov	r1, r3
 800cd60:	68b8      	ldr	r0, [r7, #8]
 800cd62:	f009 fa23 	bl	80161ac <_ZdlPvj>
      }
 800cd66:	bf00      	nop
 800cd68:	3710      	adds	r7, #16
 800cd6a:	46bd      	mov	sp, r7
 800cd6c:	bd80      	pop	{r7, pc}

0800cd6e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE10deallocateEPS6_j>:
      deallocate(_Tp* __p, size_type __t)
 800cd6e:	b580      	push	{r7, lr}
 800cd70:	b084      	sub	sp, #16
 800cd72:	af00      	add	r7, sp, #0
 800cd74:	60f8      	str	r0, [r7, #12]
 800cd76:	60b9      	str	r1, [r7, #8]
 800cd78:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 800cd7a:	687a      	ldr	r2, [r7, #4]
 800cd7c:	4613      	mov	r3, r2
 800cd7e:	005b      	lsls	r3, r3, #1
 800cd80:	4413      	add	r3, r2
 800cd82:	00db      	lsls	r3, r3, #3
 800cd84:	4619      	mov	r1, r3
 800cd86:	68b8      	ldr	r0, [r7, #8]
 800cd88:	f009 fa10 	bl	80161ac <_ZdlPvj>
      }
 800cd8c:	bf00      	nop
 800cd8e:	3710      	adds	r7, #16
 800cd90:	46bd      	mov	sp, r7
 800cd92:	bd80      	pop	{r7, pc}

0800cd94 <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEEC1ERKS1_RKS2_RKS3_RKS4_>:
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
 800cd94:	b580      	push	{r7, lr}
 800cd96:	b084      	sub	sp, #16
 800cd98:	af00      	add	r7, sp, #0
 800cd9a:	60f8      	str	r0, [r7, #12]
 800cd9c:	60b9      	str	r1, [r7, #8]
 800cd9e:	607a      	str	r2, [r7, #4]
 800cda0:	603b      	str	r3, [r7, #0]
      : _Inherited(__tail...), _Base(__head) { }
 800cda2:	69bb      	ldr	r3, [r7, #24]
 800cda4:	683a      	ldr	r2, [r7, #0]
 800cda6:	6879      	ldr	r1, [r7, #4]
 800cda8:	68f8      	ldr	r0, [r7, #12]
 800cdaa:	f000 f914 	bl	800cfd6 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEEC1ERKS1_RKS2_RKS3_>
 800cdae:	68b9      	ldr	r1, [r7, #8]
 800cdb0:	68f8      	ldr	r0, [r7, #12]
 800cdb2:	f000 f925 	bl	800d000 <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EEC1ERKS1_>
 800cdb6:	68fb      	ldr	r3, [r7, #12]
 800cdb8:	4618      	mov	r0, r3
 800cdba:	3710      	adds	r7, #16
 800cdbc:	46bd      	mov	sp, r7
 800cdbe:	bd80      	pop	{r7, pc}

0800cdc0 <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EE7_M_headERS2_>:
      _M_head(_Head_base& __b) noexcept { return __b; }
 800cdc0:	b480      	push	{r7}
 800cdc2:	b083      	sub	sp, #12
 800cdc4:	af00      	add	r7, sp, #0
 800cdc6:	6078      	str	r0, [r7, #4]
 800cdc8:	687b      	ldr	r3, [r7, #4]
 800cdca:	4618      	mov	r0, r3
 800cdcc:	370c      	adds	r7, #12
 800cdce:	46bd      	mov	sp, r7
 800cdd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdd4:	4770      	bx	lr

0800cdd6 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEE7_M_tailERS3_>:
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
 800cdd6:	b480      	push	{r7}
 800cdd8:	b083      	sub	sp, #12
 800cdda:	af00      	add	r7, sp, #0
 800cddc:	6078      	str	r0, [r7, #4]
 800cdde:	687b      	ldr	r3, [r7, #4]
 800cde0:	4618      	mov	r0, r3
 800cde2:	370c      	adds	r7, #12
 800cde4:	46bd      	mov	sp, r7
 800cde6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdea:	4770      	bx	lr

0800cdec <_ZSt4moveIRSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEEONSt16remove_referenceIT_E4typeEOS6_>:
    move(_Tp&& __t) noexcept
 800cdec:	b480      	push	{r7}
 800cdee:	b083      	sub	sp, #12
 800cdf0:	af00      	add	r7, sp, #0
 800cdf2:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800cdf4:	687b      	ldr	r3, [r7, #4]
 800cdf6:	4618      	mov	r0, r3
 800cdf8:	370c      	adds	r7, #12
 800cdfa:	46bd      	mov	sp, r7
 800cdfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce00:	4770      	bx	lr

0800ce02 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEE7_M_headERS3_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800ce02:	b580      	push	{r7, lr}
 800ce04:	b082      	sub	sp, #8
 800ce06:	af00      	add	r7, sp, #0
 800ce08:	6078      	str	r0, [r7, #4]
 800ce0a:	6878      	ldr	r0, [r7, #4]
 800ce0c:	f000 f904 	bl	800d018 <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EE7_M_headERS2_>
 800ce10:	4603      	mov	r3, r0
 800ce12:	4618      	mov	r0, r3
 800ce14:	3708      	adds	r7, #8
 800ce16:	46bd      	mov	sp, r7
 800ce18:	bd80      	pop	{r7, pc}

0800ce1a <_ZSt7forwardISt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS2_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800ce1a:	b480      	push	{r7}
 800ce1c:	b083      	sub	sp, #12
 800ce1e:	af00      	add	r7, sp, #0
 800ce20:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800ce22:	687b      	ldr	r3, [r7, #4]
 800ce24:	4618      	mov	r0, r3
 800ce26:	370c      	adds	r7, #12
 800ce28:	46bd      	mov	sp, r7
 800ce2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce2e:	4770      	bx	lr

0800ce30 <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEC1EOS2_>:
      _Tuple_impl(_Tuple_impl&& __in)
 800ce30:	b580      	push	{r7, lr}
 800ce32:	b082      	sub	sp, #8
 800ce34:	af00      	add	r7, sp, #0
 800ce36:	6078      	str	r0, [r7, #4]
 800ce38:	6039      	str	r1, [r7, #0]
      : _Base(std::forward<_Head>(_M_head(__in))) { }
 800ce3a:	6838      	ldr	r0, [r7, #0]
 800ce3c:	f000 f8f7 	bl	800d02e <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEE7_M_headERS2_>
 800ce40:	4603      	mov	r3, r0
 800ce42:	4618      	mov	r0, r3
 800ce44:	f000 f8ff 	bl	800d046 <_ZSt7forwardISt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800ce48:	4603      	mov	r3, r0
 800ce4a:	4619      	mov	r1, r3
 800ce4c:	6878      	ldr	r0, [r7, #4]
 800ce4e:	f000 f905 	bl	800d05c <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EEC1IS1_EEOT_>
 800ce52:	687b      	ldr	r3, [r7, #4]
 800ce54:	4618      	mov	r0, r3
 800ce56:	3708      	adds	r7, #8
 800ce58:	46bd      	mov	sp, r7
 800ce5a:	bd80      	pop	{r7, pc}

0800ce5c <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EEC1IS1_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800ce5c:	b580      	push	{r7, lr}
 800ce5e:	b082      	sub	sp, #8
 800ce60:	af00      	add	r7, sp, #0
 800ce62:	6078      	str	r0, [r7, #4]
 800ce64:	6039      	str	r1, [r7, #0]
	: _Head(std::forward<_UHead>(__h)) { }
 800ce66:	6838      	ldr	r0, [r7, #0]
 800ce68:	f7ff ffd7 	bl	800ce1a <_ZSt7forwardISt12_PlaceholderILi3EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800ce6c:	687b      	ldr	r3, [r7, #4]
 800ce6e:	4618      	mov	r0, r3
 800ce70:	3708      	adds	r7, #8
 800ce72:	46bd      	mov	sp, r7
 800ce74:	bd80      	pop	{r7, pc}

0800ce76 <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEEclIJS4_mS6_jEvEET0_DpOT_>:
	operator()(_Args&&... __args)
 800ce76:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ce7a:	b08a      	sub	sp, #40	; 0x28
 800ce7c:	af02      	add	r7, sp, #8
 800ce7e:	60f8      	str	r0, [r7, #12]
 800ce80:	60b9      	str	r1, [r7, #8]
 800ce82:	607a      	str	r2, [r7, #4]
 800ce84:	603b      	str	r3, [r7, #0]
	  return this->__call<_Result>(
 800ce86:	68b8      	ldr	r0, [r7, #8]
 800ce88:	f7ff fbb6 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800ce8c:	4604      	mov	r4, r0
 800ce8e:	6878      	ldr	r0, [r7, #4]
 800ce90:	f7ff fbbd 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800ce94:	4605      	mov	r5, r0
 800ce96:	6838      	ldr	r0, [r7, #0]
 800ce98:	f7ff fbc4 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800ce9c:	4606      	mov	r6, r0
 800ce9e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800cea0:	f7ff fbcb 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800cea4:	4603      	mov	r3, r0
 800cea6:	f107 0010 	add.w	r0, r7, #16
 800ceaa:	9300      	str	r3, [sp, #0]
 800ceac:	4633      	mov	r3, r6
 800ceae:	462a      	mov	r2, r5
 800ceb0:	4621      	mov	r1, r4
 800ceb2:	f000 f8e0 	bl	800d076 <_ZSt16forward_as_tupleIJRN7desenet22NetworkInterfaceDriverEmPKhjEESt5tupleIJDpOT_EES8_>
 800ceb6:	f107 0310 	add.w	r3, r7, #16
 800ceba:	4642      	mov	r2, r8
 800cebc:	4619      	mov	r1, r3
 800cebe:	68f8      	ldr	r0, [r7, #12]
 800cec0:	f000 f8fb 	bl	800d0ba <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEE6__callIvJS4_OmOS6_OjEJLj0ELj1ELj2ELj3ELj4EEEET_OSt5tupleIJDpT0_EESt12_Index_tupleIJXspT1_EEE>
	      _Bound_indexes());
 800cec4:	bf00      	nop
	}
 800cec6:	3720      	adds	r7, #32
 800cec8:	46bd      	mov	sp, r7
 800ceca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800cece <_ZNKSt9_Any_data9_M_accessIPKSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS2_22NetworkInterfaceDriverEmPKhjEPS4_St12_PlaceholderILi1EESC_ILi2EESC_ILi3EESC_ILi4EEEEEERKT_v>:
      _M_access() const
 800cece:	b580      	push	{r7, lr}
 800ced0:	b082      	sub	sp, #8
 800ced2:	af00      	add	r7, sp, #0
 800ced4:	6078      	str	r0, [r7, #4]
      { return *static_cast<const _Tp*>(_M_access()); }
 800ced6:	6878      	ldr	r0, [r7, #4]
 800ced8:	f7fe f893 	bl	800b002 <_ZNKSt9_Any_data9_M_accessEv>
 800cedc:	4603      	mov	r3, r0
 800cede:	4618      	mov	r0, r3
 800cee0:	3708      	adds	r7, #8
 800cee2:	46bd      	mov	sp, r7
 800cee4:	bd80      	pop	{r7, pc}

0800cee6 <_ZNSt16allocator_traitsISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEE8allocateERS6_j>:
      allocate(allocator_type& __a, size_type __n)
 800cee6:	b580      	push	{r7, lr}
 800cee8:	b082      	sub	sp, #8
 800ceea:	af00      	add	r7, sp, #0
 800ceec:	6078      	str	r0, [r7, #4]
 800ceee:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 800cef0:	2200      	movs	r2, #0
 800cef2:	6839      	ldr	r1, [r7, #0]
 800cef4:	6878      	ldr	r0, [r7, #4]
 800cef6:	f000 f936 	bl	800d166 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE8allocateEjPKv>
 800cefa:	4603      	mov	r3, r0
 800cefc:	4618      	mov	r0, r3
 800cefe:	3708      	adds	r7, #8
 800cf00:	46bd      	mov	sp, r7
 800cf02:	bd80      	pop	{r7, pc}

0800cf04 <_ZSt11__addressofISaISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEEEPT_RS7_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 800cf04:	b480      	push	{r7}
 800cf06:	b083      	sub	sp, #12
 800cf08:	af00      	add	r7, sp, #0
 800cf0a:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 800cf0c:	687b      	ldr	r3, [r7, #4]
 800cf0e:	4618      	mov	r0, r3
 800cf10:	370c      	adds	r7, #12
 800cf12:	46bd      	mov	sp, r7
 800cf14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf18:	4770      	bx	lr

0800cf1a <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE9constructIS5_JRKS5_EEEvPT_DpOT0_>:
	construct(_Up* __p, _Args&&... __args)
 800cf1a:	b590      	push	{r4, r7, lr}
 800cf1c:	b085      	sub	sp, #20
 800cf1e:	af00      	add	r7, sp, #0
 800cf20:	60f8      	str	r0, [r7, #12]
 800cf22:	60b9      	str	r1, [r7, #8]
 800cf24:	607a      	str	r2, [r7, #4]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 800cf26:	6878      	ldr	r0, [r7, #4]
 800cf28:	f7ff fc0a 	bl	800c740 <_ZSt7forwardIRKPN7desenet6sensor19AbstractApplicationEEOT_RNSt16remove_referenceIS6_E4typeE>
 800cf2c:	4603      	mov	r3, r0
 800cf2e:	681c      	ldr	r4, [r3, #0]
 800cf30:	68bb      	ldr	r3, [r7, #8]
 800cf32:	4619      	mov	r1, r3
 800cf34:	2004      	movs	r0, #4
 800cf36:	f7fa fbe7 	bl	8007708 <_ZnwjPv>
 800cf3a:	4603      	mov	r3, r0
 800cf3c:	601c      	str	r4, [r3, #0]
 800cf3e:	bf00      	nop
 800cf40:	3714      	adds	r7, #20
 800cf42:	46bd      	mov	sp, r7
 800cf44:	bd90      	pop	{r4, r7, pc}

0800cf46 <_ZNSt16allocator_traitsISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEE8allocateERS6_j>:
      allocate(allocator_type& __a, size_type __n)
 800cf46:	b580      	push	{r7, lr}
 800cf48:	b082      	sub	sp, #8
 800cf4a:	af00      	add	r7, sp, #0
 800cf4c:	6078      	str	r0, [r7, #4]
 800cf4e:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 800cf50:	2200      	movs	r2, #0
 800cf52:	6839      	ldr	r1, [r7, #0]
 800cf54:	6878      	ldr	r0, [r7, #4]
 800cf56:	f000 f927 	bl	800d1a8 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE8allocateEjPKv>
 800cf5a:	4603      	mov	r3, r0
 800cf5c:	4618      	mov	r0, r3
 800cf5e:	3708      	adds	r7, #8
 800cf60:	46bd      	mov	sp, r7
 800cf62:	bd80      	pop	{r7, pc}

0800cf64 <_ZSt11__addressofISaISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEEEPT_RS7_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 800cf64:	b480      	push	{r7}
 800cf66:	b083      	sub	sp, #12
 800cf68:	af00      	add	r7, sp, #0
 800cf6a:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 800cf6c:	687b      	ldr	r3, [r7, #4]
 800cf6e:	4618      	mov	r0, r3
 800cf70:	370c      	adds	r7, #12
 800cf72:	46bd      	mov	sp, r7
 800cf74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf78:	4770      	bx	lr

0800cf7a <_ZN7desenet6sensor13NetworkEntity12EventElementC1ERKS2_>:
 800cf7a:	b580      	push	{r7, lr}
 800cf7c:	b082      	sub	sp, #8
 800cf7e:	af00      	add	r7, sp, #0
 800cf80:	6078      	str	r0, [r7, #4]
 800cf82:	6039      	str	r1, [r7, #0]
 800cf84:	683b      	ldr	r3, [r7, #0]
 800cf86:	881a      	ldrh	r2, [r3, #0]
 800cf88:	687b      	ldr	r3, [r7, #4]
 800cf8a:	801a      	strh	r2, [r3, #0]
 800cf8c:	687b      	ldr	r3, [r7, #4]
 800cf8e:	1d1a      	adds	r2, r3, #4
 800cf90:	683b      	ldr	r3, [r7, #0]
 800cf92:	3304      	adds	r3, #4
 800cf94:	4619      	mov	r1, r3
 800cf96:	4610      	mov	r0, r2
 800cf98:	f7fb fd9b 	bl	8008ad2 <_ZN3hei12SharedBufferIhEC1ERKS1_>
 800cf9c:	687b      	ldr	r3, [r7, #4]
 800cf9e:	4618      	mov	r0, r3
 800cfa0:	3708      	adds	r7, #8
 800cfa2:	46bd      	mov	sp, r7
 800cfa4:	bd80      	pop	{r7, pc}

0800cfa6 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE9constructIS5_JRKS5_EEEvPT_DpOT0_>:
	construct(_Up* __p, _Args&&... __args)
 800cfa6:	b590      	push	{r4, r7, lr}
 800cfa8:	b085      	sub	sp, #20
 800cfaa:	af00      	add	r7, sp, #0
 800cfac:	60f8      	str	r0, [r7, #12]
 800cfae:	60b9      	str	r1, [r7, #8]
 800cfb0:	607a      	str	r2, [r7, #4]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 800cfb2:	6878      	ldr	r0, [r7, #4]
 800cfb4:	f7ff fc14 	bl	800c7e0 <_ZSt7forwardIRKN7desenet6sensor13NetworkEntity12EventElementEEOT_RNSt16remove_referenceIS6_E4typeE>
 800cfb8:	4604      	mov	r4, r0
 800cfba:	68bb      	ldr	r3, [r7, #8]
 800cfbc:	4619      	mov	r1, r3
 800cfbe:	2010      	movs	r0, #16
 800cfc0:	f7fa fba2 	bl	8007708 <_ZnwjPv>
 800cfc4:	4603      	mov	r3, r0
 800cfc6:	4621      	mov	r1, r4
 800cfc8:	4618      	mov	r0, r3
 800cfca:	f7ff ffd6 	bl	800cf7a <_ZN7desenet6sensor13NetworkEntity12EventElementC1ERKS2_>
 800cfce:	bf00      	nop
 800cfd0:	3714      	adds	r7, #20
 800cfd2:	46bd      	mov	sp, r7
 800cfd4:	bd90      	pop	{r4, r7, pc}

0800cfd6 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEEC1ERKS1_RKS2_RKS3_>:
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
 800cfd6:	b580      	push	{r7, lr}
 800cfd8:	b084      	sub	sp, #16
 800cfda:	af00      	add	r7, sp, #0
 800cfdc:	60f8      	str	r0, [r7, #12]
 800cfde:	60b9      	str	r1, [r7, #8]
 800cfe0:	607a      	str	r2, [r7, #4]
 800cfe2:	603b      	str	r3, [r7, #0]
      : _Inherited(__tail...), _Base(__head) { }
 800cfe4:	683a      	ldr	r2, [r7, #0]
 800cfe6:	6879      	ldr	r1, [r7, #4]
 800cfe8:	68f8      	ldr	r0, [r7, #12]
 800cfea:	f000 f8fe 	bl	800d1ea <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEEC1ERKS1_RKS2_>
 800cfee:	68b9      	ldr	r1, [r7, #8]
 800cff0:	68f8      	ldr	r0, [r7, #12]
 800cff2:	f000 f90d 	bl	800d210 <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EEC1ERKS1_>
 800cff6:	68fb      	ldr	r3, [r7, #12]
 800cff8:	4618      	mov	r0, r3
 800cffa:	3710      	adds	r7, #16
 800cffc:	46bd      	mov	sp, r7
 800cffe:	bd80      	pop	{r7, pc}

0800d000 <_ZNSt10_Head_baseILj1ESt12_PlaceholderILi1EELb1EEC1ERKS1_>:
      constexpr _Head_base(const _Head& __h)
 800d000:	b480      	push	{r7}
 800d002:	b083      	sub	sp, #12
 800d004:	af00      	add	r7, sp, #0
 800d006:	6078      	str	r0, [r7, #4]
 800d008:	6039      	str	r1, [r7, #0]
      : _Head(__h) { }
 800d00a:	687b      	ldr	r3, [r7, #4]
 800d00c:	4618      	mov	r0, r3
 800d00e:	370c      	adds	r7, #12
 800d010:	46bd      	mov	sp, r7
 800d012:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d016:	4770      	bx	lr

0800d018 <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EE7_M_headERS2_>:
      _M_head(_Head_base& __b) noexcept { return __b; }
 800d018:	b480      	push	{r7}
 800d01a:	b083      	sub	sp, #12
 800d01c:	af00      	add	r7, sp, #0
 800d01e:	6078      	str	r0, [r7, #4]
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	4618      	mov	r0, r3
 800d024:	370c      	adds	r7, #12
 800d026:	46bd      	mov	sp, r7
 800d028:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d02c:	4770      	bx	lr

0800d02e <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEE7_M_headERS2_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800d02e:	b580      	push	{r7, lr}
 800d030:	b082      	sub	sp, #8
 800d032:	af00      	add	r7, sp, #0
 800d034:	6078      	str	r0, [r7, #4]
 800d036:	6878      	ldr	r0, [r7, #4]
 800d038:	f000 f8f6 	bl	800d228 <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EE7_M_headERS2_>
 800d03c:	4603      	mov	r3, r0
 800d03e:	4618      	mov	r0, r3
 800d040:	3708      	adds	r7, #8
 800d042:	46bd      	mov	sp, r7
 800d044:	bd80      	pop	{r7, pc}

0800d046 <_ZSt7forwardISt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS2_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d046:	b480      	push	{r7}
 800d048:	b083      	sub	sp, #12
 800d04a:	af00      	add	r7, sp, #0
 800d04c:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d04e:	687b      	ldr	r3, [r7, #4]
 800d050:	4618      	mov	r0, r3
 800d052:	370c      	adds	r7, #12
 800d054:	46bd      	mov	sp, r7
 800d056:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d05a:	4770      	bx	lr

0800d05c <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EEC1IS1_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800d05c:	b580      	push	{r7, lr}
 800d05e:	b082      	sub	sp, #8
 800d060:	af00      	add	r7, sp, #0
 800d062:	6078      	str	r0, [r7, #4]
 800d064:	6039      	str	r1, [r7, #0]
	: _Head(std::forward<_UHead>(__h)) { }
 800d066:	6838      	ldr	r0, [r7, #0]
 800d068:	f7ff ffed 	bl	800d046 <_ZSt7forwardISt12_PlaceholderILi4EEEOT_RNSt16remove_referenceIS2_E4typeE>
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	4618      	mov	r0, r3
 800d070:	3708      	adds	r7, #8
 800d072:	46bd      	mov	sp, r7
 800d074:	bd80      	pop	{r7, pc}

0800d076 <_ZSt16forward_as_tupleIJRN7desenet22NetworkInterfaceDriverEmPKhjEESt5tupleIJDpOT_EES8_>:
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 2275. Why is forward_as_tuple not constexpr?
  /// std::forward_as_tuple
  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
 800d076:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d078:	b087      	sub	sp, #28
 800d07a:	af02      	add	r7, sp, #8
 800d07c:	60f8      	str	r0, [r7, #12]
 800d07e:	60b9      	str	r1, [r7, #8]
 800d080:	607a      	str	r2, [r7, #4]
 800d082:	603b      	str	r3, [r7, #0]
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }
 800d084:	68b8      	ldr	r0, [r7, #8]
 800d086:	f7ff fab7 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d08a:	4604      	mov	r4, r0
 800d08c:	6878      	ldr	r0, [r7, #4]
 800d08e:	f7ff fabe 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d092:	4605      	mov	r5, r0
 800d094:	6838      	ldr	r0, [r7, #0]
 800d096:	f7ff fac5 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d09a:	4606      	mov	r6, r0
 800d09c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d09e:	f7ff facc 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d0a2:	4603      	mov	r3, r0
 800d0a4:	9300      	str	r3, [sp, #0]
 800d0a6:	4633      	mov	r3, r6
 800d0a8:	462a      	mov	r2, r5
 800d0aa:	4621      	mov	r1, r4
 800d0ac:	68f8      	ldr	r0, [r7, #12]
 800d0ae:	f000 f8c6 	bl	800d23e <_ZNSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEC1IJS2_mS5_jELb1ELb1EEEDpOT_>
 800d0b2:	68f8      	ldr	r0, [r7, #12]
 800d0b4:	3714      	adds	r7, #20
 800d0b6:	46bd      	mov	sp, r7
 800d0b8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800d0ba <_ZNSt5_BindIFMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEPS2_St12_PlaceholderILi1EESA_ILi2EESA_ILi3EESA_ILi4EEEE6__callIvJS4_OmOS6_OjEJLj0ELj1ELj2ELj3ELj4EEEET_OSt5tupleIJDpT0_EESt12_Index_tupleIJXspT1_EEE>:
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 800d0ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d0be:	b08d      	sub	sp, #52	; 0x34
 800d0c0:	af02      	add	r7, sp, #8
 800d0c2:	60f8      	str	r0, [r7, #12]
 800d0c4:	60b9      	str	r1, [r7, #8]
 800d0c6:	713a      	strb	r2, [r7, #4]
	  return std::__invoke(_M_f,
 800d0c8:	68fc      	ldr	r4, [r7, #12]
	      _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
 800d0ca:	68fb      	ldr	r3, [r7, #12]
 800d0cc:	3308      	adds	r3, #8
 800d0ce:	4618      	mov	r0, r3
 800d0d0:	f000 f8db 	bl	800d28a <_ZSt3getILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>
 800d0d4:	4601      	mov	r1, r0
	  return std::__invoke(_M_f,
 800d0d6:	f107 0314 	add.w	r3, r7, #20
 800d0da:	68ba      	ldr	r2, [r7, #8]
 800d0dc:	4618      	mov	r0, r3
 800d0de:	f000 f8e1 	bl	800d2a4 <_ZNVKSt3_MuIPN7desenet6sensor13NetworkEntityELb0ELb0EEclIRS3_St5tupleIJRNS0_22NetworkInterfaceDriverEOmOPKhOjEEEEOT_SH_RT0_>
 800d0e2:	4606      	mov	r6, r0
	      _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
 800d0e4:	68fb      	ldr	r3, [r7, #12]
 800d0e6:	3308      	adds	r3, #8
 800d0e8:	4618      	mov	r0, r3
 800d0ea:	f000 f8e9 	bl	800d2c0 <_ZSt3getILj1EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>
 800d0ee:	4601      	mov	r1, r0
	  return std::__invoke(_M_f,
 800d0f0:	f107 0318 	add.w	r3, r7, #24
 800d0f4:	68ba      	ldr	r2, [r7, #8]
 800d0f6:	4618      	mov	r0, r3
 800d0f8:	f000 f8ee 	bl	800d2d8 <_ZNVKSt3_MuISt12_PlaceholderILi1EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj0EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj0ESG_EE4type4typeERVKS1_RSG_>
 800d0fc:	4680      	mov	r8, r0
	      _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
 800d0fe:	68fb      	ldr	r3, [r7, #12]
 800d100:	3308      	adds	r3, #8
 800d102:	4618      	mov	r0, r3
 800d104:	f000 f8fa 	bl	800d2fc <_ZSt3getILj2EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>
 800d108:	4601      	mov	r1, r0
	  return std::__invoke(_M_f,
 800d10a:	f107 031c 	add.w	r3, r7, #28
 800d10e:	68ba      	ldr	r2, [r7, #8]
 800d110:	4618      	mov	r0, r3
 800d112:	f000 f8ff 	bl	800d314 <_ZNVKSt3_MuISt12_PlaceholderILi2EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj1EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj1ESG_EE4type4typeERVKS1_RSG_>
 800d116:	4681      	mov	r9, r0
	      _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
 800d118:	68fb      	ldr	r3, [r7, #12]
 800d11a:	3308      	adds	r3, #8
 800d11c:	4618      	mov	r0, r3
 800d11e:	f000 f90b 	bl	800d338 <_ZSt3getILj3EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>
 800d122:	4601      	mov	r1, r0
	  return std::__invoke(_M_f,
 800d124:	f107 0320 	add.w	r3, r7, #32
 800d128:	68ba      	ldr	r2, [r7, #8]
 800d12a:	4618      	mov	r0, r3
 800d12c:	f000 f910 	bl	800d350 <_ZNVKSt3_MuISt12_PlaceholderILi3EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj2EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj2ESG_EE4type4typeERVKS1_RSG_>
 800d130:	4605      	mov	r5, r0
	      _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
 800d132:	68fb      	ldr	r3, [r7, #12]
 800d134:	3308      	adds	r3, #8
 800d136:	4618      	mov	r0, r3
 800d138:	f000 f91c 	bl	800d374 <_ZSt3getILj4EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>
 800d13c:	4601      	mov	r1, r0
	  return std::__invoke(_M_f,
 800d13e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800d142:	68ba      	ldr	r2, [r7, #8]
 800d144:	4618      	mov	r0, r3
 800d146:	f000 f921 	bl	800d38c <_ZNVKSt3_MuISt12_PlaceholderILi4EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj3EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj3ESG_EE4type4typeERVKS1_RSG_>
 800d14a:	4603      	mov	r3, r0
 800d14c:	9301      	str	r3, [sp, #4]
 800d14e:	9500      	str	r5, [sp, #0]
 800d150:	464b      	mov	r3, r9
 800d152:	4642      	mov	r2, r8
 800d154:	4631      	mov	r1, r6
 800d156:	4620      	mov	r0, r4
 800d158:	f000 f92a 	bl	800d3b0 <_ZSt8__invokeIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEJRPS2_S4_mS6_jEENSt15__invoke_resultIT_JDpT0_EE4typeEOSD_DpOSE_>
	      );
 800d15c:	bf00      	nop
	}
 800d15e:	372c      	adds	r7, #44	; 0x2c
 800d160:	46bd      	mov	sp, r7
 800d162:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800d166 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 800d166:	b580      	push	{r7, lr}
 800d168:	b084      	sub	sp, #16
 800d16a:	af00      	add	r7, sp, #0
 800d16c:	60f8      	str	r0, [r7, #12]
 800d16e:	60b9      	str	r1, [r7, #8]
 800d170:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 800d172:	68f8      	ldr	r0, [r7, #12]
 800d174:	f000 f94a 	bl	800d40c <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE11_M_max_sizeEv>
 800d178:	4602      	mov	r2, r0
 800d17a:	68bb      	ldr	r3, [r7, #8]
 800d17c:	4293      	cmp	r3, r2
 800d17e:	bf8c      	ite	hi
 800d180:	2301      	movhi	r3, #1
 800d182:	2300      	movls	r3, #0
 800d184:	b2db      	uxtb	r3, r3
 800d186:	2b00      	cmp	r3, #0
 800d188:	d001      	beq.n	800d18e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 800d18a:	f009 f846 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 800d18e:	68ba      	ldr	r2, [r7, #8]
 800d190:	4613      	mov	r3, r2
 800d192:	005b      	lsls	r3, r3, #1
 800d194:	4413      	add	r3, r2
 800d196:	009b      	lsls	r3, r3, #2
 800d198:	4618      	mov	r0, r3
 800d19a:	f009 f81a 	bl	80161d2 <_Znwj>
 800d19e:	4603      	mov	r3, r0
      }
 800d1a0:	4618      	mov	r0, r3
 800d1a2:	3710      	adds	r7, #16
 800d1a4:	46bd      	mov	sp, r7
 800d1a6:	bd80      	pop	{r7, pc}

0800d1a8 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 800d1a8:	b580      	push	{r7, lr}
 800d1aa:	b084      	sub	sp, #16
 800d1ac:	af00      	add	r7, sp, #0
 800d1ae:	60f8      	str	r0, [r7, #12]
 800d1b0:	60b9      	str	r1, [r7, #8]
 800d1b2:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 800d1b4:	68f8      	ldr	r0, [r7, #12]
 800d1b6:	f000 f937 	bl	800d428 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE11_M_max_sizeEv>
 800d1ba:	4602      	mov	r2, r0
 800d1bc:	68bb      	ldr	r3, [r7, #8]
 800d1be:	4293      	cmp	r3, r2
 800d1c0:	bf8c      	ite	hi
 800d1c2:	2301      	movhi	r3, #1
 800d1c4:	2300      	movls	r3, #0
 800d1c6:	b2db      	uxtb	r3, r3
 800d1c8:	2b00      	cmp	r3, #0
 800d1ca:	d001      	beq.n	800d1d0 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 800d1cc:	f009 f825 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 800d1d0:	68ba      	ldr	r2, [r7, #8]
 800d1d2:	4613      	mov	r3, r2
 800d1d4:	005b      	lsls	r3, r3, #1
 800d1d6:	4413      	add	r3, r2
 800d1d8:	00db      	lsls	r3, r3, #3
 800d1da:	4618      	mov	r0, r3
 800d1dc:	f008 fff9 	bl	80161d2 <_Znwj>
 800d1e0:	4603      	mov	r3, r0
      }
 800d1e2:	4618      	mov	r0, r3
 800d1e4:	3710      	adds	r7, #16
 800d1e6:	46bd      	mov	sp, r7
 800d1e8:	bd80      	pop	{r7, pc}

0800d1ea <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEEC1ERKS1_RKS2_>:
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
 800d1ea:	b580      	push	{r7, lr}
 800d1ec:	b084      	sub	sp, #16
 800d1ee:	af00      	add	r7, sp, #0
 800d1f0:	60f8      	str	r0, [r7, #12]
 800d1f2:	60b9      	str	r1, [r7, #8]
 800d1f4:	607a      	str	r2, [r7, #4]
      : _Inherited(__tail...), _Base(__head) { }
 800d1f6:	6879      	ldr	r1, [r7, #4]
 800d1f8:	68f8      	ldr	r0, [r7, #12]
 800d1fa:	f000 f923 	bl	800d444 <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEC1ERKS1_>
 800d1fe:	68b9      	ldr	r1, [r7, #8]
 800d200:	68f8      	ldr	r0, [r7, #12]
 800d202:	f000 f92d 	bl	800d460 <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EEC1ERKS1_>
 800d206:	68fb      	ldr	r3, [r7, #12]
 800d208:	4618      	mov	r0, r3
 800d20a:	3710      	adds	r7, #16
 800d20c:	46bd      	mov	sp, r7
 800d20e:	bd80      	pop	{r7, pc}

0800d210 <_ZNSt10_Head_baseILj2ESt12_PlaceholderILi2EELb1EEC1ERKS1_>:
      constexpr _Head_base(const _Head& __h)
 800d210:	b480      	push	{r7}
 800d212:	b083      	sub	sp, #12
 800d214:	af00      	add	r7, sp, #0
 800d216:	6078      	str	r0, [r7, #4]
 800d218:	6039      	str	r1, [r7, #0]
      : _Head(__h) { }
 800d21a:	687b      	ldr	r3, [r7, #4]
 800d21c:	4618      	mov	r0, r3
 800d21e:	370c      	adds	r7, #12
 800d220:	46bd      	mov	sp, r7
 800d222:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d226:	4770      	bx	lr

0800d228 <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EE7_M_headERS2_>:
      _M_head(_Head_base& __b) noexcept { return __b; }
 800d228:	b480      	push	{r7}
 800d22a:	b083      	sub	sp, #12
 800d22c:	af00      	add	r7, sp, #0
 800d22e:	6078      	str	r0, [r7, #4]
 800d230:	687b      	ldr	r3, [r7, #4]
 800d232:	4618      	mov	r0, r3
 800d234:	370c      	adds	r7, #12
 800d236:	46bd      	mov	sp, r7
 800d238:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d23c:	4770      	bx	lr

0800d23e <_ZNSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEC1IJS2_mS5_jELb1ELb1EEEDpOT_>:
	tuple(_UElements&&... __elements)
 800d23e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d242:	b086      	sub	sp, #24
 800d244:	af02      	add	r7, sp, #8
 800d246:	60f8      	str	r0, [r7, #12]
 800d248:	60b9      	str	r1, [r7, #8]
 800d24a:	607a      	str	r2, [r7, #4]
 800d24c:	603b      	str	r3, [r7, #0]
	: _Inherited(std::forward<_UElements>(__elements)...) { }
 800d24e:	68fc      	ldr	r4, [r7, #12]
 800d250:	68b8      	ldr	r0, [r7, #8]
 800d252:	f7ff f9d1 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d256:	4605      	mov	r5, r0
 800d258:	6878      	ldr	r0, [r7, #4]
 800d25a:	f7ff f9d8 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d25e:	4606      	mov	r6, r0
 800d260:	6838      	ldr	r0, [r7, #0]
 800d262:	f7ff f9df 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d266:	4680      	mov	r8, r0
 800d268:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d26a:	f7ff f9e6 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d26e:	4603      	mov	r3, r0
 800d270:	9300      	str	r3, [sp, #0]
 800d272:	4643      	mov	r3, r8
 800d274:	4632      	mov	r2, r6
 800d276:	4629      	mov	r1, r5
 800d278:	4620      	mov	r0, r4
 800d27a:	f000 f8fd 	bl	800d478 <_ZNSt11_Tuple_implILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEC1IS2_JmS5_jEvEEOT_DpOT0_>
 800d27e:	68fb      	ldr	r3, [r7, #12]
 800d280:	4618      	mov	r0, r3
 800d282:	3710      	adds	r7, #16
 800d284:	46bd      	mov	sp, r7
 800d286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d28a <_ZSt3getILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>:
    get(tuple<_Elements...>& __t) noexcept
 800d28a:	b580      	push	{r7, lr}
 800d28c:	b082      	sub	sp, #8
 800d28e:	af00      	add	r7, sp, #0
 800d290:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d292:	687b      	ldr	r3, [r7, #4]
 800d294:	4618      	mov	r0, r3
 800d296:	f000 f935 	bl	800d504 <_ZSt12__get_helperILj0EPN7desenet6sensor13NetworkEntityEJSt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS9_DpT1_EE>
 800d29a:	4603      	mov	r3, r0
 800d29c:	4618      	mov	r0, r3
 800d29e:	3708      	adds	r7, #8
 800d2a0:	46bd      	mov	sp, r7
 800d2a2:	bd80      	pop	{r7, pc}

0800d2a4 <_ZNVKSt3_MuIPN7desenet6sensor13NetworkEntityELb0ELb0EEclIRS3_St5tupleIJRNS0_22NetworkInterfaceDriverEOmOPKhOjEEEEOT_SH_RT0_>:
	operator()(_CVArg&& __arg, _Tuple&) const volatile
 800d2a4:	b580      	push	{r7, lr}
 800d2a6:	b084      	sub	sp, #16
 800d2a8:	af00      	add	r7, sp, #0
 800d2aa:	60f8      	str	r0, [r7, #12]
 800d2ac:	60b9      	str	r1, [r7, #8]
 800d2ae:	607a      	str	r2, [r7, #4]
	{ return std::forward<_CVArg>(__arg); }
 800d2b0:	68b8      	ldr	r0, [r7, #8]
 800d2b2:	f000 f933 	bl	800d51c <_ZSt7forwardIRPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS5_E4typeE>
 800d2b6:	4603      	mov	r3, r0
 800d2b8:	4618      	mov	r0, r3
 800d2ba:	3710      	adds	r7, #16
 800d2bc:	46bd      	mov	sp, r7
 800d2be:	bd80      	pop	{r7, pc}

0800d2c0 <_ZSt3getILj1EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>:
    get(tuple<_Elements...>& __t) noexcept
 800d2c0:	b580      	push	{r7, lr}
 800d2c2:	b082      	sub	sp, #8
 800d2c4:	af00      	add	r7, sp, #0
 800d2c6:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d2c8:	6878      	ldr	r0, [r7, #4]
 800d2ca:	f000 f932 	bl	800d532 <_ZSt12__get_helperILj1ESt12_PlaceholderILi1EEJS0_ILi2EES0_ILi3EES0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE>
 800d2ce:	4603      	mov	r3, r0
 800d2d0:	4618      	mov	r0, r3
 800d2d2:	3708      	adds	r7, #8
 800d2d4:	46bd      	mov	sp, r7
 800d2d6:	bd80      	pop	{r7, pc}

0800d2d8 <_ZNVKSt3_MuISt12_PlaceholderILi1EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj0EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj0ESG_EE4type4typeERVKS1_RSG_>:
	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 800d2d8:	b580      	push	{r7, lr}
 800d2da:	b084      	sub	sp, #16
 800d2dc:	af00      	add	r7, sp, #0
 800d2de:	60f8      	str	r0, [r7, #12]
 800d2e0:	60b9      	str	r1, [r7, #8]
 800d2e2:	607a      	str	r2, [r7, #4]
	    ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 800d2e4:	6878      	ldr	r0, [r7, #4]
 800d2e6:	f000 f930 	bl	800d54a <_ZSt4moveIRSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEONSt16remove_referenceIT_E4typeEOSC_>
 800d2ea:	4603      	mov	r3, r0
 800d2ec:	4618      	mov	r0, r3
 800d2ee:	f000 f937 	bl	800d560 <_ZSt3getILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>
 800d2f2:	4603      	mov	r3, r0
	}
 800d2f4:	4618      	mov	r0, r3
 800d2f6:	3710      	adds	r7, #16
 800d2f8:	46bd      	mov	sp, r7
 800d2fa:	bd80      	pop	{r7, pc}

0800d2fc <_ZSt3getILj2EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>:
    get(tuple<_Elements...>& __t) noexcept
 800d2fc:	b580      	push	{r7, lr}
 800d2fe:	b082      	sub	sp, #8
 800d300:	af00      	add	r7, sp, #0
 800d302:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d304:	6878      	ldr	r0, [r7, #4]
 800d306:	f000 f93b 	bl	800d580 <_ZSt12__get_helperILj2ESt12_PlaceholderILi2EEJS0_ILi3EES0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS4_DpT1_EE>
 800d30a:	4603      	mov	r3, r0
 800d30c:	4618      	mov	r0, r3
 800d30e:	3708      	adds	r7, #8
 800d310:	46bd      	mov	sp, r7
 800d312:	bd80      	pop	{r7, pc}

0800d314 <_ZNVKSt3_MuISt12_PlaceholderILi2EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj1EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj1ESG_EE4type4typeERVKS1_RSG_>:
	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 800d314:	b580      	push	{r7, lr}
 800d316:	b084      	sub	sp, #16
 800d318:	af00      	add	r7, sp, #0
 800d31a:	60f8      	str	r0, [r7, #12]
 800d31c:	60b9      	str	r1, [r7, #8]
 800d31e:	607a      	str	r2, [r7, #4]
	    ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 800d320:	6878      	ldr	r0, [r7, #4]
 800d322:	f000 f912 	bl	800d54a <_ZSt4moveIRSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEONSt16remove_referenceIT_E4typeEOSC_>
 800d326:	4603      	mov	r3, r0
 800d328:	4618      	mov	r0, r3
 800d32a:	f000 f935 	bl	800d598 <_ZSt3getILj1EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>
 800d32e:	4603      	mov	r3, r0
	}
 800d330:	4618      	mov	r0, r3
 800d332:	3710      	adds	r7, #16
 800d334:	46bd      	mov	sp, r7
 800d336:	bd80      	pop	{r7, pc}

0800d338 <_ZSt3getILj3EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>:
    get(tuple<_Elements...>& __t) noexcept
 800d338:	b580      	push	{r7, lr}
 800d33a:	b082      	sub	sp, #8
 800d33c:	af00      	add	r7, sp, #0
 800d33e:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d340:	6878      	ldr	r0, [r7, #4]
 800d342:	f000 f939 	bl	800d5b8 <_ZSt12__get_helperILj3ESt12_PlaceholderILi3EEJS0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS3_DpT1_EE>
 800d346:	4603      	mov	r3, r0
 800d348:	4618      	mov	r0, r3
 800d34a:	3708      	adds	r7, #8
 800d34c:	46bd      	mov	sp, r7
 800d34e:	bd80      	pop	{r7, pc}

0800d350 <_ZNVKSt3_MuISt12_PlaceholderILi3EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj2EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj2ESG_EE4type4typeERVKS1_RSG_>:
	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 800d350:	b580      	push	{r7, lr}
 800d352:	b084      	sub	sp, #16
 800d354:	af00      	add	r7, sp, #0
 800d356:	60f8      	str	r0, [r7, #12]
 800d358:	60b9      	str	r1, [r7, #8]
 800d35a:	607a      	str	r2, [r7, #4]
	    ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 800d35c:	6878      	ldr	r0, [r7, #4]
 800d35e:	f000 f8f4 	bl	800d54a <_ZSt4moveIRSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEONSt16remove_referenceIT_E4typeEOSC_>
 800d362:	4603      	mov	r3, r0
 800d364:	4618      	mov	r0, r3
 800d366:	f000 f933 	bl	800d5d0 <_ZSt3getILj2EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>
 800d36a:	4603      	mov	r3, r0
	}
 800d36c:	4618      	mov	r0, r3
 800d36e:	3710      	adds	r7, #16
 800d370:	46bd      	mov	sp, r7
 800d372:	bd80      	pop	{r7, pc}

0800d374 <_ZSt3getILj4EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSD_>:
    get(tuple<_Elements...>& __t) noexcept
 800d374:	b580      	push	{r7, lr}
 800d376:	b082      	sub	sp, #8
 800d378:	af00      	add	r7, sp, #0
 800d37a:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d37c:	6878      	ldr	r0, [r7, #4]
 800d37e:	f000 f937 	bl	800d5f0 <_ZSt12__get_helperILj4ESt12_PlaceholderILi4EEJEERT0_RSt11_Tuple_implIXT_EJS2_DpT1_EE>
 800d382:	4603      	mov	r3, r0
 800d384:	4618      	mov	r0, r3
 800d386:	3708      	adds	r7, #8
 800d388:	46bd      	mov	sp, r7
 800d38a:	bd80      	pop	{r7, pc}

0800d38c <_ZNVKSt3_MuISt12_PlaceholderILi4EELb0ELb1EEclISt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEEONSt9enable_ifIXltLj3EsrSt10tuple_sizeIT_E5valueESt13tuple_elementILj3ESG_EE4type4typeERVKS1_RSG_>:
	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 800d38c:	b580      	push	{r7, lr}
 800d38e:	b084      	sub	sp, #16
 800d390:	af00      	add	r7, sp, #0
 800d392:	60f8      	str	r0, [r7, #12]
 800d394:	60b9      	str	r1, [r7, #8]
 800d396:	607a      	str	r2, [r7, #4]
	    ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 800d398:	6878      	ldr	r0, [r7, #4]
 800d39a:	f000 f8d6 	bl	800d54a <_ZSt4moveIRSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEONSt16remove_referenceIT_E4typeEOSC_>
 800d39e:	4603      	mov	r3, r0
 800d3a0:	4618      	mov	r0, r3
 800d3a2:	f000 f931 	bl	800d608 <_ZSt3getILj3EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>
 800d3a6:	4603      	mov	r3, r0
	}
 800d3a8:	4618      	mov	r0, r3
 800d3aa:	3710      	adds	r7, #16
 800d3ac:	46bd      	mov	sp, r7
 800d3ae:	bd80      	pop	{r7, pc}

0800d3b0 <_ZSt8__invokeIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEJRPS2_S4_mS6_jEENSt15__invoke_resultIT_JDpT0_EE4typeEOSD_DpOSE_>:
    __invoke(_Callable&& __fn, _Args&&... __args)
 800d3b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d3b4:	b088      	sub	sp, #32
 800d3b6:	af04      	add	r7, sp, #16
 800d3b8:	60f8      	str	r0, [r7, #12]
 800d3ba:	60b9      	str	r1, [r7, #8]
 800d3bc:	607a      	str	r2, [r7, #4]
 800d3be:	603b      	str	r3, [r7, #0]
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
 800d3c0:	68f8      	ldr	r0, [r7, #12]
 800d3c2:	f000 f931 	bl	800d628 <_ZSt7forwardIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEOT_RNSt16remove_referenceISA_E4typeE>
 800d3c6:	4606      	mov	r6, r0
 800d3c8:	68b8      	ldr	r0, [r7, #8]
 800d3ca:	f000 f8a7 	bl	800d51c <_ZSt7forwardIRPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS5_E4typeE>
 800d3ce:	4680      	mov	r8, r0
 800d3d0:	6878      	ldr	r0, [r7, #4]
 800d3d2:	f7ff f911 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d3d6:	4681      	mov	r9, r0
 800d3d8:	6838      	ldr	r0, [r7, #0]
 800d3da:	f7ff f918 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d3de:	4604      	mov	r4, r0
 800d3e0:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800d3e2:	f7ff f91f 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d3e6:	4605      	mov	r5, r0
 800d3e8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d3ea:	f7ff f926 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d3ee:	4603      	mov	r3, r0
 800d3f0:	9302      	str	r3, [sp, #8]
 800d3f2:	9501      	str	r5, [sp, #4]
 800d3f4:	9400      	str	r4, [sp, #0]
 800d3f6:	464b      	mov	r3, r9
 800d3f8:	4642      	mov	r2, r8
 800d3fa:	4631      	mov	r1, r6
 800d3fc:	4650      	mov	r0, sl
 800d3fe:	f000 f91e 	bl	800d63e <_ZSt13__invoke_implIvRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjERPS2_JS4_mS6_jEET_St21__invoke_memfun_derefOT0_OT1_DpOT2_>
					std::forward<_Args>(__args)...);
 800d402:	bf00      	nop
    }
 800d404:	3710      	adds	r7, #16
 800d406:	46bd      	mov	sp, r7
 800d408:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800d40c <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 800d40c:	b480      	push	{r7}
 800d40e:	b083      	sub	sp, #12
 800d410:	af00      	add	r7, sp, #0
 800d412:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 800d414:	4b03      	ldr	r3, [pc, #12]	; (800d424 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIPN7desenet6sensor19AbstractApplicationEEE11_M_max_sizeEv+0x18>)
      }
 800d416:	4618      	mov	r0, r3
 800d418:	370c      	adds	r7, #12
 800d41a:	46bd      	mov	sp, r7
 800d41c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d420:	4770      	bx	lr
 800d422:	bf00      	nop
 800d424:	0aaaaaaa 	.word	0x0aaaaaaa

0800d428 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 800d428:	b480      	push	{r7}
 800d42a:	b083      	sub	sp, #12
 800d42c:	af00      	add	r7, sp, #0
 800d42e:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 800d430:	4b03      	ldr	r3, [pc, #12]	; (800d440 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIN7desenet6sensor13NetworkEntity12EventElementEEE11_M_max_sizeEv+0x18>)
      }
 800d432:	4618      	mov	r0, r3
 800d434:	370c      	adds	r7, #12
 800d436:	46bd      	mov	sp, r7
 800d438:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d43c:	4770      	bx	lr
 800d43e:	bf00      	nop
 800d440:	05555555 	.word	0x05555555

0800d444 <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEEC1ERKS1_>:
      constexpr _Tuple_impl(const _Head& __head)
 800d444:	b580      	push	{r7, lr}
 800d446:	b082      	sub	sp, #8
 800d448:	af00      	add	r7, sp, #0
 800d44a:	6078      	str	r0, [r7, #4]
 800d44c:	6039      	str	r1, [r7, #0]
      : _Base(__head) { }
 800d44e:	6839      	ldr	r1, [r7, #0]
 800d450:	6878      	ldr	r0, [r7, #4]
 800d452:	f000 f936 	bl	800d6c2 <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EEC1ERKS1_>
 800d456:	687b      	ldr	r3, [r7, #4]
 800d458:	4618      	mov	r0, r3
 800d45a:	3708      	adds	r7, #8
 800d45c:	46bd      	mov	sp, r7
 800d45e:	bd80      	pop	{r7, pc}

0800d460 <_ZNSt10_Head_baseILj3ESt12_PlaceholderILi3EELb1EEC1ERKS1_>:
      constexpr _Head_base(const _Head& __h)
 800d460:	b480      	push	{r7}
 800d462:	b083      	sub	sp, #12
 800d464:	af00      	add	r7, sp, #0
 800d466:	6078      	str	r0, [r7, #4]
 800d468:	6039      	str	r1, [r7, #0]
      : _Head(__h) { }
 800d46a:	687b      	ldr	r3, [r7, #4]
 800d46c:	4618      	mov	r0, r3
 800d46e:	370c      	adds	r7, #12
 800d470:	46bd      	mov	sp, r7
 800d472:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d476:	4770      	bx	lr

0800d478 <_ZNSt11_Tuple_implILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEC1IS2_JmS5_jEvEEOT_DpOT0_>:
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 800d478:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d47a:	b085      	sub	sp, #20
 800d47c:	af00      	add	r7, sp, #0
 800d47e:	60f8      	str	r0, [r7, #12]
 800d480:	60b9      	str	r1, [r7, #8]
 800d482:	607a      	str	r2, [r7, #4]
 800d484:	603b      	str	r3, [r7, #0]
	  _Base(std::forward<_UHead>(__head)) { }
 800d486:	68fc      	ldr	r4, [r7, #12]
 800d488:	6878      	ldr	r0, [r7, #4]
 800d48a:	f7ff f8c0 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d48e:	4605      	mov	r5, r0
 800d490:	6838      	ldr	r0, [r7, #0]
 800d492:	f7ff f8c7 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d496:	4606      	mov	r6, r0
 800d498:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d49a:	f7ff f8ce 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d49e:	4603      	mov	r3, r0
 800d4a0:	4632      	mov	r2, r6
 800d4a2:	4629      	mov	r1, r5
 800d4a4:	4620      	mov	r0, r4
 800d4a6:	f000 f918 	bl	800d6da <_ZNSt11_Tuple_implILj1EJOmOPKhOjEEC1ImJS2_jEvEEOT_DpOT0_>
 800d4aa:	68fb      	ldr	r3, [r7, #12]
 800d4ac:	f103 040c 	add.w	r4, r3, #12
 800d4b0:	68b8      	ldr	r0, [r7, #8]
 800d4b2:	f7ff f8a1 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d4b6:	4603      	mov	r3, r0
 800d4b8:	4619      	mov	r1, r3
 800d4ba:	4620      	mov	r0, r4
 800d4bc:	f000 f813 	bl	800d4e6 <_ZNSt10_Head_baseILj0ERN7desenet22NetworkInterfaceDriverELb0EEC1ES2_>
 800d4c0:	68fb      	ldr	r3, [r7, #12]
 800d4c2:	4618      	mov	r0, r3
 800d4c4:	3714      	adds	r7, #20
 800d4c6:	46bd      	mov	sp, r7
 800d4c8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800d4ca <_ZNSt11_Tuple_implILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEE7_M_headERS8_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800d4ca:	b580      	push	{r7, lr}
 800d4cc:	b082      	sub	sp, #8
 800d4ce:	af00      	add	r7, sp, #0
 800d4d0:	6078      	str	r0, [r7, #4]
 800d4d2:	687b      	ldr	r3, [r7, #4]
 800d4d4:	330c      	adds	r3, #12
 800d4d6:	4618      	mov	r0, r3
 800d4d8:	f000 f924 	bl	800d724 <_ZNSt10_Head_baseILj0ERN7desenet22NetworkInterfaceDriverELb0EE7_M_headERS3_>
 800d4dc:	4603      	mov	r3, r0
 800d4de:	4618      	mov	r0, r3
 800d4e0:	3708      	adds	r7, #8
 800d4e2:	46bd      	mov	sp, r7
 800d4e4:	bd80      	pop	{r7, pc}

0800d4e6 <_ZNSt10_Head_baseILj0ERN7desenet22NetworkInterfaceDriverELb0EEC1ES2_>:
      constexpr _Head_base(const _Head& __h)
 800d4e6:	b480      	push	{r7}
 800d4e8:	b083      	sub	sp, #12
 800d4ea:	af00      	add	r7, sp, #0
 800d4ec:	6078      	str	r0, [r7, #4]
 800d4ee:	6039      	str	r1, [r7, #0]
      : _M_head_impl(__h) { }
 800d4f0:	687b      	ldr	r3, [r7, #4]
 800d4f2:	683a      	ldr	r2, [r7, #0]
 800d4f4:	601a      	str	r2, [r3, #0]
 800d4f6:	687b      	ldr	r3, [r7, #4]
 800d4f8:	4618      	mov	r0, r3
 800d4fa:	370c      	adds	r7, #12
 800d4fc:	46bd      	mov	sp, r7
 800d4fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d502:	4770      	bx	lr

0800d504 <_ZSt12__get_helperILj0EPN7desenet6sensor13NetworkEntityEJSt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS9_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d504:	b580      	push	{r7, lr}
 800d506:	b082      	sub	sp, #8
 800d508:	af00      	add	r7, sp, #0
 800d50a:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d50c:	6878      	ldr	r0, [r7, #4]
 800d50e:	f7fe fd7b 	bl	800c008 <_ZNSt11_Tuple_implILj0EJPN7desenet6sensor13NetworkEntityESt12_PlaceholderILi1EES4_ILi2EES4_ILi3EES4_ILi4EEEE7_M_headERS9_>
 800d512:	4603      	mov	r3, r0
 800d514:	4618      	mov	r0, r3
 800d516:	3708      	adds	r7, #8
 800d518:	46bd      	mov	sp, r7
 800d51a:	bd80      	pop	{r7, pc}

0800d51c <_ZSt7forwardIRPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS5_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d51c:	b480      	push	{r7}
 800d51e:	b083      	sub	sp, #12
 800d520:	af00      	add	r7, sp, #0
 800d522:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d524:	687b      	ldr	r3, [r7, #4]
 800d526:	4618      	mov	r0, r3
 800d528:	370c      	adds	r7, #12
 800d52a:	46bd      	mov	sp, r7
 800d52c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d530:	4770      	bx	lr

0800d532 <_ZSt12__get_helperILj1ESt12_PlaceholderILi1EEJS0_ILi2EES0_ILi3EES0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d532:	b580      	push	{r7, lr}
 800d534:	b082      	sub	sp, #8
 800d536:	af00      	add	r7, sp, #0
 800d538:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d53a:	6878      	ldr	r0, [r7, #4]
 800d53c:	f7fe ffed 	bl	800c51a <_ZNSt11_Tuple_implILj1EJSt12_PlaceholderILi1EES0_ILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS5_>
 800d540:	4603      	mov	r3, r0
 800d542:	4618      	mov	r0, r3
 800d544:	3708      	adds	r7, #8
 800d546:	46bd      	mov	sp, r7
 800d548:	bd80      	pop	{r7, pc}

0800d54a <_ZSt4moveIRSt5tupleIJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEEONSt16remove_referenceIT_E4typeEOSC_>:
    move(_Tp&& __t) noexcept
 800d54a:	b480      	push	{r7}
 800d54c:	b083      	sub	sp, #12
 800d54e:	af00      	add	r7, sp, #0
 800d550:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 800d552:	687b      	ldr	r3, [r7, #4]
 800d554:	4618      	mov	r0, r3
 800d556:	370c      	adds	r7, #12
 800d558:	46bd      	mov	sp, r7
 800d55a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d55e:	4770      	bx	lr

0800d560 <_ZSt3getILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>:
    get(tuple<_Elements...>&& __t) noexcept
 800d560:	b580      	push	{r7, lr}
 800d562:	b082      	sub	sp, #8
 800d564:	af00      	add	r7, sp, #0
 800d566:	6078      	str	r0, [r7, #4]
      return std::forward<__element_type&&>(std::get<__i>(__t));
 800d568:	6878      	ldr	r0, [r7, #4]
 800d56a:	f000 f910 	bl	800d78e <_ZSt3getILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>
 800d56e:	4603      	mov	r3, r0
 800d570:	4618      	mov	r0, r3
 800d572:	f7ff f841 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d576:	4603      	mov	r3, r0
    }
 800d578:	4618      	mov	r0, r3
 800d57a:	3708      	adds	r7, #8
 800d57c:	46bd      	mov	sp, r7
 800d57e:	bd80      	pop	{r7, pc}

0800d580 <_ZSt12__get_helperILj2ESt12_PlaceholderILi2EEJS0_ILi3EES0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS4_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d580:	b580      	push	{r7, lr}
 800d582:	b082      	sub	sp, #8
 800d584:	af00      	add	r7, sp, #0
 800d586:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d588:	6878      	ldr	r0, [r7, #4]
 800d58a:	f7ff fa4d 	bl	800ca28 <_ZNSt11_Tuple_implILj2EJSt12_PlaceholderILi2EES0_ILi3EES0_ILi4EEEE7_M_headERS4_>
 800d58e:	4603      	mov	r3, r0
 800d590:	4618      	mov	r0, r3
 800d592:	3708      	adds	r7, #8
 800d594:	46bd      	mov	sp, r7
 800d596:	bd80      	pop	{r7, pc}

0800d598 <_ZSt3getILj1EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>:
    get(tuple<_Elements...>&& __t) noexcept
 800d598:	b580      	push	{r7, lr}
 800d59a:	b082      	sub	sp, #8
 800d59c:	af00      	add	r7, sp, #0
 800d59e:	6078      	str	r0, [r7, #4]
      return std::forward<__element_type&&>(std::get<__i>(__t));
 800d5a0:	6878      	ldr	r0, [r7, #4]
 800d5a2:	f000 f901 	bl	800d7a8 <_ZSt3getILj1EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>
 800d5a6:	4603      	mov	r3, r0
 800d5a8:	4618      	mov	r0, r3
 800d5aa:	f000 f8d5 	bl	800d758 <_ZSt7forwardIOmEOT_RNSt16remove_referenceIS1_E4typeE>
 800d5ae:	4603      	mov	r3, r0
    }
 800d5b0:	4618      	mov	r0, r3
 800d5b2:	3708      	adds	r7, #8
 800d5b4:	46bd      	mov	sp, r7
 800d5b6:	bd80      	pop	{r7, pc}

0800d5b8 <_ZSt12__get_helperILj3ESt12_PlaceholderILi3EEJS0_ILi4EEEERT0_RSt11_Tuple_implIXT_EJS3_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d5b8:	b580      	push	{r7, lr}
 800d5ba:	b082      	sub	sp, #8
 800d5bc:	af00      	add	r7, sp, #0
 800d5be:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d5c0:	6878      	ldr	r0, [r7, #4]
 800d5c2:	f7ff fc1e 	bl	800ce02 <_ZNSt11_Tuple_implILj3EJSt12_PlaceholderILi3EES0_ILi4EEEE7_M_headERS3_>
 800d5c6:	4603      	mov	r3, r0
 800d5c8:	4618      	mov	r0, r3
 800d5ca:	3708      	adds	r7, #8
 800d5cc:	46bd      	mov	sp, r7
 800d5ce:	bd80      	pop	{r7, pc}

0800d5d0 <_ZSt3getILj2EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>:
    get(tuple<_Elements...>&& __t) noexcept
 800d5d0:	b580      	push	{r7, lr}
 800d5d2:	b082      	sub	sp, #8
 800d5d4:	af00      	add	r7, sp, #0
 800d5d6:	6078      	str	r0, [r7, #4]
      return std::forward<__element_type&&>(std::get<__i>(__t));
 800d5d8:	6878      	ldr	r0, [r7, #4]
 800d5da:	f000 f8f2 	bl	800d7c2 <_ZSt3getILj2EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>
 800d5de:	4603      	mov	r3, r0
 800d5e0:	4618      	mov	r0, r3
 800d5e2:	f000 f8fb 	bl	800d7dc <_ZSt7forwardIOPKhEOT_RNSt16remove_referenceIS3_E4typeE>
 800d5e6:	4603      	mov	r3, r0
    }
 800d5e8:	4618      	mov	r0, r3
 800d5ea:	3708      	adds	r7, #8
 800d5ec:	46bd      	mov	sp, r7
 800d5ee:	bd80      	pop	{r7, pc}

0800d5f0 <_ZSt12__get_helperILj4ESt12_PlaceholderILi4EEJEERT0_RSt11_Tuple_implIXT_EJS2_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d5f0:	b580      	push	{r7, lr}
 800d5f2:	b082      	sub	sp, #8
 800d5f4:	af00      	add	r7, sp, #0
 800d5f6:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d5f8:	6878      	ldr	r0, [r7, #4]
 800d5fa:	f7ff fd18 	bl	800d02e <_ZNSt11_Tuple_implILj4EJSt12_PlaceholderILi4EEEE7_M_headERS2_>
 800d5fe:	4603      	mov	r3, r0
 800d600:	4618      	mov	r0, r3
 800d602:	3708      	adds	r7, #8
 800d604:	46bd      	mov	sp, r7
 800d606:	bd80      	pop	{r7, pc}

0800d608 <_ZSt3getILj3EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeEOSC_>:
    get(tuple<_Elements...>&& __t) noexcept
 800d608:	b580      	push	{r7, lr}
 800d60a:	b082      	sub	sp, #8
 800d60c:	af00      	add	r7, sp, #0
 800d60e:	6078      	str	r0, [r7, #4]
      return std::forward<__element_type&&>(std::get<__i>(__t));
 800d610:	6878      	ldr	r0, [r7, #4]
 800d612:	f000 f8ee 	bl	800d7f2 <_ZSt3getILj3EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>
 800d616:	4603      	mov	r3, r0
 800d618:	4618      	mov	r0, r3
 800d61a:	f000 f8f7 	bl	800d80c <_ZSt7forwardIOjEOT_RNSt16remove_referenceIS1_E4typeE>
 800d61e:	4603      	mov	r3, r0
    }
 800d620:	4618      	mov	r0, r3
 800d622:	3708      	adds	r7, #8
 800d624:	46bd      	mov	sp, r7
 800d626:	bd80      	pop	{r7, pc}

0800d628 <_ZSt7forwardIRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjEEOT_RNSt16remove_referenceISA_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d628:	b480      	push	{r7}
 800d62a:	b083      	sub	sp, #12
 800d62c:	af00      	add	r7, sp, #0
 800d62e:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d630:	687b      	ldr	r3, [r7, #4]
 800d632:	4618      	mov	r0, r3
 800d634:	370c      	adds	r7, #12
 800d636:	46bd      	mov	sp, r7
 800d638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d63c:	4770      	bx	lr

0800d63e <_ZSt13__invoke_implIvRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjERPS2_JS4_mS6_jEET_St21__invoke_memfun_derefOT0_OT1_DpOT2_>:
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
 800d63e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d642:	b088      	sub	sp, #32
 800d644:	af02      	add	r7, sp, #8
 800d646:	7538      	strb	r0, [r7, #20]
 800d648:	6139      	str	r1, [r7, #16]
 800d64a:	60fa      	str	r2, [r7, #12]
 800d64c:	60bb      	str	r3, [r7, #8]
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
 800d64e:	68f8      	ldr	r0, [r7, #12]
 800d650:	f7ff ff64 	bl	800d51c <_ZSt7forwardIRPN7desenet6sensor13NetworkEntityEEOT_RNSt16remove_referenceIS5_E4typeE>
 800d654:	4603      	mov	r3, r0
 800d656:	681b      	ldr	r3, [r3, #0]
 800d658:	693a      	ldr	r2, [r7, #16]
 800d65a:	6852      	ldr	r2, [r2, #4]
 800d65c:	1052      	asrs	r2, r2, #1
 800d65e:	189d      	adds	r5, r3, r2
 800d660:	693a      	ldr	r2, [r7, #16]
 800d662:	6852      	ldr	r2, [r2, #4]
 800d664:	f002 0201 	and.w	r2, r2, #1
 800d668:	2a00      	cmp	r2, #0
 800d66a:	d102      	bne.n	800d672 <_ZSt13__invoke_implIvRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjERPS2_JS4_mS6_jEET_St21__invoke_memfun_derefOT0_OT1_DpOT2_+0x34>
 800d66c:	693b      	ldr	r3, [r7, #16]
 800d66e:	681c      	ldr	r4, [r3, #0]
 800d670:	e008      	b.n	800d684 <_ZSt13__invoke_implIvRMN7desenet6sensor13NetworkEntityEFvRNS0_22NetworkInterfaceDriverEmPKhjERPS2_JS4_mS6_jEET_St21__invoke_memfun_derefOT0_OT1_DpOT2_+0x46>
 800d672:	693a      	ldr	r2, [r7, #16]
 800d674:	6852      	ldr	r2, [r2, #4]
 800d676:	1052      	asrs	r2, r2, #1
 800d678:	4413      	add	r3, r2
 800d67a:	681b      	ldr	r3, [r3, #0]
 800d67c:	693a      	ldr	r2, [r7, #16]
 800d67e:	6812      	ldr	r2, [r2, #0]
 800d680:	4413      	add	r3, r2
 800d682:	681c      	ldr	r4, [r3, #0]
 800d684:	68b8      	ldr	r0, [r7, #8]
 800d686:	f7fe ffb7 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 800d68a:	4680      	mov	r8, r0
 800d68c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800d68e:	f7fe ffbe 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d692:	4603      	mov	r3, r0
 800d694:	681e      	ldr	r6, [r3, #0]
 800d696:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d698:	f7fe ffc4 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d69c:	4603      	mov	r3, r0
 800d69e:	681b      	ldr	r3, [r3, #0]
 800d6a0:	607b      	str	r3, [r7, #4]
 800d6a2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800d6a4:	f7fe ffc9 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d6a8:	4603      	mov	r3, r0
 800d6aa:	681b      	ldr	r3, [r3, #0]
 800d6ac:	9300      	str	r3, [sp, #0]
 800d6ae:	687b      	ldr	r3, [r7, #4]
 800d6b0:	4632      	mov	r2, r6
 800d6b2:	4641      	mov	r1, r8
 800d6b4:	4628      	mov	r0, r5
 800d6b6:	47a0      	blx	r4
 800d6b8:	bf00      	nop
    }
 800d6ba:	3718      	adds	r7, #24
 800d6bc:	46bd      	mov	sp, r7
 800d6be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d6c2 <_ZNSt10_Head_baseILj4ESt12_PlaceholderILi4EELb1EEC1ERKS1_>:
      constexpr _Head_base(const _Head& __h)
 800d6c2:	b480      	push	{r7}
 800d6c4:	b083      	sub	sp, #12
 800d6c6:	af00      	add	r7, sp, #0
 800d6c8:	6078      	str	r0, [r7, #4]
 800d6ca:	6039      	str	r1, [r7, #0]
      : _Head(__h) { }
 800d6cc:	687b      	ldr	r3, [r7, #4]
 800d6ce:	4618      	mov	r0, r3
 800d6d0:	370c      	adds	r7, #12
 800d6d2:	46bd      	mov	sp, r7
 800d6d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6d8:	4770      	bx	lr

0800d6da <_ZNSt11_Tuple_implILj1EJOmOPKhOjEEC1ImJS2_jEvEEOT_DpOT0_>:
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 800d6da:	b5b0      	push	{r4, r5, r7, lr}
 800d6dc:	b084      	sub	sp, #16
 800d6de:	af00      	add	r7, sp, #0
 800d6e0:	60f8      	str	r0, [r7, #12]
 800d6e2:	60b9      	str	r1, [r7, #8]
 800d6e4:	607a      	str	r2, [r7, #4]
 800d6e6:	603b      	str	r3, [r7, #0]
	  _Base(std::forward<_UHead>(__head)) { }
 800d6e8:	68fc      	ldr	r4, [r7, #12]
 800d6ea:	6878      	ldr	r0, [r7, #4]
 800d6ec:	f7fe ff9a 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d6f0:	4605      	mov	r5, r0
 800d6f2:	6838      	ldr	r0, [r7, #0]
 800d6f4:	f7fe ffa1 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d6f8:	4603      	mov	r3, r0
 800d6fa:	461a      	mov	r2, r3
 800d6fc:	4629      	mov	r1, r5
 800d6fe:	4620      	mov	r0, r4
 800d700:	f000 f88f 	bl	800d822 <_ZNSt11_Tuple_implILj2EJOPKhOjEEC1IS1_JjEvEEOT_DpOT0_>
 800d704:	68fb      	ldr	r3, [r7, #12]
 800d706:	f103 0408 	add.w	r4, r3, #8
 800d70a:	68b8      	ldr	r0, [r7, #8]
 800d70c:	f7fe ff7f 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d710:	4603      	mov	r3, r0
 800d712:	4619      	mov	r1, r3
 800d714:	4620      	mov	r0, r4
 800d716:	f000 f82a 	bl	800d76e <_ZNSt10_Head_baseILj1EOmLb0EEC1ImEEOT_>
 800d71a:	68fb      	ldr	r3, [r7, #12]
 800d71c:	4618      	mov	r0, r3
 800d71e:	3710      	adds	r7, #16
 800d720:	46bd      	mov	sp, r7
 800d722:	bdb0      	pop	{r4, r5, r7, pc}

0800d724 <_ZNSt10_Head_baseILj0ERN7desenet22NetworkInterfaceDriverELb0EE7_M_headERS3_>:
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 800d724:	b480      	push	{r7}
 800d726:	b083      	sub	sp, #12
 800d728:	af00      	add	r7, sp, #0
 800d72a:	6078      	str	r0, [r7, #4]
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	681b      	ldr	r3, [r3, #0]
 800d730:	4618      	mov	r0, r3
 800d732:	370c      	adds	r7, #12
 800d734:	46bd      	mov	sp, r7
 800d736:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d73a:	4770      	bx	lr

0800d73c <_ZNSt11_Tuple_implILj1EJOmOPKhOjEE7_M_headERS5_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800d73c:	b580      	push	{r7, lr}
 800d73e:	b082      	sub	sp, #8
 800d740:	af00      	add	r7, sp, #0
 800d742:	6078      	str	r0, [r7, #4]
 800d744:	687b      	ldr	r3, [r7, #4]
 800d746:	3308      	adds	r3, #8
 800d748:	4618      	mov	r0, r3
 800d74a:	f000 f888 	bl	800d85e <_ZNSt10_Head_baseILj1EOmLb0EE7_M_headERS1_>
 800d74e:	4603      	mov	r3, r0
 800d750:	4618      	mov	r0, r3
 800d752:	3708      	adds	r7, #8
 800d754:	46bd      	mov	sp, r7
 800d756:	bd80      	pop	{r7, pc}

0800d758 <_ZSt7forwardIOmEOT_RNSt16remove_referenceIS1_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d758:	b480      	push	{r7}
 800d75a:	b083      	sub	sp, #12
 800d75c:	af00      	add	r7, sp, #0
 800d75e:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d760:	687b      	ldr	r3, [r7, #4]
 800d762:	4618      	mov	r0, r3
 800d764:	370c      	adds	r7, #12
 800d766:	46bd      	mov	sp, r7
 800d768:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d76c:	4770      	bx	lr

0800d76e <_ZNSt10_Head_baseILj1EOmLb0EEC1ImEEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800d76e:	b580      	push	{r7, lr}
 800d770:	b082      	sub	sp, #8
 800d772:	af00      	add	r7, sp, #0
 800d774:	6078      	str	r0, [r7, #4]
 800d776:	6039      	str	r1, [r7, #0]
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 800d778:	6838      	ldr	r0, [r7, #0]
 800d77a:	f7fe ff48 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 800d77e:	4602      	mov	r2, r0
 800d780:	687b      	ldr	r3, [r7, #4]
 800d782:	601a      	str	r2, [r3, #0]
 800d784:	687b      	ldr	r3, [r7, #4]
 800d786:	4618      	mov	r0, r3
 800d788:	3708      	adds	r7, #8
 800d78a:	46bd      	mov	sp, r7
 800d78c:	bd80      	pop	{r7, pc}

0800d78e <_ZSt3getILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>:
    get(tuple<_Elements...>& __t) noexcept
 800d78e:	b580      	push	{r7, lr}
 800d790:	b082      	sub	sp, #8
 800d792:	af00      	add	r7, sp, #0
 800d794:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d796:	687b      	ldr	r3, [r7, #4]
 800d798:	4618      	mov	r0, r3
 800d79a:	f000 f88a 	bl	800d8b2 <_ZSt12__get_helperILj0ERN7desenet22NetworkInterfaceDriverEJOmOPKhOjEERT0_RSt11_Tuple_implIXT_EJS8_DpT1_EE>
 800d79e:	4603      	mov	r3, r0
 800d7a0:	4618      	mov	r0, r3
 800d7a2:	3708      	adds	r7, #8
 800d7a4:	46bd      	mov	sp, r7
 800d7a6:	bd80      	pop	{r7, pc}

0800d7a8 <_ZSt3getILj1EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>:
    get(tuple<_Elements...>& __t) noexcept
 800d7a8:	b580      	push	{r7, lr}
 800d7aa:	b082      	sub	sp, #8
 800d7ac:	af00      	add	r7, sp, #0
 800d7ae:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d7b0:	687b      	ldr	r3, [r7, #4]
 800d7b2:	4618      	mov	r0, r3
 800d7b4:	f000 f889 	bl	800d8ca <_ZSt12__get_helperILj1EOmJOPKhOjEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE>
 800d7b8:	4603      	mov	r3, r0
 800d7ba:	4618      	mov	r0, r3
 800d7bc:	3708      	adds	r7, #8
 800d7be:	46bd      	mov	sp, r7
 800d7c0:	bd80      	pop	{r7, pc}

0800d7c2 <_ZSt3getILj2EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>:
    get(tuple<_Elements...>& __t) noexcept
 800d7c2:	b580      	push	{r7, lr}
 800d7c4:	b082      	sub	sp, #8
 800d7c6:	af00      	add	r7, sp, #0
 800d7c8:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d7ca:	687b      	ldr	r3, [r7, #4]
 800d7cc:	4618      	mov	r0, r3
 800d7ce:	f000 f888 	bl	800d8e2 <_ZSt12__get_helperILj2EOPKhJOjEERT0_RSt11_Tuple_implIXT_EJS4_DpT1_EE>
 800d7d2:	4603      	mov	r3, r0
 800d7d4:	4618      	mov	r0, r3
 800d7d6:	3708      	adds	r7, #8
 800d7d8:	46bd      	mov	sp, r7
 800d7da:	bd80      	pop	{r7, pc}

0800d7dc <_ZSt7forwardIOPKhEOT_RNSt16remove_referenceIS3_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d7dc:	b480      	push	{r7}
 800d7de:	b083      	sub	sp, #12
 800d7e0:	af00      	add	r7, sp, #0
 800d7e2:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d7e4:	687b      	ldr	r3, [r7, #4]
 800d7e6:	4618      	mov	r0, r3
 800d7e8:	370c      	adds	r7, #12
 800d7ea:	46bd      	mov	sp, r7
 800d7ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7f0:	4770      	bx	lr

0800d7f2 <_ZSt3getILj3EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSC_>:
    get(tuple<_Elements...>& __t) noexcept
 800d7f2:	b580      	push	{r7, lr}
 800d7f4:	b082      	sub	sp, #8
 800d7f6:	af00      	add	r7, sp, #0
 800d7f8:	6078      	str	r0, [r7, #4]
    { return std::__get_helper<__i>(__t); }
 800d7fa:	687b      	ldr	r3, [r7, #4]
 800d7fc:	4618      	mov	r0, r3
 800d7fe:	f000 f87c 	bl	800d8fa <_ZSt12__get_helperILj3EOjJEERT0_RSt11_Tuple_implIXT_EJS1_DpT1_EE>
 800d802:	4603      	mov	r3, r0
 800d804:	4618      	mov	r0, r3
 800d806:	3708      	adds	r7, #8
 800d808:	46bd      	mov	sp, r7
 800d80a:	bd80      	pop	{r7, pc}

0800d80c <_ZSt7forwardIOjEOT_RNSt16remove_referenceIS1_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 800d80c:	b480      	push	{r7}
 800d80e:	b083      	sub	sp, #12
 800d810:	af00      	add	r7, sp, #0
 800d812:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 800d814:	687b      	ldr	r3, [r7, #4]
 800d816:	4618      	mov	r0, r3
 800d818:	370c      	adds	r7, #12
 800d81a:	46bd      	mov	sp, r7
 800d81c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d820:	4770      	bx	lr

0800d822 <_ZNSt11_Tuple_implILj2EJOPKhOjEEC1IS1_JjEvEEOT_DpOT0_>:
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 800d822:	b590      	push	{r4, r7, lr}
 800d824:	b085      	sub	sp, #20
 800d826:	af00      	add	r7, sp, #0
 800d828:	60f8      	str	r0, [r7, #12]
 800d82a:	60b9      	str	r1, [r7, #8]
 800d82c:	607a      	str	r2, [r7, #4]
	  _Base(std::forward<_UHead>(__head)) { }
 800d82e:	68fc      	ldr	r4, [r7, #12]
 800d830:	6878      	ldr	r0, [r7, #4]
 800d832:	f7fe ff02 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d836:	4603      	mov	r3, r0
 800d838:	4619      	mov	r1, r3
 800d83a:	4620      	mov	r0, r4
 800d83c:	f000 f869 	bl	800d912 <_ZNSt11_Tuple_implILj3EJOjEEC1IjEEOT_>
 800d840:	68fb      	ldr	r3, [r7, #12]
 800d842:	1d1c      	adds	r4, r3, #4
 800d844:	68b8      	ldr	r0, [r7, #8]
 800d846:	f7fe feed 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d84a:	4603      	mov	r3, r0
 800d84c:	4619      	mov	r1, r3
 800d84e:	4620      	mov	r0, r4
 800d850:	f000 f81f 	bl	800d892 <_ZNSt10_Head_baseILj2EOPKhLb0EEC1IS1_EEOT_>
 800d854:	68fb      	ldr	r3, [r7, #12]
 800d856:	4618      	mov	r0, r3
 800d858:	3714      	adds	r7, #20
 800d85a:	46bd      	mov	sp, r7
 800d85c:	bd90      	pop	{r4, r7, pc}

0800d85e <_ZNSt10_Head_baseILj1EOmLb0EE7_M_headERS1_>:
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 800d85e:	b480      	push	{r7}
 800d860:	b083      	sub	sp, #12
 800d862:	af00      	add	r7, sp, #0
 800d864:	6078      	str	r0, [r7, #4]
 800d866:	687b      	ldr	r3, [r7, #4]
 800d868:	681b      	ldr	r3, [r3, #0]
 800d86a:	4618      	mov	r0, r3
 800d86c:	370c      	adds	r7, #12
 800d86e:	46bd      	mov	sp, r7
 800d870:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d874:	4770      	bx	lr

0800d876 <_ZNSt11_Tuple_implILj2EJOPKhOjEE7_M_headERS4_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800d876:	b580      	push	{r7, lr}
 800d878:	b082      	sub	sp, #8
 800d87a:	af00      	add	r7, sp, #0
 800d87c:	6078      	str	r0, [r7, #4]
 800d87e:	687b      	ldr	r3, [r7, #4]
 800d880:	3304      	adds	r3, #4
 800d882:	4618      	mov	r0, r3
 800d884:	f000 f858 	bl	800d938 <_ZNSt10_Head_baseILj2EOPKhLb0EE7_M_headERS3_>
 800d888:	4603      	mov	r3, r0
 800d88a:	4618      	mov	r0, r3
 800d88c:	3708      	adds	r7, #8
 800d88e:	46bd      	mov	sp, r7
 800d890:	bd80      	pop	{r7, pc}

0800d892 <_ZNSt10_Head_baseILj2EOPKhLb0EEC1IS1_EEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800d892:	b580      	push	{r7, lr}
 800d894:	b082      	sub	sp, #8
 800d896:	af00      	add	r7, sp, #0
 800d898:	6078      	str	r0, [r7, #4]
 800d89a:	6039      	str	r1, [r7, #0]
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 800d89c:	6838      	ldr	r0, [r7, #0]
 800d89e:	f7fe fec1 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 800d8a2:	4602      	mov	r2, r0
 800d8a4:	687b      	ldr	r3, [r7, #4]
 800d8a6:	601a      	str	r2, [r3, #0]
 800d8a8:	687b      	ldr	r3, [r7, #4]
 800d8aa:	4618      	mov	r0, r3
 800d8ac:	3708      	adds	r7, #8
 800d8ae:	46bd      	mov	sp, r7
 800d8b0:	bd80      	pop	{r7, pc}

0800d8b2 <_ZSt12__get_helperILj0ERN7desenet22NetworkInterfaceDriverEJOmOPKhOjEERT0_RSt11_Tuple_implIXT_EJS8_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d8b2:	b580      	push	{r7, lr}
 800d8b4:	b082      	sub	sp, #8
 800d8b6:	af00      	add	r7, sp, #0
 800d8b8:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d8ba:	6878      	ldr	r0, [r7, #4]
 800d8bc:	f7ff fe05 	bl	800d4ca <_ZNSt11_Tuple_implILj0EJRN7desenet22NetworkInterfaceDriverEOmOPKhOjEE7_M_headERS8_>
 800d8c0:	4603      	mov	r3, r0
 800d8c2:	4618      	mov	r0, r3
 800d8c4:	3708      	adds	r7, #8
 800d8c6:	46bd      	mov	sp, r7
 800d8c8:	bd80      	pop	{r7, pc}

0800d8ca <_ZSt12__get_helperILj1EOmJOPKhOjEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d8ca:	b580      	push	{r7, lr}
 800d8cc:	b082      	sub	sp, #8
 800d8ce:	af00      	add	r7, sp, #0
 800d8d0:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d8d2:	6878      	ldr	r0, [r7, #4]
 800d8d4:	f7ff ff32 	bl	800d73c <_ZNSt11_Tuple_implILj1EJOmOPKhOjEE7_M_headERS5_>
 800d8d8:	4603      	mov	r3, r0
 800d8da:	4618      	mov	r0, r3
 800d8dc:	3708      	adds	r7, #8
 800d8de:	46bd      	mov	sp, r7
 800d8e0:	bd80      	pop	{r7, pc}

0800d8e2 <_ZSt12__get_helperILj2EOPKhJOjEERT0_RSt11_Tuple_implIXT_EJS4_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d8e2:	b580      	push	{r7, lr}
 800d8e4:	b082      	sub	sp, #8
 800d8e6:	af00      	add	r7, sp, #0
 800d8e8:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d8ea:	6878      	ldr	r0, [r7, #4]
 800d8ec:	f7ff ffc3 	bl	800d876 <_ZNSt11_Tuple_implILj2EJOPKhOjEE7_M_headERS4_>
 800d8f0:	4603      	mov	r3, r0
 800d8f2:	4618      	mov	r0, r3
 800d8f4:	3708      	adds	r7, #8
 800d8f6:	46bd      	mov	sp, r7
 800d8f8:	bd80      	pop	{r7, pc}

0800d8fa <_ZSt12__get_helperILj3EOjJEERT0_RSt11_Tuple_implIXT_EJS1_DpT1_EE>:
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 800d8fa:	b580      	push	{r7, lr}
 800d8fc:	b082      	sub	sp, #8
 800d8fe:	af00      	add	r7, sp, #0
 800d900:	6078      	str	r0, [r7, #4]
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 800d902:	6878      	ldr	r0, [r7, #4]
 800d904:	f000 f824 	bl	800d950 <_ZNSt11_Tuple_implILj3EJOjEE7_M_headERS1_>
 800d908:	4603      	mov	r3, r0
 800d90a:	4618      	mov	r0, r3
 800d90c:	3708      	adds	r7, #8
 800d90e:	46bd      	mov	sp, r7
 800d910:	bd80      	pop	{r7, pc}

0800d912 <_ZNSt11_Tuple_implILj3EJOjEEC1IjEEOT_>:
        constexpr _Tuple_impl(_UHead&& __head)
 800d912:	b590      	push	{r4, r7, lr}
 800d914:	b083      	sub	sp, #12
 800d916:	af00      	add	r7, sp, #0
 800d918:	6078      	str	r0, [r7, #4]
 800d91a:	6039      	str	r1, [r7, #0]
	: _Base(std::forward<_UHead>(__head)) { }
 800d91c:	687c      	ldr	r4, [r7, #4]
 800d91e:	6838      	ldr	r0, [r7, #0]
 800d920:	f7fe fe8b 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d924:	4603      	mov	r3, r0
 800d926:	4619      	mov	r1, r3
 800d928:	4620      	mov	r0, r4
 800d92a:	f000 f81e 	bl	800d96a <_ZNSt10_Head_baseILj3EOjLb0EEC1IjEEOT_>
 800d92e:	687b      	ldr	r3, [r7, #4]
 800d930:	4618      	mov	r0, r3
 800d932:	370c      	adds	r7, #12
 800d934:	46bd      	mov	sp, r7
 800d936:	bd90      	pop	{r4, r7, pc}

0800d938 <_ZNSt10_Head_baseILj2EOPKhLb0EE7_M_headERS3_>:
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 800d938:	b480      	push	{r7}
 800d93a:	b083      	sub	sp, #12
 800d93c:	af00      	add	r7, sp, #0
 800d93e:	6078      	str	r0, [r7, #4]
 800d940:	687b      	ldr	r3, [r7, #4]
 800d942:	681b      	ldr	r3, [r3, #0]
 800d944:	4618      	mov	r0, r3
 800d946:	370c      	adds	r7, #12
 800d948:	46bd      	mov	sp, r7
 800d94a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d94e:	4770      	bx	lr

0800d950 <_ZNSt11_Tuple_implILj3EJOjEE7_M_headERS1_>:
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 800d950:	b580      	push	{r7, lr}
 800d952:	b082      	sub	sp, #8
 800d954:	af00      	add	r7, sp, #0
 800d956:	6078      	str	r0, [r7, #4]
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	4618      	mov	r0, r3
 800d95c:	f000 f815 	bl	800d98a <_ZNSt10_Head_baseILj3EOjLb0EE7_M_headERS1_>
 800d960:	4603      	mov	r3, r0
 800d962:	4618      	mov	r0, r3
 800d964:	3708      	adds	r7, #8
 800d966:	46bd      	mov	sp, r7
 800d968:	bd80      	pop	{r7, pc}

0800d96a <_ZNSt10_Head_baseILj3EOjLb0EEC1IjEEOT_>:
        constexpr _Head_base(_UHead&& __h)
 800d96a:	b580      	push	{r7, lr}
 800d96c:	b082      	sub	sp, #8
 800d96e:	af00      	add	r7, sp, #0
 800d970:	6078      	str	r0, [r7, #4]
 800d972:	6039      	str	r1, [r7, #0]
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 800d974:	6838      	ldr	r0, [r7, #0]
 800d976:	f7fe fe60 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 800d97a:	4602      	mov	r2, r0
 800d97c:	687b      	ldr	r3, [r7, #4]
 800d97e:	601a      	str	r2, [r3, #0]
 800d980:	687b      	ldr	r3, [r7, #4]
 800d982:	4618      	mov	r0, r3
 800d984:	3708      	adds	r7, #8
 800d986:	46bd      	mov	sp, r7
 800d988:	bd80      	pop	{r7, pc}

0800d98a <_ZNSt10_Head_baseILj3EOjLb0EE7_M_headERS1_>:
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 800d98a:	b480      	push	{r7}
 800d98c:	b083      	sub	sp, #12
 800d98e:	af00      	add	r7, sp, #0
 800d990:	6078      	str	r0, [r7, #4]
 800d992:	687b      	ldr	r3, [r7, #4]
 800d994:	681b      	ldr	r3, [r3, #0]
 800d996:	4618      	mov	r0, r3
 800d998:	370c      	adds	r7, #12
 800d99a:	46bd      	mov	sp, r7
 800d99c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9a0:	4770      	bx	lr
	...

0800d9a4 <_Z41__static_initialization_and_destruction_0ii>:
 800d9a4:	b580      	push	{r7, lr}
 800d9a6:	b088      	sub	sp, #32
 800d9a8:	af00      	add	r7, sp, #0
 800d9aa:	6078      	str	r0, [r7, #4]
 800d9ac:	6039      	str	r1, [r7, #0]
 800d9ae:	687b      	ldr	r3, [r7, #4]
 800d9b0:	2b01      	cmp	r3, #1
 800d9b2:	d122      	bne.n	800d9fa <_Z41__static_initialization_and_destruction_0ii+0x56>
 800d9b4:	683b      	ldr	r3, [r7, #0]
 800d9b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d9ba:	4293      	cmp	r3, r2
 800d9bc:	d11d      	bne.n	800d9fa <_Z41__static_initialization_and_destruction_0ii+0x56>
 800d9be:	4b18      	ldr	r3, [pc, #96]	; (800da20 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800d9c0:	681b      	ldr	r3, [r3, #0]
 800d9c2:	613b      	str	r3, [r7, #16]
 800d9c4:	f107 0310 	add.w	r3, r7, #16
 800d9c8:	60bb      	str	r3, [r7, #8]
 800d9ca:	2304      	movs	r3, #4
 800d9cc:	60fb      	str	r3, [r7, #12]
 800d9ce:	f107 0308 	add.w	r3, r7, #8
 800d9d2:	e893 0006 	ldmia.w	r3, {r1, r2}
 800d9d6:	4813      	ldr	r0, [pc, #76]	; (800da24 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800d9d8:	f7f9 f9ac 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800d9dc:	4b12      	ldr	r3, [pc, #72]	; (800da28 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800d9de:	681b      	ldr	r3, [r3, #0]
 800d9e0:	61fb      	str	r3, [r7, #28]
 800d9e2:	f107 031c 	add.w	r3, r7, #28
 800d9e6:	617b      	str	r3, [r7, #20]
 800d9e8:	2304      	movs	r3, #4
 800d9ea:	61bb      	str	r3, [r7, #24]
 800d9ec:	f107 0314 	add.w	r3, r7, #20
 800d9f0:	e893 0006 	ldmia.w	r3, {r1, r2}
 800d9f4:	480d      	ldr	r0, [pc, #52]	; (800da2c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800d9f6:	f7f9 f99d 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800d9fa:	687b      	ldr	r3, [r7, #4]
 800d9fc:	2b00      	cmp	r3, #0
 800d9fe:	d10a      	bne.n	800da16 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800da00:	683b      	ldr	r3, [r7, #0]
 800da02:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800da06:	4293      	cmp	r3, r2
 800da08:	d105      	bne.n	800da16 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800da0a:	4808      	ldr	r0, [pc, #32]	; (800da2c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800da0c:	f7f9 fadc 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800da10:	4804      	ldr	r0, [pc, #16]	; (800da24 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800da12:	f7f9 fad9 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800da16:	bf00      	nop
 800da18:	3720      	adds	r7, #32
 800da1a:	46bd      	mov	sp, r7
 800da1c:	bd80      	pop	{r7, pc}
 800da1e:	bf00      	nop
 800da20:	08018cb0 	.word	0x08018cb0
 800da24:	20001924 	.word	0x20001924
 800da28:	08018cb4 	.word	0x08018cb4
 800da2c:	2000192c 	.word	0x2000192c

0800da30 <_GLOBAL__sub_I__ZN7desenet6sensor13NetworkEntity10_pInstanceE>:
 800da30:	b580      	push	{r7, lr}
 800da32:	af00      	add	r7, sp, #0
 800da34:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800da38:	2001      	movs	r0, #1
 800da3a:	f7ff ffb3 	bl	800d9a4 <_Z41__static_initialization_and_destruction_0ii>
 800da3e:	bd80      	pop	{r7, pc}

0800da40 <_GLOBAL__sub_D__ZN7desenet6sensor13NetworkEntity10_pInstanceE>:
 800da40:	b580      	push	{r7, lr}
 800da42:	af00      	add	r7, sp, #0
 800da44:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800da48:	2000      	movs	r0, #0
 800da4a:	f7ff ffab 	bl	800d9a4 <_Z41__static_initialization_and_destruction_0ii>
 800da4e:	bd80      	pop	{r7, pc}

0800da50 <_Z41__static_initialization_and_destruction_0ii>:
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   //
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   //
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   //
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   //
    { 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 },   //
 };
 800da50:	b580      	push	{r7, lr}
 800da52:	b088      	sub	sp, #32
 800da54:	af00      	add	r7, sp, #0
 800da56:	6078      	str	r0, [r7, #4]
 800da58:	6039      	str	r1, [r7, #0]
 800da5a:	687b      	ldr	r3, [r7, #4]
 800da5c:	2b01      	cmp	r3, #1
 800da5e:	d122      	bne.n	800daa6 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800da60:	683b      	ldr	r3, [r7, #0]
 800da62:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800da66:	4293      	cmp	r3, r2
 800da68:	d11d      	bne.n	800daa6 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800da6a:	4b18      	ldr	r3, [pc, #96]	; (800dacc <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800da6c:	681b      	ldr	r3, [r3, #0]
 800da6e:	613b      	str	r3, [r7, #16]
 800da70:	f107 0310 	add.w	r3, r7, #16
 800da74:	60bb      	str	r3, [r7, #8]
 800da76:	2304      	movs	r3, #4
 800da78:	60fb      	str	r3, [r7, #12]
 800da7a:	f107 0308 	add.w	r3, r7, #8
 800da7e:	e893 0006 	ldmia.w	r3, {r1, r2}
 800da82:	4813      	ldr	r0, [pc, #76]	; (800dad0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800da84:	f7f9 f956 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800da88:	4b12      	ldr	r3, [pc, #72]	; (800dad4 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800da8a:	681b      	ldr	r3, [r3, #0]
 800da8c:	61fb      	str	r3, [r7, #28]
 800da8e:	f107 031c 	add.w	r3, r7, #28
 800da92:	617b      	str	r3, [r7, #20]
 800da94:	2304      	movs	r3, #4
 800da96:	61bb      	str	r3, [r7, #24]
 800da98:	f107 0314 	add.w	r3, r7, #20
 800da9c:	e893 0006 	ldmia.w	r3, {r1, r2}
 800daa0:	480d      	ldr	r0, [pc, #52]	; (800dad8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800daa2:	f7f9 f947 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800daa6:	687b      	ldr	r3, [r7, #4]
 800daa8:	2b00      	cmp	r3, #0
 800daaa:	d10a      	bne.n	800dac2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800daac:	683b      	ldr	r3, [r7, #0]
 800daae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800dab2:	4293      	cmp	r3, r2
 800dab4:	d105      	bne.n	800dac2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800dab6:	4808      	ldr	r0, [pc, #32]	; (800dad8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800dab8:	f7f9 fa86 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800dabc:	4804      	ldr	r0, [pc, #16]	; (800dad0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800dabe:	f7f9 fa83 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800dac2:	bf00      	nop
 800dac4:	3720      	adds	r7, #32
 800dac6:	46bd      	mov	sp, r7
 800dac8:	bd80      	pop	{r7, pc}
 800daca:	bf00      	nop
 800dacc:	08018da0 	.word	0x08018da0
 800dad0:	20001938 	.word	0x20001938
 800dad4:	08018da4 	.word	0x08018da4
 800dad8:	20001940 	.word	0x20001940

0800dadc <_GLOBAL__sub_I__ZN24MonochromeDisplayPainter10FontLookupE>:
 800dadc:	b580      	push	{r7, lr}
 800dade:	af00      	add	r7, sp, #0
 800dae0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800dae4:	2001      	movs	r0, #1
 800dae6:	f7ff ffb3 	bl	800da50 <_Z41__static_initialization_and_destruction_0ii>
 800daea:	bd80      	pop	{r7, pc}

0800daec <_GLOBAL__sub_D__ZN24MonochromeDisplayPainter10FontLookupE>:
 800daec:	b580      	push	{r7, lr}
 800daee:	af00      	add	r7, sp, #0
 800daf0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800daf4:	2000      	movs	r0, #0
 800daf6:	f7ff ffab 	bl	800da50 <_Z41__static_initialization_and_destruction_0ii>
 800dafa:	bd80      	pop	{r7, pc}

0800dafc <_ZN18IMonochromeDisplay5PointC1Eii>:
		inline explicit Point( int x = 0 , int y = 0 ) : x( x ) , y( y ) {}
 800dafc:	b480      	push	{r7}
 800dafe:	b085      	sub	sp, #20
 800db00:	af00      	add	r7, sp, #0
 800db02:	60f8      	str	r0, [r7, #12]
 800db04:	60b9      	str	r1, [r7, #8]
 800db06:	607a      	str	r2, [r7, #4]
 800db08:	68fb      	ldr	r3, [r7, #12]
 800db0a:	68ba      	ldr	r2, [r7, #8]
 800db0c:	601a      	str	r2, [r3, #0]
 800db0e:	68fb      	ldr	r3, [r7, #12]
 800db10:	687a      	ldr	r2, [r7, #4]
 800db12:	605a      	str	r2, [r3, #4]
 800db14:	68fb      	ldr	r3, [r7, #12]
 800db16:	4618      	mov	r0, r3
 800db18:	3714      	adds	r7, #20
 800db1a:	46bd      	mov	sp, r7
 800db1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db20:	4770      	bx	lr
	...

0800db24 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb>:
  #include "fixmath/fix16.h"
  #include "fixmath/fix16.hpp"
#endif // DISPLAYPAINTER_USE_EXTENED_FEATURES
#include "MonochromeDisplayPainter"

MonochromeDisplayPainter::MonochromeDisplayPainter( IMonochromeDisplay * display , bool autoUpdate )
 800db24:	b590      	push	{r4, r7, lr}
 800db26:	b085      	sub	sp, #20
 800db28:	af00      	add	r7, sp, #0
 800db2a:	60f8      	str	r0, [r7, #12]
 800db2c:	60b9      	str	r1, [r7, #8]
 800db2e:	4613      	mov	r3, r2
 800db30:	71fb      	strb	r3, [r7, #7]
	: _display( display ) , _offscreenBitmap( NULL ) , _disableSync( false ) , _autoUpdate( autoUpdate )
 800db32:	4a0f      	ldr	r2, [pc, #60]	; (800db70 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb+0x4c>)
 800db34:	68fb      	ldr	r3, [r7, #12]
 800db36:	601a      	str	r2, [r3, #0]
 800db38:	68fb      	ldr	r3, [r7, #12]
 800db3a:	68ba      	ldr	r2, [r7, #8]
 800db3c:	605a      	str	r2, [r3, #4]
 800db3e:	68fb      	ldr	r3, [r7, #12]
 800db40:	2200      	movs	r2, #0
 800db42:	60da      	str	r2, [r3, #12]
 800db44:	68fb      	ldr	r3, [r7, #12]
 800db46:	2200      	movs	r2, #0
 800db48:	741a      	strb	r2, [r3, #16]
 800db4a:	68fb      	ldr	r3, [r7, #12]
 800db4c:	79fa      	ldrb	r2, [r7, #7]
 800db4e:	745a      	strb	r2, [r3, #17]
{
	// Ask the display for his accelerated drawing methods.
	if ( display ) _accelMethods = display->acceleratedDrawingMethods();
 800db50:	68bb      	ldr	r3, [r7, #8]
 800db52:	2b00      	cmp	r3, #0
 800db54:	d007      	beq.n	800db66 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb+0x42>
 800db56:	68bb      	ldr	r3, [r7, #8]
 800db58:	681b      	ldr	r3, [r3, #0]
 800db5a:	330c      	adds	r3, #12
 800db5c:	681b      	ldr	r3, [r3, #0]
 800db5e:	68fc      	ldr	r4, [r7, #12]
 800db60:	68b8      	ldr	r0, [r7, #8]
 800db62:	4798      	blx	r3
 800db64:	60a0      	str	r0, [r4, #8]
}
 800db66:	68fb      	ldr	r3, [r7, #12]
 800db68:	4618      	mov	r0, r3
 800db6a:	3714      	adds	r7, #20
 800db6c:	46bd      	mov	sp, r7
 800db6e:	bd90      	pop	{r4, r7, pc}
 800db70:	0801bdb8 	.word	0x0801bdb8

0800db74 <_ZN24MonochromeDisplayPainterD1Ev>:

MonochromeDisplayPainter::~MonochromeDisplayPainter()
 800db74:	b580      	push	{r7, lr}
 800db76:	b082      	sub	sp, #8
 800db78:	af00      	add	r7, sp, #0
 800db7a:	6078      	str	r0, [r7, #4]
 800db7c:	4a05      	ldr	r2, [pc, #20]	; (800db94 <_ZN24MonochromeDisplayPainterD1Ev+0x20>)
 800db7e:	687b      	ldr	r3, [r7, #4]
 800db80:	601a      	str	r2, [r3, #0]
{
	// End painting.
	end();
 800db82:	6878      	ldr	r0, [r7, #4]
 800db84:	f000 f832 	bl	800dbec <_ZN24MonochromeDisplayPainter3endEv>
}
 800db88:	687b      	ldr	r3, [r7, #4]
 800db8a:	4618      	mov	r0, r3
 800db8c:	3708      	adds	r7, #8
 800db8e:	46bd      	mov	sp, r7
 800db90:	bd80      	pop	{r7, pc}
 800db92:	bf00      	nop
 800db94:	0801bdb8 	.word	0x0801bdb8

0800db98 <_ZN24MonochromeDisplayPainterD0Ev>:
MonochromeDisplayPainter::~MonochromeDisplayPainter()
 800db98:	b580      	push	{r7, lr}
 800db9a:	b082      	sub	sp, #8
 800db9c:	af00      	add	r7, sp, #0
 800db9e:	6078      	str	r0, [r7, #4]
}
 800dba0:	6878      	ldr	r0, [r7, #4]
 800dba2:	f7ff ffe7 	bl	800db74 <_ZN24MonochromeDisplayPainterD1Ev>
 800dba6:	2114      	movs	r1, #20
 800dba8:	6878      	ldr	r0, [r7, #4]
 800dbaa:	f008 faff 	bl	80161ac <_ZdlPvj>
 800dbae:	687b      	ldr	r3, [r7, #4]
 800dbb0:	4618      	mov	r0, r3
 800dbb2:	3708      	adds	r7, #8
 800dbb4:	46bd      	mov	sp, r7
 800dbb6:	bd80      	pop	{r7, pc}

0800dbb8 <_ZN24MonochromeDisplayPainter5beginEP18IMonochromeDisplay>:

void MonochromeDisplayPainter::begin( IMonochromeDisplay * display )
{
 800dbb8:	b590      	push	{r4, r7, lr}
 800dbba:	b083      	sub	sp, #12
 800dbbc:	af00      	add	r7, sp, #0
 800dbbe:	6078      	str	r0, [r7, #4]
 800dbc0:	6039      	str	r1, [r7, #0]
	// End the work relationship with the old display if there was any.
	end();
 800dbc2:	6878      	ldr	r0, [r7, #4]
 800dbc4:	f000 f812 	bl	800dbec <_ZN24MonochromeDisplayPainter3endEv>

	// Set display pointer and ask the device for his capabilities.
	_display = display;
 800dbc8:	687b      	ldr	r3, [r7, #4]
 800dbca:	683a      	ldr	r2, [r7, #0]
 800dbcc:	605a      	str	r2, [r3, #4]
	if ( display ) _accelMethods = display->acceleratedDrawingMethods();
 800dbce:	683b      	ldr	r3, [r7, #0]
 800dbd0:	2b00      	cmp	r3, #0
 800dbd2:	d007      	beq.n	800dbe4 <_ZN24MonochromeDisplayPainter5beginEP18IMonochromeDisplay+0x2c>
 800dbd4:	683b      	ldr	r3, [r7, #0]
 800dbd6:	681b      	ldr	r3, [r3, #0]
 800dbd8:	330c      	adds	r3, #12
 800dbda:	681b      	ldr	r3, [r3, #0]
 800dbdc:	687c      	ldr	r4, [r7, #4]
 800dbde:	6838      	ldr	r0, [r7, #0]
 800dbe0:	4798      	blx	r3
 800dbe2:	60a0      	str	r0, [r4, #8]
}
 800dbe4:	bf00      	nop
 800dbe6:	370c      	adds	r7, #12
 800dbe8:	46bd      	mov	sp, r7
 800dbea:	bd90      	pop	{r4, r7, pc}

0800dbec <_ZN24MonochromeDisplayPainter3endEv>:

void MonochromeDisplayPainter::end()
{
 800dbec:	b580      	push	{r7, lr}
 800dbee:	b082      	sub	sp, #8
 800dbf0:	af00      	add	r7, sp, #0
 800dbf2:	6078      	str	r0, [r7, #4]
	// Commit changes if the display exists.
	if ( _display && !_autoUpdate )
 800dbf4:	687b      	ldr	r3, [r7, #4]
 800dbf6:	685b      	ldr	r3, [r3, #4]
 800dbf8:	2b00      	cmp	r3, #0
 800dbfa:	d009      	beq.n	800dc10 <_ZN24MonochromeDisplayPainter3endEv+0x24>
 800dbfc:	687b      	ldr	r3, [r7, #4]
 800dbfe:	7c5b      	ldrb	r3, [r3, #17]
 800dc00:	f083 0301 	eor.w	r3, r3, #1
 800dc04:	b2db      	uxtb	r3, r3
 800dc06:	2b00      	cmp	r3, #0
 800dc08:	d002      	beq.n	800dc10 <_ZN24MonochromeDisplayPainter3endEv+0x24>
		update();
 800dc0a:	6878      	ldr	r0, [r7, #4]
 800dc0c:	f000 f8ea 	bl	800dde4 <_ZN24MonochromeDisplayPainter6updateEv>

	// We can not work anymore with the recent display object.
	_display = NULL;
 800dc10:	687b      	ldr	r3, [r7, #4]
 800dc12:	2200      	movs	r2, #0
 800dc14:	605a      	str	r2, [r3, #4]

	// If we used an off-screen bitmap, we have to remove it.
	if ( _offscreenBitmap )
 800dc16:	687b      	ldr	r3, [r7, #4]
 800dc18:	68db      	ldr	r3, [r3, #12]
 800dc1a:	2b00      	cmp	r3, #0
 800dc1c:	d00b      	beq.n	800dc36 <_ZN24MonochromeDisplayPainter3endEv+0x4a>
	{
		delete[] _offscreenBitmap;
 800dc1e:	687b      	ldr	r3, [r7, #4]
 800dc20:	68db      	ldr	r3, [r3, #12]
 800dc22:	2b00      	cmp	r3, #0
 800dc24:	d004      	beq.n	800dc30 <_ZN24MonochromeDisplayPainter3endEv+0x44>
 800dc26:	687b      	ldr	r3, [r7, #4]
 800dc28:	68db      	ldr	r3, [r3, #12]
 800dc2a:	4618      	mov	r0, r3
 800dc2c:	f008 fac0 	bl	80161b0 <_ZdaPv>
		_offscreenBitmap = NULL;
 800dc30:	687b      	ldr	r3, [r7, #4]
 800dc32:	2200      	movs	r2, #0
 800dc34:	60da      	str	r2, [r3, #12]
	}
}
 800dc36:	bf00      	nop
 800dc38:	3708      	adds	r7, #8
 800dc3a:	46bd      	mov	sp, r7
 800dc3c:	bd80      	pop	{r7, pc}
	...

0800dc40 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE>:

void MonochromeDisplayPainter::clear( IMonochromeDisplay::PixelColor color )
{
 800dc40:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dc42:	b093      	sub	sp, #76	; 0x4c
 800dc44:	af02      	add	r7, sp, #8
 800dc46:	6078      	str	r0, [r7, #4]
 800dc48:	460b      	mov	r3, r1
 800dc4a:	70fb      	strb	r3, [r7, #3]
	assert( _display );
 800dc4c:	687b      	ldr	r3, [r7, #4]
 800dc4e:	685b      	ldr	r3, [r3, #4]
 800dc50:	2b00      	cmp	r3, #0
 800dc52:	d105      	bne.n	800dc60 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x20>
 800dc54:	4b60      	ldr	r3, [pc, #384]	; (800ddd8 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x198>)
 800dc56:	4a61      	ldr	r2, [pc, #388]	; (800dddc <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x19c>)
 800dc58:	2136      	movs	r1, #54	; 0x36
 800dc5a:	4861      	ldr	r0, [pc, #388]	; (800dde0 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x1a0>)
 800dc5c:	f008 fb9a 	bl	8016394 <__assert_func>
	if ( _display )
 800dc60:	687b      	ldr	r3, [r7, #4]
 800dc62:	685b      	ldr	r3, [r3, #4]
 800dc64:	2b00      	cmp	r3, #0
 800dc66:	f000 80b2 	beq.w	800ddce <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x18e>
	{
		// Try first the accelerated clear method.
		if ( _accelMethods.clearAccelerated )
 800dc6a:	687b      	ldr	r3, [r7, #4]
 800dc6c:	7a1b      	ldrb	r3, [r3, #8]
 800dc6e:	f003 0301 	and.w	r3, r3, #1
 800dc72:	b2db      	uxtb	r3, r3
 800dc74:	2b00      	cmp	r3, #0
 800dc76:	d03e      	beq.n	800dcf6 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0xb6>
		{
			_display->clear( color );
 800dc78:	687b      	ldr	r3, [r7, #4]
 800dc7a:	685a      	ldr	r2, [r3, #4]
 800dc7c:	687b      	ldr	r3, [r7, #4]
 800dc7e:	685b      	ldr	r3, [r3, #4]
 800dc80:	681b      	ldr	r3, [r3, #0]
 800dc82:	3324      	adds	r3, #36	; 0x24
 800dc84:	681b      	ldr	r3, [r3, #0]
 800dc86:	f997 1003 	ldrsb.w	r1, [r7, #3]
 800dc8a:	4610      	mov	r0, r2
 800dc8c:	4798      	blx	r3

			if ( _offscreenBitmap )
 800dc8e:	687b      	ldr	r3, [r7, #4]
 800dc90:	68db      	ldr	r3, [r3, #12]
 800dc92:	2b00      	cmp	r3, #0
 800dc94:	f000 809b 	beq.w	800ddce <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x18e>
			{
				memset( _offscreenBitmap , color == IMonochromeDisplay::White ? 0x00 : 0xFF ,
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	68dd      	ldr	r5, [r3, #12]
 800dc9c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800dca0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dca4:	d101      	bne.n	800dcaa <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x6a>
 800dca6:	2600      	movs	r6, #0
 800dca8:	e000      	b.n	800dcac <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x6c>
 800dcaa:	26ff      	movs	r6, #255	; 0xff
						( ( _display->resolution().width * _display->resolution().height ) + 7 ) / 8 );
 800dcac:	687b      	ldr	r3, [r7, #4]
 800dcae:	6859      	ldr	r1, [r3, #4]
 800dcb0:	687b      	ldr	r3, [r7, #4]
 800dcb2:	685b      	ldr	r3, [r3, #4]
 800dcb4:	681b      	ldr	r3, [r3, #0]
 800dcb6:	3308      	adds	r3, #8
 800dcb8:	681b      	ldr	r3, [r3, #0]
 800dcba:	f107 0208 	add.w	r2, r7, #8
 800dcbe:	4610      	mov	r0, r2
 800dcc0:	4798      	blx	r3
 800dcc2:	68bc      	ldr	r4, [r7, #8]
 800dcc4:	687b      	ldr	r3, [r7, #4]
 800dcc6:	6859      	ldr	r1, [r3, #4]
 800dcc8:	687b      	ldr	r3, [r7, #4]
 800dcca:	685b      	ldr	r3, [r3, #4]
 800dccc:	681b      	ldr	r3, [r3, #0]
 800dcce:	3308      	adds	r3, #8
 800dcd0:	681b      	ldr	r3, [r3, #0]
 800dcd2:	f107 0210 	add.w	r2, r7, #16
 800dcd6:	4610      	mov	r0, r2
 800dcd8:	4798      	blx	r3
 800dcda:	697b      	ldr	r3, [r7, #20]
 800dcdc:	fb04 f303 	mul.w	r3, r4, r3
 800dce0:	3307      	adds	r3, #7
 800dce2:	2b00      	cmp	r3, #0
 800dce4:	da00      	bge.n	800dce8 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0xa8>
 800dce6:	3307      	adds	r3, #7
 800dce8:	10db      	asrs	r3, r3, #3
				memset( _offscreenBitmap , color == IMonochromeDisplay::White ? 0x00 : 0xFF ,
 800dcea:	461a      	mov	r2, r3
 800dcec:	4631      	mov	r1, r6
 800dcee:	4628      	mov	r0, r5
 800dcf0:	f008 fbe8 	bl	80164c4 <memset>
		{
			drawRectangle( IMonochromeDisplay::Point( 0 , 0 ) , _display->resolution() ,
					       IMonochromeDisplay::Undefined , color );
		}
	}
}
 800dcf4:	e06b      	b.n	800ddce <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x18e>
		else if ( _accelMethods.memoryCopyAccelerated )
 800dcf6:	687b      	ldr	r3, [r7, #4]
 800dcf8:	7a1b      	ldrb	r3, [r3, #8]
 800dcfa:	f003 0302 	and.w	r3, r3, #2
 800dcfe:	b2db      	uxtb	r3, r3
 800dd00:	2b00      	cmp	r3, #0
 800dd02:	d047      	beq.n	800dd94 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x154>
			_createOffsetBitmap();
 800dd04:	2100      	movs	r1, #0
 800dd06:	6878      	ldr	r0, [r7, #4]
 800dd08:	f000 fbae 	bl	800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>
			memset( _offscreenBitmap , color == IMonochromeDisplay::White ? 0x00 : 0xFF ,
 800dd0c:	687b      	ldr	r3, [r7, #4]
 800dd0e:	68dd      	ldr	r5, [r3, #12]
 800dd10:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800dd14:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd18:	d101      	bne.n	800dd1e <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0xde>
 800dd1a:	2600      	movs	r6, #0
 800dd1c:	e000      	b.n	800dd20 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0xe0>
 800dd1e:	26ff      	movs	r6, #255	; 0xff
					( ( _display->resolution().width * _display->resolution().height ) + 7 ) / 8 );
 800dd20:	687b      	ldr	r3, [r7, #4]
 800dd22:	6859      	ldr	r1, [r3, #4]
 800dd24:	687b      	ldr	r3, [r7, #4]
 800dd26:	685b      	ldr	r3, [r3, #4]
 800dd28:	681b      	ldr	r3, [r3, #0]
 800dd2a:	3308      	adds	r3, #8
 800dd2c:	681b      	ldr	r3, [r3, #0]
 800dd2e:	f107 0218 	add.w	r2, r7, #24
 800dd32:	4610      	mov	r0, r2
 800dd34:	4798      	blx	r3
 800dd36:	69bc      	ldr	r4, [r7, #24]
 800dd38:	687b      	ldr	r3, [r7, #4]
 800dd3a:	6859      	ldr	r1, [r3, #4]
 800dd3c:	687b      	ldr	r3, [r7, #4]
 800dd3e:	685b      	ldr	r3, [r3, #4]
 800dd40:	681b      	ldr	r3, [r3, #0]
 800dd42:	3308      	adds	r3, #8
 800dd44:	681b      	ldr	r3, [r3, #0]
 800dd46:	f107 0220 	add.w	r2, r7, #32
 800dd4a:	4610      	mov	r0, r2
 800dd4c:	4798      	blx	r3
 800dd4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd50:	fb04 f303 	mul.w	r3, r4, r3
 800dd54:	3307      	adds	r3, #7
 800dd56:	2b00      	cmp	r3, #0
 800dd58:	da00      	bge.n	800dd5c <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x11c>
 800dd5a:	3307      	adds	r3, #7
 800dd5c:	10db      	asrs	r3, r3, #3
			memset( _offscreenBitmap , color == IMonochromeDisplay::White ? 0x00 : 0xFF ,
 800dd5e:	461a      	mov	r2, r3
 800dd60:	4631      	mov	r1, r6
 800dd62:	4628      	mov	r0, r5
 800dd64:	f008 fbae 	bl	80164c4 <memset>
			if ( _autoUpdate )
 800dd68:	687b      	ldr	r3, [r7, #4]
 800dd6a:	7c5b      	ldrb	r3, [r3, #17]
 800dd6c:	2b00      	cmp	r3, #0
 800dd6e:	d02e      	beq.n	800ddce <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x18e>
				_syncDisplay( 0 , _display->resolution().height );
 800dd70:	687b      	ldr	r3, [r7, #4]
 800dd72:	6859      	ldr	r1, [r3, #4]
 800dd74:	687b      	ldr	r3, [r7, #4]
 800dd76:	685b      	ldr	r3, [r3, #4]
 800dd78:	681b      	ldr	r3, [r3, #0]
 800dd7a:	3308      	adds	r3, #8
 800dd7c:	681b      	ldr	r3, [r3, #0]
 800dd7e:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800dd82:	4610      	mov	r0, r2
 800dd84:	4798      	blx	r3
 800dd86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dd88:	461a      	mov	r2, r3
 800dd8a:	2100      	movs	r1, #0
 800dd8c:	6878      	ldr	r0, [r7, #4]
 800dd8e:	f000 fcb8 	bl	800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>
}
 800dd92:	e01c      	b.n	800ddce <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE+0x18e>
			drawRectangle( IMonochromeDisplay::Point( 0 , 0 ) , _display->resolution() ,
 800dd94:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800dd98:	2200      	movs	r2, #0
 800dd9a:	2100      	movs	r1, #0
 800dd9c:	4618      	mov	r0, r3
 800dd9e:	f7ff fead 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
 800dda2:	687b      	ldr	r3, [r7, #4]
 800dda4:	6859      	ldr	r1, [r3, #4]
 800dda6:	687b      	ldr	r3, [r7, #4]
 800dda8:	685b      	ldr	r3, [r3, #4]
 800ddaa:	681b      	ldr	r3, [r3, #0]
 800ddac:	3308      	adds	r3, #8
 800ddae:	681b      	ldr	r3, [r3, #0]
 800ddb0:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800ddb4:	4610      	mov	r0, r2
 800ddb6:	4798      	blx	r3
 800ddb8:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800ddbc:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800ddc0:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800ddc4:	9300      	str	r3, [sp, #0]
 800ddc6:	2300      	movs	r3, #0
 800ddc8:	6878      	ldr	r0, [r7, #4]
 800ddca:	f000 f925 	bl	800e018 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_>
}
 800ddce:	bf00      	nop
 800ddd0:	3744      	adds	r7, #68	; 0x44
 800ddd2:	46bd      	mov	sp, r7
 800ddd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ddd6:	bf00      	nop
 800ddd8:	08018da8 	.word	0x08018da8
 800dddc:	08018db4 	.word	0x08018db4
 800dde0:	08018dfc 	.word	0x08018dfc

0800dde4 <_ZN24MonochromeDisplayPainter6updateEv>:
{
	_autoUpdate = autoUpdate;
}

void MonochromeDisplayPainter::update()
{
 800dde4:	b580      	push	{r7, lr}
 800dde6:	b084      	sub	sp, #16
 800dde8:	af00      	add	r7, sp, #0
 800ddea:	6078      	str	r0, [r7, #4]
	_syncDisplay( 0 , _display->resolution().height );
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	6859      	ldr	r1, [r3, #4]
 800ddf0:	687b      	ldr	r3, [r7, #4]
 800ddf2:	685b      	ldr	r3, [r3, #4]
 800ddf4:	681b      	ldr	r3, [r3, #0]
 800ddf6:	3308      	adds	r3, #8
 800ddf8:	681b      	ldr	r3, [r3, #0]
 800ddfa:	f107 0208 	add.w	r2, r7, #8
 800ddfe:	4610      	mov	r0, r2
 800de00:	4798      	blx	r3
 800de02:	68fb      	ldr	r3, [r7, #12]
 800de04:	461a      	mov	r2, r3
 800de06:	2100      	movs	r1, #0
 800de08:	6878      	ldr	r0, [r7, #4]
 800de0a:	f000 fc7a 	bl	800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>
}
 800de0e:	bf00      	nop
 800de10:	3710      	adds	r7, #16
 800de12:	46bd      	mov	sp, r7
 800de14:	bd80      	pop	{r7, pc}

0800de16 <_ZSt3maxIiERKT_S2_S2_>:
    max(const _Tp& __a, const _Tp& __b)
 800de16:	b480      	push	{r7}
 800de18:	b083      	sub	sp, #12
 800de1a:	af00      	add	r7, sp, #0
 800de1c:	6078      	str	r0, [r7, #4]
 800de1e:	6039      	str	r1, [r7, #0]
      if (__a < __b)
 800de20:	687b      	ldr	r3, [r7, #4]
 800de22:	681a      	ldr	r2, [r3, #0]
 800de24:	683b      	ldr	r3, [r7, #0]
 800de26:	681b      	ldr	r3, [r3, #0]
 800de28:	429a      	cmp	r2, r3
 800de2a:	da01      	bge.n	800de30 <_ZSt3maxIiERKT_S2_S2_+0x1a>
	return __b;
 800de2c:	683b      	ldr	r3, [r7, #0]
 800de2e:	e000      	b.n	800de32 <_ZSt3maxIiERKT_S2_S2_+0x1c>
      return __a;
 800de30:	687b      	ldr	r3, [r7, #4]
    }
 800de32:	4618      	mov	r0, r3
 800de34:	370c      	adds	r7, #12
 800de36:	46bd      	mov	sp, r7
 800de38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de3c:	4770      	bx	lr
	...

0800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>:
}

void MonochromeDisplayPainter::drawLine( const IMonochromeDisplay::Point & begin ,
										 const IMonochromeDisplay::Point & end ,
										 IMonochromeDisplay::PixelColor color )
{
 800de40:	b590      	push	{r4, r7, lr}
 800de42:	b08d      	sub	sp, #52	; 0x34
 800de44:	af00      	add	r7, sp, #0
 800de46:	60f8      	str	r0, [r7, #12]
 800de48:	60b9      	str	r1, [r7, #8]
 800de4a:	607a      	str	r2, [r7, #4]
 800de4c:	70fb      	strb	r3, [r7, #3]
	assert( _display );
 800de4e:	68fb      	ldr	r3, [r7, #12]
 800de50:	685b      	ldr	r3, [r3, #4]
 800de52:	2b00      	cmp	r3, #0
 800de54:	d105      	bne.n	800de62 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x22>
 800de56:	4b6d      	ldr	r3, [pc, #436]	; (800e00c <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1cc>)
 800de58:	4a6d      	ldr	r2, [pc, #436]	; (800e010 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1d0>)
 800de5a:	2187      	movs	r1, #135	; 0x87
 800de5c:	486d      	ldr	r0, [pc, #436]	; (800e014 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1d4>)
 800de5e:	f008 fa99 	bl	8016394 <__assert_func>
	if ( _display )
 800de62:	68fb      	ldr	r3, [r7, #12]
 800de64:	685b      	ldr	r3, [r3, #4]
 800de66:	2b00      	cmp	r3, #0
 800de68:	f000 80cc 	beq.w	800e004 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1c4>
	{
		// Try first the accelerated method.
		if ( _accelMethods.drawLineAccelerated && !_offscreenBitmap )
 800de6c:	68fb      	ldr	r3, [r7, #12]
 800de6e:	7a1b      	ldrb	r3, [r3, #8]
 800de70:	f003 0304 	and.w	r3, r3, #4
 800de74:	b2db      	uxtb	r3, r3
 800de76:	2b00      	cmp	r3, #0
 800de78:	d010      	beq.n	800de9c <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x5c>
 800de7a:	68fb      	ldr	r3, [r7, #12]
 800de7c:	68db      	ldr	r3, [r3, #12]
 800de7e:	2b00      	cmp	r3, #0
 800de80:	d10c      	bne.n	800de9c <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x5c>
		{
			_display->drawLine( begin , end , color );
 800de82:	68fb      	ldr	r3, [r7, #12]
 800de84:	6858      	ldr	r0, [r3, #4]
 800de86:	68fb      	ldr	r3, [r7, #12]
 800de88:	685b      	ldr	r3, [r3, #4]
 800de8a:	681b      	ldr	r3, [r3, #0]
 800de8c:	3330      	adds	r3, #48	; 0x30
 800de8e:	681c      	ldr	r4, [r3, #0]
 800de90:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800de94:	687a      	ldr	r2, [r7, #4]
 800de96:	68b9      	ldr	r1, [r7, #8]
 800de98:	47a0      	blx	r4
			// Sync affected lines with hardware screen.
			if ( _autoUpdate )
				_syncDisplay( std::min( begin.y , end.y ) , std::max( begin.y , end.y ) + 1 );
		}
	}
}
 800de9a:	e0b3      	b.n	800e004 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1c4>
			if ( _accelMethods.memoryCopyAccelerated )
 800de9c:	68fb      	ldr	r3, [r7, #12]
 800de9e:	7a1b      	ldrb	r3, [r3, #8]
 800dea0:	f003 0302 	and.w	r3, r3, #2
 800dea4:	b2db      	uxtb	r3, r3
 800dea6:	2b00      	cmp	r3, #0
 800dea8:	d003      	beq.n	800deb2 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x72>
				_createOffsetBitmap( true );
 800deaa:	2101      	movs	r1, #1
 800deac:	68f8      	ldr	r0, [r7, #12]
 800deae:	f000 fadb 	bl	800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>
			IMonochromeDisplay::Point p = begin;
 800deb2:	68ba      	ldr	r2, [r7, #8]
 800deb4:	f107 0310 	add.w	r3, r7, #16
 800deb8:	e892 0003 	ldmia.w	r2, {r0, r1}
 800debc:	e883 0003 	stmia.w	r3, {r0, r1}
			dx = end.x - begin.x;
 800dec0:	687b      	ldr	r3, [r7, #4]
 800dec2:	681a      	ldr	r2, [r3, #0]
 800dec4:	68bb      	ldr	r3, [r7, #8]
 800dec6:	681b      	ldr	r3, [r3, #0]
 800dec8:	1ad3      	subs	r3, r2, r3
 800deca:	62fb      	str	r3, [r7, #44]	; 0x2c
			dy = end.y - begin.y;
 800decc:	687b      	ldr	r3, [r7, #4]
 800dece:	685a      	ldr	r2, [r3, #4]
 800ded0:	68bb      	ldr	r3, [r7, #8]
 800ded2:	685b      	ldr	r3, [r3, #4]
 800ded4:	1ad3      	subs	r3, r2, r3
 800ded6:	62bb      	str	r3, [r7, #40]	; 0x28
			if ( dx >= 0 ) ix = 1;
 800ded8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800deda:	2b00      	cmp	r3, #0
 800dedc:	db02      	blt.n	800dee4 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0xa4>
 800dede:	2301      	movs	r3, #1
 800dee0:	627b      	str	r3, [r7, #36]	; 0x24
 800dee2:	e007      	b.n	800def4 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0xb4>
				ix = -1;
 800dee4:	f04f 33ff 	mov.w	r3, #4294967295
 800dee8:	627b      	str	r3, [r7, #36]	; 0x24
				dx = abs( dx );
 800deea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800deec:	2b00      	cmp	r3, #0
 800deee:	bfb8      	it	lt
 800def0:	425b      	neglt	r3, r3
 800def2:	62fb      	str	r3, [r7, #44]	; 0x2c
			if ( dy >= 0 ) iy = 1;
 800def4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800def6:	2b00      	cmp	r3, #0
 800def8:	db02      	blt.n	800df00 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0xc0>
 800defa:	2301      	movs	r3, #1
 800defc:	623b      	str	r3, [r7, #32]
 800defe:	e007      	b.n	800df10 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0xd0>
				iy = -1;
 800df00:	f04f 33ff 	mov.w	r3, #4294967295
 800df04:	623b      	str	r3, [r7, #32]
				dy = abs( dy );
 800df06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df08:	2b00      	cmp	r3, #0
 800df0a:	bfb8      	it	lt
 800df0c:	425b      	neglt	r3, r3
 800df0e:	62bb      	str	r3, [r7, #40]	; 0x28
			if ( dx > dy )
 800df10:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800df12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df14:	429a      	cmp	r2, r3
 800df16:	dd2b      	ble.n	800df70 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x130>
				err = 2 * dy - dx;
 800df18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df1a:	005a      	lsls	r2, r3, #1
 800df1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800df1e:	1ad3      	subs	r3, r2, r3
 800df20:	61fb      	str	r3, [r7, #28]
				for ( i = 0 ; i <= dx ; i++ )
 800df22:	2300      	movs	r3, #0
 800df24:	61bb      	str	r3, [r7, #24]
 800df26:	69ba      	ldr	r2, [r7, #24]
 800df28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800df2a:	429a      	cmp	r2, r3
 800df2c:	dc4c      	bgt.n	800dfc8 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x188>
					_setPixel( p , color );
 800df2e:	f997 2003 	ldrsb.w	r2, [r7, #3]
 800df32:	f107 0310 	add.w	r3, r7, #16
 800df36:	4619      	mov	r1, r3
 800df38:	68f8      	ldr	r0, [r7, #12]
 800df3a:	f000 faf4 	bl	800e526 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>
					if ( err >= 0 )
 800df3e:	69fb      	ldr	r3, [r7, #28]
 800df40:	2b00      	cmp	r3, #0
 800df42:	db08      	blt.n	800df56 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x116>
						err -= 2 * dx;
 800df44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800df46:	005b      	lsls	r3, r3, #1
 800df48:	69fa      	ldr	r2, [r7, #28]
 800df4a:	1ad3      	subs	r3, r2, r3
 800df4c:	61fb      	str	r3, [r7, #28]
						p.y += iy;
 800df4e:	697a      	ldr	r2, [r7, #20]
 800df50:	6a3b      	ldr	r3, [r7, #32]
 800df52:	4413      	add	r3, r2
 800df54:	617b      	str	r3, [r7, #20]
					err += 2 * dy;
 800df56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df58:	005b      	lsls	r3, r3, #1
 800df5a:	69fa      	ldr	r2, [r7, #28]
 800df5c:	4413      	add	r3, r2
 800df5e:	61fb      	str	r3, [r7, #28]
					p.x += ix;
 800df60:	693a      	ldr	r2, [r7, #16]
 800df62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800df64:	4413      	add	r3, r2
 800df66:	613b      	str	r3, [r7, #16]
				for ( i = 0 ; i <= dx ; i++ )
 800df68:	69bb      	ldr	r3, [r7, #24]
 800df6a:	3301      	adds	r3, #1
 800df6c:	61bb      	str	r3, [r7, #24]
 800df6e:	e7da      	b.n	800df26 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0xe6>
				err = 2 * dx - dy;
 800df70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800df72:	005a      	lsls	r2, r3, #1
 800df74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df76:	1ad3      	subs	r3, r2, r3
 800df78:	61fb      	str	r3, [r7, #28]
				for ( i = 0 ; i <= dy ; i++ )
 800df7a:	2300      	movs	r3, #0
 800df7c:	61bb      	str	r3, [r7, #24]
 800df7e:	69ba      	ldr	r2, [r7, #24]
 800df80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df82:	429a      	cmp	r2, r3
 800df84:	dc20      	bgt.n	800dfc8 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x188>
					_setPixel( p , color );
 800df86:	f997 2003 	ldrsb.w	r2, [r7, #3]
 800df8a:	f107 0310 	add.w	r3, r7, #16
 800df8e:	4619      	mov	r1, r3
 800df90:	68f8      	ldr	r0, [r7, #12]
 800df92:	f000 fac8 	bl	800e526 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>
					if (err >= 0)
 800df96:	69fb      	ldr	r3, [r7, #28]
 800df98:	2b00      	cmp	r3, #0
 800df9a:	db08      	blt.n	800dfae <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x16e>
						err -= 2 * dy;
 800df9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df9e:	005b      	lsls	r3, r3, #1
 800dfa0:	69fa      	ldr	r2, [r7, #28]
 800dfa2:	1ad3      	subs	r3, r2, r3
 800dfa4:	61fb      	str	r3, [r7, #28]
						p.x += ix;
 800dfa6:	693a      	ldr	r2, [r7, #16]
 800dfa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dfaa:	4413      	add	r3, r2
 800dfac:	613b      	str	r3, [r7, #16]
					err += 2 * dx;
 800dfae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dfb0:	005b      	lsls	r3, r3, #1
 800dfb2:	69fa      	ldr	r2, [r7, #28]
 800dfb4:	4413      	add	r3, r2
 800dfb6:	61fb      	str	r3, [r7, #28]
					p.y += iy;
 800dfb8:	697a      	ldr	r2, [r7, #20]
 800dfba:	6a3b      	ldr	r3, [r7, #32]
 800dfbc:	4413      	add	r3, r2
 800dfbe:	617b      	str	r3, [r7, #20]
				for ( i = 0 ; i <= dy ; i++ )
 800dfc0:	69bb      	ldr	r3, [r7, #24]
 800dfc2:	3301      	adds	r3, #1
 800dfc4:	61bb      	str	r3, [r7, #24]
 800dfc6:	e7da      	b.n	800df7e <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x13e>
			if ( _autoUpdate )
 800dfc8:	68fb      	ldr	r3, [r7, #12]
 800dfca:	7c5b      	ldrb	r3, [r3, #17]
 800dfcc:	2b00      	cmp	r3, #0
 800dfce:	d019      	beq.n	800e004 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE+0x1c4>
				_syncDisplay( std::min( begin.y , end.y ) , std::max( begin.y , end.y ) + 1 );
 800dfd0:	68bb      	ldr	r3, [r7, #8]
 800dfd2:	1d1a      	adds	r2, r3, #4
 800dfd4:	687b      	ldr	r3, [r7, #4]
 800dfd6:	3304      	adds	r3, #4
 800dfd8:	4619      	mov	r1, r3
 800dfda:	4610      	mov	r0, r2
 800dfdc:	f000 fb7d 	bl	800e6da <_ZSt3minIiERKT_S2_S2_>
 800dfe0:	4603      	mov	r3, r0
 800dfe2:	681c      	ldr	r4, [r3, #0]
 800dfe4:	68bb      	ldr	r3, [r7, #8]
 800dfe6:	1d1a      	adds	r2, r3, #4
 800dfe8:	687b      	ldr	r3, [r7, #4]
 800dfea:	3304      	adds	r3, #4
 800dfec:	4619      	mov	r1, r3
 800dfee:	4610      	mov	r0, r2
 800dff0:	f7ff ff11 	bl	800de16 <_ZSt3maxIiERKT_S2_S2_>
 800dff4:	4603      	mov	r3, r0
 800dff6:	681b      	ldr	r3, [r3, #0]
 800dff8:	3301      	adds	r3, #1
 800dffa:	461a      	mov	r2, r3
 800dffc:	4621      	mov	r1, r4
 800dffe:	68f8      	ldr	r0, [r7, #12]
 800e000:	f000 fb7f 	bl	800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>
}
 800e004:	bf00      	nop
 800e006:	3734      	adds	r7, #52	; 0x34
 800e008:	46bd      	mov	sp, r7
 800e00a:	bd90      	pop	{r4, r7, pc}
 800e00c:	08018da8 	.word	0x08018da8
 800e010:	08018ee8 	.word	0x08018ee8
 800e014:	08018dfc 	.word	0x08018dfc

0800e018 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_>:

void MonochromeDisplayPainter::drawRectangle( const IMonochromeDisplay::Point & topLeft ,
											  const IMonochromeDisplay::Size & size ,
											  IMonochromeDisplay::PixelColor stroke ,
											  IMonochromeDisplay::PixelColor fill )
{
 800e018:	b590      	push	{r4, r7, lr}
 800e01a:	b099      	sub	sp, #100	; 0x64
 800e01c:	af00      	add	r7, sp, #0
 800e01e:	60f8      	str	r0, [r7, #12]
 800e020:	60b9      	str	r1, [r7, #8]
 800e022:	607a      	str	r2, [r7, #4]
 800e024:	70fb      	strb	r3, [r7, #3]
	assert( _display );
 800e026:	68fb      	ldr	r3, [r7, #12]
 800e028:	685b      	ldr	r3, [r3, #4]
 800e02a:	2b00      	cmp	r3, #0
 800e02c:	d105      	bne.n	800e03a <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x22>
 800e02e:	4b9b      	ldr	r3, [pc, #620]	; (800e29c <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x284>)
 800e030:	4a9b      	ldr	r2, [pc, #620]	; (800e2a0 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x288>)
 800e032:	21de      	movs	r1, #222	; 0xde
 800e034:	489b      	ldr	r0, [pc, #620]	; (800e2a4 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x28c>)
 800e036:	f008 f9ad 	bl	8016394 <__assert_func>
	if ( _display )
 800e03a:	68fb      	ldr	r3, [r7, #12]
 800e03c:	685b      	ldr	r3, [r3, #4]
 800e03e:	2b00      	cmp	r3, #0
 800e040:	f000 8127 	beq.w	800e292 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x27a>
	{
		// Do we need to fill the rectangle?
		if ( fill != IMonochromeDisplay::Undefined )
 800e044:	f997 3070 	ldrsb.w	r3, [r7, #112]	; 0x70
 800e048:	2b00      	cmp	r3, #0
 800e04a:	d06d      	beq.n	800e128 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x110>
		{
			// Try first the accelerated method.
			if ( _accelMethods.drawRectangeFillAccelerated && !_offscreenBitmap )
 800e04c:	68fb      	ldr	r3, [r7, #12]
 800e04e:	7a1b      	ldrb	r3, [r3, #8]
 800e050:	f003 0310 	and.w	r3, r3, #16
 800e054:	b2db      	uxtb	r3, r3
 800e056:	2b00      	cmp	r3, #0
 800e058:	d010      	beq.n	800e07c <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x64>
 800e05a:	68fb      	ldr	r3, [r7, #12]
 800e05c:	68db      	ldr	r3, [r3, #12]
 800e05e:	2b00      	cmp	r3, #0
 800e060:	d10c      	bne.n	800e07c <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x64>
			{
				_display->fillRectangle( topLeft , size , fill );
 800e062:	68fb      	ldr	r3, [r7, #12]
 800e064:	6858      	ldr	r0, [r3, #4]
 800e066:	68fb      	ldr	r3, [r7, #12]
 800e068:	685b      	ldr	r3, [r3, #4]
 800e06a:	681b      	ldr	r3, [r3, #0]
 800e06c:	3338      	adds	r3, #56	; 0x38
 800e06e:	681c      	ldr	r4, [r3, #0]
 800e070:	f997 3070 	ldrsb.w	r3, [r7, #112]	; 0x70
 800e074:	687a      	ldr	r2, [r7, #4]
 800e076:	68b9      	ldr	r1, [r7, #8]
 800e078:	47a0      	blx	r4
 800e07a:	e055      	b.n	800e128 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x110>

			// Fall back to software rendered method by either buffer copy or direct pixel access.
			else
			{
				// If memory copy acceleration is supported, ensure that the local buffer is ready.
				if ( _accelMethods.memoryCopyAccelerated )
 800e07c:	68fb      	ldr	r3, [r7, #12]
 800e07e:	7a1b      	ldrb	r3, [r3, #8]
 800e080:	f003 0302 	and.w	r3, r3, #2
 800e084:	b2db      	uxtb	r3, r3
 800e086:	2b00      	cmp	r3, #0
 800e088:	d003      	beq.n	800e092 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x7a>
					_createOffsetBitmap( true );
 800e08a:	2101      	movs	r1, #1
 800e08c:	68f8      	ldr	r0, [r7, #12]
 800e08e:	f000 f9eb 	bl	800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>

				// Calculate fill surface.
				IMonochromeDisplay::Point start = topLeft;
 800e092:	68ba      	ldr	r2, [r7, #8]
 800e094:	f107 0318 	add.w	r3, r7, #24
 800e098:	e892 0003 	ldmia.w	r2, {r0, r1}
 800e09c:	e883 0003 	stmia.w	r3, {r0, r1}
				IMonochromeDisplay::Point end( topLeft.x + size.width - 1 , topLeft.y + size.height - 1 );
 800e0a0:	68bb      	ldr	r3, [r7, #8]
 800e0a2:	681a      	ldr	r2, [r3, #0]
 800e0a4:	687b      	ldr	r3, [r7, #4]
 800e0a6:	681b      	ldr	r3, [r3, #0]
 800e0a8:	4413      	add	r3, r2
 800e0aa:	1e59      	subs	r1, r3, #1
 800e0ac:	68bb      	ldr	r3, [r7, #8]
 800e0ae:	685a      	ldr	r2, [r3, #4]
 800e0b0:	687b      	ldr	r3, [r7, #4]
 800e0b2:	685b      	ldr	r3, [r3, #4]
 800e0b4:	4413      	add	r3, r2
 800e0b6:	1e5a      	subs	r2, r3, #1
 800e0b8:	f107 0310 	add.w	r3, r7, #16
 800e0bc:	4618      	mov	r0, r3
 800e0be:	f7ff fd1d 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>

				// If there is a stroke, we can fill less points.
				if ( stroke != IMonochromeDisplay::Undefined )
 800e0c2:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e0c6:	2b00      	cmp	r3, #0
 800e0c8:	d00b      	beq.n	800e0e2 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0xca>
				{
					start.x++;
 800e0ca:	69bb      	ldr	r3, [r7, #24]
 800e0cc:	3301      	adds	r3, #1
 800e0ce:	61bb      	str	r3, [r7, #24]
					start.y++;
 800e0d0:	69fb      	ldr	r3, [r7, #28]
 800e0d2:	3301      	adds	r3, #1
 800e0d4:	61fb      	str	r3, [r7, #28]
					end.x--;
 800e0d6:	693b      	ldr	r3, [r7, #16]
 800e0d8:	3b01      	subs	r3, #1
 800e0da:	613b      	str	r3, [r7, #16]
					end.y--;
 800e0dc:	697b      	ldr	r3, [r7, #20]
 800e0de:	3b01      	subs	r3, #1
 800e0e0:	617b      	str	r3, [r7, #20]
				}

				// Fill the rectangle.
				for ( int x =start.x ; x <= end.x ; ++x )
 800e0e2:	69bb      	ldr	r3, [r7, #24]
 800e0e4:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e0e6:	693b      	ldr	r3, [r7, #16]
 800e0e8:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e0ea:	429a      	cmp	r2, r3
 800e0ec:	dc1c      	bgt.n	800e128 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x110>
					for ( int y = start.y ; y <= end.y ; ++y )
 800e0ee:	69fb      	ldr	r3, [r7, #28]
 800e0f0:	65bb      	str	r3, [r7, #88]	; 0x58
 800e0f2:	697b      	ldr	r3, [r7, #20]
 800e0f4:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e0f6:	429a      	cmp	r2, r3
 800e0f8:	dc12      	bgt.n	800e120 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x108>
						_setPixel( IMonochromeDisplay::Point( x , y ) , fill );
 800e0fa:	f107 0320 	add.w	r3, r7, #32
 800e0fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e100:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e102:	4618      	mov	r0, r3
 800e104:	f7ff fcfa 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
 800e108:	f997 2070 	ldrsb.w	r2, [r7, #112]	; 0x70
 800e10c:	f107 0320 	add.w	r3, r7, #32
 800e110:	4619      	mov	r1, r3
 800e112:	68f8      	ldr	r0, [r7, #12]
 800e114:	f000 fa07 	bl	800e526 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>
					for ( int y = start.y ; y <= end.y ; ++y )
 800e118:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e11a:	3301      	adds	r3, #1
 800e11c:	65bb      	str	r3, [r7, #88]	; 0x58
 800e11e:	e7e8      	b.n	800e0f2 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0xda>
				for ( int x =start.x ; x <= end.x ; ++x )
 800e120:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e122:	3301      	adds	r3, #1
 800e124:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e126:	e7de      	b.n	800e0e6 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0xce>
			}
		}

		// Draw border if needed.
		if ( stroke != IMonochromeDisplay::Undefined )
 800e128:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e12c:	2b00      	cmp	r3, #0
 800e12e:	f000 809e 	beq.w	800e26e <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x256>
		{
			// Try first the accelerated method.
			if ( _accelMethods.drawRectangleStrokeAccelerated && !_offscreenBitmap )
 800e132:	68fb      	ldr	r3, [r7, #12]
 800e134:	7a1b      	ldrb	r3, [r3, #8]
 800e136:	f003 0308 	and.w	r3, r3, #8
 800e13a:	b2db      	uxtb	r3, r3
 800e13c:	2b00      	cmp	r3, #0
 800e13e:	d010      	beq.n	800e162 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x14a>
 800e140:	68fb      	ldr	r3, [r7, #12]
 800e142:	68db      	ldr	r3, [r3, #12]
 800e144:	2b00      	cmp	r3, #0
 800e146:	d10c      	bne.n	800e162 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x14a>
			{
				_display->drawRectangle( topLeft , size , stroke );
 800e148:	68fb      	ldr	r3, [r7, #12]
 800e14a:	6858      	ldr	r0, [r3, #4]
 800e14c:	68fb      	ldr	r3, [r7, #12]
 800e14e:	685b      	ldr	r3, [r3, #4]
 800e150:	681b      	ldr	r3, [r3, #0]
 800e152:	3334      	adds	r3, #52	; 0x34
 800e154:	681c      	ldr	r4, [r3, #0]
 800e156:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e15a:	687a      	ldr	r2, [r7, #4]
 800e15c:	68b9      	ldr	r1, [r7, #8]
 800e15e:	47a0      	blx	r4
 800e160:	e085      	b.n	800e26e <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x256>

			// Fall back to software rendered method.
			else
			{
				// If memory copy acceleration is supported, ensure that the local buffer is ready.
				if ( _accelMethods.memoryCopyAccelerated )
 800e162:	68fb      	ldr	r3, [r7, #12]
 800e164:	7a1b      	ldrb	r3, [r3, #8]
 800e166:	f003 0302 	and.w	r3, r3, #2
 800e16a:	b2db      	uxtb	r3, r3
 800e16c:	2b00      	cmp	r3, #0
 800e16e:	d006      	beq.n	800e17e <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x166>
				{
					_createOffsetBitmap( true );
 800e170:	2101      	movs	r1, #1
 800e172:	68f8      	ldr	r0, [r7, #12]
 800e174:	f000 f978 	bl	800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>

					// Do not flush the display buffer 4 times to the display!
					_disableSync = true;
 800e178:	68fb      	ldr	r3, [r7, #12]
 800e17a:	2201      	movs	r2, #1
 800e17c:	741a      	strb	r2, [r3, #16]
				}

				drawLine( topLeft ,
						  IMonochromeDisplay::Point( topLeft.x , topLeft.y + size.height - 1 ) ,
 800e17e:	68bb      	ldr	r3, [r7, #8]
 800e180:	6819      	ldr	r1, [r3, #0]
 800e182:	68bb      	ldr	r3, [r7, #8]
 800e184:	685a      	ldr	r2, [r3, #4]
 800e186:	687b      	ldr	r3, [r7, #4]
 800e188:	685b      	ldr	r3, [r3, #4]
 800e18a:	4413      	add	r3, r2
 800e18c:	1e5a      	subs	r2, r3, #1
 800e18e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800e192:	4618      	mov	r0, r3
 800e194:	f7ff fcb2 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
				drawLine( topLeft ,
 800e198:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e19c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e1a0:	68b9      	ldr	r1, [r7, #8]
 800e1a2:	68f8      	ldr	r0, [r7, #12]
 800e1a4:	f7ff fe4c 	bl	800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>
						  stroke );
				drawLine( IMonochromeDisplay::Point( topLeft.x , topLeft.y + size.height - 1 ) ,
 800e1a8:	68bb      	ldr	r3, [r7, #8]
 800e1aa:	6819      	ldr	r1, [r3, #0]
 800e1ac:	68bb      	ldr	r3, [r7, #8]
 800e1ae:	685a      	ldr	r2, [r3, #4]
 800e1b0:	687b      	ldr	r3, [r7, #4]
 800e1b2:	685b      	ldr	r3, [r3, #4]
 800e1b4:	4413      	add	r3, r2
 800e1b6:	1e5a      	subs	r2, r3, #1
 800e1b8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800e1bc:	4618      	mov	r0, r3
 800e1be:	f7ff fc9d 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
						  IMonochromeDisplay::Point( topLeft.x + size.width - 1 , topLeft.y + size.height - 1 ) ,
 800e1c2:	68bb      	ldr	r3, [r7, #8]
 800e1c4:	681a      	ldr	r2, [r3, #0]
 800e1c6:	687b      	ldr	r3, [r7, #4]
 800e1c8:	681b      	ldr	r3, [r3, #0]
 800e1ca:	4413      	add	r3, r2
 800e1cc:	1e59      	subs	r1, r3, #1
 800e1ce:	68bb      	ldr	r3, [r7, #8]
 800e1d0:	685a      	ldr	r2, [r3, #4]
 800e1d2:	687b      	ldr	r3, [r7, #4]
 800e1d4:	685b      	ldr	r3, [r3, #4]
 800e1d6:	4413      	add	r3, r2
 800e1d8:	1e5a      	subs	r2, r3, #1
 800e1da:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800e1de:	4618      	mov	r0, r3
 800e1e0:	f7ff fc8c 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
				drawLine( IMonochromeDisplay::Point( topLeft.x , topLeft.y + size.height - 1 ) ,
 800e1e4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e1e8:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800e1ec:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800e1f0:	68f8      	ldr	r0, [r7, #12]
 800e1f2:	f7ff fe25 	bl	800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>
						  stroke);
				drawLine( IMonochromeDisplay::Point( topLeft.x + size.width - 1 , topLeft.y + size.height - 1 ) ,
 800e1f6:	68bb      	ldr	r3, [r7, #8]
 800e1f8:	681a      	ldr	r2, [r3, #0]
 800e1fa:	687b      	ldr	r3, [r7, #4]
 800e1fc:	681b      	ldr	r3, [r3, #0]
 800e1fe:	4413      	add	r3, r2
 800e200:	1e59      	subs	r1, r3, #1
 800e202:	68bb      	ldr	r3, [r7, #8]
 800e204:	685a      	ldr	r2, [r3, #4]
 800e206:	687b      	ldr	r3, [r7, #4]
 800e208:	685b      	ldr	r3, [r3, #4]
 800e20a:	4413      	add	r3, r2
 800e20c:	1e5a      	subs	r2, r3, #1
 800e20e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800e212:	4618      	mov	r0, r3
 800e214:	f7ff fc72 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
						  IMonochromeDisplay::Point( topLeft.x + size.width - 1 , topLeft.y ) ,
 800e218:	68bb      	ldr	r3, [r7, #8]
 800e21a:	681a      	ldr	r2, [r3, #0]
 800e21c:	687b      	ldr	r3, [r7, #4]
 800e21e:	681b      	ldr	r3, [r3, #0]
 800e220:	4413      	add	r3, r2
 800e222:	1e59      	subs	r1, r3, #1
 800e224:	68bb      	ldr	r3, [r7, #8]
 800e226:	685a      	ldr	r2, [r3, #4]
 800e228:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800e22c:	4618      	mov	r0, r3
 800e22e:	f7ff fc65 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
				drawLine( IMonochromeDisplay::Point( topLeft.x + size.width - 1 , topLeft.y + size.height - 1 ) ,
 800e232:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e236:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800e23a:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800e23e:	68f8      	ldr	r0, [r7, #12]
 800e240:	f7ff fdfe 	bl	800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>
						  stroke );
				drawLine( IMonochromeDisplay::Point( topLeft.x + size.width - 1 , topLeft.y ) ,
 800e244:	68bb      	ldr	r3, [r7, #8]
 800e246:	681a      	ldr	r2, [r3, #0]
 800e248:	687b      	ldr	r3, [r7, #4]
 800e24a:	681b      	ldr	r3, [r3, #0]
 800e24c:	4413      	add	r3, r2
 800e24e:	1e59      	subs	r1, r3, #1
 800e250:	68bb      	ldr	r3, [r7, #8]
 800e252:	685a      	ldr	r2, [r3, #4]
 800e254:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800e258:	4618      	mov	r0, r3
 800e25a:	f7ff fc4f 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
 800e25e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e262:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800e266:	68ba      	ldr	r2, [r7, #8]
 800e268:	68f8      	ldr	r0, [r7, #12]
 800e26a:	f7ff fde9 	bl	800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>
						  stroke );
			}
		}

		// Finally sync screen.
		_disableSync = false;
 800e26e:	68fb      	ldr	r3, [r7, #12]
 800e270:	2200      	movs	r2, #0
 800e272:	741a      	strb	r2, [r3, #16]
		if ( _autoUpdate )
 800e274:	68fb      	ldr	r3, [r7, #12]
 800e276:	7c5b      	ldrb	r3, [r3, #17]
 800e278:	2b00      	cmp	r3, #0
 800e27a:	d00a      	beq.n	800e292 <_ZN24MonochromeDisplayPainter13drawRectangleERKN18IMonochromeDisplay5PointERKNS0_4SizeENS0_10PixelColorES7_+0x27a>
			_syncDisplay( topLeft.y , topLeft.y + size.height );
 800e27c:	68bb      	ldr	r3, [r7, #8]
 800e27e:	6859      	ldr	r1, [r3, #4]
 800e280:	68bb      	ldr	r3, [r7, #8]
 800e282:	685a      	ldr	r2, [r3, #4]
 800e284:	687b      	ldr	r3, [r7, #4]
 800e286:	685b      	ldr	r3, [r3, #4]
 800e288:	4413      	add	r3, r2
 800e28a:	461a      	mov	r2, r3
 800e28c:	68f8      	ldr	r0, [r7, #12]
 800e28e:	f000 fa38 	bl	800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>
	}
}
 800e292:	bf00      	nop
 800e294:	3764      	adds	r7, #100	; 0x64
 800e296:	46bd      	mov	sp, r7
 800e298:	bd90      	pop	{r4, r7, pc}
 800e29a:	bf00      	nop
 800e29c:	08018da8 	.word	0x08018da8
 800e2a0:	08018f74 	.word	0x08018f74
 800e2a4:	08018dfc 	.word	0x08018dfc

0800e2a8 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE>:
#endif // DISPLAYPAINTER_USE_EXTENED_FEATURES

void MonochromeDisplayPainter::drawText( const IMonochromeDisplay::Point & topLeft ,
			   	   	   	   	   	   	     const std::string & text ,
			   	   	   	   	   	   	     IMonochromeDisplay::PixelColor color )
{
 800e2a8:	b590      	push	{r4, r7, lr}
 800e2aa:	b08f      	sub	sp, #60	; 0x3c
 800e2ac:	af00      	add	r7, sp, #0
 800e2ae:	60f8      	str	r0, [r7, #12]
 800e2b0:	60b9      	str	r1, [r7, #8]
 800e2b2:	607a      	str	r2, [r7, #4]
 800e2b4:	70fb      	strb	r3, [r7, #3]
	assert( _display );
 800e2b6:	68fb      	ldr	r3, [r7, #12]
 800e2b8:	685b      	ldr	r3, [r3, #4]
 800e2ba:	2b00      	cmp	r3, #0
 800e2bc:	d106      	bne.n	800e2cc <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x24>
 800e2be:	4b66      	ldr	r3, [pc, #408]	; (800e458 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1b0>)
 800e2c0:	4a66      	ldr	r2, [pc, #408]	; (800e45c <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1b4>)
 800e2c2:	f240 1193 	movw	r1, #403	; 0x193
 800e2c6:	4866      	ldr	r0, [pc, #408]	; (800e460 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1b8>)
 800e2c8:	f008 f864 	bl	8016394 <__assert_func>
	if ( _display )
 800e2cc:	68fb      	ldr	r3, [r7, #12]
 800e2ce:	685b      	ldr	r3, [r3, #4]
 800e2d0:	2b00      	cmp	r3, #0
 800e2d2:	f000 80bc 	beq.w	800e44e <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1a6>
	{
		// Well we need some text.
		if ( !text.empty() )
 800e2d6:	6878      	ldr	r0, [r7, #4]
 800e2d8:	f007 fff3 	bl	80162c2 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5emptyEv>
 800e2dc:	4603      	mov	r3, r0
 800e2de:	f083 0301 	eor.w	r3, r3, #1
 800e2e2:	b2db      	uxtb	r3, r3
 800e2e4:	2b00      	cmp	r3, #0
 800e2e6:	f000 80b2 	beq.w	800e44e <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1a6>
		{
			// Try first the accelerated method.
			if ( _accelMethods.drawTextAccelerated && !_offscreenBitmap )
 800e2ea:	68fb      	ldr	r3, [r7, #12]
 800e2ec:	7a1b      	ldrb	r3, [r3, #8]
 800e2ee:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800e2f2:	b2db      	uxtb	r3, r3
 800e2f4:	2b00      	cmp	r3, #0
 800e2f6:	d010      	beq.n	800e31a <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x72>
 800e2f8:	68fb      	ldr	r3, [r7, #12]
 800e2fa:	68db      	ldr	r3, [r3, #12]
 800e2fc:	2b00      	cmp	r3, #0
 800e2fe:	d10c      	bne.n	800e31a <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x72>
			{
				_display->drawText( topLeft , text , color );
 800e300:	68fb      	ldr	r3, [r7, #12]
 800e302:	6858      	ldr	r0, [r3, #4]
 800e304:	68fb      	ldr	r3, [r7, #12]
 800e306:	685b      	ldr	r3, [r3, #4]
 800e308:	681b      	ldr	r3, [r3, #0]
 800e30a:	3344      	adds	r3, #68	; 0x44
 800e30c:	681c      	ldr	r4, [r3, #0]
 800e30e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e312:	687a      	ldr	r2, [r7, #4]
 800e314:	68b9      	ldr	r1, [r7, #8]
 800e316:	47a0      	blx	r4
				if ( _autoUpdate )
					_syncDisplay( topLeft.y , topLeft.y + 7 );
			}
		}
	}
}
 800e318:	e099      	b.n	800e44e <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1a6>
				if ( _accelMethods.memoryCopyAccelerated )
 800e31a:	68fb      	ldr	r3, [r7, #12]
 800e31c:	7a1b      	ldrb	r3, [r3, #8]
 800e31e:	f003 0302 	and.w	r3, r3, #2
 800e322:	b2db      	uxtb	r3, r3
 800e324:	2b00      	cmp	r3, #0
 800e326:	d003      	beq.n	800e330 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x88>
					_createOffsetBitmap( true );
 800e328:	2101      	movs	r1, #1
 800e32a:	68f8      	ldr	r0, [r7, #12]
 800e32c:	f000 f89c 	bl	800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>
				IMonochromeDisplay::Point p = topLeft;
 800e330:	68ba      	ldr	r2, [r7, #8]
 800e332:	f107 0310 	add.w	r3, r7, #16
 800e336:	e892 0003 	ldmia.w	r2, {r0, r1}
 800e33a:	e883 0003 	stmia.w	r3, {r0, r1}
				unsigned int textPosition = 0;
 800e33e:	2300      	movs	r3, #0
 800e340:	637b      	str	r3, [r7, #52]	; 0x34
				while( p.x <= ( _display->resolution().width - 5 ) && textPosition < text.size() )
 800e342:	68fb      	ldr	r3, [r7, #12]
 800e344:	6859      	ldr	r1, [r3, #4]
 800e346:	68fb      	ldr	r3, [r7, #12]
 800e348:	685b      	ldr	r3, [r3, #4]
 800e34a:	681b      	ldr	r3, [r3, #0]
 800e34c:	3308      	adds	r3, #8
 800e34e:	681b      	ldr	r3, [r3, #0]
 800e350:	f107 0218 	add.w	r2, r7, #24
 800e354:	4610      	mov	r0, r2
 800e356:	4798      	blx	r3
 800e358:	69bb      	ldr	r3, [r7, #24]
 800e35a:	1f1a      	subs	r2, r3, #4
 800e35c:	693b      	ldr	r3, [r7, #16]
 800e35e:	429a      	cmp	r2, r3
 800e360:	dd08      	ble.n	800e374 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0xcc>
 800e362:	6878      	ldr	r0, [r7, #4]
 800e364:	f007 ffab 	bl	80162be <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv>
 800e368:	4602      	mov	r2, r0
 800e36a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e36c:	4293      	cmp	r3, r2
 800e36e:	d201      	bcs.n	800e374 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0xcc>
 800e370:	2301      	movs	r3, #1
 800e372:	e000      	b.n	800e376 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0xce>
 800e374:	2300      	movs	r3, #0
 800e376:	2b00      	cmp	r3, #0
 800e378:	d05c      	beq.n	800e434 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x18c>
					unsigned char character = text[textPosition];
 800e37a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800e37c:	6878      	ldr	r0, [r7, #4]
 800e37e:	f007 ffa5 	bl	80162cc <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEixEj>
 800e382:	4603      	mov	r3, r0
 800e384:	781b      	ldrb	r3, [r3, #0]
 800e386:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
					if ( character > 223 ) character -= 86;
 800e38a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800e38e:	2bdf      	cmp	r3, #223	; 0xdf
 800e390:	d904      	bls.n	800e39c <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0xf4>
 800e392:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800e396:	3b56      	subs	r3, #86	; 0x56
 800e398:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
					if ( character < 32 || character > 177 ) character = ' ';
 800e39c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800e3a0:	2b1f      	cmp	r3, #31
 800e3a2:	d903      	bls.n	800e3ac <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x104>
 800e3a4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800e3a8:	2bb1      	cmp	r3, #177	; 0xb1
 800e3aa:	d902      	bls.n	800e3b2 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x10a>
 800e3ac:	2320      	movs	r3, #32
 800e3ae:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
					for ( int x = 0 ; x < 5 ; ++x )
 800e3b2:	2300      	movs	r3, #0
 800e3b4:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e3b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e3b8:	2b04      	cmp	r3, #4
 800e3ba:	dc34      	bgt.n	800e426 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x17e>
						for ( int y = 0 ; y < 7 ; ++y )
 800e3bc:	2300      	movs	r3, #0
 800e3be:	62bb      	str	r3, [r7, #40]	; 0x28
 800e3c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e3c2:	2b06      	cmp	r3, #6
 800e3c4:	dc2b      	bgt.n	800e41e <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x176>
							if ( FontLookup[character - 32][x] & ( 1 << y ) )
 800e3c6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800e3ca:	f1a3 0220 	sub.w	r2, r3, #32
 800e3ce:	4925      	ldr	r1, [pc, #148]	; (800e464 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1bc>)
 800e3d0:	4613      	mov	r3, r2
 800e3d2:	005b      	lsls	r3, r3, #1
 800e3d4:	4413      	add	r3, r2
 800e3d6:	005b      	lsls	r3, r3, #1
 800e3d8:	18ca      	adds	r2, r1, r3
 800e3da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e3dc:	4413      	add	r3, r2
 800e3de:	781b      	ldrb	r3, [r3, #0]
 800e3e0:	461a      	mov	r2, r3
 800e3e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e3e4:	fa42 f303 	asr.w	r3, r2, r3
 800e3e8:	f003 0301 	and.w	r3, r3, #1
 800e3ec:	2b00      	cmp	r3, #0
 800e3ee:	d012      	beq.n	800e416 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x16e>
								_setPixel( IMonochromeDisplay::Point( p.x + x , p.y + y ) , color );
 800e3f0:	693a      	ldr	r2, [r7, #16]
 800e3f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e3f4:	18d1      	adds	r1, r2, r3
 800e3f6:	697a      	ldr	r2, [r7, #20]
 800e3f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e3fa:	441a      	add	r2, r3
 800e3fc:	f107 0320 	add.w	r3, r7, #32
 800e400:	4618      	mov	r0, r3
 800e402:	f7ff fb7b 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
 800e406:	f997 2003 	ldrsb.w	r2, [r7, #3]
 800e40a:	f107 0320 	add.w	r3, r7, #32
 800e40e:	4619      	mov	r1, r3
 800e410:	68f8      	ldr	r0, [r7, #12]
 800e412:	f000 f888 	bl	800e526 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>
						for ( int y = 0 ; y < 7 ; ++y )
 800e416:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e418:	3301      	adds	r3, #1
 800e41a:	62bb      	str	r3, [r7, #40]	; 0x28
 800e41c:	e7d0      	b.n	800e3c0 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x118>
					for ( int x = 0 ; x < 5 ; ++x )
 800e41e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e420:	3301      	adds	r3, #1
 800e422:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e424:	e7c7      	b.n	800e3b6 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x10e>
					textPosition++;
 800e426:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e428:	3301      	adds	r3, #1
 800e42a:	637b      	str	r3, [r7, #52]	; 0x34
					p.x += 6;
 800e42c:	693b      	ldr	r3, [r7, #16]
 800e42e:	3306      	adds	r3, #6
 800e430:	613b      	str	r3, [r7, #16]
				while( p.x <= ( _display->resolution().width - 5 ) && textPosition < text.size() )
 800e432:	e786      	b.n	800e342 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x9a>
				if ( _autoUpdate )
 800e434:	68fb      	ldr	r3, [r7, #12]
 800e436:	7c5b      	ldrb	r3, [r3, #17]
 800e438:	2b00      	cmp	r3, #0
 800e43a:	d008      	beq.n	800e44e <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x1a6>
					_syncDisplay( topLeft.y , topLeft.y + 7 );
 800e43c:	68bb      	ldr	r3, [r7, #8]
 800e43e:	6859      	ldr	r1, [r3, #4]
 800e440:	68bb      	ldr	r3, [r7, #8]
 800e442:	685b      	ldr	r3, [r3, #4]
 800e444:	3307      	adds	r3, #7
 800e446:	461a      	mov	r2, r3
 800e448:	68f8      	ldr	r0, [r7, #12]
 800e44a:	f000 f95a 	bl	800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>
}
 800e44e:	bf00      	nop
 800e450:	373c      	adds	r7, #60	; 0x3c
 800e452:	46bd      	mov	sp, r7
 800e454:	bd90      	pop	{r4, r7, pc}
 800e456:	bf00      	nop
 800e458:	08018da8 	.word	0x08018da8
 800e45c:	08019024 	.word	0x08019024
 800e460:	08018dfc 	.word	0x08018dfc
 800e464:	0801ba48 	.word	0x0801ba48

0800e468 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb>:
	}
}
#endif // DISPLAYPAINTER_USE_EXTENED_FEATURES

void MonochromeDisplayPainter::_createOffsetBitmap( bool copyFromDisplay )
{
 800e468:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e46a:	b08d      	sub	sp, #52	; 0x34
 800e46c:	af00      	add	r7, sp, #0
 800e46e:	60f8      	str	r0, [r7, #12]
 800e470:	460b      	mov	r3, r1
 800e472:	72fb      	strb	r3, [r7, #11]
	// Do we need to create the bitmap or does it already exists?
	if ( !_offscreenBitmap )
 800e474:	68fb      	ldr	r3, [r7, #12]
 800e476:	68db      	ldr	r3, [r3, #12]
 800e478:	2b00      	cmp	r3, #0
 800e47a:	d150      	bne.n	800e51e <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb+0xb6>
	{
		// Allocate memory for off-screen bitmap.
		_offscreenBitmap =
			new uint8_t[( ( _display->resolution().width * _display->resolution().height ) + 7 ) / 8];
 800e47c:	68fb      	ldr	r3, [r7, #12]
 800e47e:	6859      	ldr	r1, [r3, #4]
 800e480:	68fb      	ldr	r3, [r7, #12]
 800e482:	685b      	ldr	r3, [r3, #4]
 800e484:	681b      	ldr	r3, [r3, #0]
 800e486:	3308      	adds	r3, #8
 800e488:	681b      	ldr	r3, [r3, #0]
 800e48a:	f107 0210 	add.w	r2, r7, #16
 800e48e:	4610      	mov	r0, r2
 800e490:	4798      	blx	r3
 800e492:	693c      	ldr	r4, [r7, #16]
 800e494:	68fb      	ldr	r3, [r7, #12]
 800e496:	6859      	ldr	r1, [r3, #4]
 800e498:	68fb      	ldr	r3, [r7, #12]
 800e49a:	685b      	ldr	r3, [r3, #4]
 800e49c:	681b      	ldr	r3, [r3, #0]
 800e49e:	3308      	adds	r3, #8
 800e4a0:	681b      	ldr	r3, [r3, #0]
 800e4a2:	f107 0218 	add.w	r2, r7, #24
 800e4a6:	4610      	mov	r0, r2
 800e4a8:	4798      	blx	r3
 800e4aa:	69fb      	ldr	r3, [r7, #28]
 800e4ac:	fb04 f303 	mul.w	r3, r4, r3
 800e4b0:	3307      	adds	r3, #7
 800e4b2:	2b00      	cmp	r3, #0
 800e4b4:	da00      	bge.n	800e4b8 <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb+0x50>
 800e4b6:	3307      	adds	r3, #7
 800e4b8:	10db      	asrs	r3, r3, #3
 800e4ba:	4618      	mov	r0, r3
 800e4bc:	f007 fe9a 	bl	80161f4 <_Znaj>
 800e4c0:	4603      	mov	r3, r0
 800e4c2:	461a      	mov	r2, r3
		_offscreenBitmap =
 800e4c4:	68fb      	ldr	r3, [r7, #12]
 800e4c6:	60da      	str	r2, [r3, #12]

		// If needed, we copy the actual content of the display to the off-screen buffer.
		if ( copyFromDisplay )
 800e4c8:	7afb      	ldrb	r3, [r7, #11]
 800e4ca:	2b00      	cmp	r3, #0
 800e4cc:	d027      	beq.n	800e51e <_ZN24MonochromeDisplayPainter19_createOffsetBitmapEb+0xb6>
			_display->readDisplayMemory( 0 , _offscreenBitmap ,
 800e4ce:	68fb      	ldr	r3, [r7, #12]
 800e4d0:	685e      	ldr	r6, [r3, #4]
 800e4d2:	68fb      	ldr	r3, [r7, #12]
 800e4d4:	685b      	ldr	r3, [r3, #4]
					_display->resolution().width * _display->resolution().height );
 800e4d6:	681b      	ldr	r3, [r3, #0]
 800e4d8:	332c      	adds	r3, #44	; 0x2c
 800e4da:	681c      	ldr	r4, [r3, #0]
			_display->readDisplayMemory( 0 , _offscreenBitmap ,
 800e4dc:	68fb      	ldr	r3, [r7, #12]
 800e4de:	68db      	ldr	r3, [r3, #12]
 800e4e0:	607b      	str	r3, [r7, #4]
					_display->resolution().width * _display->resolution().height );
 800e4e2:	68fb      	ldr	r3, [r7, #12]
 800e4e4:	6859      	ldr	r1, [r3, #4]
 800e4e6:	68fb      	ldr	r3, [r7, #12]
 800e4e8:	685b      	ldr	r3, [r3, #4]
 800e4ea:	681b      	ldr	r3, [r3, #0]
 800e4ec:	3308      	adds	r3, #8
 800e4ee:	681b      	ldr	r3, [r3, #0]
 800e4f0:	f107 0220 	add.w	r2, r7, #32
 800e4f4:	4610      	mov	r0, r2
 800e4f6:	4798      	blx	r3
 800e4f8:	6a3d      	ldr	r5, [r7, #32]
 800e4fa:	68fb      	ldr	r3, [r7, #12]
 800e4fc:	6859      	ldr	r1, [r3, #4]
 800e4fe:	68fb      	ldr	r3, [r7, #12]
 800e500:	685b      	ldr	r3, [r3, #4]
 800e502:	681b      	ldr	r3, [r3, #0]
 800e504:	3308      	adds	r3, #8
 800e506:	681b      	ldr	r3, [r3, #0]
 800e508:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e50c:	4610      	mov	r0, r2
 800e50e:	4798      	blx	r3
 800e510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e512:	fb05 f303 	mul.w	r3, r5, r3
			_display->readDisplayMemory( 0 , _offscreenBitmap ,
 800e516:	687a      	ldr	r2, [r7, #4]
 800e518:	2100      	movs	r1, #0
 800e51a:	4630      	mov	r0, r6
 800e51c:	47a0      	blx	r4
	}
}
 800e51e:	bf00      	nop
 800e520:	3734      	adds	r7, #52	; 0x34
 800e522:	46bd      	mov	sp, r7
 800e524:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800e526 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>:

void MonochromeDisplayPainter::_setPixel( const IMonochromeDisplay::Point & p , IMonochromeDisplay::PixelColor color )
{
 800e526:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e528:	b091      	sub	sp, #68	; 0x44
 800e52a:	af00      	add	r7, sp, #0
 800e52c:	60f8      	str	r0, [r7, #12]
 800e52e:	60b9      	str	r1, [r7, #8]
 800e530:	4613      	mov	r3, r2
 800e532:	71fb      	strb	r3, [r7, #7]
	// Check pixel bounds.
	if ( p.x >= 0 && p.x < _display->resolution().width && p.y >= 0 && p.y < _display->resolution().height )
 800e534:	68bb      	ldr	r3, [r7, #8]
 800e536:	681b      	ldr	r3, [r3, #0]
 800e538:	2b00      	cmp	r3, #0
 800e53a:	db25      	blt.n	800e588 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x62>
 800e53c:	68bb      	ldr	r3, [r7, #8]
 800e53e:	681c      	ldr	r4, [r3, #0]
 800e540:	68fb      	ldr	r3, [r7, #12]
 800e542:	6859      	ldr	r1, [r3, #4]
 800e544:	68fb      	ldr	r3, [r7, #12]
 800e546:	685b      	ldr	r3, [r3, #4]
 800e548:	681b      	ldr	r3, [r3, #0]
 800e54a:	3308      	adds	r3, #8
 800e54c:	681b      	ldr	r3, [r3, #0]
 800e54e:	f107 0210 	add.w	r2, r7, #16
 800e552:	4610      	mov	r0, r2
 800e554:	4798      	blx	r3
 800e556:	693b      	ldr	r3, [r7, #16]
 800e558:	429c      	cmp	r4, r3
 800e55a:	da15      	bge.n	800e588 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x62>
 800e55c:	68bb      	ldr	r3, [r7, #8]
 800e55e:	685b      	ldr	r3, [r3, #4]
 800e560:	2b00      	cmp	r3, #0
 800e562:	db11      	blt.n	800e588 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x62>
 800e564:	68bb      	ldr	r3, [r7, #8]
 800e566:	685c      	ldr	r4, [r3, #4]
 800e568:	68fb      	ldr	r3, [r7, #12]
 800e56a:	6859      	ldr	r1, [r3, #4]
 800e56c:	68fb      	ldr	r3, [r7, #12]
 800e56e:	685b      	ldr	r3, [r3, #4]
 800e570:	681b      	ldr	r3, [r3, #0]
 800e572:	3308      	adds	r3, #8
 800e574:	681b      	ldr	r3, [r3, #0]
 800e576:	f107 0218 	add.w	r2, r7, #24
 800e57a:	4610      	mov	r0, r2
 800e57c:	4798      	blx	r3
 800e57e:	69fb      	ldr	r3, [r7, #28]
 800e580:	429c      	cmp	r4, r3
 800e582:	da01      	bge.n	800e588 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x62>
 800e584:	2301      	movs	r3, #1
 800e586:	e000      	b.n	800e58a <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x64>
 800e588:	2300      	movs	r3, #0
 800e58a:	2b00      	cmp	r3, #0
 800e58c:	f000 80a1 	beq.w	800e6d2 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x1ac>
	{
		// Do we need to draw into the off-screen bitmap?
		if ( _offscreenBitmap )
 800e590:	68fb      	ldr	r3, [r7, #12]
 800e592:	68db      	ldr	r3, [r3, #12]
 800e594:	2b00      	cmp	r3, #0
 800e596:	f000 8091 	beq.w	800e6bc <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x196>
		{
			// Draw into the off-screen bitmap.
			if ( color == IMonochromeDisplay::White )
 800e59a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800e59e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e5a2:	d143      	bne.n	800e62c <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x106>
				*( _offscreenBitmap + ( p.y * _display->resolution().width + p.x ) / 8 ) &=
					~( 1 << ( ( p.y * _display->resolution().width + p.x ) % 8 ) );
 800e5a4:	68bb      	ldr	r3, [r7, #8]
 800e5a6:	685c      	ldr	r4, [r3, #4]
 800e5a8:	68fb      	ldr	r3, [r7, #12]
 800e5aa:	6859      	ldr	r1, [r3, #4]
 800e5ac:	68fb      	ldr	r3, [r7, #12]
 800e5ae:	685b      	ldr	r3, [r3, #4]
 800e5b0:	681b      	ldr	r3, [r3, #0]
 800e5b2:	3308      	adds	r3, #8
 800e5b4:	681b      	ldr	r3, [r3, #0]
 800e5b6:	f107 0220 	add.w	r2, r7, #32
 800e5ba:	4610      	mov	r0, r2
 800e5bc:	4798      	blx	r3
 800e5be:	6a3b      	ldr	r3, [r7, #32]
 800e5c0:	fb03 f204 	mul.w	r2, r3, r4
 800e5c4:	68bb      	ldr	r3, [r7, #8]
 800e5c6:	681b      	ldr	r3, [r3, #0]
 800e5c8:	4413      	add	r3, r2
 800e5ca:	425a      	negs	r2, r3
 800e5cc:	f003 0307 	and.w	r3, r3, #7
 800e5d0:	f002 0207 	and.w	r2, r2, #7
 800e5d4:	bf58      	it	pl
 800e5d6:	4253      	negpl	r3, r2
 800e5d8:	2201      	movs	r2, #1
 800e5da:	fa02 f303 	lsl.w	r3, r2, r3
 800e5de:	43de      	mvns	r6, r3
				*( _offscreenBitmap + ( p.y * _display->resolution().width + p.x ) / 8 ) &=
 800e5e0:	68fb      	ldr	r3, [r7, #12]
 800e5e2:	68dc      	ldr	r4, [r3, #12]
 800e5e4:	68bb      	ldr	r3, [r7, #8]
 800e5e6:	685d      	ldr	r5, [r3, #4]
 800e5e8:	68fb      	ldr	r3, [r7, #12]
 800e5ea:	6859      	ldr	r1, [r3, #4]
 800e5ec:	68fb      	ldr	r3, [r7, #12]
 800e5ee:	685b      	ldr	r3, [r3, #4]
 800e5f0:	681b      	ldr	r3, [r3, #0]
 800e5f2:	3308      	adds	r3, #8
 800e5f4:	681b      	ldr	r3, [r3, #0]
 800e5f6:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e5fa:	4610      	mov	r0, r2
 800e5fc:	4798      	blx	r3
 800e5fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e600:	fb03 f205 	mul.w	r2, r3, r5
 800e604:	68bb      	ldr	r3, [r7, #8]
 800e606:	681b      	ldr	r3, [r3, #0]
 800e608:	4413      	add	r3, r2
 800e60a:	2b00      	cmp	r3, #0
 800e60c:	da00      	bge.n	800e610 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0xea>
 800e60e:	3307      	adds	r3, #7
 800e610:	10db      	asrs	r3, r3, #3
 800e612:	4619      	mov	r1, r3
 800e614:	460b      	mov	r3, r1
 800e616:	4423      	add	r3, r4
 800e618:	781b      	ldrb	r3, [r3, #0]
 800e61a:	b25a      	sxtb	r2, r3
 800e61c:	b273      	sxtb	r3, r6
 800e61e:	4013      	ands	r3, r2
 800e620:	b25a      	sxtb	r2, r3
 800e622:	68fb      	ldr	r3, [r7, #12]
 800e624:	68db      	ldr	r3, [r3, #12]
 800e626:	440b      	add	r3, r1
 800e628:	b2d2      	uxtb	r2, r2
 800e62a:	701a      	strb	r2, [r3, #0]

			if ( color == IMonochromeDisplay::Black )
 800e62c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800e630:	2b01      	cmp	r3, #1
 800e632:	d14e      	bne.n	800e6d2 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x1ac>
				*( _offscreenBitmap + ( p.y * _display->resolution().width + p.x ) / 8 ) |=
					( 1 << ( ( p.y * _display->resolution().width + p.x ) % 8 ) );
 800e634:	68bb      	ldr	r3, [r7, #8]
 800e636:	685c      	ldr	r4, [r3, #4]
 800e638:	68fb      	ldr	r3, [r7, #12]
 800e63a:	6859      	ldr	r1, [r3, #4]
 800e63c:	68fb      	ldr	r3, [r7, #12]
 800e63e:	685b      	ldr	r3, [r3, #4]
 800e640:	681b      	ldr	r3, [r3, #0]
 800e642:	3308      	adds	r3, #8
 800e644:	681b      	ldr	r3, [r3, #0]
 800e646:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800e64a:	4610      	mov	r0, r2
 800e64c:	4798      	blx	r3
 800e64e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e650:	fb03 f204 	mul.w	r2, r3, r4
 800e654:	68bb      	ldr	r3, [r7, #8]
 800e656:	681b      	ldr	r3, [r3, #0]
 800e658:	4413      	add	r3, r2
 800e65a:	425a      	negs	r2, r3
 800e65c:	f003 0307 	and.w	r3, r3, #7
 800e660:	f002 0207 	and.w	r2, r2, #7
 800e664:	bf58      	it	pl
 800e666:	4253      	negpl	r3, r2
 800e668:	2201      	movs	r2, #1
 800e66a:	fa02 f603 	lsl.w	r6, r2, r3
				*( _offscreenBitmap + ( p.y * _display->resolution().width + p.x ) / 8 ) |=
 800e66e:	68fb      	ldr	r3, [r7, #12]
 800e670:	68dc      	ldr	r4, [r3, #12]
 800e672:	68bb      	ldr	r3, [r7, #8]
 800e674:	685d      	ldr	r5, [r3, #4]
 800e676:	68fb      	ldr	r3, [r7, #12]
 800e678:	6859      	ldr	r1, [r3, #4]
 800e67a:	68fb      	ldr	r3, [r7, #12]
 800e67c:	685b      	ldr	r3, [r3, #4]
 800e67e:	681b      	ldr	r3, [r3, #0]
 800e680:	3308      	adds	r3, #8
 800e682:	681b      	ldr	r3, [r3, #0]
 800e684:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800e688:	4610      	mov	r0, r2
 800e68a:	4798      	blx	r3
 800e68c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e68e:	fb03 f205 	mul.w	r2, r3, r5
 800e692:	68bb      	ldr	r3, [r7, #8]
 800e694:	681b      	ldr	r3, [r3, #0]
 800e696:	4413      	add	r3, r2
 800e698:	2b00      	cmp	r3, #0
 800e69a:	da00      	bge.n	800e69e <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x178>
 800e69c:	3307      	adds	r3, #7
 800e69e:	10db      	asrs	r3, r3, #3
 800e6a0:	4619      	mov	r1, r3
 800e6a2:	460b      	mov	r3, r1
 800e6a4:	4423      	add	r3, r4
 800e6a6:	781b      	ldrb	r3, [r3, #0]
 800e6a8:	b25a      	sxtb	r2, r3
 800e6aa:	b273      	sxtb	r3, r6
 800e6ac:	4313      	orrs	r3, r2
 800e6ae:	b25a      	sxtb	r2, r3
 800e6b0:	68fb      	ldr	r3, [r7, #12]
 800e6b2:	68db      	ldr	r3, [r3, #12]
 800e6b4:	440b      	add	r3, r1
 800e6b6:	b2d2      	uxtb	r2, r2
 800e6b8:	701a      	strb	r2, [r3, #0]
		{
			// Draw directly onto the display.
			_display->setPixel( p , color );
		}
	}
}
 800e6ba:	e00a      	b.n	800e6d2 <_ZN24MonochromeDisplayPainter9_setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE+0x1ac>
			_display->setPixel( p , color );
 800e6bc:	68fb      	ldr	r3, [r7, #12]
 800e6be:	6858      	ldr	r0, [r3, #4]
 800e6c0:	68fb      	ldr	r3, [r7, #12]
 800e6c2:	685b      	ldr	r3, [r3, #4]
 800e6c4:	681b      	ldr	r3, [r3, #0]
 800e6c6:	3320      	adds	r3, #32
 800e6c8:	681b      	ldr	r3, [r3, #0]
 800e6ca:	f997 2007 	ldrsb.w	r2, [r7, #7]
 800e6ce:	68b9      	ldr	r1, [r7, #8]
 800e6d0:	4798      	blx	r3
}
 800e6d2:	bf00      	nop
 800e6d4:	3744      	adds	r7, #68	; 0x44
 800e6d6:	46bd      	mov	sp, r7
 800e6d8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800e6da <_ZSt3minIiERKT_S2_S2_>:
    min(const _Tp& __a, const _Tp& __b)
 800e6da:	b480      	push	{r7}
 800e6dc:	b083      	sub	sp, #12
 800e6de:	af00      	add	r7, sp, #0
 800e6e0:	6078      	str	r0, [r7, #4]
 800e6e2:	6039      	str	r1, [r7, #0]
      if (__b < __a)
 800e6e4:	683b      	ldr	r3, [r7, #0]
 800e6e6:	681a      	ldr	r2, [r3, #0]
 800e6e8:	687b      	ldr	r3, [r7, #4]
 800e6ea:	681b      	ldr	r3, [r3, #0]
 800e6ec:	429a      	cmp	r2, r3
 800e6ee:	da01      	bge.n	800e6f4 <_ZSt3minIiERKT_S2_S2_+0x1a>
	return __b;
 800e6f0:	683b      	ldr	r3, [r7, #0]
 800e6f2:	e000      	b.n	800e6f6 <_ZSt3minIiERKT_S2_S2_+0x1c>
      return __a;
 800e6f4:	687b      	ldr	r3, [r7, #4]
    }
 800e6f6:	4618      	mov	r0, r3
 800e6f8:	370c      	adds	r7, #12
 800e6fa:	46bd      	mov	sp, r7
 800e6fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e700:	4770      	bx	lr

0800e702 <_ZN24MonochromeDisplayPainter12_syncDisplayEii>:

void MonochromeDisplayPainter::_syncDisplay( int startLine , int endLine )
{
 800e702:	b590      	push	{r4, r7, lr}
 800e704:	b091      	sub	sp, #68	; 0x44
 800e706:	af00      	add	r7, sp, #0
 800e708:	60f8      	str	r0, [r7, #12]
 800e70a:	60b9      	str	r1, [r7, #8]
 800e70c:	607a      	str	r2, [r7, #4]
	// Do we need to sync the display.
	if ( _offscreenBitmap && !_disableSync )
 800e70e:	68fb      	ldr	r3, [r7, #12]
 800e710:	68db      	ldr	r3, [r3, #12]
 800e712:	2b00      	cmp	r3, #0
 800e714:	d07b      	beq.n	800e80e <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x10c>
 800e716:	68fb      	ldr	r3, [r7, #12]
 800e718:	7c1b      	ldrb	r3, [r3, #16]
 800e71a:	f083 0301 	eor.w	r3, r3, #1
 800e71e:	b2db      	uxtb	r3, r3
 800e720:	2b00      	cmp	r3, #0
 800e722:	d074      	beq.n	800e80e <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x10c>
	{
		// Check line (Y) bounds.
		if ( startLine >= 0 && startLine <= _display->resolution().height &&
 800e724:	68bb      	ldr	r3, [r7, #8]
			 endLine >= 0 && endLine <= _display->resolution().height )
 800e726:	2b00      	cmp	r3, #0
 800e728:	db22      	blt.n	800e770 <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x6e>
		if ( startLine >= 0 && startLine <= _display->resolution().height &&
 800e72a:	68fb      	ldr	r3, [r7, #12]
 800e72c:	6859      	ldr	r1, [r3, #4]
 800e72e:	68fb      	ldr	r3, [r7, #12]
 800e730:	685b      	ldr	r3, [r3, #4]
 800e732:	681b      	ldr	r3, [r3, #0]
 800e734:	3308      	adds	r3, #8
 800e736:	681b      	ldr	r3, [r3, #0]
 800e738:	f107 0214 	add.w	r2, r7, #20
 800e73c:	4610      	mov	r0, r2
 800e73e:	4798      	blx	r3
 800e740:	69ba      	ldr	r2, [r7, #24]
 800e742:	68bb      	ldr	r3, [r7, #8]
 800e744:	429a      	cmp	r2, r3
 800e746:	db13      	blt.n	800e770 <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x6e>
			 endLine >= 0 && endLine <= _display->resolution().height )
 800e748:	687b      	ldr	r3, [r7, #4]
		if ( startLine >= 0 && startLine <= _display->resolution().height &&
 800e74a:	2b00      	cmp	r3, #0
 800e74c:	db10      	blt.n	800e770 <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x6e>
			 endLine >= 0 && endLine <= _display->resolution().height )
 800e74e:	68fb      	ldr	r3, [r7, #12]
 800e750:	6859      	ldr	r1, [r3, #4]
 800e752:	68fb      	ldr	r3, [r7, #12]
 800e754:	685b      	ldr	r3, [r3, #4]
 800e756:	681b      	ldr	r3, [r3, #0]
 800e758:	3308      	adds	r3, #8
 800e75a:	681b      	ldr	r3, [r3, #0]
 800e75c:	f107 021c 	add.w	r2, r7, #28
 800e760:	4610      	mov	r0, r2
 800e762:	4798      	blx	r3
 800e764:	6a3a      	ldr	r2, [r7, #32]
 800e766:	687b      	ldr	r3, [r7, #4]
 800e768:	429a      	cmp	r2, r3
 800e76a:	db01      	blt.n	800e770 <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x6e>
 800e76c:	2301      	movs	r3, #1
 800e76e:	e000      	b.n	800e772 <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x70>
 800e770:	2300      	movs	r3, #0
		if ( startLine >= 0 && startLine <= _display->resolution().height &&
 800e772:	2b00      	cmp	r3, #0
 800e774:	d04b      	beq.n	800e80e <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0x10c>
		{
			size_t bitOffset = std::min( startLine , endLine ) * _display->resolution().width;
 800e776:	1d3a      	adds	r2, r7, #4
 800e778:	f107 0308 	add.w	r3, r7, #8
 800e77c:	4611      	mov	r1, r2
 800e77e:	4618      	mov	r0, r3
 800e780:	f7ff ffab 	bl	800e6da <_ZSt3minIiERKT_S2_S2_>
 800e784:	4603      	mov	r3, r0
 800e786:	681c      	ldr	r4, [r3, #0]
 800e788:	68fb      	ldr	r3, [r7, #12]
 800e78a:	6859      	ldr	r1, [r3, #4]
 800e78c:	68fb      	ldr	r3, [r7, #12]
 800e78e:	685b      	ldr	r3, [r3, #4]
 800e790:	681b      	ldr	r3, [r3, #0]
 800e792:	3308      	adds	r3, #8
 800e794:	681b      	ldr	r3, [r3, #0]
 800e796:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800e79a:	4610      	mov	r0, r2
 800e79c:	4798      	blx	r3
 800e79e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e7a0:	fb04 f303 	mul.w	r3, r4, r3
 800e7a4:	63fb      	str	r3, [r7, #60]	; 0x3c
			size_t numberOfBits = _display->resolution().width * abs( endLine - startLine );
 800e7a6:	68fb      	ldr	r3, [r7, #12]
 800e7a8:	6859      	ldr	r1, [r3, #4]
 800e7aa:	68fb      	ldr	r3, [r7, #12]
 800e7ac:	685b      	ldr	r3, [r3, #4]
 800e7ae:	681b      	ldr	r3, [r3, #0]
 800e7b0:	3308      	adds	r3, #8
 800e7b2:	681b      	ldr	r3, [r3, #0]
 800e7b4:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800e7b8:	4610      	mov	r0, r2
 800e7ba:	4798      	blx	r3
 800e7bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e7be:	6879      	ldr	r1, [r7, #4]
 800e7c0:	68ba      	ldr	r2, [r7, #8]
 800e7c2:	1a8a      	subs	r2, r1, r2
 800e7c4:	2a00      	cmp	r2, #0
 800e7c6:	bfb8      	it	lt
 800e7c8:	4252      	neglt	r2, r2
 800e7ca:	fb02 f303 	mul.w	r3, r2, r3
 800e7ce:	63bb      	str	r3, [r7, #56]	; 0x38
			size_t modulo = bitOffset % 8;
 800e7d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e7d2:	f003 0307 	and.w	r3, r3, #7
 800e7d6:	637b      	str	r3, [r7, #52]	; 0x34

			// Align the start address and the number of bits to 8 bit bounds.
			if ( modulo )
 800e7d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e7da:	2b00      	cmp	r3, #0
 800e7dc:	d007      	beq.n	800e7ee <_ZN24MonochromeDisplayPainter12_syncDisplayEii+0xec>
			{
				bitOffset -= modulo;
 800e7de:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e7e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e7e2:	1ad3      	subs	r3, r2, r3
 800e7e4:	63fb      	str	r3, [r7, #60]	; 0x3c
				numberOfBits += modulo;
 800e7e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e7e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e7ea:	4413      	add	r3, r2
 800e7ec:	63bb      	str	r3, [r7, #56]	; 0x38
			}

			// Write the off-screen bitmap buffer to the display.
			_display->writeDisplayMemory( bitOffset / 8 , _offscreenBitmap + bitOffset / 8 , numberOfBits );
 800e7ee:	68fb      	ldr	r3, [r7, #12]
 800e7f0:	6858      	ldr	r0, [r3, #4]
 800e7f2:	68fb      	ldr	r3, [r7, #12]
 800e7f4:	685b      	ldr	r3, [r3, #4]
 800e7f6:	681b      	ldr	r3, [r3, #0]
 800e7f8:	3328      	adds	r3, #40	; 0x28
 800e7fa:	681c      	ldr	r4, [r3, #0]
 800e7fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e7fe:	08d9      	lsrs	r1, r3, #3
 800e800:	68fb      	ldr	r3, [r7, #12]
 800e802:	68da      	ldr	r2, [r3, #12]
 800e804:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e806:	08db      	lsrs	r3, r3, #3
 800e808:	441a      	add	r2, r3
 800e80a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e80c:	47a0      	blx	r4
		}
	}
}
 800e80e:	bf00      	nop
 800e810:	3744      	adds	r7, #68	; 0x44
 800e812:	46bd      	mov	sp, r7
 800e814:	bd90      	pop	{r4, r7, pc}
	...

0800e818 <_Z41__static_initialization_and_destruction_0ii>:
 800e818:	b580      	push	{r7, lr}
 800e81a:	b088      	sub	sp, #32
 800e81c:	af00      	add	r7, sp, #0
 800e81e:	6078      	str	r0, [r7, #4]
 800e820:	6039      	str	r1, [r7, #0]
 800e822:	687b      	ldr	r3, [r7, #4]
 800e824:	2b01      	cmp	r3, #1
 800e826:	d122      	bne.n	800e86e <_Z41__static_initialization_and_destruction_0ii+0x56>
 800e828:	683b      	ldr	r3, [r7, #0]
 800e82a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e82e:	4293      	cmp	r3, r2
 800e830:	d11d      	bne.n	800e86e <_Z41__static_initialization_and_destruction_0ii+0x56>
 800e832:	4b18      	ldr	r3, [pc, #96]	; (800e894 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800e834:	681b      	ldr	r3, [r3, #0]
 800e836:	613b      	str	r3, [r7, #16]
 800e838:	f107 0310 	add.w	r3, r7, #16
 800e83c:	60bb      	str	r3, [r7, #8]
 800e83e:	2304      	movs	r3, #4
 800e840:	60fb      	str	r3, [r7, #12]
 800e842:	f107 0308 	add.w	r3, r7, #8
 800e846:	e893 0006 	ldmia.w	r3, {r1, r2}
 800e84a:	4813      	ldr	r0, [pc, #76]	; (800e898 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800e84c:	f7f8 fa72 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800e850:	4b12      	ldr	r3, [pc, #72]	; (800e89c <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800e852:	681b      	ldr	r3, [r3, #0]
 800e854:	61fb      	str	r3, [r7, #28]
 800e856:	f107 031c 	add.w	r3, r7, #28
 800e85a:	617b      	str	r3, [r7, #20]
 800e85c:	2304      	movs	r3, #4
 800e85e:	61bb      	str	r3, [r7, #24]
 800e860:	f107 0314 	add.w	r3, r7, #20
 800e864:	e893 0006 	ldmia.w	r3, {r1, r2}
 800e868:	480d      	ldr	r0, [pc, #52]	; (800e8a0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800e86a:	f7f8 fa63 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800e86e:	687b      	ldr	r3, [r7, #4]
 800e870:	2b00      	cmp	r3, #0
 800e872:	d10a      	bne.n	800e88a <_Z41__static_initialization_and_destruction_0ii+0x72>
 800e874:	683b      	ldr	r3, [r7, #0]
 800e876:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e87a:	4293      	cmp	r3, r2
 800e87c:	d105      	bne.n	800e88a <_Z41__static_initialization_and_destruction_0ii+0x72>
 800e87e:	4808      	ldr	r0, [pc, #32]	; (800e8a0 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800e880:	f7f8 fba2 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800e884:	4804      	ldr	r0, [pc, #16]	; (800e898 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800e886:	f7f8 fb9f 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800e88a:	bf00      	nop
 800e88c:	3720      	adds	r7, #32
 800e88e:	46bd      	mov	sp, r7
 800e890:	bd80      	pop	{r7, pc}
 800e892:	bf00      	nop
 800e894:	08019188 	.word	0x08019188
 800e898:	20001948 	.word	0x20001948
 800e89c:	0801918c 	.word	0x0801918c
 800e8a0:	20001950 	.word	0x20001950

0800e8a4 <_GLOBAL__sub_I__ZN24MonochromeDisplayPainterC2EP18IMonochromeDisplayb>:
 800e8a4:	b580      	push	{r7, lr}
 800e8a6:	af00      	add	r7, sp, #0
 800e8a8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800e8ac:	2001      	movs	r0, #1
 800e8ae:	f7ff ffb3 	bl	800e818 <_Z41__static_initialization_and_destruction_0ii>
 800e8b2:	bd80      	pop	{r7, pc}

0800e8b4 <_GLOBAL__sub_D__ZN24MonochromeDisplayPainterC2EP18IMonochromeDisplayb>:
 800e8b4:	b580      	push	{r7, lr}
 800e8b6:	af00      	add	r7, sp, #0
 800e8b8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800e8bc:	2000      	movs	r0, #0
 800e8be:	f7ff ffab 	bl	800e818 <_Z41__static_initialization_and_destruction_0ii>
 800e8c2:	bd80      	pop	{r7, pc}

0800e8c4 <_ZN5board13Accelerometer13isInitializedEv>:
	static void getAccelerationValues(int16_t & x, int16_t & y, int16_t & z);
	static void onIrq(uint16_t GPIO_Pin);

protected:
	static void initializeAccelerometer();
	inline static bool isInitialized() { return _bInitialized; }
 800e8c4:	b480      	push	{r7}
 800e8c6:	af00      	add	r7, sp, #0
 800e8c8:	4b03      	ldr	r3, [pc, #12]	; (800e8d8 <_ZN5board13Accelerometer13isInitializedEv+0x14>)
 800e8ca:	781b      	ldrb	r3, [r3, #0]
 800e8cc:	4618      	mov	r0, r3
 800e8ce:	46bd      	mov	sp, r7
 800e8d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8d4:	4770      	bx	lr
 800e8d6:	bf00      	nop
 800e8d8:	20001968 	.word	0x20001968

0800e8dc <_ZN5board13Accelerometer23initializeAccelerometerEv>:
} acc_data;

bool Accelerometer::_bInitialized = false;

void Accelerometer::initializeAccelerometer()
{
 800e8dc:	b580      	push	{r7, lr}
 800e8de:	af00      	add	r7, sp, #0
    Accelerometer_Init();
 800e8e0:	f000 f8a8 	bl	800ea34 <Accelerometer_Init>

#if (ACCELEROMETER_ENABLE_IRQ != 0)
    Accelerometer_EnableInterrupt();
#endif
}
 800e8e4:	bf00      	nop
 800e8e6:	bd80      	pop	{r7, pc}

0800e8e8 <_ZN5board13Accelerometer21getAccelerationValuesERsS1_S1_>:

// static
void Accelerometer::getAccelerationValues(int16_t & x, int16_t & y, int16_t & z)
{
 800e8e8:	b580      	push	{r7, lr}
 800e8ea:	b086      	sub	sp, #24
 800e8ec:	af00      	add	r7, sp, #0
 800e8ee:	60f8      	str	r0, [r7, #12]
 800e8f0:	60b9      	str	r1, [r7, #8]
 800e8f2:	607a      	str	r2, [r7, #4]
	int16_t tx = 0, ty = 0, tz = 0;
 800e8f4:	2300      	movs	r3, #0
 800e8f6:	82fb      	strh	r3, [r7, #22]
 800e8f8:	2300      	movs	r3, #0
 800e8fa:	82bb      	strh	r3, [r7, #20]
 800e8fc:	2300      	movs	r3, #0
 800e8fe:	827b      	strh	r3, [r7, #18]

	Accelerometer_Get(&tx, &ty, &tz);
 800e900:	f107 0212 	add.w	r2, r7, #18
 800e904:	f107 0114 	add.w	r1, r7, #20
 800e908:	f107 0316 	add.w	r3, r7, #22
 800e90c:	4618      	mov	r0, r3
 800e90e:	f000 f8cd 	bl	800eaac <Accelerometer_Get>

	x = tx;
 800e912:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800e916:	68fb      	ldr	r3, [r7, #12]
 800e918:	801a      	strh	r2, [r3, #0]
	y = ty;
 800e91a:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800e91e:	68bb      	ldr	r3, [r7, #8]
 800e920:	801a      	strh	r2, [r3, #0]
	z = tz;
 800e922:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 800e926:	687b      	ldr	r3, [r7, #4]
 800e928:	801a      	strh	r2, [r3, #0]
}
 800e92a:	bf00      	nop
 800e92c:	3718      	adds	r7, #24
 800e92e:	46bd      	mov	sp, r7
 800e930:	bd80      	pop	{r7, pc}

0800e932 <_ZN5board13Accelerometer5onIrqEt>:

void Accelerometer::onIrq(uint16_t GPIO_Pin)
{
 800e932:	b480      	push	{r7}
 800e934:	b083      	sub	sp, #12
 800e936:	af00      	add	r7, sp, #0
 800e938:	4603      	mov	r3, r0
 800e93a:	80fb      	strh	r3, [r7, #6]
	Trace::outln("Acc::FF_WU_SRC");
#endif
#if (ACCELEROMETER_ENABLE_IRQ != 0)
	Accelerometer_ClearInterrupt();
#endif
}
 800e93c:	bf00      	nop
 800e93e:	370c      	adds	r7, #12
 800e940:	46bd      	mov	sp, r7
 800e942:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e946:	4770      	bx	lr

0800e948 <_ZN5board13Accelerometer10initializeEv>:

bool Accelerometer::initialize()
{
 800e948:	b580      	push	{r7, lr}
 800e94a:	b082      	sub	sp, #8
 800e94c:	af00      	add	r7, sp, #0
 800e94e:	6078      	str	r0, [r7, #4]
	if (!isInitialized())
 800e950:	f7ff ffb8 	bl	800e8c4 <_ZN5board13Accelerometer13isInitializedEv>
 800e954:	4603      	mov	r3, r0
 800e956:	f083 0301 	eor.w	r3, r3, #1
 800e95a:	b2db      	uxtb	r3, r3
 800e95c:	2b00      	cmp	r3, #0
 800e95e:	d003      	beq.n	800e968 <_ZN5board13Accelerometer10initializeEv+0x20>
	{
		initializeAccelerometer();
 800e960:	f7ff ffbc 	bl	800e8dc <_ZN5board13Accelerometer23initializeAccelerometerEv>
		return true;
 800e964:	2301      	movs	r3, #1
 800e966:	e005      	b.n	800e974 <_ZN5board13Accelerometer10initializeEv+0x2c>
	}
	assert(false);	// Resource should only be initialized once. Maybe you have more then one instance of Accelerometer.
 800e968:	4b04      	ldr	r3, [pc, #16]	; (800e97c <_ZN5board13Accelerometer10initializeEv+0x34>)
 800e96a:	4a05      	ldr	r2, [pc, #20]	; (800e980 <_ZN5board13Accelerometer10initializeEv+0x38>)
 800e96c:	213a      	movs	r1, #58	; 0x3a
 800e96e:	4805      	ldr	r0, [pc, #20]	; (800e984 <_ZN5board13Accelerometer10initializeEv+0x3c>)
 800e970:	f007 fd10 	bl	8016394 <__assert_func>
	return false;
}
 800e974:	4618      	mov	r0, r3
 800e976:	3708      	adds	r7, #8
 800e978:	46bd      	mov	sp, r7
 800e97a:	bd80      	pop	{r7, pc}
 800e97c:	08019190 	.word	0x08019190
 800e980:	08019198 	.word	0x08019198
 800e984:	080191c0 	.word	0x080191c0

0800e988 <_Z41__static_initialization_and_destruction_0ii>:
	Trace::out("Acc::wakeup");
#endif
	Accelerometer_Init();
}

} // namespace board
 800e988:	b580      	push	{r7, lr}
 800e98a:	b088      	sub	sp, #32
 800e98c:	af00      	add	r7, sp, #0
 800e98e:	6078      	str	r0, [r7, #4]
 800e990:	6039      	str	r1, [r7, #0]
 800e992:	687b      	ldr	r3, [r7, #4]
 800e994:	2b01      	cmp	r3, #1
 800e996:	d122      	bne.n	800e9de <_Z41__static_initialization_and_destruction_0ii+0x56>
 800e998:	683b      	ldr	r3, [r7, #0]
 800e99a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e99e:	4293      	cmp	r3, r2
 800e9a0:	d11d      	bne.n	800e9de <_Z41__static_initialization_and_destruction_0ii+0x56>
 800e9a2:	4b18      	ldr	r3, [pc, #96]	; (800ea04 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800e9a4:	681b      	ldr	r3, [r3, #0]
 800e9a6:	613b      	str	r3, [r7, #16]
 800e9a8:	f107 0310 	add.w	r3, r7, #16
 800e9ac:	60bb      	str	r3, [r7, #8]
 800e9ae:	2304      	movs	r3, #4
 800e9b0:	60fb      	str	r3, [r7, #12]
 800e9b2:	f107 0308 	add.w	r3, r7, #8
 800e9b6:	e893 0006 	ldmia.w	r3, {r1, r2}
 800e9ba:	4813      	ldr	r0, [pc, #76]	; (800ea08 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800e9bc:	f7f8 f9ba 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800e9c0:	4b12      	ldr	r3, [pc, #72]	; (800ea0c <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800e9c2:	681b      	ldr	r3, [r3, #0]
 800e9c4:	61fb      	str	r3, [r7, #28]
 800e9c6:	f107 031c 	add.w	r3, r7, #28
 800e9ca:	617b      	str	r3, [r7, #20]
 800e9cc:	2304      	movs	r3, #4
 800e9ce:	61bb      	str	r3, [r7, #24]
 800e9d0:	f107 0314 	add.w	r3, r7, #20
 800e9d4:	e893 0006 	ldmia.w	r3, {r1, r2}
 800e9d8:	480d      	ldr	r0, [pc, #52]	; (800ea10 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800e9da:	f7f8 f9ab 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800e9de:	687b      	ldr	r3, [r7, #4]
 800e9e0:	2b00      	cmp	r3, #0
 800e9e2:	d10a      	bne.n	800e9fa <_Z41__static_initialization_and_destruction_0ii+0x72>
 800e9e4:	683b      	ldr	r3, [r7, #0]
 800e9e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e9ea:	4293      	cmp	r3, r2
 800e9ec:	d105      	bne.n	800e9fa <_Z41__static_initialization_and_destruction_0ii+0x72>
 800e9ee:	4808      	ldr	r0, [pc, #32]	; (800ea10 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800e9f0:	f7f8 faea 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800e9f4:	4804      	ldr	r0, [pc, #16]	; (800ea08 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800e9f6:	f7f8 fae7 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800e9fa:	bf00      	nop
 800e9fc:	3720      	adds	r7, #32
 800e9fe:	46bd      	mov	sp, r7
 800ea00:	bd80      	pop	{r7, pc}
 800ea02:	bf00      	nop
 800ea04:	0801933c 	.word	0x0801933c
 800ea08:	20001958 	.word	0x20001958
 800ea0c:	08019340 	.word	0x08019340
 800ea10:	20001960 	.word	0x20001960

0800ea14 <_GLOBAL__sub_I__ZN5board13Accelerometer13_bInitializedE>:
 800ea14:	b580      	push	{r7, lr}
 800ea16:	af00      	add	r7, sp, #0
 800ea18:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ea1c:	2001      	movs	r0, #1
 800ea1e:	f7ff ffb3 	bl	800e988 <_Z41__static_initialization_and_destruction_0ii>
 800ea22:	bd80      	pop	{r7, pc}

0800ea24 <_GLOBAL__sub_D__ZN5board13Accelerometer13_bInitializedE>:
 800ea24:	b580      	push	{r7, lr}
 800ea26:	af00      	add	r7, sp, #0
 800ea28:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ea2c:	2000      	movs	r0, #0
 800ea2e:	f7ff ffab 	bl	800e988 <_Z41__static_initialization_and_destruction_0ii>
 800ea32:	bd80      	pop	{r7, pc}

0800ea34 <Accelerometer_Init>:

//********************************************************************************
// Init this sensors
//********************************************************************************
uint32_t Accelerometer_Init()
{
 800ea34:	b580      	push	{r7, lr}
 800ea36:	b084      	sub	sp, #16
 800ea38:	af02      	add	r7, sp, #8
    uint8_t data[5];

    data[0] = ACCEL_WHO_AM_I;
 800ea3a:	230f      	movs	r3, #15
 800ea3c:	703b      	strb	r3, [r7, #0]
    HAL_I2C_Master_Transmit(&ACCEL_I2C,ACCEL_ADDR,data,1,20);
 800ea3e:	463a      	mov	r2, r7
 800ea40:	2314      	movs	r3, #20
 800ea42:	9300      	str	r3, [sp, #0]
 800ea44:	2301      	movs	r3, #1
 800ea46:	2132      	movs	r1, #50	; 0x32
 800ea48:	4816      	ldr	r0, [pc, #88]	; (800eaa4 <Accelerometer_Init+0x70>)
 800ea4a:	f7f3 f9a7 	bl	8001d9c <HAL_I2C_Master_Transmit>
    HAL_I2C_Master_Receive(&ACCEL_I2C,ACCEL_ADDR,data,1,20);
 800ea4e:	463a      	mov	r2, r7
 800ea50:	2314      	movs	r3, #20
 800ea52:	9300      	str	r3, [sp, #0]
 800ea54:	2301      	movs	r3, #1
 800ea56:	2132      	movs	r1, #50	; 0x32
 800ea58:	4812      	ldr	r0, [pc, #72]	; (800eaa4 <Accelerometer_Init+0x70>)
 800ea5a:	f7f3 fa93 	bl	8001f84 <HAL_I2C_Master_Receive>
    if(data[0] != ACCEL_WHO_AM_I_DATA)
 800ea5e:	783b      	ldrb	r3, [r7, #0]
 800ea60:	2b33      	cmp	r3, #51	; 0x33
 800ea62:	d001      	beq.n	800ea68 <Accelerometer_Init+0x34>
    {
        return ACCEL_RESPONSE_ERROR;
 800ea64:	4b10      	ldr	r3, [pc, #64]	; (800eaa8 <Accelerometer_Init+0x74>)
 800ea66:	e018      	b.n	800ea9a <Accelerometer_Init+0x66>
    }
    //------------------------------------------------------------------------------
    data[0] = ACCEL_CTRL_REG0;						// disable internal pull-up
 800ea68:	231e      	movs	r3, #30
 800ea6a:	703b      	strb	r3, [r7, #0]
    data[1] = 0x90;												// 25 Hz measure
 800ea6c:	2390      	movs	r3, #144	; 0x90
 800ea6e:	707b      	strb	r3, [r7, #1]
    HAL_I2C_Master_Transmit(&ACCEL_I2C,ACCEL_ADDR,data,2,20);
 800ea70:	463a      	mov	r2, r7
 800ea72:	2314      	movs	r3, #20
 800ea74:	9300      	str	r3, [sp, #0]
 800ea76:	2302      	movs	r3, #2
 800ea78:	2132      	movs	r1, #50	; 0x32
 800ea7a:	480a      	ldr	r0, [pc, #40]	; (800eaa4 <Accelerometer_Init+0x70>)
 800ea7c:	f7f3 f98e 	bl	8001d9c <HAL_I2C_Master_Transmit>
    //------------------------------------------------------------------------------
    data[0] = ACCEL_CTRL_REG1;
 800ea80:	2320      	movs	r3, #32
 800ea82:	703b      	strb	r3, [r7, #0]
    data[1] = 0xB7;												// 25 Hz measure, high resolution
 800ea84:	23b7      	movs	r3, #183	; 0xb7
 800ea86:	707b      	strb	r3, [r7, #1]
    HAL_I2C_Master_Transmit(&ACCEL_I2C,ACCEL_ADDR,data,2,20);
 800ea88:	463a      	mov	r2, r7
 800ea8a:	2314      	movs	r3, #20
 800ea8c:	9300      	str	r3, [sp, #0]
 800ea8e:	2302      	movs	r3, #2
 800ea90:	2132      	movs	r1, #50	; 0x32
 800ea92:	4804      	ldr	r0, [pc, #16]	; (800eaa4 <Accelerometer_Init+0x70>)
 800ea94:	f7f3 f982 	bl	8001d9c <HAL_I2C_Master_Transmit>

    return 0;   // no error
 800ea98:	2300      	movs	r3, #0
}
 800ea9a:	4618      	mov	r0, r3
 800ea9c:	3708      	adds	r7, #8
 800ea9e:	46bd      	mov	sp, r7
 800eaa0:	bd80      	pop	{r7, pc}
 800eaa2:	bf00      	nop
 800eaa4:	2000009c 	.word	0x2000009c
 800eaa8:	ffff0001 	.word	0xffff0001

0800eaac <Accelerometer_Get>:
//********************************************************************************
// Measure this sensors values x,y,z
// Values are signed in mg
//********************************************************************************
uint32_t Accelerometer_Get(int16_t * x, int16_t * y, int16_t * z)
{
 800eaac:	b580      	push	{r7, lr}
 800eaae:	b088      	sub	sp, #32
 800eab0:	af02      	add	r7, sp, #8
 800eab2:	60f8      	str	r0, [r7, #12]
 800eab4:	60b9      	str	r1, [r7, #8]
 800eab6:	607a      	str	r2, [r7, #4]
    uint8_t tmp[7];

    tmp[0] = ACCEL_DATA_REGS;
 800eab8:	23a8      	movs	r3, #168	; 0xa8
 800eaba:	743b      	strb	r3, [r7, #16]
    HAL_I2C_Master_Transmit(&ACCEL_I2C,ACCEL_ADDR,tmp,1,20);
 800eabc:	f107 0210 	add.w	r2, r7, #16
 800eac0:	2314      	movs	r3, #20
 800eac2:	9300      	str	r3, [sp, #0]
 800eac4:	2301      	movs	r3, #1
 800eac6:	2132      	movs	r1, #50	; 0x32
 800eac8:	4820      	ldr	r0, [pc, #128]	; (800eb4c <Accelerometer_Get+0xa0>)
 800eaca:	f7f3 f967 	bl	8001d9c <HAL_I2C_Master_Transmit>
    HAL_I2C_Master_Receive(&ACCEL_I2C,ACCEL_ADDR,tmp,6,20);
 800eace:	f107 0210 	add.w	r2, r7, #16
 800ead2:	2314      	movs	r3, #20
 800ead4:	9300      	str	r3, [sp, #0]
 800ead6:	2306      	movs	r3, #6
 800ead8:	2132      	movs	r1, #50	; 0x32
 800eada:	481c      	ldr	r0, [pc, #112]	; (800eb4c <Accelerometer_Get+0xa0>)
 800eadc:	f7f3 fa52 	bl	8001f84 <HAL_I2C_Master_Receive>
    *x = tmp[0] | (tmp[1] << 8);
 800eae0:	7c3b      	ldrb	r3, [r7, #16]
 800eae2:	b21a      	sxth	r2, r3
 800eae4:	7c7b      	ldrb	r3, [r7, #17]
 800eae6:	021b      	lsls	r3, r3, #8
 800eae8:	b21b      	sxth	r3, r3
 800eaea:	4313      	orrs	r3, r2
 800eaec:	b21a      	sxth	r2, r3
 800eaee:	68fb      	ldr	r3, [r7, #12]
 800eaf0:	801a      	strh	r2, [r3, #0]
    *y = tmp[2] | (tmp[3] << 8);
 800eaf2:	7cbb      	ldrb	r3, [r7, #18]
 800eaf4:	b21a      	sxth	r2, r3
 800eaf6:	7cfb      	ldrb	r3, [r7, #19]
 800eaf8:	021b      	lsls	r3, r3, #8
 800eafa:	b21b      	sxth	r3, r3
 800eafc:	4313      	orrs	r3, r2
 800eafe:	b21a      	sxth	r2, r3
 800eb00:	68bb      	ldr	r3, [r7, #8]
 800eb02:	801a      	strh	r2, [r3, #0]
    *z = tmp[4] | (tmp[5] << 8);
 800eb04:	7d3b      	ldrb	r3, [r7, #20]
 800eb06:	b21a      	sxth	r2, r3
 800eb08:	7d7b      	ldrb	r3, [r7, #21]
 800eb0a:	021b      	lsls	r3, r3, #8
 800eb0c:	b21b      	sxth	r3, r3
 800eb0e:	4313      	orrs	r3, r2
 800eb10:	b21a      	sxth	r2, r3
 800eb12:	687b      	ldr	r3, [r7, #4]
 800eb14:	801a      	strh	r2, [r3, #0]
    // for high resolution (shift value)
    *x = *x >> 4;
 800eb16:	68fb      	ldr	r3, [r7, #12]
 800eb18:	f9b3 3000 	ldrsh.w	r3, [r3]
 800eb1c:	111b      	asrs	r3, r3, #4
 800eb1e:	b21a      	sxth	r2, r3
 800eb20:	68fb      	ldr	r3, [r7, #12]
 800eb22:	801a      	strh	r2, [r3, #0]
    *y = *y >> 4;
 800eb24:	68bb      	ldr	r3, [r7, #8]
 800eb26:	f9b3 3000 	ldrsh.w	r3, [r3]
 800eb2a:	111b      	asrs	r3, r3, #4
 800eb2c:	b21a      	sxth	r2, r3
 800eb2e:	68bb      	ldr	r3, [r7, #8]
 800eb30:	801a      	strh	r2, [r3, #0]
    *z = *z >> 4;
 800eb32:	687b      	ldr	r3, [r7, #4]
 800eb34:	f9b3 3000 	ldrsh.w	r3, [r3]
 800eb38:	111b      	asrs	r3, r3, #4
 800eb3a:	b21a      	sxth	r2, r3
 800eb3c:	687b      	ldr	r3, [r7, #4]
 800eb3e:	801a      	strh	r2, [r3, #0]
    return 0;
 800eb40:	2300      	movs	r3, #0
}
 800eb42:	4618      	mov	r0, r3
 800eb44:	3718      	adds	r7, #24
 800eb46:	46bd      	mov	sp, r7
 800eb48:	bd80      	pop	{r7, pc}
 800eb4a:	bf00      	nop
 800eb4c:	2000009c 	.word	0x2000009c

0800eb50 <_ZN5board10initializeEv>:
#include "platform-config.h"
#include "trace/trace.h"
#include "board.h"

void board::initialize()
{
 800eb50:	b580      	push	{r7, lr}
 800eb52:	af00      	add	r7, sp, #0
#if (USE_TRACE != 0)
	Trace::initialize();
 800eb54:	f000 fcfe 	bl	800f554 <_ZN5Trace10initializeEv>
#endif // USE_TRACE
}
 800eb58:	bf00      	nop
 800eb5a:	bd80      	pop	{r7, pc}

0800eb5c <_Z41__static_initialization_and_destruction_0ii>:
 800eb5c:	b580      	push	{r7, lr}
 800eb5e:	b088      	sub	sp, #32
 800eb60:	af00      	add	r7, sp, #0
 800eb62:	6078      	str	r0, [r7, #4]
 800eb64:	6039      	str	r1, [r7, #0]
 800eb66:	687b      	ldr	r3, [r7, #4]
 800eb68:	2b01      	cmp	r3, #1
 800eb6a:	d122      	bne.n	800ebb2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800eb6c:	683b      	ldr	r3, [r7, #0]
 800eb6e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800eb72:	4293      	cmp	r3, r2
 800eb74:	d11d      	bne.n	800ebb2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800eb76:	4b18      	ldr	r3, [pc, #96]	; (800ebd8 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800eb78:	681b      	ldr	r3, [r3, #0]
 800eb7a:	613b      	str	r3, [r7, #16]
 800eb7c:	f107 0310 	add.w	r3, r7, #16
 800eb80:	60bb      	str	r3, [r7, #8]
 800eb82:	2304      	movs	r3, #4
 800eb84:	60fb      	str	r3, [r7, #12]
 800eb86:	f107 0308 	add.w	r3, r7, #8
 800eb8a:	e893 0006 	ldmia.w	r3, {r1, r2}
 800eb8e:	4813      	ldr	r0, [pc, #76]	; (800ebdc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800eb90:	f7f8 f8d0 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800eb94:	4b12      	ldr	r3, [pc, #72]	; (800ebe0 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800eb96:	681b      	ldr	r3, [r3, #0]
 800eb98:	61fb      	str	r3, [r7, #28]
 800eb9a:	f107 031c 	add.w	r3, r7, #28
 800eb9e:	617b      	str	r3, [r7, #20]
 800eba0:	2304      	movs	r3, #4
 800eba2:	61bb      	str	r3, [r7, #24]
 800eba4:	f107 0314 	add.w	r3, r7, #20
 800eba8:	e893 0006 	ldmia.w	r3, {r1, r2}
 800ebac:	480d      	ldr	r0, [pc, #52]	; (800ebe4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800ebae:	f7f8 f8c1 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800ebb2:	687b      	ldr	r3, [r7, #4]
 800ebb4:	2b00      	cmp	r3, #0
 800ebb6:	d10a      	bne.n	800ebce <_Z41__static_initialization_and_destruction_0ii+0x72>
 800ebb8:	683b      	ldr	r3, [r7, #0]
 800ebba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ebbe:	4293      	cmp	r3, r2
 800ebc0:	d105      	bne.n	800ebce <_Z41__static_initialization_and_destruction_0ii+0x72>
 800ebc2:	4808      	ldr	r0, [pc, #32]	; (800ebe4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800ebc4:	f7f8 fa00 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800ebc8:	4804      	ldr	r0, [pc, #16]	; (800ebdc <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800ebca:	f7f8 f9fd 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800ebce:	bf00      	nop
 800ebd0:	3720      	adds	r7, #32
 800ebd2:	46bd      	mov	sp, r7
 800ebd4:	bd80      	pop	{r7, pc}
 800ebd6:	bf00      	nop
 800ebd8:	0801942c 	.word	0x0801942c
 800ebdc:	2000196c 	.word	0x2000196c
 800ebe0:	08019430 	.word	0x08019430
 800ebe4:	20001974 	.word	0x20001974

0800ebe8 <_GLOBAL__sub_I__ZN5board10initializeEv>:
 800ebe8:	b580      	push	{r7, lr}
 800ebea:	af00      	add	r7, sp, #0
 800ebec:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ebf0:	2001      	movs	r0, #1
 800ebf2:	f7ff ffb3 	bl	800eb5c <_Z41__static_initialization_and_destruction_0ii>
 800ebf6:	bd80      	pop	{r7, pc}

0800ebf8 <_GLOBAL__sub_D__ZN5board10initializeEv>:
 800ebf8:	b580      	push	{r7, lr}
 800ebfa:	af00      	add	r7, sp, #0
 800ebfc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ec00:	2000      	movs	r0, #0
 800ec02:	f7ff ffab 	bl	800eb5c <_Z41__static_initialization_and_destruction_0ii>
 800ec06:	bd80      	pop	{r7, pc}

0800ec08 <_ZN9IJoystickC1Ev>:
 */
class IJoystick
{
protected:
    // It is just an interface, so constructor and destructor should be not public.
    explicit IJoystick() {}
 800ec08:	b480      	push	{r7}
 800ec0a:	b083      	sub	sp, #12
 800ec0c:	af00      	add	r7, sp, #0
 800ec0e:	6078      	str	r0, [r7, #4]
 800ec10:	4a04      	ldr	r2, [pc, #16]	; (800ec24 <_ZN9IJoystickC1Ev+0x1c>)
 800ec12:	687b      	ldr	r3, [r7, #4]
 800ec14:	601a      	str	r2, [r3, #0]
 800ec16:	687b      	ldr	r3, [r7, #4]
 800ec18:	4618      	mov	r0, r3
 800ec1a:	370c      	adds	r7, #12
 800ec1c:	46bd      	mov	sp, r7
 800ec1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec22:	4770      	bx	lr
 800ec24:	0801be10 	.word	0x0801be10

0800ec28 <_ZN9IJoystickD1Ev>:
    virtual ~IJoystick() {}
 800ec28:	b480      	push	{r7}
 800ec2a:	b083      	sub	sp, #12
 800ec2c:	af00      	add	r7, sp, #0
 800ec2e:	6078      	str	r0, [r7, #4]
 800ec30:	4a04      	ldr	r2, [pc, #16]	; (800ec44 <_ZN9IJoystickD1Ev+0x1c>)
 800ec32:	687b      	ldr	r3, [r7, #4]
 800ec34:	601a      	str	r2, [r3, #0]
 800ec36:	687b      	ldr	r3, [r7, #4]
 800ec38:	4618      	mov	r0, r3
 800ec3a:	370c      	adds	r7, #12
 800ec3c:	46bd      	mov	sp, r7
 800ec3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec42:	4770      	bx	lr
 800ec44:	0801be10 	.word	0x0801be10

0800ec48 <_ZN9IJoystickD0Ev>:
 800ec48:	b580      	push	{r7, lr}
 800ec4a:	b082      	sub	sp, #8
 800ec4c:	af00      	add	r7, sp, #0
 800ec4e:	6078      	str	r0, [r7, #4]
 800ec50:	6878      	ldr	r0, [r7, #4]
 800ec52:	f7ff ffe9 	bl	800ec28 <_ZN9IJoystickD1Ev>
 800ec56:	2104      	movs	r1, #4
 800ec58:	6878      	ldr	r0, [r7, #4]
 800ec5a:	f007 faa7 	bl	80161ac <_ZdlPvj>
 800ec5e:	687b      	ldr	r3, [r7, #4]
 800ec60:	4618      	mov	r0, r3
 800ec62:	3708      	adds	r7, #8
 800ec64:	46bd      	mov	sp, r7
 800ec66:	bd80      	pop	{r7, pc}

0800ec68 <_ZN5board8JoystickC1Ev>:
#include "xf/xfstaticevent.h"
#include "joystick.h"

namespace board {

Joystick::Joystick()
 800ec68:	b580      	push	{r7, lr}
 800ec6a:	b082      	sub	sp, #8
 800ec6c:	af00      	add	r7, sp, #0
 800ec6e:	6078      	str	r0, [r7, #4]
 800ec70:	687b      	ldr	r3, [r7, #4]
 800ec72:	4618      	mov	r0, r3
 800ec74:	f7ff ffc8 	bl	800ec08 <_ZN9IJoystickC1Ev>
 800ec78:	687b      	ldr	r3, [r7, #4]
 800ec7a:	3304      	adds	r3, #4
 800ec7c:	2100      	movs	r1, #0
 800ec7e:	4618      	mov	r0, r3
 800ec80:	f005 fa50 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 800ec84:	4a0c      	ldr	r2, [pc, #48]	; (800ecb8 <_ZN5board8JoystickC1Ev+0x50>)
 800ec86:	687b      	ldr	r3, [r7, #4]
 800ec88:	601a      	str	r2, [r3, #0]
 800ec8a:	4a0c      	ldr	r2, [pc, #48]	; (800ecbc <_ZN5board8JoystickC1Ev+0x54>)
 800ec8c:	687b      	ldr	r3, [r7, #4]
 800ec8e:	605a      	str	r2, [r3, #4]
{
	_bInitialized = false;
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	2200      	movs	r2, #0
 800ec94:	741a      	strb	r2, [r3, #16]
	_pObserver = NULL;
 800ec96:	687b      	ldr	r3, [r7, #4]
 800ec98:	2200      	movs	r2, #0
 800ec9a:	615a      	str	r2, [r3, #20]
	_position.position = Invalid;
 800ec9c:	687b      	ldr	r3, [r7, #4]
 800ec9e:	2200      	movs	r2, #0
 800eca0:	761a      	strb	r2, [r3, #24]
	_currentState = STATE_INITIAL;
 800eca2:	687b      	ldr	r3, [r7, #4]
 800eca4:	2201      	movs	r2, #1
 800eca6:	771a      	strb	r2, [r3, #28]
	_timeoutActive = false;
 800eca8:	687b      	ldr	r3, [r7, #4]
 800ecaa:	2200      	movs	r2, #0
 800ecac:	775a      	strb	r2, [r3, #29]
}
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	4618      	mov	r0, r3
 800ecb2:	3708      	adds	r7, #8
 800ecb4:	46bd      	mov	sp, r7
 800ecb6:	bd80      	pop	{r7, pc}
 800ecb8:	0801bdc8 	.word	0x0801bdc8
 800ecbc:	0801bdec 	.word	0x0801bdec

0800ecc0 <_ZN5board8Joystick10initializeEv>:
	_position.position = Invalid;
	_currentState = STATE_INITIAL;
}

bool Joystick::initialize()
{
 800ecc0:	b480      	push	{r7}
 800ecc2:	b083      	sub	sp, #12
 800ecc4:	af00      	add	r7, sp, #0
 800ecc6:	6078      	str	r0, [r7, #4]
	if (!_bInitialized)
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	7c1b      	ldrb	r3, [r3, #16]
 800eccc:	f083 0301 	eor.w	r3, r3, #1
 800ecd0:	b2db      	uxtb	r3, r3
 800ecd2:	2b00      	cmp	r3, #0
 800ecd4:	d004      	beq.n	800ece0 <_ZN5board8Joystick10initializeEv+0x20>
	{
		_bInitialized = true;
 800ecd6:	687b      	ldr	r3, [r7, #4]
 800ecd8:	2201      	movs	r2, #1
 800ecda:	741a      	strb	r2, [r3, #16]

		return true;
 800ecdc:	2301      	movs	r3, #1
 800ecde:	e000      	b.n	800ece2 <_ZN5board8Joystick10initializeEv+0x22>
	}
	return false;
 800ece0:	2300      	movs	r3, #0
}
 800ece2:	4618      	mov	r0, r3
 800ece4:	370c      	adds	r7, #12
 800ece6:	46bd      	mov	sp, r7
 800ece8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecec:	4770      	bx	lr

0800ecee <_ZN5board8Joystick11setObserverEP17IJoystickObserver>:

bool Joystick::setObserver(IJoystickObserver * observer)
{
 800ecee:	b480      	push	{r7}
 800ecf0:	b083      	sub	sp, #12
 800ecf2:	af00      	add	r7, sp, #0
 800ecf4:	6078      	str	r0, [r7, #4]
 800ecf6:	6039      	str	r1, [r7, #0]
	_pObserver = observer;
 800ecf8:	687b      	ldr	r3, [r7, #4]
 800ecfa:	683a      	ldr	r2, [r7, #0]
 800ecfc:	615a      	str	r2, [r3, #20]

	return true;
 800ecfe:	2301      	movs	r3, #1
}
 800ed00:	4618      	mov	r0, r3
 800ed02:	370c      	adds	r7, #12
 800ed04:	46bd      	mov	sp, r7
 800ed06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed0a:	4770      	bx	lr

0800ed0c <_ZN5board8Joystick5startEv>:

void Joystick::start()
{
 800ed0c:	b580      	push	{r7, lr}
 800ed0e:	b082      	sub	sp, #8
 800ed10:	af00      	add	r7, sp, #0
 800ed12:	6078      	str	r0, [r7, #4]
	startBehavior();
 800ed14:	687b      	ldr	r3, [r7, #4]
 800ed16:	1d1a      	adds	r2, r3, #4
 800ed18:	687b      	ldr	r3, [r7, #4]
 800ed1a:	685b      	ldr	r3, [r3, #4]
 800ed1c:	3308      	adds	r3, #8
 800ed1e:	681b      	ldr	r3, [r3, #0]
 800ed20:	4610      	mov	r0, r2
 800ed22:	4798      	blx	r3
}
 800ed24:	bf00      	nop
 800ed26:	3708      	adds	r7, #8
 800ed28:	46bd      	mov	sp, r7
 800ed2a:	bd80      	pop	{r7, pc}

0800ed2c <__tcf_0>:

//static
Joystick & Joystick::instance()
{
	static Joystick joystick;
 800ed2c:	b580      	push	{r7, lr}
 800ed2e:	af00      	add	r7, sp, #0
 800ed30:	4801      	ldr	r0, [pc, #4]	; (800ed38 <__tcf_0+0xc>)
 800ed32:	f000 fa69 	bl	800f208 <_ZN5board8JoystickD1Ev>
 800ed36:	bd80      	pop	{r7, pc}
 800ed38:	2000198c 	.word	0x2000198c

0800ed3c <_ZN5board8Joystick8instanceEv>:
{
 800ed3c:	b580      	push	{r7, lr}
 800ed3e:	af00      	add	r7, sp, #0
	static Joystick joystick;
 800ed40:	4b12      	ldr	r3, [pc, #72]	; (800ed8c <_ZN5board8Joystick8instanceEv+0x50>)
 800ed42:	781b      	ldrb	r3, [r3, #0]
 800ed44:	f3bf 8f5b 	dmb	ish
 800ed48:	b2db      	uxtb	r3, r3
 800ed4a:	f003 0301 	and.w	r3, r3, #1
 800ed4e:	2b00      	cmp	r3, #0
 800ed50:	bf0c      	ite	eq
 800ed52:	2301      	moveq	r3, #1
 800ed54:	2300      	movne	r3, #0
 800ed56:	b2db      	uxtb	r3, r3
 800ed58:	2b00      	cmp	r3, #0
 800ed5a:	d013      	beq.n	800ed84 <_ZN5board8Joystick8instanceEv+0x48>
 800ed5c:	480b      	ldr	r0, [pc, #44]	; (800ed8c <_ZN5board8Joystick8instanceEv+0x50>)
 800ed5e:	f007 fa29 	bl	80161b4 <__cxa_guard_acquire>
 800ed62:	4603      	mov	r3, r0
 800ed64:	2b00      	cmp	r3, #0
 800ed66:	bf14      	ite	ne
 800ed68:	2301      	movne	r3, #1
 800ed6a:	2300      	moveq	r3, #0
 800ed6c:	b2db      	uxtb	r3, r3
 800ed6e:	2b00      	cmp	r3, #0
 800ed70:	d008      	beq.n	800ed84 <_ZN5board8Joystick8instanceEv+0x48>
 800ed72:	4807      	ldr	r0, [pc, #28]	; (800ed90 <_ZN5board8Joystick8instanceEv+0x54>)
 800ed74:	f7ff ff78 	bl	800ec68 <_ZN5board8JoystickC1Ev>
 800ed78:	4806      	ldr	r0, [pc, #24]	; (800ed94 <_ZN5board8Joystick8instanceEv+0x58>)
 800ed7a:	f007 fb29 	bl	80163d0 <atexit>
 800ed7e:	4803      	ldr	r0, [pc, #12]	; (800ed8c <_ZN5board8Joystick8instanceEv+0x50>)
 800ed80:	f007 fa24 	bl	80161cc <__cxa_guard_release>

	return joystick;
 800ed84:	4b02      	ldr	r3, [pc, #8]	; (800ed90 <_ZN5board8Joystick8instanceEv+0x54>)
}
 800ed86:	4618      	mov	r0, r3
 800ed88:	bd80      	pop	{r7, pc}
 800ed8a:	bf00      	nop
 800ed8c:	200019ac 	.word	0x200019ac
 800ed90:	2000198c 	.word	0x2000198c
 800ed94:	0800ed2d 	.word	0x0800ed2d

0800ed98 <_ZNK5board8Joystick8positionEv>:

IJoystick::Position Joystick::position() const
{
 800ed98:	b480      	push	{r7}
 800ed9a:	b083      	sub	sp, #12
 800ed9c:	af00      	add	r7, sp, #0
 800ed9e:	6078      	str	r0, [r7, #4]
	return _position;
 800eda0:	687b      	ldr	r3, [r7, #4]
 800eda2:	699b      	ldr	r3, [r3, #24]
}
 800eda4:	4618      	mov	r0, r3
 800eda6:	370c      	adds	r7, #12
 800eda8:	46bd      	mov	sp, r7
 800edaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800edae:	4770      	bx	lr

0800edb0 <_ZNK5board8Joystick17navigationButtonsEv>:

Joystick::PressedButtons Joystick::navigationButtons() const
{
 800edb0:	b580      	push	{r7, lr}
 800edb2:	b082      	sub	sp, #8
 800edb4:	af00      	add	r7, sp, #0
 800edb6:	6078      	str	r0, [r7, #4]
    return _readActualPosition();
 800edb8:	6878      	ldr	r0, [r7, #4]
 800edba:	f000 f805 	bl	800edc8 <_ZNK5board8Joystick19_readActualPositionEv>
 800edbe:	4603      	mov	r3, r0
}
 800edc0:	4618      	mov	r0, r3
 800edc2:	3708      	adds	r7, #8
 800edc4:	46bd      	mov	sp, r7
 800edc6:	bd80      	pop	{r7, pc}

0800edc8 <_ZNK5board8Joystick19_readActualPositionEv>:

Joystick::PressedButtons Joystick::_readActualPosition() const
{
 800edc8:	b580      	push	{r7, lr}
 800edca:	b084      	sub	sp, #16
 800edcc:	af00      	add	r7, sp, #0
 800edce:	6078      	str	r0, [r7, #4]
    PressedButtons pressed = Invalid;
 800edd0:	2300      	movs	r3, #0
 800edd2:	60fb      	str	r3, [r7, #12]

    // Check UP button pressed
    pressed |= (HAL_GPIO_ReadPin(NAVS_UP_GPIO_Port, NAVS_UP_Pin) == GPIO_PIN_RESET) ? JoystickButton::Up : JoystickButton::Invalid;
 800edd4:	f44f 7100 	mov.w	r1, #512	; 0x200
 800edd8:	4826      	ldr	r0, [pc, #152]	; (800ee74 <_ZNK5board8Joystick19_readActualPositionEv+0xac>)
 800edda:	f7f2 ff07 	bl	8001bec <HAL_GPIO_ReadPin>
 800edde:	4603      	mov	r3, r0
 800ede0:	2b00      	cmp	r3, #0
 800ede2:	d101      	bne.n	800ede8 <_ZNK5board8Joystick19_readActualPositionEv+0x20>
 800ede4:	2308      	movs	r3, #8
 800ede6:	e000      	b.n	800edea <_ZNK5board8Joystick19_readActualPositionEv+0x22>
 800ede8:	2300      	movs	r3, #0
 800edea:	461a      	mov	r2, r3
 800edec:	68fb      	ldr	r3, [r7, #12]
 800edee:	4313      	orrs	r3, r2
 800edf0:	60fb      	str	r3, [r7, #12]

    // Check DOWN button pressed
    pressed |= (HAL_GPIO_ReadPin(NAVS_DOWN_GPIO_Port, NAVS_DOWN_Pin) == GPIO_PIN_RESET) ? JoystickButton::Down : JoystickButton::Invalid;
 800edf2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800edf6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800edfa:	f7f2 fef7 	bl	8001bec <HAL_GPIO_ReadPin>
 800edfe:	4603      	mov	r3, r0
 800ee00:	2b00      	cmp	r3, #0
 800ee02:	d101      	bne.n	800ee08 <_ZNK5board8Joystick19_readActualPositionEv+0x40>
 800ee04:	2310      	movs	r3, #16
 800ee06:	e000      	b.n	800ee0a <_ZNK5board8Joystick19_readActualPositionEv+0x42>
 800ee08:	2300      	movs	r3, #0
 800ee0a:	461a      	mov	r2, r3
 800ee0c:	68fb      	ldr	r3, [r7, #12]
 800ee0e:	4313      	orrs	r3, r2
 800ee10:	60fb      	str	r3, [r7, #12]

    // And also for the remaining buttons
    pressed |= (HAL_GPIO_ReadPin(NAVS_LEFT_GPIO_Port, NAVS_LEFT_Pin) == GPIO_PIN_RESET) ? JoystickButton::Left : JoystickButton::Invalid;
 800ee12:	2110      	movs	r1, #16
 800ee14:	4818      	ldr	r0, [pc, #96]	; (800ee78 <_ZNK5board8Joystick19_readActualPositionEv+0xb0>)
 800ee16:	f7f2 fee9 	bl	8001bec <HAL_GPIO_ReadPin>
 800ee1a:	4603      	mov	r3, r0
 800ee1c:	2b00      	cmp	r3, #0
 800ee1e:	d101      	bne.n	800ee24 <_ZNK5board8Joystick19_readActualPositionEv+0x5c>
 800ee20:	2302      	movs	r3, #2
 800ee22:	e000      	b.n	800ee26 <_ZNK5board8Joystick19_readActualPositionEv+0x5e>
 800ee24:	2300      	movs	r3, #0
 800ee26:	461a      	mov	r2, r3
 800ee28:	68fb      	ldr	r3, [r7, #12]
 800ee2a:	4313      	orrs	r3, r2
 800ee2c:	60fb      	str	r3, [r7, #12]
    pressed |= (HAL_GPIO_ReadPin(NAVS_RIGHT_GPIO_Port, NAVS_RIGHT_Pin) == GPIO_PIN_RESET) ? JoystickButton::Right : JoystickButton::Invalid;
 800ee2e:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ee32:	4810      	ldr	r0, [pc, #64]	; (800ee74 <_ZNK5board8Joystick19_readActualPositionEv+0xac>)
 800ee34:	f7f2 feda 	bl	8001bec <HAL_GPIO_ReadPin>
 800ee38:	4603      	mov	r3, r0
 800ee3a:	2b00      	cmp	r3, #0
 800ee3c:	d101      	bne.n	800ee42 <_ZNK5board8Joystick19_readActualPositionEv+0x7a>
 800ee3e:	2304      	movs	r3, #4
 800ee40:	e000      	b.n	800ee44 <_ZNK5board8Joystick19_readActualPositionEv+0x7c>
 800ee42:	2300      	movs	r3, #0
 800ee44:	461a      	mov	r2, r3
 800ee46:	68fb      	ldr	r3, [r7, #12]
 800ee48:	4313      	orrs	r3, r2
 800ee4a:	60fb      	str	r3, [r7, #12]
    pressed |= (HAL_GPIO_ReadPin(NAVS_CENTER_GPIO_Port, NAVS_CENTER_Pin) == GPIO_PIN_RESET) ? JoystickButton::Pressed : JoystickButton::Invalid;
 800ee4c:	2120      	movs	r1, #32
 800ee4e:	480a      	ldr	r0, [pc, #40]	; (800ee78 <_ZNK5board8Joystick19_readActualPositionEv+0xb0>)
 800ee50:	f7f2 fecc 	bl	8001bec <HAL_GPIO_ReadPin>
 800ee54:	4603      	mov	r3, r0
 800ee56:	2b00      	cmp	r3, #0
 800ee58:	d101      	bne.n	800ee5e <_ZNK5board8Joystick19_readActualPositionEv+0x96>
 800ee5a:	2320      	movs	r3, #32
 800ee5c:	e000      	b.n	800ee60 <_ZNK5board8Joystick19_readActualPositionEv+0x98>
 800ee5e:	2300      	movs	r3, #0
 800ee60:	461a      	mov	r2, r3
 800ee62:	68fb      	ldr	r3, [r7, #12]
 800ee64:	4313      	orrs	r3, r2
 800ee66:	60fb      	str	r3, [r7, #12]

    return pressed;
 800ee68:	68fb      	ldr	r3, [r7, #12]
}
 800ee6a:	4618      	mov	r0, r3
 800ee6c:	3710      	adds	r7, #16
 800ee6e:	46bd      	mov	sp, r7
 800ee70:	bd80      	pop	{r7, pc}
 800ee72:	bf00      	nop
 800ee74:	48000800 	.word	0x48000800
 800ee78:	48000400 	.word	0x48000400

0800ee7c <_ZN5board8Joystick12processEventEv>:

EventStatus Joystick::processEvent()
{
 800ee7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ee7e:	b085      	sub	sp, #20
 800ee80:	af00      	add	r7, sp, #0
 800ee82:	6078      	str	r0, [r7, #4]
	eEventStatus eventStatus = EventStatus::Unknown;
 800ee84:	2300      	movs	r3, #0
 800ee86:	72fb      	strb	r3, [r7, #11]

	switch (_currentState)
 800ee88:	687b      	ldr	r3, [r7, #4]
 800ee8a:	7f1b      	ldrb	r3, [r3, #28]
 800ee8c:	2b01      	cmp	r3, #1
 800ee8e:	d002      	beq.n	800ee96 <_ZN5board8Joystick12processEventEv+0x1a>
 800ee90:	2b02      	cmp	r3, #2
 800ee92:	d02b      	beq.n	800eeec <_ZN5board8Joystick12processEventEv+0x70>
				eventStatus = EventStatus::Consumed;
			}
		}
		break;
	default:
		break;
 800ee94:	e097      	b.n	800efc6 <_ZN5board8Joystick12processEventEv+0x14a>
			if (getCurrentEvent()->getEventType() == IXFEvent::Initial)
 800ee96:	687b      	ldr	r3, [r7, #4]
 800ee98:	3304      	adds	r3, #4
 800ee9a:	4618      	mov	r0, r3
 800ee9c:	f005 fa20 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 800eea0:	4603      	mov	r3, r0
 800eea2:	4618      	mov	r0, r3
 800eea4:	f7f7 fd7d 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800eea8:	4603      	mov	r3, r0
 800eeaa:	2b01      	cmp	r3, #1
 800eeac:	bf0c      	ite	eq
 800eeae:	2301      	moveq	r3, #1
 800eeb0:	2300      	movne	r3, #0
 800eeb2:	b2db      	uxtb	r3, r3
 800eeb4:	2b00      	cmp	r3, #0
 800eeb6:	f000 8083 	beq.w	800efc0 <_ZN5board8Joystick12processEventEv+0x144>
				GEN(XFNullTransition());
 800eeba:	687b      	ldr	r3, [r7, #4]
 800eebc:	1d1d      	adds	r5, r3, #4
 800eebe:	687b      	ldr	r3, [r7, #4]
 800eec0:	685b      	ldr	r3, [r3, #4]
 800eec2:	330c      	adds	r3, #12
 800eec4:	681c      	ldr	r4, [r3, #0]
 800eec6:	2014      	movs	r0, #20
 800eec8:	f007 f983 	bl	80161d2 <_Znwj>
 800eecc:	4603      	mov	r3, r0
 800eece:	461e      	mov	r6, r3
 800eed0:	2200      	movs	r2, #0
 800eed2:	2100      	movs	r1, #0
 800eed4:	4630      	mov	r0, r6
 800eed6:	f005 f8ad 	bl	8014034 <_ZN16XFNullTransitionC1EiP11IXFReactive>
 800eeda:	4631      	mov	r1, r6
 800eedc:	4628      	mov	r0, r5
 800eede:	47a0      	blx	r4
				_currentState = STATE_CHECK_JOYSTICK;
 800eee0:	687b      	ldr	r3, [r7, #4]
 800eee2:	2202      	movs	r2, #2
 800eee4:	771a      	strb	r2, [r3, #28]
				eventStatus = EventStatus::Consumed;
 800eee6:	2301      	movs	r3, #1
 800eee8:	72fb      	strb	r3, [r7, #11]
		break;
 800eeea:	e069      	b.n	800efc0 <_ZN5board8Joystick12processEventEv+0x144>
		    if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 800eeec:	687b      	ldr	r3, [r7, #4]
 800eeee:	3304      	adds	r3, #4
 800eef0:	4618      	mov	r0, r3
 800eef2:	f005 f9f5 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 800eef6:	4603      	mov	r3, r0
 800eef8:	4618      	mov	r0, r3
 800eefa:	f7f7 fd52 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800eefe:	4603      	mov	r3, r0
 800ef00:	2b03      	cmp	r3, #3
 800ef02:	d10d      	bne.n	800ef20 <_ZN5board8Joystick12processEventEv+0xa4>
		        getCurrentEvent()->getId() == Event_IRQ)
 800ef04:	687b      	ldr	r3, [r7, #4]
 800ef06:	3304      	adds	r3, #4
 800ef08:	4618      	mov	r0, r3
 800ef0a:	f005 f9e9 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 800ef0e:	4603      	mov	r3, r0
 800ef10:	4618      	mov	r0, r3
 800ef12:	f7f7 fd53 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 800ef16:	4603      	mov	r3, r0
		    if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 800ef18:	2b01      	cmp	r3, #1
 800ef1a:	d101      	bne.n	800ef20 <_ZN5board8Joystick12processEventEv+0xa4>
 800ef1c:	2301      	movs	r3, #1
 800ef1e:	e000      	b.n	800ef22 <_ZN5board8Joystick12processEventEv+0xa6>
 800ef20:	2300      	movs	r3, #0
 800ef22:	2b00      	cmp	r3, #0
 800ef24:	d017      	beq.n	800ef56 <_ZN5board8Joystick12processEventEv+0xda>
		          if (!_timeoutActive)
 800ef26:	687b      	ldr	r3, [r7, #4]
 800ef28:	7f5b      	ldrb	r3, [r3, #29]
 800ef2a:	f083 0301 	eor.w	r3, r3, #1
 800ef2e:	b2db      	uxtb	r3, r3
 800ef30:	2b00      	cmp	r3, #0
 800ef32:	d00d      	beq.n	800ef50 <_ZN5board8Joystick12processEventEv+0xd4>
		              getThread()->scheduleTimeout(Timeout_CHECK_JOYSTICK_id, 50, this);
 800ef34:	687b      	ldr	r3, [r7, #4]
 800ef36:	1d1a      	adds	r2, r3, #4
 800ef38:	687b      	ldr	r3, [r7, #4]
 800ef3a:	685b      	ldr	r3, [r3, #4]
 800ef3c:	3318      	adds	r3, #24
 800ef3e:	681b      	ldr	r3, [r3, #0]
 800ef40:	4610      	mov	r0, r2
 800ef42:	4798      	blx	r3
 800ef44:	687b      	ldr	r3, [r7, #4]
 800ef46:	3304      	adds	r3, #4
 800ef48:	2232      	movs	r2, #50	; 0x32
 800ef4a:	2101      	movs	r1, #1
 800ef4c:	f005 fb83 	bl	8014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>
		          _timeoutActive = true;
 800ef50:	687b      	ldr	r3, [r7, #4]
 800ef52:	2201      	movs	r2, #1
 800ef54:	775a      	strb	r2, [r3, #29]
			if (getCurrentEvent()->getEventType() == IXFEvent::NullTransition ||
 800ef56:	687b      	ldr	r3, [r7, #4]
 800ef58:	3304      	adds	r3, #4
 800ef5a:	4618      	mov	r0, r3
 800ef5c:	f005 f9c0 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 800ef60:	4603      	mov	r3, r0
 800ef62:	4618      	mov	r0, r3
 800ef64:	f7f7 fd1d 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800ef68:	4603      	mov	r3, r0
 800ef6a:	2b02      	cmp	r3, #2
 800ef6c:	d017      	beq.n	800ef9e <_ZN5board8Joystick12processEventEv+0x122>
				(getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 800ef6e:	687b      	ldr	r3, [r7, #4]
 800ef70:	3304      	adds	r3, #4
 800ef72:	4618      	mov	r0, r3
 800ef74:	f005 f9b4 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 800ef78:	4603      	mov	r3, r0
 800ef7a:	4618      	mov	r0, r3
 800ef7c:	f7f7 fd11 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 800ef80:	4603      	mov	r3, r0
			if (getCurrentEvent()->getEventType() == IXFEvent::NullTransition ||
 800ef82:	2b04      	cmp	r3, #4
 800ef84:	d10d      	bne.n	800efa2 <_ZN5board8Joystick12processEventEv+0x126>
				 getCurrentTimeout()->getId() == Timeout_CHECK_JOYSTICK_id))
 800ef86:	687b      	ldr	r3, [r7, #4]
 800ef88:	3304      	adds	r3, #4
 800ef8a:	4618      	mov	r0, r3
 800ef8c:	f005 f9c2 	bl	8014314 <_ZN10XFReactive17getCurrentTimeoutEv>
 800ef90:	4603      	mov	r3, r0
 800ef92:	4618      	mov	r0, r3
 800ef94:	f7f7 fd12 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 800ef98:	4603      	mov	r3, r0
				(getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 800ef9a:	2b01      	cmp	r3, #1
 800ef9c:	d101      	bne.n	800efa2 <_ZN5board8Joystick12processEventEv+0x126>
			if (getCurrentEvent()->getEventType() == IXFEvent::NullTransition ||
 800ef9e:	2301      	movs	r3, #1
 800efa0:	e000      	b.n	800efa4 <_ZN5board8Joystick12processEventEv+0x128>
 800efa2:	2300      	movs	r3, #0
 800efa4:	2b00      	cmp	r3, #0
 800efa6:	d00d      	beq.n	800efc4 <_ZN5board8Joystick12processEventEv+0x148>
					doCheckJoystickState();
 800efa8:	6878      	ldr	r0, [r7, #4]
 800efaa:	f000 f81d 	bl	800efe8 <_ZN5board8Joystick20doCheckJoystickStateEv>
				_timeoutActive = false;
 800efae:	687b      	ldr	r3, [r7, #4]
 800efb0:	2200      	movs	r2, #0
 800efb2:	775a      	strb	r2, [r3, #29]
				_currentState = STATE_CHECK_JOYSTICK;
 800efb4:	687b      	ldr	r3, [r7, #4]
 800efb6:	2202      	movs	r2, #2
 800efb8:	771a      	strb	r2, [r3, #28]
				eventStatus = EventStatus::Consumed;
 800efba:	2301      	movs	r3, #1
 800efbc:	72fb      	strb	r3, [r7, #11]
		break;
 800efbe:	e001      	b.n	800efc4 <_ZN5board8Joystick12processEventEv+0x148>
		break;
 800efc0:	bf00      	nop
 800efc2:	e000      	b.n	800efc6 <_ZN5board8Joystick12processEventEv+0x14a>
		break;
 800efc4:	bf00      	nop
	}

	return eventStatus;
 800efc6:	7afa      	ldrb	r2, [r7, #11]
 800efc8:	f107 030c 	add.w	r3, r7, #12
 800efcc:	4611      	mov	r1, r2
 800efce:	4618      	mov	r0, r3
 800efd0:	f7f7 fd00 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 800efd4:	7b3b      	ldrb	r3, [r7, #12]
}
 800efd6:	4618      	mov	r0, r3
 800efd8:	3714      	adds	r7, #20
 800efda:	46bd      	mov	sp, r7
 800efdc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800efde <_ZThn4_N5board8Joystick12processEventEv>:
	const Joystick & operator =(const Joystick & j) { (void)(j); return j; }	///< Forbids to copy a joystick.

	PressedButtons _readActualPosition() const;         ///< Reads the button state on the corresponding GPIOs.

	// From XFReactive
	virtual EventStatus processEvent();
 800efde:	f1a0 0004 	sub.w	r0, r0, #4
 800efe2:	f7ff bf4b 	b.w	800ee7c <_ZN5board8Joystick12processEventEv>
	...

0800efe8 <_ZN5board8Joystick20doCheckJoystickStateEv>:

void Joystick::doCheckJoystickState()
{
 800efe8:	b5b0      	push	{r4, r5, r7, lr}
 800efea:	b084      	sub	sp, #16
 800efec:	af00      	add	r7, sp, #0
 800efee:	6078      	str	r0, [r7, #4]
	// Store previously calculated value
	const Position oldPosition = _position;
 800eff0:	687b      	ldr	r3, [r7, #4]
 800eff2:	699b      	ldr	r3, [r3, #24]
 800eff4:	60fb      	str	r3, [r7, #12]

	_position.pressedButtons =  _readActualPosition();
 800eff6:	6878      	ldr	r0, [r7, #4]
 800eff8:	f7ff fee6 	bl	800edc8 <_ZNK5board8Joystick19_readActualPositionEv>
 800effc:	4602      	mov	r2, r0
 800effe:	687b      	ldr	r3, [r7, #4]
 800f000:	619a      	str	r2, [r3, #24]

	//Trace::outln("Button state: 0x%0X", _position.pressedButtons);

	// Did the position of the joystick change?
	if (oldPosition.pressedButtons != _position.pressedButtons)
 800f002:	68fa      	ldr	r2, [r7, #12]
 800f004:	687b      	ldr	r3, [r7, #4]
 800f006:	699b      	ldr	r3, [r3, #24]
 800f008:	429a      	cmp	r2, r3
 800f00a:	d073      	beq.n	800f0f4 <_ZN5board8Joystick20doCheckJoystickStateEv+0x10c>
	{
#if (JOYSTICK_TRACE_VERBOSE != 0)

	    if ((oldPosition.pressedButtons & JoystickButton::Up) != (_position.pressedButtons & JoystickButton::Up))
 800f00c:	68fa      	ldr	r2, [r7, #12]
 800f00e:	687b      	ldr	r3, [r7, #4]
 800f010:	699b      	ldr	r3, [r3, #24]
 800f012:	4053      	eors	r3, r2
 800f014:	f003 0308 	and.w	r3, r3, #8
 800f018:	2b00      	cmp	r3, #0
 800f01a:	d00a      	beq.n	800f032 <_ZN5board8Joystick20doCheckJoystickStateEv+0x4a>
	    {
            traceOut("Joystick button up %s", (_position.pressedButtons == JoystickButton::Up) ? "pressed" : "released");
 800f01c:	687b      	ldr	r3, [r7, #4]
 800f01e:	699b      	ldr	r3, [r3, #24]
 800f020:	2b08      	cmp	r3, #8
 800f022:	d101      	bne.n	800f028 <_ZN5board8Joystick20doCheckJoystickStateEv+0x40>
 800f024:	4b35      	ldr	r3, [pc, #212]	; (800f0fc <_ZN5board8Joystick20doCheckJoystickStateEv+0x114>)
 800f026:	e000      	b.n	800f02a <_ZN5board8Joystick20doCheckJoystickStateEv+0x42>
 800f028:	4b35      	ldr	r3, [pc, #212]	; (800f100 <_ZN5board8Joystick20doCheckJoystickStateEv+0x118>)
 800f02a:	4619      	mov	r1, r3
 800f02c:	4835      	ldr	r0, [pc, #212]	; (800f104 <_ZN5board8Joystick20doCheckJoystickStateEv+0x11c>)
 800f02e:	f000 f873 	bl	800f118 <_ZN5board8Joystick8traceOutEPKcz>
	    }

        if ((oldPosition.pressedButtons & JoystickButton::Down) != (_position.pressedButtons & JoystickButton::Down))
 800f032:	68fa      	ldr	r2, [r7, #12]
 800f034:	687b      	ldr	r3, [r7, #4]
 800f036:	699b      	ldr	r3, [r3, #24]
 800f038:	4053      	eors	r3, r2
 800f03a:	f003 0310 	and.w	r3, r3, #16
 800f03e:	2b00      	cmp	r3, #0
 800f040:	d00a      	beq.n	800f058 <_ZN5board8Joystick20doCheckJoystickStateEv+0x70>
        {
            traceOut("Joystick button down %s", (_position.pressedButtons == JoystickButton::Down) ? "pressed" : "released");
 800f042:	687b      	ldr	r3, [r7, #4]
 800f044:	699b      	ldr	r3, [r3, #24]
 800f046:	2b10      	cmp	r3, #16
 800f048:	d101      	bne.n	800f04e <_ZN5board8Joystick20doCheckJoystickStateEv+0x66>
 800f04a:	4b2c      	ldr	r3, [pc, #176]	; (800f0fc <_ZN5board8Joystick20doCheckJoystickStateEv+0x114>)
 800f04c:	e000      	b.n	800f050 <_ZN5board8Joystick20doCheckJoystickStateEv+0x68>
 800f04e:	4b2c      	ldr	r3, [pc, #176]	; (800f100 <_ZN5board8Joystick20doCheckJoystickStateEv+0x118>)
 800f050:	4619      	mov	r1, r3
 800f052:	482d      	ldr	r0, [pc, #180]	; (800f108 <_ZN5board8Joystick20doCheckJoystickStateEv+0x120>)
 800f054:	f000 f860 	bl	800f118 <_ZN5board8Joystick8traceOutEPKcz>
        }

        if ((oldPosition.pressedButtons & JoystickButton::Left) != (_position.pressedButtons & JoystickButton::Left))
 800f058:	68fa      	ldr	r2, [r7, #12]
 800f05a:	687b      	ldr	r3, [r7, #4]
 800f05c:	699b      	ldr	r3, [r3, #24]
 800f05e:	4053      	eors	r3, r2
 800f060:	f003 0302 	and.w	r3, r3, #2
 800f064:	2b00      	cmp	r3, #0
 800f066:	d00a      	beq.n	800f07e <_ZN5board8Joystick20doCheckJoystickStateEv+0x96>
        {
            traceOut("Joystick button left %s", (_position.pressedButtons == JoystickButton::Left) ? "pressed" : "released");
 800f068:	687b      	ldr	r3, [r7, #4]
 800f06a:	699b      	ldr	r3, [r3, #24]
 800f06c:	2b02      	cmp	r3, #2
 800f06e:	d101      	bne.n	800f074 <_ZN5board8Joystick20doCheckJoystickStateEv+0x8c>
 800f070:	4b22      	ldr	r3, [pc, #136]	; (800f0fc <_ZN5board8Joystick20doCheckJoystickStateEv+0x114>)
 800f072:	e000      	b.n	800f076 <_ZN5board8Joystick20doCheckJoystickStateEv+0x8e>
 800f074:	4b22      	ldr	r3, [pc, #136]	; (800f100 <_ZN5board8Joystick20doCheckJoystickStateEv+0x118>)
 800f076:	4619      	mov	r1, r3
 800f078:	4824      	ldr	r0, [pc, #144]	; (800f10c <_ZN5board8Joystick20doCheckJoystickStateEv+0x124>)
 800f07a:	f000 f84d 	bl	800f118 <_ZN5board8Joystick8traceOutEPKcz>
        }

        if ((oldPosition.pressedButtons & JoystickButton::Right) != (_position.pressedButtons & JoystickButton::Right))
 800f07e:	68fa      	ldr	r2, [r7, #12]
 800f080:	687b      	ldr	r3, [r7, #4]
 800f082:	699b      	ldr	r3, [r3, #24]
 800f084:	4053      	eors	r3, r2
 800f086:	f003 0304 	and.w	r3, r3, #4
 800f08a:	2b00      	cmp	r3, #0
 800f08c:	d00a      	beq.n	800f0a4 <_ZN5board8Joystick20doCheckJoystickStateEv+0xbc>
        {
            traceOut("Joystick button right %s", (_position.pressedButtons == JoystickButton::Right) ? "pressed" : "released");
 800f08e:	687b      	ldr	r3, [r7, #4]
 800f090:	699b      	ldr	r3, [r3, #24]
 800f092:	2b04      	cmp	r3, #4
 800f094:	d101      	bne.n	800f09a <_ZN5board8Joystick20doCheckJoystickStateEv+0xb2>
 800f096:	4b19      	ldr	r3, [pc, #100]	; (800f0fc <_ZN5board8Joystick20doCheckJoystickStateEv+0x114>)
 800f098:	e000      	b.n	800f09c <_ZN5board8Joystick20doCheckJoystickStateEv+0xb4>
 800f09a:	4b19      	ldr	r3, [pc, #100]	; (800f100 <_ZN5board8Joystick20doCheckJoystickStateEv+0x118>)
 800f09c:	4619      	mov	r1, r3
 800f09e:	481c      	ldr	r0, [pc, #112]	; (800f110 <_ZN5board8Joystick20doCheckJoystickStateEv+0x128>)
 800f0a0:	f000 f83a 	bl	800f118 <_ZN5board8Joystick8traceOutEPKcz>
        }

        if ((oldPosition.pressedButtons & JoystickButton::Pressed) != (_position.pressedButtons & JoystickButton::Pressed))
 800f0a4:	68fa      	ldr	r2, [r7, #12]
 800f0a6:	687b      	ldr	r3, [r7, #4]
 800f0a8:	699b      	ldr	r3, [r3, #24]
 800f0aa:	4053      	eors	r3, r2
 800f0ac:	f003 0320 	and.w	r3, r3, #32
 800f0b0:	2b00      	cmp	r3, #0
 800f0b2:	d00a      	beq.n	800f0ca <_ZN5board8Joystick20doCheckJoystickStateEv+0xe2>
        {
            traceOut("Joystick button center %s", (_position.pressedButtons == JoystickButton::Pressed) ? "pressed" : "released");
 800f0b4:	687b      	ldr	r3, [r7, #4]
 800f0b6:	699b      	ldr	r3, [r3, #24]
 800f0b8:	2b20      	cmp	r3, #32
 800f0ba:	d101      	bne.n	800f0c0 <_ZN5board8Joystick20doCheckJoystickStateEv+0xd8>
 800f0bc:	4b0f      	ldr	r3, [pc, #60]	; (800f0fc <_ZN5board8Joystick20doCheckJoystickStateEv+0x114>)
 800f0be:	e000      	b.n	800f0c2 <_ZN5board8Joystick20doCheckJoystickStateEv+0xda>
 800f0c0:	4b0f      	ldr	r3, [pc, #60]	; (800f100 <_ZN5board8Joystick20doCheckJoystickStateEv+0x118>)
 800f0c2:	4619      	mov	r1, r3
 800f0c4:	4813      	ldr	r0, [pc, #76]	; (800f114 <_ZN5board8Joystick20doCheckJoystickStateEv+0x12c>)
 800f0c6:	f000 f827 	bl	800f118 <_ZN5board8Joystick8traceOutEPKcz>
        }

#endif // (JOYSTICK_TRACE_VERBOSE != 0)

		// Notify observer
		if (_pObserver)
 800f0ca:	687b      	ldr	r3, [r7, #4]
 800f0cc:	695b      	ldr	r3, [r3, #20]
 800f0ce:	2b00      	cmp	r3, #0
 800f0d0:	d010      	beq.n	800f0f4 <_ZN5board8Joystick20doCheckJoystickStateEv+0x10c>
		{
			_pObserver->onPositionChange(position());
 800f0d2:	687b      	ldr	r3, [r7, #4]
 800f0d4:	695d      	ldr	r5, [r3, #20]
 800f0d6:	687b      	ldr	r3, [r7, #4]
 800f0d8:	695b      	ldr	r3, [r3, #20]
 800f0da:	681b      	ldr	r3, [r3, #0]
 800f0dc:	3308      	adds	r3, #8
 800f0de:	681c      	ldr	r4, [r3, #0]
 800f0e0:	687b      	ldr	r3, [r7, #4]
 800f0e2:	681b      	ldr	r3, [r3, #0]
 800f0e4:	3314      	adds	r3, #20
 800f0e6:	681b      	ldr	r3, [r3, #0]
 800f0e8:	6878      	ldr	r0, [r7, #4]
 800f0ea:	4798      	blx	r3
 800f0ec:	4603      	mov	r3, r0
 800f0ee:	4619      	mov	r1, r3
 800f0f0:	4628      	mov	r0, r5
 800f0f2:	47a0      	blx	r4
		}
	}
}
 800f0f4:	bf00      	nop
 800f0f6:	3710      	adds	r7, #16
 800f0f8:	46bd      	mov	sp, r7
 800f0fa:	bdb0      	pop	{r4, r5, r7, pc}
 800f0fc:	08019434 	.word	0x08019434
 800f100:	0801943c 	.word	0x0801943c
 800f104:	08019448 	.word	0x08019448
 800f108:	08019460 	.word	0x08019460
 800f10c:	08019478 	.word	0x08019478
 800f110:	08019490 	.word	0x08019490
 800f114:	080194ac 	.word	0x080194ac

0800f118 <_ZN5board8Joystick8traceOutEPKcz>:

void Joystick::traceOut(const char * const format, ...)
{
 800f118:	b40f      	push	{r0, r1, r2, r3}
 800f11a:	b580      	push	{r7, lr}
 800f11c:	b082      	sub	sp, #8
 800f11e:	af00      	add	r7, sp, #0
	static const unsigned int STR_SIZE = 64;
	static char str[STR_SIZE];

	va_list args;

	va_start(args, format);
 800f120:	f107 0314 	add.w	r3, r7, #20
 800f124:	607b      	str	r3, [r7, #4]
	vsiprintf(str, format, args);
 800f126:	687a      	ldr	r2, [r7, #4]
 800f128:	6939      	ldr	r1, [r7, #16]
 800f12a:	480c      	ldr	r0, [pc, #48]	; (800f15c <_ZN5board8Joystick8traceOutEPKcz+0x44>)
 800f12c:	f007 fe5e 	bl	8016dec <vsiprintf>
	va_end(args);

	assert(strlen(str) < STR_SIZE);		// Uups! str is too small
 800f130:	480a      	ldr	r0, [pc, #40]	; (800f15c <_ZN5board8Joystick8traceOutEPKcz+0x44>)
 800f132:	f7f1 f89d 	bl	8000270 <strlen>
 800f136:	4603      	mov	r3, r0
 800f138:	2b3f      	cmp	r3, #63	; 0x3f
 800f13a:	d905      	bls.n	800f148 <_ZN5board8Joystick8traceOutEPKcz+0x30>
 800f13c:	4b08      	ldr	r3, [pc, #32]	; (800f160 <_ZN5board8Joystick8traceOutEPKcz+0x48>)
 800f13e:	4a09      	ldr	r2, [pc, #36]	; (800f164 <_ZN5board8Joystick8traceOutEPKcz+0x4c>)
 800f140:	21ce      	movs	r1, #206	; 0xce
 800f142:	4809      	ldr	r0, [pc, #36]	; (800f168 <_ZN5board8Joystick8traceOutEPKcz+0x50>)
 800f144:	f007 f926 	bl	8016394 <__assert_func>

	Trace::outln(str);
 800f148:	4804      	ldr	r0, [pc, #16]	; (800f15c <_ZN5board8Joystick8traceOutEPKcz+0x44>)
 800f14a:	f000 fa7f 	bl	800f64c <_ZN5Trace5outlnEPKcz>
#else
	(void)(format);
#endif
}
 800f14e:	bf00      	nop
 800f150:	3708      	adds	r7, #8
 800f152:	46bd      	mov	sp, r7
 800f154:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f158:	b004      	add	sp, #16
 800f15a:	4770      	bx	lr
 800f15c:	200019b0 	.word	0x200019b0
 800f160:	080194c8 	.word	0x080194c8
 800f164:	080194e0 	.word	0x080194e0
 800f168:	08019518 	.word	0x08019518

0800f16c <__tcf_1>:

void Joystick::onIrq(uint16_t GPIO_Pin)
{
    static XFStaticEvent irqEvent(Event_IRQ);
 800f16c:	b580      	push	{r7, lr}
 800f16e:	af00      	add	r7, sp, #0
 800f170:	4801      	ldr	r0, [pc, #4]	; (800f178 <__tcf_1+0xc>)
 800f172:	f005 f91f 	bl	80143b4 <_ZN13XFStaticEventD1Ev>
 800f176:	bd80      	pop	{r7, pc}
 800f178:	200019f0 	.word	0x200019f0

0800f17c <_ZN5board8Joystick5onIrqEt>:
{
 800f17c:	b580      	push	{r7, lr}
 800f17e:	b082      	sub	sp, #8
 800f180:	af00      	add	r7, sp, #0
 800f182:	6078      	str	r0, [r7, #4]
 800f184:	460b      	mov	r3, r1
 800f186:	807b      	strh	r3, [r7, #2]
    static XFStaticEvent irqEvent(Event_IRQ);
 800f188:	4b1b      	ldr	r3, [pc, #108]	; (800f1f8 <_ZN5board8Joystick5onIrqEt+0x7c>)
 800f18a:	781b      	ldrb	r3, [r3, #0]
 800f18c:	f3bf 8f5b 	dmb	ish
 800f190:	b2db      	uxtb	r3, r3
 800f192:	f003 0301 	and.w	r3, r3, #1
 800f196:	2b00      	cmp	r3, #0
 800f198:	bf0c      	ite	eq
 800f19a:	2301      	moveq	r3, #1
 800f19c:	2300      	movne	r3, #0
 800f19e:	b2db      	uxtb	r3, r3
 800f1a0:	2b00      	cmp	r3, #0
 800f1a2:	d015      	beq.n	800f1d0 <_ZN5board8Joystick5onIrqEt+0x54>
 800f1a4:	4814      	ldr	r0, [pc, #80]	; (800f1f8 <_ZN5board8Joystick5onIrqEt+0x7c>)
 800f1a6:	f007 f805 	bl	80161b4 <__cxa_guard_acquire>
 800f1aa:	4603      	mov	r3, r0
 800f1ac:	2b00      	cmp	r3, #0
 800f1ae:	bf14      	ite	ne
 800f1b0:	2301      	movne	r3, #1
 800f1b2:	2300      	moveq	r3, #0
 800f1b4:	b2db      	uxtb	r3, r3
 800f1b6:	2b00      	cmp	r3, #0
 800f1b8:	d00a      	beq.n	800f1d0 <_ZN5board8Joystick5onIrqEt+0x54>
 800f1ba:	2200      	movs	r2, #0
 800f1bc:	2101      	movs	r1, #1
 800f1be:	480f      	ldr	r0, [pc, #60]	; (800f1fc <_ZN5board8Joystick5onIrqEt+0x80>)
 800f1c0:	f005 f8dc 	bl	801437c <_ZN13XFStaticEventC1EiP11IXFReactive>
 800f1c4:	480e      	ldr	r0, [pc, #56]	; (800f200 <_ZN5board8Joystick5onIrqEt+0x84>)
 800f1c6:	f007 f903 	bl	80163d0 <atexit>
 800f1ca:	480b      	ldr	r0, [pc, #44]	; (800f1f8 <_ZN5board8Joystick5onIrqEt+0x7c>)
 800f1cc:	f006 fffe 	bl	80161cc <__cxa_guard_release>

    enterISR();
 800f1d0:	4b0c      	ldr	r3, [pc, #48]	; (800f204 <_ZN5board8Joystick5onIrqEt+0x88>)
 800f1d2:	2201      	movs	r2, #1
 800f1d4:	701a      	strb	r2, [r3, #0]
    pushEvent( &irqEvent );
 800f1d6:	687b      	ldr	r3, [r7, #4]
 800f1d8:	1d1a      	adds	r2, r3, #4
 800f1da:	687b      	ldr	r3, [r7, #4]
 800f1dc:	685b      	ldr	r3, [r3, #4]
 800f1de:	330c      	adds	r3, #12
 800f1e0:	681b      	ldr	r3, [r3, #0]
 800f1e2:	4906      	ldr	r1, [pc, #24]	; (800f1fc <_ZN5board8Joystick5onIrqEt+0x80>)
 800f1e4:	4610      	mov	r0, r2
 800f1e6:	4798      	blx	r3
    exitISR();
 800f1e8:	4b06      	ldr	r3, [pc, #24]	; (800f204 <_ZN5board8Joystick5onIrqEt+0x88>)
 800f1ea:	2200      	movs	r2, #0
 800f1ec:	701a      	strb	r2, [r3, #0]
}
 800f1ee:	bf00      	nop
 800f1f0:	3708      	adds	r7, #8
 800f1f2:	46bd      	mov	sp, r7
 800f1f4:	bd80      	pop	{r7, pc}
 800f1f6:	bf00      	nop
 800f1f8:	20001a04 	.word	0x20001a04
 800f1fc:	200019f0 	.word	0x200019f0
 800f200:	0800f16d 	.word	0x0800f16d
 800f204:	20001dd4 	.word	0x20001dd4

0800f208 <_ZN5board8JoystickD1Ev>:
class Joystick : public IJoystick, public XFReactive
 800f208:	b580      	push	{r7, lr}
 800f20a:	b082      	sub	sp, #8
 800f20c:	af00      	add	r7, sp, #0
 800f20e:	6078      	str	r0, [r7, #4]
 800f210:	4a09      	ldr	r2, [pc, #36]	; (800f238 <_ZN5board8JoystickD1Ev+0x30>)
 800f212:	687b      	ldr	r3, [r7, #4]
 800f214:	601a      	str	r2, [r3, #0]
 800f216:	4a09      	ldr	r2, [pc, #36]	; (800f23c <_ZN5board8JoystickD1Ev+0x34>)
 800f218:	687b      	ldr	r3, [r7, #4]
 800f21a:	605a      	str	r2, [r3, #4]
 800f21c:	687b      	ldr	r3, [r7, #4]
 800f21e:	3304      	adds	r3, #4
 800f220:	4618      	mov	r0, r3
 800f222:	f004 ffa1 	bl	8014168 <_ZN10XFReactiveD1Ev>
 800f226:	687b      	ldr	r3, [r7, #4]
 800f228:	4618      	mov	r0, r3
 800f22a:	f7ff fcfd 	bl	800ec28 <_ZN9IJoystickD1Ev>
 800f22e:	687b      	ldr	r3, [r7, #4]
 800f230:	4618      	mov	r0, r3
 800f232:	3708      	adds	r7, #8
 800f234:	46bd      	mov	sp, r7
 800f236:	bd80      	pop	{r7, pc}
 800f238:	0801bdc8 	.word	0x0801bdc8
 800f23c:	0801bdec 	.word	0x0801bdec

0800f240 <_ZThn4_N5board8JoystickD1Ev>:
 800f240:	f1a0 0004 	sub.w	r0, r0, #4
 800f244:	e7e0      	b.n	800f208 <_ZN5board8JoystickD1Ev>
 800f246:	bf00      	nop

0800f248 <_ZN5board8JoystickD0Ev>:
 800f248:	b580      	push	{r7, lr}
 800f24a:	b082      	sub	sp, #8
 800f24c:	af00      	add	r7, sp, #0
 800f24e:	6078      	str	r0, [r7, #4]
 800f250:	6878      	ldr	r0, [r7, #4]
 800f252:	f7ff ffd9 	bl	800f208 <_ZN5board8JoystickD1Ev>
 800f256:	2120      	movs	r1, #32
 800f258:	6878      	ldr	r0, [r7, #4]
 800f25a:	f006 ffa7 	bl	80161ac <_ZdlPvj>
 800f25e:	687b      	ldr	r3, [r7, #4]
 800f260:	4618      	mov	r0, r3
 800f262:	3708      	adds	r7, #8
 800f264:	46bd      	mov	sp, r7
 800f266:	bd80      	pop	{r7, pc}

0800f268 <_ZThn4_N5board8JoystickD0Ev>:
 800f268:	f1a0 0004 	sub.w	r0, r0, #4
 800f26c:	e7ec      	b.n	800f248 <_ZN5board8JoystickD0Ev>
	...

0800f270 <_Z41__static_initialization_and_destruction_0ii>:

} // namespace board
 800f270:	b580      	push	{r7, lr}
 800f272:	b088      	sub	sp, #32
 800f274:	af00      	add	r7, sp, #0
 800f276:	6078      	str	r0, [r7, #4]
 800f278:	6039      	str	r1, [r7, #0]
 800f27a:	687b      	ldr	r3, [r7, #4]
 800f27c:	2b01      	cmp	r3, #1
 800f27e:	d122      	bne.n	800f2c6 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800f280:	683b      	ldr	r3, [r7, #0]
 800f282:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f286:	4293      	cmp	r3, r2
 800f288:	d11d      	bne.n	800f2c6 <_Z41__static_initialization_and_destruction_0ii+0x56>
 800f28a:	4b18      	ldr	r3, [pc, #96]	; (800f2ec <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800f28c:	681b      	ldr	r3, [r3, #0]
 800f28e:	613b      	str	r3, [r7, #16]
 800f290:	f107 0310 	add.w	r3, r7, #16
 800f294:	60bb      	str	r3, [r7, #8]
 800f296:	2304      	movs	r3, #4
 800f298:	60fb      	str	r3, [r7, #12]
 800f29a:	f107 0308 	add.w	r3, r7, #8
 800f29e:	e893 0006 	ldmia.w	r3, {r1, r2}
 800f2a2:	4813      	ldr	r0, [pc, #76]	; (800f2f0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800f2a4:	f7f7 fd46 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800f2a8:	4b12      	ldr	r3, [pc, #72]	; (800f2f4 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800f2aa:	681b      	ldr	r3, [r3, #0]
 800f2ac:	61fb      	str	r3, [r7, #28]
 800f2ae:	f107 031c 	add.w	r3, r7, #28
 800f2b2:	617b      	str	r3, [r7, #20]
 800f2b4:	2304      	movs	r3, #4
 800f2b6:	61bb      	str	r3, [r7, #24]
 800f2b8:	f107 0314 	add.w	r3, r7, #20
 800f2bc:	e893 0006 	ldmia.w	r3, {r1, r2}
 800f2c0:	480d      	ldr	r0, [pc, #52]	; (800f2f8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800f2c2:	f7f7 fd37 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800f2c6:	687b      	ldr	r3, [r7, #4]
 800f2c8:	2b00      	cmp	r3, #0
 800f2ca:	d10a      	bne.n	800f2e2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800f2cc:	683b      	ldr	r3, [r7, #0]
 800f2ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f2d2:	4293      	cmp	r3, r2
 800f2d4:	d105      	bne.n	800f2e2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800f2d6:	4808      	ldr	r0, [pc, #32]	; (800f2f8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800f2d8:	f7f7 fe76 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800f2dc:	4804      	ldr	r0, [pc, #16]	; (800f2f0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800f2de:	f7f7 fe73 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800f2e2:	bf00      	nop
 800f2e4:	3720      	adds	r7, #32
 800f2e6:	46bd      	mov	sp, r7
 800f2e8:	bd80      	pop	{r7, pc}
 800f2ea:	bf00      	nop
 800f2ec:	0801968c 	.word	0x0801968c
 800f2f0:	2000197c 	.word	0x2000197c
 800f2f4:	08019690 	.word	0x08019690
 800f2f8:	20001984 	.word	0x20001984

0800f2fc <_GLOBAL__sub_I__ZN5board8JoystickC2Ev>:
 800f2fc:	b580      	push	{r7, lr}
 800f2fe:	af00      	add	r7, sp, #0
 800f300:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800f304:	2001      	movs	r0, #1
 800f306:	f7ff ffb3 	bl	800f270 <_Z41__static_initialization_and_destruction_0ii>
 800f30a:	bd80      	pop	{r7, pc}

0800f30c <_GLOBAL__sub_D__ZN5board8JoystickC2Ev>:
 800f30c:	b580      	push	{r7, lr}
 800f30e:	af00      	add	r7, sp, #0
 800f310:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800f314:	2000      	movs	r0, #0
 800f316:	f7ff ffab 	bl	800f270 <_Z41__static_initialization_and_destruction_0ii>
 800f31a:	bd80      	pop	{r7, pc}

0800f31c <_ZN10LedFlasherD1Ev>:
{
    friend class ::board::LedController;

protected:
    LedFlasher(uint16_t ledIndex, board::LedController & ledController);
	virtual ~LedFlasher() {}
 800f31c:	b580      	push	{r7, lr}
 800f31e:	b082      	sub	sp, #8
 800f320:	af00      	add	r7, sp, #0
 800f322:	6078      	str	r0, [r7, #4]
 800f324:	4a05      	ldr	r2, [pc, #20]	; (800f33c <_ZN10LedFlasherD1Ev+0x20>)
 800f326:	687b      	ldr	r3, [r7, #4]
 800f328:	601a      	str	r2, [r3, #0]
 800f32a:	687b      	ldr	r3, [r7, #4]
 800f32c:	4618      	mov	r0, r3
 800f32e:	f004 ff1b 	bl	8014168 <_ZN10XFReactiveD1Ev>
 800f332:	687b      	ldr	r3, [r7, #4]
 800f334:	4618      	mov	r0, r3
 800f336:	3708      	adds	r7, #8
 800f338:	46bd      	mov	sp, r7
 800f33a:	bd80      	pop	{r7, pc}
 800f33c:	0801dc28 	.word	0x0801dc28

0800f340 <_ZN10LedFlasherD0Ev>:
 800f340:	b580      	push	{r7, lr}
 800f342:	b082      	sub	sp, #8
 800f344:	af00      	add	r7, sp, #0
 800f346:	6078      	str	r0, [r7, #4]
 800f348:	6878      	ldr	r0, [r7, #4]
 800f34a:	f7ff ffe7 	bl	800f31c <_ZN10LedFlasherD1Ev>
 800f34e:	2118      	movs	r1, #24
 800f350:	6878      	ldr	r0, [r7, #4]
 800f352:	f006 ff2b 	bl	80161ac <_ZdlPvj>
 800f356:	687b      	ldr	r3, [r7, #4]
 800f358:	4618      	mov	r0, r3
 800f35a:	3708      	adds	r7, #8
 800f35c:	46bd      	mov	sp, r7
 800f35e:	bd80      	pop	{r7, pc}

0800f360 <_ZN5board13LedControllerC1Ev>:
#include "mcu/mcu.h"
#include "ledcontroller.h"

namespace board {

LedController::LedController()
 800f360:	b580      	push	{r7, lr}
 800f362:	b082      	sub	sp, #8
 800f364:	af00      	add	r7, sp, #0
 800f366:	6078      	str	r0, [r7, #4]
 : _bInitialized(false),
   _ledFlasher(0, *this)
 800f368:	4a08      	ldr	r2, [pc, #32]	; (800f38c <_ZN5board13LedControllerC1Ev+0x2c>)
 800f36a:	687b      	ldr	r3, [r7, #4]
 800f36c:	601a      	str	r2, [r3, #0]
 800f36e:	687b      	ldr	r3, [r7, #4]
 800f370:	2200      	movs	r2, #0
 800f372:	711a      	strb	r2, [r3, #4]
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	3308      	adds	r3, #8
 800f378:	687a      	ldr	r2, [r7, #4]
 800f37a:	2100      	movs	r1, #0
 800f37c:	4618      	mov	r0, r3
 800f37e:	f004 fb05 	bl	801398c <_ZN10LedFlasherC1EtRN5board13LedControllerE>
{

}
 800f382:	687b      	ldr	r3, [r7, #4]
 800f384:	4618      	mov	r0, r3
 800f386:	3708      	adds	r7, #8
 800f388:	46bd      	mov	sp, r7
 800f38a:	bd80      	pop	{r7, pc}
 800f38c:	0801be30 	.word	0x0801be30

0800f390 <_ZN5board13LedControllerD1Ev>:

LedController::~LedController()
 800f390:	b580      	push	{r7, lr}
 800f392:	b082      	sub	sp, #8
 800f394:	af00      	add	r7, sp, #0
 800f396:	6078      	str	r0, [r7, #4]
 800f398:	4a06      	ldr	r2, [pc, #24]	; (800f3b4 <_ZN5board13LedControllerD1Ev+0x24>)
 800f39a:	687b      	ldr	r3, [r7, #4]
 800f39c:	601a      	str	r2, [r3, #0]
 800f39e:	687b      	ldr	r3, [r7, #4]
 800f3a0:	3308      	adds	r3, #8
 800f3a2:	4618      	mov	r0, r3
 800f3a4:	f7ff ffba 	bl	800f31c <_ZN10LedFlasherD1Ev>
{

}
 800f3a8:	687b      	ldr	r3, [r7, #4]
 800f3aa:	4618      	mov	r0, r3
 800f3ac:	3708      	adds	r7, #8
 800f3ae:	46bd      	mov	sp, r7
 800f3b0:	bd80      	pop	{r7, pc}
 800f3b2:	bf00      	nop
 800f3b4:	0801be30 	.word	0x0801be30

0800f3b8 <_ZN5board13LedControllerD0Ev>:
LedController::~LedController()
 800f3b8:	b580      	push	{r7, lr}
 800f3ba:	b082      	sub	sp, #8
 800f3bc:	af00      	add	r7, sp, #0
 800f3be:	6078      	str	r0, [r7, #4]
}
 800f3c0:	6878      	ldr	r0, [r7, #4]
 800f3c2:	f7ff ffe5 	bl	800f390 <_ZN5board13LedControllerD1Ev>
 800f3c6:	2120      	movs	r1, #32
 800f3c8:	6878      	ldr	r0, [r7, #4]
 800f3ca:	f006 feef 	bl	80161ac <_ZdlPvj>
 800f3ce:	687b      	ldr	r3, [r7, #4]
 800f3d0:	4618      	mov	r0, r3
 800f3d2:	3708      	adds	r7, #8
 800f3d4:	46bd      	mov	sp, r7
 800f3d6:	bd80      	pop	{r7, pc}

0800f3d8 <__tcf_0>:

//static
LedController & LedController::instance()
{
	static LedController ledController;
 800f3d8:	b580      	push	{r7, lr}
 800f3da:	af00      	add	r7, sp, #0
 800f3dc:	4801      	ldr	r0, [pc, #4]	; (800f3e4 <__tcf_0+0xc>)
 800f3de:	f7ff ffd7 	bl	800f390 <_ZN5board13LedControllerD1Ev>
 800f3e2:	bd80      	pop	{r7, pc}
 800f3e4:	20001a08 	.word	0x20001a08

0800f3e8 <_ZN5board13LedController8instanceEv>:
{
 800f3e8:	b580      	push	{r7, lr}
 800f3ea:	af00      	add	r7, sp, #0
	static LedController ledController;
 800f3ec:	4b12      	ldr	r3, [pc, #72]	; (800f438 <_ZN5board13LedController8instanceEv+0x50>)
 800f3ee:	781b      	ldrb	r3, [r3, #0]
 800f3f0:	f3bf 8f5b 	dmb	ish
 800f3f4:	b2db      	uxtb	r3, r3
 800f3f6:	f003 0301 	and.w	r3, r3, #1
 800f3fa:	2b00      	cmp	r3, #0
 800f3fc:	bf0c      	ite	eq
 800f3fe:	2301      	moveq	r3, #1
 800f400:	2300      	movne	r3, #0
 800f402:	b2db      	uxtb	r3, r3
 800f404:	2b00      	cmp	r3, #0
 800f406:	d013      	beq.n	800f430 <_ZN5board13LedController8instanceEv+0x48>
 800f408:	480b      	ldr	r0, [pc, #44]	; (800f438 <_ZN5board13LedController8instanceEv+0x50>)
 800f40a:	f006 fed3 	bl	80161b4 <__cxa_guard_acquire>
 800f40e:	4603      	mov	r3, r0
 800f410:	2b00      	cmp	r3, #0
 800f412:	bf14      	ite	ne
 800f414:	2301      	movne	r3, #1
 800f416:	2300      	moveq	r3, #0
 800f418:	b2db      	uxtb	r3, r3
 800f41a:	2b00      	cmp	r3, #0
 800f41c:	d008      	beq.n	800f430 <_ZN5board13LedController8instanceEv+0x48>
 800f41e:	4807      	ldr	r0, [pc, #28]	; (800f43c <_ZN5board13LedController8instanceEv+0x54>)
 800f420:	f7ff ff9e 	bl	800f360 <_ZN5board13LedControllerC1Ev>
 800f424:	4806      	ldr	r0, [pc, #24]	; (800f440 <_ZN5board13LedController8instanceEv+0x58>)
 800f426:	f006 ffd3 	bl	80163d0 <atexit>
 800f42a:	4803      	ldr	r0, [pc, #12]	; (800f438 <_ZN5board13LedController8instanceEv+0x50>)
 800f42c:	f006 fece 	bl	80161cc <__cxa_guard_release>
	
	return ledController;
 800f430:	4b02      	ldr	r3, [pc, #8]	; (800f43c <_ZN5board13LedController8instanceEv+0x54>)
}
 800f432:	4618      	mov	r0, r3
 800f434:	bd80      	pop	{r7, pc}
 800f436:	bf00      	nop
 800f438:	20001a28 	.word	0x20001a28
 800f43c:	20001a08 	.word	0x20001a08
 800f440:	0800f3d9 	.word	0x0800f3d9

0800f444 <_ZN5board13LedController10initializeEv>:

bool LedController::initialize()
{
 800f444:	b480      	push	{r7}
 800f446:	b083      	sub	sp, #12
 800f448:	af00      	add	r7, sp, #0
 800f44a:	6078      	str	r0, [r7, #4]
	if (!_bInitialized)
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	791b      	ldrb	r3, [r3, #4]
 800f450:	f083 0301 	eor.w	r3, r3, #1
 800f454:	b2db      	uxtb	r3, r3
 800f456:	2b00      	cmp	r3, #0
 800f458:	d002      	beq.n	800f460 <_ZN5board13LedController10initializeEv+0x1c>
	{
		_bInitialized = true;
 800f45a:	687b      	ldr	r3, [r7, #4]
 800f45c:	2201      	movs	r2, #1
 800f45e:	711a      	strb	r2, [r3, #4]

	}
	return true;
 800f460:	2301      	movs	r3, #1
}
 800f462:	4618      	mov	r0, r3
 800f464:	370c      	adds	r7, #12
 800f466:	46bd      	mov	sp, r7
 800f468:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f46c:	4770      	bx	lr

0800f46e <_ZN5board13LedController5startEv>:

void LedController::start()
{
 800f46e:	b580      	push	{r7, lr}
 800f470:	b082      	sub	sp, #8
 800f472:	af00      	add	r7, sp, #0
 800f474:	6078      	str	r0, [r7, #4]
	_ledFlasher.start();
 800f476:	687b      	ldr	r3, [r7, #4]
 800f478:	3308      	adds	r3, #8
 800f47a:	4618      	mov	r0, r3
 800f47c:	f004 faa8 	bl	80139d0 <_ZN10LedFlasher5startEv>
}
 800f480:	bf00      	nop
 800f482:	3708      	adds	r7, #8
 800f484:	46bd      	mov	sp, r7
 800f486:	bd80      	pop	{r7, pc}

0800f488 <_ZN5board13LedController6setLedEib>:

void LedController::setLed(int index, bool bEnable)
{
 800f488:	b580      	push	{r7, lr}
 800f48a:	b084      	sub	sp, #16
 800f48c:	af00      	add	r7, sp, #0
 800f48e:	60f8      	str	r0, [r7, #12]
 800f490:	60b9      	str	r1, [r7, #8]
 800f492:	4613      	mov	r3, r2
 800f494:	71fb      	strb	r3, [r7, #7]
	assert(_bInitialized);	// Call method initialize() first!
 800f496:	68fb      	ldr	r3, [r7, #12]
 800f498:	791b      	ldrb	r3, [r3, #4]
 800f49a:	2b00      	cmp	r3, #0
 800f49c:	d105      	bne.n	800f4aa <_ZN5board13LedController6setLedEib+0x22>
 800f49e:	4b0e      	ldr	r3, [pc, #56]	; (800f4d8 <_ZN5board13LedController6setLedEib+0x50>)
 800f4a0:	4a0e      	ldr	r2, [pc, #56]	; (800f4dc <_ZN5board13LedController6setLedEib+0x54>)
 800f4a2:	212d      	movs	r1, #45	; 0x2d
 800f4a4:	480e      	ldr	r0, [pc, #56]	; (800f4e0 <_ZN5board13LedController6setLedEib+0x58>)
 800f4a6:	f006 ff75 	bl	8016394 <__assert_func>

	if (index == 0)
 800f4aa:	68bb      	ldr	r3, [r7, #8]
 800f4ac:	2b00      	cmp	r3, #0
 800f4ae:	d10f      	bne.n	800f4d0 <_ZN5board13LedController6setLedEib+0x48>
	{
		// Using green LED 'LD2' on Nucleo board
		if (bEnable)
 800f4b0:	79fb      	ldrb	r3, [r7, #7]
 800f4b2:	2b00      	cmp	r3, #0
 800f4b4:	d006      	beq.n	800f4c4 <_ZN5board13LedController6setLedEib+0x3c>
		{

			HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
 800f4b6:	2201      	movs	r2, #1
 800f4b8:	2120      	movs	r1, #32
 800f4ba:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800f4be:	f7f2 fbad 	bl	8001c1c <HAL_GPIO_WritePin>
		else
		{
            HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
		}
	}
}
 800f4c2:	e005      	b.n	800f4d0 <_ZN5board13LedController6setLedEib+0x48>
            HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 800f4c4:	2200      	movs	r2, #0
 800f4c6:	2120      	movs	r1, #32
 800f4c8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800f4cc:	f7f2 fba6 	bl	8001c1c <HAL_GPIO_WritePin>
}
 800f4d0:	bf00      	nop
 800f4d2:	3710      	adds	r7, #16
 800f4d4:	46bd      	mov	sp, r7
 800f4d6:	bd80      	pop	{r7, pc}
 800f4d8:	08019694 	.word	0x08019694
 800f4dc:	080196a4 	.word	0x080196a4
 800f4e0:	080196d4 	.word	0x080196d4

0800f4e4 <_ZN5board13LedController8flashLedEt>:

void LedController::flashLed(uint16_t index /* = 0 */)
{
 800f4e4:	b580      	push	{r7, lr}
 800f4e6:	b082      	sub	sp, #8
 800f4e8:	af00      	add	r7, sp, #0
 800f4ea:	6078      	str	r0, [r7, #4]
 800f4ec:	460b      	mov	r3, r1
 800f4ee:	807b      	strh	r3, [r7, #2]
	if (index == 0)
 800f4f0:	887b      	ldrh	r3, [r7, #2]
 800f4f2:	2b00      	cmp	r3, #0
 800f4f4:	d104      	bne.n	800f500 <_ZN5board13LedController8flashLedEt+0x1c>
	{
		_ledFlasher.flashLed();
 800f4f6:	687b      	ldr	r3, [r7, #4]
 800f4f8:	3308      	adds	r3, #8
 800f4fa:	4618      	mov	r0, r3
 800f4fc:	f004 fa74 	bl	80139e8 <_ZN10LedFlasher8flashLedEv>
	}
}
 800f500:	bf00      	nop
 800f502:	3708      	adds	r7, #8
 800f504:	46bd      	mov	sp, r7
 800f506:	bd80      	pop	{r7, pc}

0800f508 <_ZN4Uart4uartEh>:
	/**
	 * Static accessor to the instances of UART. Used by the factory.
	 * You should not use this method directly. Use the factory to
	 * access an UART instead.
	 */
	static inline Uart & uart(const unsigned char uartNbr)
 800f508:	b580      	push	{r7, lr}
 800f50a:	b082      	sub	sp, #8
 800f50c:	af00      	add	r7, sp, #0
 800f50e:	4603      	mov	r3, r0
 800f510:	71fb      	strb	r3, [r7, #7]
	{
		assert(uartNbr < UART_COUNT);
 800f512:	79fb      	ldrb	r3, [r7, #7]
 800f514:	2b02      	cmp	r3, #2
 800f516:	d905      	bls.n	800f524 <_ZN4Uart4uartEh+0x1c>
 800f518:	4b06      	ldr	r3, [pc, #24]	; (800f534 <_ZN4Uart4uartEh+0x2c>)
 800f51a:	4a07      	ldr	r2, [pc, #28]	; (800f538 <_ZN4Uart4uartEh+0x30>)
 800f51c:	2125      	movs	r1, #37	; 0x25
 800f51e:	4807      	ldr	r0, [pc, #28]	; (800f53c <_ZN4Uart4uartEh+0x34>)
 800f520:	f006 ff38 	bl	8016394 <__assert_func>
		return *_sUart[uartNbr];
 800f524:	79fb      	ldrb	r3, [r7, #7]
 800f526:	4a06      	ldr	r2, [pc, #24]	; (800f540 <_ZN4Uart4uartEh+0x38>)
 800f528:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	}
 800f52c:	4618      	mov	r0, r3
 800f52e:	3708      	adds	r7, #8
 800f530:	46bd      	mov	sp, r7
 800f532:	bd80      	pop	{r7, pc}
 800f534:	08019764 	.word	0x08019764
 800f538:	0801977c 	.word	0x0801977c
 800f53c:	080197a4 	.word	0x080197a4
 800f540:	20001e08 	.word	0x20001e08

0800f544 <__tcf_0>:
	static Uart uart(1);	// UART2

	uart.initialize(115200);
#endif // TC_STM32
#ifdef TC_STM32CUBEIDE
	static Uart uart(TRACE_UART_INDEX, &huart2);    // UART2
 800f544:	b580      	push	{r7, lr}
 800f546:	af00      	add	r7, sp, #0
 800f548:	4801      	ldr	r0, [pc, #4]	; (800f550 <__tcf_0+0xc>)
 800f54a:	f004 f98b 	bl	8013864 <_ZN4UartD1Ev>
 800f54e:	bd80      	pop	{r7, pc}
 800f550:	20001b3c 	.word	0x20001b3c

0800f554 <_ZN5Trace10initializeEv>:
{
 800f554:	b580      	push	{r7, lr}
 800f556:	af00      	add	r7, sp, #0
	static Uart uart(TRACE_UART_INDEX, &huart2);    // UART2
 800f558:	4b14      	ldr	r3, [pc, #80]	; (800f5ac <_ZN5Trace10initializeEv+0x58>)
 800f55a:	781b      	ldrb	r3, [r3, #0]
 800f55c:	f3bf 8f5b 	dmb	ish
 800f560:	b2db      	uxtb	r3, r3
 800f562:	f003 0301 	and.w	r3, r3, #1
 800f566:	2b00      	cmp	r3, #0
 800f568:	bf0c      	ite	eq
 800f56a:	2301      	moveq	r3, #1
 800f56c:	2300      	movne	r3, #0
 800f56e:	b2db      	uxtb	r3, r3
 800f570:	2b00      	cmp	r3, #0
 800f572:	d016      	beq.n	800f5a2 <_ZN5Trace10initializeEv+0x4e>
 800f574:	480d      	ldr	r0, [pc, #52]	; (800f5ac <_ZN5Trace10initializeEv+0x58>)
 800f576:	f006 fe1d 	bl	80161b4 <__cxa_guard_acquire>
 800f57a:	4603      	mov	r3, r0
 800f57c:	2b00      	cmp	r3, #0
 800f57e:	bf14      	ite	ne
 800f580:	2301      	movne	r3, #1
 800f582:	2300      	moveq	r3, #0
 800f584:	b2db      	uxtb	r3, r3
 800f586:	2b00      	cmp	r3, #0
 800f588:	d00b      	beq.n	800f5a2 <_ZN5Trace10initializeEv+0x4e>
 800f58a:	2300      	movs	r3, #0
 800f58c:	4a08      	ldr	r2, [pc, #32]	; (800f5b0 <_ZN5Trace10initializeEv+0x5c>)
 800f58e:	2101      	movs	r1, #1
 800f590:	4808      	ldr	r0, [pc, #32]	; (800f5b4 <_ZN5Trace10initializeEv+0x60>)
 800f592:	f004 f91b 	bl	80137cc <_ZN4UartC1EhP20__UART_HandleTypeDefb>
 800f596:	4808      	ldr	r0, [pc, #32]	; (800f5b8 <_ZN5Trace10initializeEv+0x64>)
 800f598:	f006 ff1a 	bl	80163d0 <atexit>
 800f59c:	4803      	ldr	r0, [pc, #12]	; (800f5ac <_ZN5Trace10initializeEv+0x58>)
 800f59e:	f006 fe15 	bl	80161cc <__cxa_guard_release>

	// Baud-rate is defined by STM32CubeIDE's .ioc file
    uart.initialize();
 800f5a2:	4804      	ldr	r0, [pc, #16]	; (800f5b4 <_ZN5Trace10initializeEv+0x60>)
 800f5a4:	f004 f97e 	bl	80138a4 <_ZN4Uart10initializeEv>
#endif // TC_STM32CUBEIDE
#endif
#endif
}
 800f5a8:	bf00      	nop
 800f5aa:	bd80      	pop	{r7, pc}
 800f5ac:	20001bcc 	.word	0x20001bcc
 800f5b0:	200001fc 	.word	0x200001fc
 800f5b4:	20001b3c 	.word	0x20001b3c
 800f5b8:	0800f545 	.word	0x0800f545

0800f5bc <_ZN5Trace6_printEPcb>:
 * @param str The string to print
 * @param addEndLine If true check if the string ends with a new line.
 */
// static
void Trace::_print(char * str, bool addEndLine /* = false */)
{
 800f5bc:	b580      	push	{r7, lr}
 800f5be:	b084      	sub	sp, #16
 800f5c0:	af00      	add	r7, sp, #0
 800f5c2:	6078      	str	r0, [r7, #4]
 800f5c4:	460b      	mov	r3, r1
 800f5c6:	70fb      	strb	r3, [r7, #3]
#if (USE_TRACE != 0)
	const int len = strlen(str);
 800f5c8:	6878      	ldr	r0, [r7, #4]
 800f5ca:	f7f0 fe51 	bl	8000270 <strlen>
 800f5ce:	4603      	mov	r3, r0
 800f5d0:	60fb      	str	r3, [r7, #12]

	if (addEndLine && (str[len - 1] != '\n'))
 800f5d2:	78fb      	ldrb	r3, [r7, #3]
 800f5d4:	2b00      	cmp	r3, #0
 800f5d6:	d01a      	beq.n	800f60e <_ZN5Trace6_printEPcb+0x52>
 800f5d8:	68fb      	ldr	r3, [r7, #12]
 800f5da:	3b01      	subs	r3, #1
 800f5dc:	687a      	ldr	r2, [r7, #4]
 800f5de:	4413      	add	r3, r2
 800f5e0:	781b      	ldrb	r3, [r3, #0]
 800f5e2:	2b0a      	cmp	r3, #10
 800f5e4:	d013      	beq.n	800f60e <_ZN5Trace6_printEPcb+0x52>
		str[len + 1] = '\n';
		str[len + 2] = '\0';
		assert(len < TRACE_BUFFER_SIZE - 2);	// String too long for buffer
#else
		// Add "\r" (linux host)
		str[len] 	 = '\r';
 800f5e6:	68fb      	ldr	r3, [r7, #12]
 800f5e8:	687a      	ldr	r2, [r7, #4]
 800f5ea:	4413      	add	r3, r2
 800f5ec:	220d      	movs	r2, #13
 800f5ee:	701a      	strb	r2, [r3, #0]
		str[len + 1] = '\0';
 800f5f0:	68fb      	ldr	r3, [r7, #12]
 800f5f2:	3301      	adds	r3, #1
 800f5f4:	687a      	ldr	r2, [r7, #4]
 800f5f6:	4413      	add	r3, r2
 800f5f8:	2200      	movs	r2, #0
 800f5fa:	701a      	strb	r2, [r3, #0]
		assert(len < TRACE_BUFFER_SIZE - 1);	// String too long for buffer
 800f5fc:	68fb      	ldr	r3, [r7, #12]
 800f5fe:	2bfe      	cmp	r3, #254	; 0xfe
 800f600:	dd0e      	ble.n	800f620 <_ZN5Trace6_printEPcb+0x64>
 800f602:	4b0e      	ldr	r3, [pc, #56]	; (800f63c <_ZN5Trace6_printEPcb+0x80>)
 800f604:	4a0e      	ldr	r2, [pc, #56]	; (800f640 <_ZN5Trace6_printEPcb+0x84>)
 800f606:	2143      	movs	r1, #67	; 0x43
 800f608:	480e      	ldr	r0, [pc, #56]	; (800f644 <_ZN5Trace6_printEPcb+0x88>)
 800f60a:	f006 fec3 	bl	8016394 <__assert_func>
#endif
	}
	else
	{
		assert(len < TRACE_BUFFER_SIZE);		// String too long for buffer
 800f60e:	68fb      	ldr	r3, [r7, #12]
 800f610:	2bff      	cmp	r3, #255	; 0xff
 800f612:	dd05      	ble.n	800f620 <_ZN5Trace6_printEPcb+0x64>
 800f614:	4b0c      	ldr	r3, [pc, #48]	; (800f648 <_ZN5Trace6_printEPcb+0x8c>)
 800f616:	4a0a      	ldr	r2, [pc, #40]	; (800f640 <_ZN5Trace6_printEPcb+0x84>)
 800f618:	2148      	movs	r1, #72	; 0x48
 800f61a:	480a      	ldr	r0, [pc, #40]	; (800f644 <_ZN5Trace6_printEPcb+0x88>)
 800f61c:	f006 feba 	bl	8016394 <__assert_func>
	}

	Uart::uart(TRACE_UART_INDEX).write(str);
 800f620:	2001      	movs	r0, #1
 800f622:	f7ff ff71 	bl	800f508 <_ZN4Uart4uartEh>
 800f626:	4603      	mov	r3, r0
 800f628:	2200      	movs	r2, #0
 800f62a:	6879      	ldr	r1, [r7, #4]
 800f62c:	4618      	mov	r0, r3
 800f62e:	f004 f944 	bl	80138ba <_ZN4Uart5writeEPKcj>
#endif // USE_TRACE
}
 800f632:	bf00      	nop
 800f634:	3710      	adds	r7, #16
 800f636:	46bd      	mov	sp, r7
 800f638:	bd80      	pop	{r7, pc}
 800f63a:	bf00      	nop
 800f63c:	0801982c 	.word	0x0801982c
 800f640:	08019848 	.word	0x08019848
 800f644:	08019870 	.word	0x08019870
 800f648:	080198f8 	.word	0x080198f8

0800f64c <_ZN5Trace5outlnEPKcz>:

// static
void Trace::outln(const char * const format, ...)
{
 800f64c:	b40f      	push	{r0, r1, r2, r3}
 800f64e:	b580      	push	{r7, lr}
 800f650:	b082      	sub	sp, #8
 800f652:	af00      	add	r7, sp, #0
#if (USE_TRACE != 0)
	va_list args;

	va_start(args, format);
 800f654:	f107 0314 	add.w	r3, r7, #20
 800f658:	607b      	str	r3, [r7, #4]
	vsiprintf(strTrace, format, args);
 800f65a:	687a      	ldr	r2, [r7, #4]
 800f65c:	6939      	ldr	r1, [r7, #16]
 800f65e:	4807      	ldr	r0, [pc, #28]	; (800f67c <_ZN5Trace5outlnEPKcz+0x30>)
 800f660:	f007 fbc4 	bl	8016dec <vsiprintf>
	va_end(args);

	_print(strTrace, true);
 800f664:	2101      	movs	r1, #1
 800f666:	4805      	ldr	r0, [pc, #20]	; (800f67c <_ZN5Trace5outlnEPKcz+0x30>)
 800f668:	f7ff ffa8 	bl	800f5bc <_ZN5Trace6_printEPcb>
#endif // USE_TRACE
}
 800f66c:	bf00      	nop
 800f66e:	3708      	adds	r7, #8
 800f670:	46bd      	mov	sp, r7
 800f672:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f676:	b004      	add	sp, #16
 800f678:	4770      	bx	lr
 800f67a:	bf00      	nop
 800f67c:	20001a3c 	.word	0x20001a3c

0800f680 <trace>:

	va_end(arguments);
}

extern "C" void trace(const char * const format , ...)
{
 800f680:	b40f      	push	{r0, r1, r2, r3}
 800f682:	b580      	push	{r7, lr}
 800f684:	b082      	sub	sp, #8
 800f686:	af00      	add	r7, sp, #0
#if (USE_TRACE != 0)
	va_list args;
	va_start(args, format);
 800f688:	f107 0314 	add.w	r3, r7, #20
 800f68c:	607b      	str	r3, [r7, #4]
	vsprintf(strTrace, format, args);
 800f68e:	687a      	ldr	r2, [r7, #4]
 800f690:	6939      	ldr	r1, [r7, #16]
 800f692:	4807      	ldr	r0, [pc, #28]	; (800f6b0 <trace+0x30>)
 800f694:	f007 fbaa 	bl	8016dec <vsiprintf>
	va_end(args);

	Trace::_print(strTrace, false);
 800f698:	2100      	movs	r1, #0
 800f69a:	4805      	ldr	r0, [pc, #20]	; (800f6b0 <trace+0x30>)
 800f69c:	f7ff ff8e 	bl	800f5bc <_ZN5Trace6_printEPcb>
#endif // USE_TRACE
}
 800f6a0:	bf00      	nop
 800f6a2:	3708      	adds	r7, #8
 800f6a4:	46bd      	mov	sp, r7
 800f6a6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f6aa:	b004      	add	sp, #16
 800f6ac:	4770      	bx	lr
 800f6ae:	bf00      	nop
 800f6b0:	20001a3c 	.word	0x20001a3c

0800f6b4 <_Z41__static_initialization_and_destruction_0ii>:
	vsprintf(strTrace, format, args);
	va_end(args);

	Trace::_print(strTrace, true);
#endif // USE_TRACE
}
 800f6b4:	b580      	push	{r7, lr}
 800f6b6:	b088      	sub	sp, #32
 800f6b8:	af00      	add	r7, sp, #0
 800f6ba:	6078      	str	r0, [r7, #4]
 800f6bc:	6039      	str	r1, [r7, #0]
 800f6be:	687b      	ldr	r3, [r7, #4]
 800f6c0:	2b01      	cmp	r3, #1
 800f6c2:	d122      	bne.n	800f70a <_Z41__static_initialization_and_destruction_0ii+0x56>
 800f6c4:	683b      	ldr	r3, [r7, #0]
 800f6c6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f6ca:	4293      	cmp	r3, r2
 800f6cc:	d11d      	bne.n	800f70a <_Z41__static_initialization_and_destruction_0ii+0x56>
 800f6ce:	4b18      	ldr	r3, [pc, #96]	; (800f730 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 800f6d0:	681b      	ldr	r3, [r3, #0]
 800f6d2:	613b      	str	r3, [r7, #16]
 800f6d4:	f107 0310 	add.w	r3, r7, #16
 800f6d8:	60bb      	str	r3, [r7, #8]
 800f6da:	2304      	movs	r3, #4
 800f6dc:	60fb      	str	r3, [r7, #12]
 800f6de:	f107 0308 	add.w	r3, r7, #8
 800f6e2:	e893 0006 	ldmia.w	r3, {r1, r2}
 800f6e6:	4813      	ldr	r0, [pc, #76]	; (800f734 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800f6e8:	f7f7 fb24 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 800f6ec:	4b12      	ldr	r3, [pc, #72]	; (800f738 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 800f6ee:	681b      	ldr	r3, [r3, #0]
 800f6f0:	61fb      	str	r3, [r7, #28]
 800f6f2:	f107 031c 	add.w	r3, r7, #28
 800f6f6:	617b      	str	r3, [r7, #20]
 800f6f8:	2304      	movs	r3, #4
 800f6fa:	61bb      	str	r3, [r7, #24]
 800f6fc:	f107 0314 	add.w	r3, r7, #20
 800f700:	e893 0006 	ldmia.w	r3, {r1, r2}
 800f704:	480d      	ldr	r0, [pc, #52]	; (800f73c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800f706:	f7f7 fb15 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 800f70a:	687b      	ldr	r3, [r7, #4]
 800f70c:	2b00      	cmp	r3, #0
 800f70e:	d10a      	bne.n	800f726 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800f710:	683b      	ldr	r3, [r7, #0]
 800f712:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f716:	4293      	cmp	r3, r2
 800f718:	d105      	bne.n	800f726 <_Z41__static_initialization_and_destruction_0ii+0x72>
 800f71a:	4808      	ldr	r0, [pc, #32]	; (800f73c <_Z41__static_initialization_and_destruction_0ii+0x88>)
 800f71c:	f7f7 fc54 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 800f720:	4804      	ldr	r0, [pc, #16]	; (800f734 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 800f722:	f7f7 fc51 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 800f726:	bf00      	nop
 800f728:	3720      	adds	r7, #32
 800f72a:	46bd      	mov	sp, r7
 800f72c:	bd80      	pop	{r7, pc}
 800f72e:	bf00      	nop
 800f730:	080199f8 	.word	0x080199f8
 800f734:	20001a2c 	.word	0x20001a2c
 800f738:	080199fc 	.word	0x080199fc
 800f73c:	20001a34 	.word	0x20001a34

0800f740 <_GLOBAL__sub_I_strTrace>:
 800f740:	b580      	push	{r7, lr}
 800f742:	af00      	add	r7, sp, #0
 800f744:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800f748:	2001      	movs	r0, #1
 800f74a:	f7ff ffb3 	bl	800f6b4 <_Z41__static_initialization_and_destruction_0ii>
 800f74e:	bd80      	pop	{r7, pc}

0800f750 <_GLOBAL__sub_D_strTrace>:
 800f750:	b580      	push	{r7, lr}
 800f752:	af00      	add	r7, sp, #0
 800f754:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800f758:	2000      	movs	r0, #0
 800f75a:	f7ff ffab 	bl	800f6b4 <_Z41__static_initialization_and_destruction_0ii>
 800f75e:	bd80      	pop	{r7, pc}

0800f760 <_ZN2ep7DisplayC1Ev>:

namespace ep {

Display * Display::pInstance = nullptr;

Display::Display()
 800f760:	b480      	push	{r7}
 800f762:	b083      	sub	sp, #12
 800f764:	af00      	add	r7, sp, #0
 800f766:	6078      	str	r0, [r7, #4]
 800f768:	4a0c      	ldr	r2, [pc, #48]	; (800f79c <_ZN2ep7DisplayC1Ev+0x3c>)
 800f76a:	687b      	ldr	r3, [r7, #4]
 800f76c:	601a      	str	r2, [r3, #0]
{
    spi = nullptr;
 800f76e:	687b      	ldr	r3, [r7, #4]
 800f770:	2200      	movs	r2, #0
 800f772:	605a      	str	r2, [r3, #4]
    pinDC = nullptr;
 800f774:	687b      	ldr	r3, [r7, #4]
 800f776:	2200      	movs	r2, #0
 800f778:	609a      	str	r2, [r3, #8]
    pinBusy = nullptr;
 800f77a:	687b      	ldr	r3, [r7, #4]
 800f77c:	2200      	movs	r2, #0
 800f77e:	60da      	str	r2, [r3, #12]
    pinReset = nullptr;
 800f780:	687b      	ldr	r3, [r7, #4]
 800f782:	2200      	movs	r2, #0
 800f784:	611a      	str	r2, [r3, #16]
    pInstance = nullptr;
 800f786:	4b06      	ldr	r3, [pc, #24]	; (800f7a0 <_ZN2ep7DisplayC1Ev+0x40>)
 800f788:	2200      	movs	r2, #0
 800f78a:	601a      	str	r2, [r3, #0]
}
 800f78c:	687b      	ldr	r3, [r7, #4]
 800f78e:	4618      	mov	r0, r3
 800f790:	370c      	adds	r7, #12
 800f792:	46bd      	mov	sp, r7
 800f794:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f798:	4770      	bx	lr
 800f79a:	bf00      	nop
 800f79c:	0801be40 	.word	0x0801be40
 800f7a0:	20001bd0 	.word	0x20001bd0

0800f7a4 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_>:
    pinDC    :   pin used to say to the display if it's some Data or a command
    pinBusy  :   pin used by the display to say if busy or not
    pinReset :   pin used to perform a reset to the display
******************************************************************************/
void Display::initialize(SPI_HandleTypeDef * spi, Gpo * pinDC, Gpi * pinBusy, Gpo * pinReset)
{
 800f7a4:	b580      	push	{r7, lr}
 800f7a6:	b084      	sub	sp, #16
 800f7a8:	af00      	add	r7, sp, #0
 800f7aa:	60f8      	str	r0, [r7, #12]
 800f7ac:	60b9      	str	r1, [r7, #8]
 800f7ae:	607a      	str	r2, [r7, #4]
 800f7b0:	603b      	str	r3, [r7, #0]
    if (spi && pinDC && pinBusy && pinReset)
 800f7b2:	68bb      	ldr	r3, [r7, #8]
 800f7b4:	2b00      	cmp	r3, #0
 800f7b6:	d01e      	beq.n	800f7f6 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x52>
 800f7b8:	687b      	ldr	r3, [r7, #4]
 800f7ba:	2b00      	cmp	r3, #0
 800f7bc:	d01b      	beq.n	800f7f6 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x52>
 800f7be:	683b      	ldr	r3, [r7, #0]
 800f7c0:	2b00      	cmp	r3, #0
 800f7c2:	d018      	beq.n	800f7f6 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x52>
 800f7c4:	69bb      	ldr	r3, [r7, #24]
 800f7c6:	2b00      	cmp	r3, #0
 800f7c8:	d015      	beq.n	800f7f6 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x52>
    {
        this->spi = spi;
 800f7ca:	68fb      	ldr	r3, [r7, #12]
 800f7cc:	68ba      	ldr	r2, [r7, #8]
 800f7ce:	605a      	str	r2, [r3, #4]
        this->pinDC = pinDC;
 800f7d0:	68fb      	ldr	r3, [r7, #12]
 800f7d2:	687a      	ldr	r2, [r7, #4]
 800f7d4:	609a      	str	r2, [r3, #8]
        this->pinBusy = pinBusy;
 800f7d6:	68fb      	ldr	r3, [r7, #12]
 800f7d8:	683a      	ldr	r2, [r7, #0]
 800f7da:	60da      	str	r2, [r3, #12]
        this->pinReset = pinReset;
 800f7dc:	68fb      	ldr	r3, [r7, #12]
 800f7de:	69ba      	ldr	r2, [r7, #24]
 800f7e0:	611a      	str	r2, [r3, #16]
        pInstance = this;
 800f7e2:	4a09      	ldr	r2, [pc, #36]	; (800f808 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x64>)
 800f7e4:	68fb      	ldr	r3, [r7, #12]
 800f7e6:	6013      	str	r3, [r2, #0]
    }
    else
    {
        assert(false);
    }
    init();
 800f7e8:	68fb      	ldr	r3, [r7, #12]
 800f7ea:	681b      	ldr	r3, [r3, #0]
 800f7ec:	3308      	adds	r3, #8
 800f7ee:	681b      	ldr	r3, [r3, #0]
 800f7f0:	68f8      	ldr	r0, [r7, #12]
 800f7f2:	4798      	blx	r3
}
 800f7f4:	e005      	b.n	800f802 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x5e>
        assert(false);
 800f7f6:	4b05      	ldr	r3, [pc, #20]	; (800f80c <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x68>)
 800f7f8:	4a05      	ldr	r2, [pc, #20]	; (800f810 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x6c>)
 800f7fa:	2125      	movs	r1, #37	; 0x25
 800f7fc:	4805      	ldr	r0, [pc, #20]	; (800f814 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_+0x70>)
 800f7fe:	f006 fdc9 	bl	8016394 <__assert_func>
}
 800f802:	3710      	adds	r7, #16
 800f804:	46bd      	mov	sp, r7
 800f806:	bd80      	pop	{r7, pc}
 800f808:	20001bd0 	.word	0x20001bd0
 800f80c:	08019a00 	.word	0x08019a00
 800f810:	08019a08 	.word	0x08019a08
 800f814:	08019a58 	.word	0x08019a58

0800f818 <_ZN2ep7Display9SPI_WriteEh>:
function:	communicate with the command to the display
parameter:
    command :   value of the data or the command
******************************************************************************/
void Display::SPI_Write(unsigned char command)
{
 800f818:	b580      	push	{r7, lr}
 800f81a:	b082      	sub	sp, #8
 800f81c:	af00      	add	r7, sp, #0
 800f81e:	6078      	str	r0, [r7, #4]
 800f820:	460b      	mov	r3, r1
 800f822:	70fb      	strb	r3, [r7, #3]
    HAL_SPI_Transmit(this->spi, &command, 1, -1);
 800f824:	687b      	ldr	r3, [r7, #4]
 800f826:	6858      	ldr	r0, [r3, #4]
 800f828:	1cf9      	adds	r1, r7, #3
 800f82a:	f04f 33ff 	mov.w	r3, #4294967295
 800f82e:	2201      	movs	r2, #1
 800f830:	f7f4 fae7 	bl	8003e02 <HAL_SPI_Transmit>
}
 800f834:	bf00      	nop
 800f836:	3708      	adds	r7, #8
 800f838:	46bd      	mov	sp, r7
 800f83a:	bd80      	pop	{r7, pc}

0800f83c <_ZN2ep7Display8writeCMDEh>:
function:	write a command to the display (well, to the chip)
parameter:
    command :   value of the command
******************************************************************************/
void Display::writeCMD(uint8_t command)
{
 800f83c:	b580      	push	{r7, lr}
 800f83e:	b082      	sub	sp, #8
 800f840:	af00      	add	r7, sp, #0
 800f842:	6078      	str	r0, [r7, #4]
 800f844:	460b      	mov	r3, r1
 800f846:	70fb      	strb	r3, [r7, #3]
    this->pinDC->off();
 800f848:	687b      	ldr	r3, [r7, #4]
 800f84a:	689b      	ldr	r3, [r3, #8]
 800f84c:	4618      	mov	r0, r3
 800f84e:	f000 fe64 	bl	801051a <_ZN2ep3Gpo3offEv>
    SPI_Write(command);
 800f852:	78fb      	ldrb	r3, [r7, #3]
 800f854:	4619      	mov	r1, r3
 800f856:	6878      	ldr	r0, [r7, #4]
 800f858:	f7ff ffde 	bl	800f818 <_ZN2ep7Display9SPI_WriteEh>
}
 800f85c:	bf00      	nop
 800f85e:	3708      	adds	r7, #8
 800f860:	46bd      	mov	sp, r7
 800f862:	bd80      	pop	{r7, pc}

0800f864 <_ZN2ep7Display9writeDATAEh>:
function:	write some data to the display (well, to the chip)
parameter:
    command : value of the data
******************************************************************************/
void Display::writeDATA(uint8_t command)
{
 800f864:	b580      	push	{r7, lr}
 800f866:	b082      	sub	sp, #8
 800f868:	af00      	add	r7, sp, #0
 800f86a:	6078      	str	r0, [r7, #4]
 800f86c:	460b      	mov	r3, r1
 800f86e:	70fb      	strb	r3, [r7, #3]
    this->pinDC->on();
 800f870:	687b      	ldr	r3, [r7, #4]
 800f872:	689b      	ldr	r3, [r3, #8]
 800f874:	4618      	mov	r0, r3
 800f876:	f000 fe3f 	bl	80104f8 <_ZN2ep3Gpo2onEv>
    SPI_Write(command);
 800f87a:	78fb      	ldrb	r3, [r7, #3]
 800f87c:	4619      	mov	r1, r3
 800f87e:	6878      	ldr	r0, [r7, #4]
 800f880:	f7ff ffca 	bl	800f818 <_ZN2ep7Display9SPI_WriteEh>
}
 800f884:	bf00      	nop
 800f886:	3708      	adds	r7, #8
 800f888:	46bd      	mov	sp, r7
 800f88a:	bd80      	pop	{r7, pc}

0800f88c <_ZN2ep7Display9initResetEv>:

/******************************************************************************
function:	Perform a reset to the display
******************************************************************************/
void Display::initReset()
{
 800f88c:	b580      	push	{r7, lr}
 800f88e:	b082      	sub	sp, #8
 800f890:	af00      	add	r7, sp, #0
 800f892:	6078      	str	r0, [r7, #4]
    this->pinReset->off();
 800f894:	687b      	ldr	r3, [r7, #4]
 800f896:	691b      	ldr	r3, [r3, #16]
 800f898:	4618      	mov	r0, r3
 800f89a:	f000 fe3e 	bl	801051a <_ZN2ep3Gpo3offEv>
    HAL_Delay(50);
 800f89e:	2032      	movs	r0, #50	; 0x32
 800f8a0:	f7f1 fe02 	bl	80014a8 <HAL_Delay>
    this->pinReset->on();
 800f8a4:	687b      	ldr	r3, [r7, #4]
 800f8a6:	691b      	ldr	r3, [r3, #16]
 800f8a8:	4618      	mov	r0, r3
 800f8aa:	f000 fe25 	bl	80104f8 <_ZN2ep3Gpo2onEv>
    HAL_Delay(50);
 800f8ae:	2032      	movs	r0, #50	; 0x32
 800f8b0:	f7f1 fdfa 	bl	80014a8 <HAL_Delay>
}
 800f8b4:	bf00      	nop
 800f8b6:	3708      	adds	r7, #8
 800f8b8:	46bd      	mov	sp, r7
 800f8ba:	bd80      	pop	{r7, pc}

0800f8bc <_ZN2ep7Display12lcdChkstatusEv>:

/******************************************************************************
function:	Check if the display is busy
******************************************************************************/
void Display::lcdChkstatus()
{
 800f8bc:	b580      	push	{r7, lr}
 800f8be:	b084      	sub	sp, #16
 800f8c0:	af00      	add	r7, sp, #0
 800f8c2:	6078      	str	r0, [r7, #4]
    GPIO_PinState busy = this->pinBusy->read();
 800f8c4:	687b      	ldr	r3, [r7, #4]
 800f8c6:	68db      	ldr	r3, [r3, #12]
 800f8c8:	4618      	mov	r0, r3
 800f8ca:	f000 fddd 	bl	8010488 <_ZN2ep3Gpi4readEv>
 800f8ce:	4603      	mov	r3, r0
 800f8d0:	73fb      	strb	r3, [r7, #15]

    while (busy == GPIO_PIN_SET)
 800f8d2:	7bfb      	ldrb	r3, [r7, #15]
 800f8d4:	2b01      	cmp	r3, #1
 800f8d6:	d10a      	bne.n	800f8ee <_ZN2ep7Display12lcdChkstatusEv+0x32>
    {
        HAL_Delay(10);
 800f8d8:	200a      	movs	r0, #10
 800f8da:	f7f1 fde5 	bl	80014a8 <HAL_Delay>
        busy = this->pinBusy->read();
 800f8de:	687b      	ldr	r3, [r7, #4]
 800f8e0:	68db      	ldr	r3, [r3, #12]
 800f8e2:	4618      	mov	r0, r3
 800f8e4:	f000 fdd0 	bl	8010488 <_ZN2ep3Gpi4readEv>
 800f8e8:	4603      	mov	r3, r0
 800f8ea:	73fb      	strb	r3, [r7, #15]
    while (busy == GPIO_PIN_SET)
 800f8ec:	e7f1      	b.n	800f8d2 <_ZN2ep7Display12lcdChkstatusEv+0x16>
    }
}
 800f8ee:	bf00      	nop
 800f8f0:	3710      	adds	r7, #16
 800f8f2:	46bd      	mov	sp, r7
 800f8f4:	bd80      	pop	{r7, pc}
	...

0800f8f8 <_ZN2ep12DisplayFirst4initEv>:

/******************************************************************************
function:	Perform some init instructions for the display
******************************************************************************/
void DisplayFirst::init()
{
 800f8f8:	b580      	push	{r7, lr}
 800f8fa:	b086      	sub	sp, #24
 800f8fc:	af00      	add	r7, sp, #0
 800f8fe:	6078      	str	r0, [r7, #4]
	//GD : This annotation is used to notify that this isn't the settings that was found in Adafruit example code
	//But settings found for a better "short refresh" (most of them is certainly useless however)
    uint8_t buf[5];
    initReset();                    // Electronic paper IC reset
 800f900:	687b      	ldr	r3, [r7, #4]
 800f902:	4618      	mov	r0, r3
 800f904:	f7ff ffc2 	bl	800f88c <_ZN2ep7Display9initResetEv>
    lcdChkstatus();
 800f908:	687b      	ldr	r3, [r7, #4]
 800f90a:	4618      	mov	r0, r3
 800f90c:	f7ff ffd6 	bl	800f8bc <_ZN2ep7Display12lcdChkstatusEv>

    writeCMD(SSD1608_SW_RESET);     // soft reset
 800f910:	687b      	ldr	r3, [r7, #4]
 800f912:	2112      	movs	r1, #18
 800f914:	4618      	mov	r0, r3
 800f916:	f7ff ff91 	bl	800f83c <_ZN2ep7Display8writeCMDEh>

    lcdChkstatus();
 800f91a:	687b      	ldr	r3, [r7, #4]
 800f91c:	4618      	mov	r0, r3
 800f91e:	f7ff ffcd 	bl	800f8bc <_ZN2ep7Display12lcdChkstatusEv>

    // driver output control
    buf[0] = HEIGHT - 1;
 800f922:	23c7      	movs	r3, #199	; 0xc7
 800f924:	733b      	strb	r3, [r7, #12]
    buf[1] = (HEIGHT - 1) >> 8;
 800f926:	2300      	movs	r3, #0
 800f928:	737b      	strb	r3, [r7, #13]
    buf[2] = 0x00;
 800f92a:	2300      	movs	r3, #0
 800f92c:	73bb      	strb	r3, [r7, #14]
    writeCMD(SSD1608_DRIVER_CONTROL);
 800f92e:	687b      	ldr	r3, [r7, #4]
 800f930:	2101      	movs	r1, #1
 800f932:	4618      	mov	r0, r3
 800f934:	f7ff ff82 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(buf[0]);
 800f938:	687b      	ldr	r3, [r7, #4]
 800f93a:	7b3a      	ldrb	r2, [r7, #12]
 800f93c:	4611      	mov	r1, r2
 800f93e:	4618      	mov	r0, r3
 800f940:	f7ff ff90 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(buf[1]);
 800f944:	687b      	ldr	r3, [r7, #4]
 800f946:	7b7a      	ldrb	r2, [r7, #13]
 800f948:	4611      	mov	r1, r2
 800f94a:	4618      	mov	r0, r3
 800f94c:	f7ff ff8a 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(buf[2]);
 800f950:	687b      	ldr	r3, [r7, #4]
 800f952:	7bba      	ldrb	r2, [r7, #14]
 800f954:	4611      	mov	r1, r2
 800f956:	4618      	mov	r0, r3
 800f958:	f7ff ff84 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    //Gate Driving voltage Control (GD)
    writeCMD(SSD1608_GATE_VOLTAGE);
 800f95c:	687b      	ldr	r3, [r7, #4]
 800f95e:	2103      	movs	r1, #3
 800f960:	4618      	mov	r0, r3
 800f962:	f7ff ff6b 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x00);
 800f966:	687b      	ldr	r3, [r7, #4]
 800f968:	2100      	movs	r1, #0
 800f96a:	4618      	mov	r0, r3
 800f96c:	f7ff ff7a 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Set dummy line period
    writeCMD(SSD1608_WRITE_DUMMY);
 800f970:	687b      	ldr	r3, [r7, #4]
 800f972:	213a      	movs	r1, #58	; 0x3a
 800f974:	4618      	mov	r0, r3
 800f976:	f7ff ff61 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    //writeDATA(0x1B);
    writeDATA(0x1A); //GD
 800f97a:	687b      	ldr	r3, [r7, #4]
 800f97c:	211a      	movs	r1, #26
 800f97e:	4618      	mov	r0, r3
 800f980:	f7ff ff70 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Set gate line width
    writeCMD(SSD1608_WRITE_GATELINE);
 800f984:	687b      	ldr	r3, [r7, #4]
 800f986:	213b      	movs	r1, #59	; 0x3b
 800f988:	4618      	mov	r0, r3
 800f98a:	f7ff ff57 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    //writeDATA(0x0B);
    writeDATA(0x08);	//GD
 800f98e:	687b      	ldr	r3, [r7, #4]
 800f990:	2108      	movs	r1, #8
 800f992:	4618      	mov	r0, r3
 800f994:	f7ff ff66 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Data entry sequence
    writeCMD(SSD1608_DATA_MODE);
 800f998:	687b      	ldr	r3, [r7, #4]
 800f99a:	2111      	movs	r1, #17
 800f99c:	4618      	mov	r0, r3
 800f99e:	f7ff ff4d 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x03);
 800f9a2:	687b      	ldr	r3, [r7, #4]
 800f9a4:	2103      	movs	r1, #3
 800f9a6:	4618      	mov	r0, r3
 800f9a8:	f7ff ff5c 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Set ram X start/end position
    buf[0]=WIDTH / 8 - 1;
 800f9ac:	2318      	movs	r3, #24
 800f9ae:	733b      	strb	r3, [r7, #12]
    writeCMD(SSD1608_SET_RAMXPOS);
 800f9b0:	687b      	ldr	r3, [r7, #4]
 800f9b2:	2144      	movs	r1, #68	; 0x44
 800f9b4:	4618      	mov	r0, r3
 800f9b6:	f7ff ff41 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x00);
 800f9ba:	687b      	ldr	r3, [r7, #4]
 800f9bc:	2100      	movs	r1, #0
 800f9be:	4618      	mov	r0, r3
 800f9c0:	f7ff ff50 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(buf[0]);
 800f9c4:	687b      	ldr	r3, [r7, #4]
 800f9c6:	7b3a      	ldrb	r2, [r7, #12]
 800f9c8:	4611      	mov	r1, r2
 800f9ca:	4618      	mov	r0, r3
 800f9cc:	f7ff ff4a 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Set ram Y start/end position
    buf[0]=HEIGHT - 1;
 800f9d0:	23c7      	movs	r3, #199	; 0xc7
 800f9d2:	733b      	strb	r3, [r7, #12]
    buf[1]=(HEIGHT - 1) >> 8;
 800f9d4:	2300      	movs	r3, #0
 800f9d6:	737b      	strb	r3, [r7, #13]
    writeCMD(SSD1608_SET_RAMYPOS);
 800f9d8:	687b      	ldr	r3, [r7, #4]
 800f9da:	2145      	movs	r1, #69	; 0x45
 800f9dc:	4618      	mov	r0, r3
 800f9de:	f7ff ff2d 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x00);
 800f9e2:	687b      	ldr	r3, [r7, #4]
 800f9e4:	2100      	movs	r1, #0
 800f9e6:	4618      	mov	r0, r3
 800f9e8:	f7ff ff3c 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(0x00);
 800f9ec:	687b      	ldr	r3, [r7, #4]
 800f9ee:	2100      	movs	r1, #0
 800f9f0:	4618      	mov	r0, r3
 800f9f2:	f7ff ff37 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(buf[0]);
 800f9f6:	687b      	ldr	r3, [r7, #4]
 800f9f8:	7b3a      	ldrb	r2, [r7, #12]
 800f9fa:	4611      	mov	r1, r2
 800f9fc:	4618      	mov	r0, r3
 800f9fe:	f7ff ff31 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(buf[1]);
 800fa02:	687b      	ldr	r3, [r7, #4]
 800fa04:	7b7a      	ldrb	r2, [r7, #13]
 800fa06:	4611      	mov	r1, r2
 800fa08:	4618      	mov	r0, r3
 800fa0a:	f7ff ff2b 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    // Vcom Voltage
    writeCMD(SSD1608_WRITE_VCOM);
 800fa0e:	687b      	ldr	r3, [r7, #4]
 800fa10:	212c      	movs	r1, #44	; 0x2c
 800fa12:	4618      	mov	r0, r3
 800fa14:	f7ff ff12 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    //writeDATA(0x70);
    writeDATA(0xA8);	//GD
 800fa18:	687b      	ldr	r3, [r7, #4]
 800fa1a:	21a8      	movs	r1, #168	; 0xa8
 800fa1c:	4618      	mov	r0, r3
 800fa1e:	f7ff ff21 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    writeCMD(SSD1608_WRITE_LUT);
 800fa22:	687b      	ldr	r3, [r7, #4]
 800fa24:	2132      	movs	r1, #50	; 0x32
 800fa26:	4618      	mov	r0, r3
 800fa28:	f7ff ff08 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    for(uint32_t i = 0; i<30 ; i++){
 800fa2c:	2300      	movs	r3, #0
 800fa2e:	617b      	str	r3, [r7, #20]
 800fa30:	697b      	ldr	r3, [r7, #20]
 800fa32:	2b1d      	cmp	r3, #29
 800fa34:	d80c      	bhi.n	800fa50 <_ZN2ep12DisplayFirst4initEv+0x158>
        writeDATA(LUT_DATA[i]);
 800fa36:	687a      	ldr	r2, [r7, #4]
 800fa38:	490e      	ldr	r1, [pc, #56]	; (800fa74 <_ZN2ep12DisplayFirst4initEv+0x17c>)
 800fa3a:	697b      	ldr	r3, [r7, #20]
 800fa3c:	440b      	add	r3, r1
 800fa3e:	781b      	ldrb	r3, [r3, #0]
 800fa40:	4619      	mov	r1, r3
 800fa42:	4610      	mov	r0, r2
 800fa44:	f7ff ff0e 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    for(uint32_t i = 0; i<30 ; i++){
 800fa48:	697b      	ldr	r3, [r7, #20]
 800fa4a:	3301      	adds	r3, #1
 800fa4c:	617b      	str	r3, [r7, #20]
 800fa4e:	e7ef      	b.n	800fa30 <_ZN2ep12DisplayFirst4initEv+0x138>
    }

    // border color
    buf[0] = 0x00;
 800fa50:	2300      	movs	r3, #0
 800fa52:	733b      	strb	r3, [r7, #12]
    writeCMD(SSD1608_WRITE_BORDER);
 800fa54:	687b      	ldr	r3, [r7, #4]
 800fa56:	213c      	movs	r1, #60	; 0x3c
 800fa58:	4618      	mov	r0, r3
 800fa5a:	f7ff feef 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(buf[0]);
 800fa5e:	687b      	ldr	r3, [r7, #4]
 800fa60:	7b3a      	ldrb	r2, [r7, #12]
 800fa62:	4611      	mov	r1, r2
 800fa64:	4618      	mov	r0, r3
 800fa66:	f7ff fefd 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
}
 800fa6a:	bf00      	nop
 800fa6c:	3718      	adds	r7, #24
 800fa6e:	46bd      	mov	sp, r7
 800fa70:	bd80      	pop	{r7, pc}
 800fa72:	bf00      	nop
 800fa74:	0801be58 	.word	0x0801be58

0800fa78 <_ZN2ep12DisplayFirst7displayEPh>:
function:   Display the array (image)
parameter:
    image :   array which contain the picture
******************************************************************************/
void DisplayFirst::display(uint8_t * image)
{
 800fa78:	b580      	push	{r7, lr}
 800fa7a:	b084      	sub	sp, #16
 800fa7c:	af00      	add	r7, sp, #0
 800fa7e:	6078      	str	r0, [r7, #4]
 800fa80:	6039      	str	r1, [r7, #0]
    //Set ram address to 0
    // Set RAM X address counter
    writeCMD(SSD1608_SET_RAMXCOUNT);
 800fa82:	687b      	ldr	r3, [r7, #4]
 800fa84:	214e      	movs	r1, #78	; 0x4e
 800fa86:	4618      	mov	r0, r3
 800fa88:	f7ff fed8 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x00);
 800fa8c:	687b      	ldr	r3, [r7, #4]
 800fa8e:	2100      	movs	r1, #0
 800fa90:	4618      	mov	r0, r3
 800fa92:	f7ff fee7 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    // Set RAM Y address counter
    writeCMD(SSD1608_SET_RAMYCOUNT);
 800fa96:	687b      	ldr	r3, [r7, #4]
 800fa98:	214f      	movs	r1, #79	; 0x4f
 800fa9a:	4618      	mov	r0, r3
 800fa9c:	f7ff fece 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0x00);
 800faa0:	687b      	ldr	r3, [r7, #4]
 800faa2:	2100      	movs	r1, #0
 800faa4:	4618      	mov	r0, r3
 800faa6:	f7ff fedd 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeDATA(0x00);
 800faaa:	687b      	ldr	r3, [r7, #4]
 800faac:	2100      	movs	r1, #0
 800faae:	4618      	mov	r0, r3
 800fab0:	f7ff fed8 	bl	800f864 <_ZN2ep7Display9writeDATAEh>

    writeCMD(SSD1608_WRITE_RAM);
 800fab4:	687b      	ldr	r3, [r7, #4]
 800fab6:	2124      	movs	r1, #36	; 0x24
 800fab8:	4618      	mov	r0, r3
 800faba:	f7ff febf 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    for(uint32_t i = 0; i < 5000; i++)
 800fabe:	2300      	movs	r3, #0
 800fac0:	60fb      	str	r3, [r7, #12]
 800fac2:	68fb      	ldr	r3, [r7, #12]
 800fac4:	f241 3287 	movw	r2, #4999	; 0x1387
 800fac8:	4293      	cmp	r3, r2
 800faca:	d80b      	bhi.n	800fae4 <_ZN2ep12DisplayFirst7displayEPh+0x6c>
    {
        writeDATA(image[i]);
 800facc:	6878      	ldr	r0, [r7, #4]
 800face:	683a      	ldr	r2, [r7, #0]
 800fad0:	68fb      	ldr	r3, [r7, #12]
 800fad2:	4413      	add	r3, r2
 800fad4:	781b      	ldrb	r3, [r3, #0]
 800fad6:	4619      	mov	r1, r3
 800fad8:	f7ff fec4 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    for(uint32_t i = 0; i < 5000; i++)
 800fadc:	68fb      	ldr	r3, [r7, #12]
 800fade:	3301      	adds	r3, #1
 800fae0:	60fb      	str	r3, [r7, #12]
 800fae2:	e7ee      	b.n	800fac2 <_ZN2ep12DisplayFirst7displayEPh+0x4a>
    }
    writeCMD(SSD1608_DISP_CTRL2);
 800fae4:	687b      	ldr	r3, [r7, #4]
 800fae6:	2122      	movs	r1, #34	; 0x22
 800fae8:	4618      	mov	r0, r3
 800faea:	f7ff fea7 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
    writeDATA(0xC7);
 800faee:	687b      	ldr	r3, [r7, #4]
 800faf0:	21c7      	movs	r1, #199	; 0xc7
 800faf2:	4618      	mov	r0, r3
 800faf4:	f7ff feb6 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
    writeCMD(SSD1608_MASTER_ACTIVATE);
 800faf8:	687b      	ldr	r3, [r7, #4]
 800fafa:	2120      	movs	r1, #32
 800fafc:	4618      	mov	r0, r3
 800fafe:	f7ff fe9d 	bl	800f83c <_ZN2ep7Display8writeCMDEh>

    lcdChkstatus();
 800fb02:	687b      	ldr	r3, [r7, #4]
 800fb04:	4618      	mov	r0, r3
 800fb06:	f7ff fed9 	bl	800f8bc <_ZN2ep7Display12lcdChkstatusEv>
}
 800fb0a:	bf00      	nop
 800fb0c:	3710      	adds	r7, #16
 800fb0e:	46bd      	mov	sp, r7
 800fb10:	bd80      	pop	{r7, pc}
	...

0800fb14 <_ZN2ep12DisplayFirst17setLUTLongRefreshEv>:

void DisplayFirst::setLUTLongRefresh()
{
 800fb14:	b580      	push	{r7, lr}
 800fb16:	b084      	sub	sp, #16
 800fb18:	af00      	add	r7, sp, #0
 800fb1a:	6078      	str	r0, [r7, #4]
	writeCMD(SSD1608_WRITE_LUT);
 800fb1c:	687b      	ldr	r3, [r7, #4]
 800fb1e:	2132      	movs	r1, #50	; 0x32
 800fb20:	4618      	mov	r0, r3
 800fb22:	f7ff fe8b 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
	for(uint32_t i = 0; i < 30; i++)
 800fb26:	2300      	movs	r3, #0
 800fb28:	60fb      	str	r3, [r7, #12]
 800fb2a:	68fb      	ldr	r3, [r7, #12]
 800fb2c:	2b1d      	cmp	r3, #29
 800fb2e:	d80c      	bhi.n	800fb4a <_ZN2ep12DisplayFirst17setLUTLongRefreshEv+0x36>
	{
		writeDATA(LUT_DATA[i]);
 800fb30:	687a      	ldr	r2, [r7, #4]
 800fb32:	4908      	ldr	r1, [pc, #32]	; (800fb54 <_ZN2ep12DisplayFirst17setLUTLongRefreshEv+0x40>)
 800fb34:	68fb      	ldr	r3, [r7, #12]
 800fb36:	440b      	add	r3, r1
 800fb38:	781b      	ldrb	r3, [r3, #0]
 800fb3a:	4619      	mov	r1, r3
 800fb3c:	4610      	mov	r0, r2
 800fb3e:	f7ff fe91 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
	for(uint32_t i = 0; i < 30; i++)
 800fb42:	68fb      	ldr	r3, [r7, #12]
 800fb44:	3301      	adds	r3, #1
 800fb46:	60fb      	str	r3, [r7, #12]
 800fb48:	e7ef      	b.n	800fb2a <_ZN2ep12DisplayFirst17setLUTLongRefreshEv+0x16>
	}
}
 800fb4a:	bf00      	nop
 800fb4c:	3710      	adds	r7, #16
 800fb4e:	46bd      	mov	sp, r7
 800fb50:	bd80      	pop	{r7, pc}
 800fb52:	bf00      	nop
 800fb54:	0801be58 	.word	0x0801be58

0800fb58 <_ZN2ep12DisplayFirst18setLUTShortRefreshEv>:

void DisplayFirst::setLUTShortRefresh()
{
 800fb58:	b580      	push	{r7, lr}
 800fb5a:	b084      	sub	sp, #16
 800fb5c:	af00      	add	r7, sp, #0
 800fb5e:	6078      	str	r0, [r7, #4]
	writeCMD(SSD1608_WRITE_LUT);
 800fb60:	687b      	ldr	r3, [r7, #4]
 800fb62:	2132      	movs	r1, #50	; 0x32
 800fb64:	4618      	mov	r0, r3
 800fb66:	f7ff fe69 	bl	800f83c <_ZN2ep7Display8writeCMDEh>
	for(uint32_t i = 0; i < 30; i++)
 800fb6a:	2300      	movs	r3, #0
 800fb6c:	60fb      	str	r3, [r7, #12]
 800fb6e:	68fb      	ldr	r3, [r7, #12]
 800fb70:	2b1d      	cmp	r3, #29
 800fb72:	d80c      	bhi.n	800fb8e <_ZN2ep12DisplayFirst18setLUTShortRefreshEv+0x36>
	{
		writeDATA(LUT_part1[i]);
 800fb74:	687a      	ldr	r2, [r7, #4]
 800fb76:	4908      	ldr	r1, [pc, #32]	; (800fb98 <_ZN2ep12DisplayFirst18setLUTShortRefreshEv+0x40>)
 800fb78:	68fb      	ldr	r3, [r7, #12]
 800fb7a:	440b      	add	r3, r1
 800fb7c:	781b      	ldrb	r3, [r3, #0]
 800fb7e:	4619      	mov	r1, r3
 800fb80:	4610      	mov	r0, r2
 800fb82:	f7ff fe6f 	bl	800f864 <_ZN2ep7Display9writeDATAEh>
	for(uint32_t i = 0; i < 30; i++)
 800fb86:	68fb      	ldr	r3, [r7, #12]
 800fb88:	3301      	adds	r3, #1
 800fb8a:	60fb      	str	r3, [r7, #12]
 800fb8c:	e7ef      	b.n	800fb6e <_ZN2ep12DisplayFirst18setLUTShortRefreshEv+0x16>
	}
}
 800fb8e:	bf00      	nop
 800fb90:	3710      	adds	r7, #16
 800fb92:	46bd      	mov	sp, r7
 800fb94:	bd80      	pop	{r7, pc}
 800fb96:	bf00      	nop
 800fb98:	0801be78 	.word	0x0801be78

0800fb9c <_ZN2ep7DisplayD1Ev>:
class Display
{
    friend class ::MonochromeDisplay;
public:
    Display();
    virtual ~Display() = default;
 800fb9c:	b480      	push	{r7}
 800fb9e:	b083      	sub	sp, #12
 800fba0:	af00      	add	r7, sp, #0
 800fba2:	6078      	str	r0, [r7, #4]
 800fba4:	4a04      	ldr	r2, [pc, #16]	; (800fbb8 <_ZN2ep7DisplayD1Ev+0x1c>)
 800fba6:	687b      	ldr	r3, [r7, #4]
 800fba8:	601a      	str	r2, [r3, #0]
 800fbaa:	687b      	ldr	r3, [r7, #4]
 800fbac:	4618      	mov	r0, r3
 800fbae:	370c      	adds	r7, #12
 800fbb0:	46bd      	mov	sp, r7
 800fbb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbb6:	4770      	bx	lr
 800fbb8:	0801be40 	.word	0x0801be40

0800fbbc <_ZN2ep7DisplayD0Ev>:
 800fbbc:	b580      	push	{r7, lr}
 800fbbe:	b082      	sub	sp, #8
 800fbc0:	af00      	add	r7, sp, #0
 800fbc2:	6078      	str	r0, [r7, #4]
 800fbc4:	6878      	ldr	r0, [r7, #4]
 800fbc6:	f7ff ffe9 	bl	800fb9c <_ZN2ep7DisplayD1Ev>
 800fbca:	2114      	movs	r1, #20
 800fbcc:	6878      	ldr	r0, [r7, #4]
 800fbce:	f006 faed 	bl	80161ac <_ZdlPvj>
 800fbd2:	687b      	ldr	r3, [r7, #4]
 800fbd4:	4618      	mov	r0, r3
 800fbd6:	3708      	adds	r7, #8
 800fbd8:	46bd      	mov	sp, r7
 800fbda:	bd80      	pop	{r7, pc}

0800fbdc <_ZN2ep12DisplayFirstD1Ev>:
 */
class DisplayFirst : public Display
{
public:
    DisplayFirst() = default;
    virtual ~DisplayFirst() = default;
 800fbdc:	b580      	push	{r7, lr}
 800fbde:	b082      	sub	sp, #8
 800fbe0:	af00      	add	r7, sp, #0
 800fbe2:	6078      	str	r0, [r7, #4]
 800fbe4:	4a05      	ldr	r2, [pc, #20]	; (800fbfc <_ZN2ep12DisplayFirstD1Ev+0x20>)
 800fbe6:	687b      	ldr	r3, [r7, #4]
 800fbe8:	601a      	str	r2, [r3, #0]
 800fbea:	687b      	ldr	r3, [r7, #4]
 800fbec:	4618      	mov	r0, r3
 800fbee:	f7ff ffd5 	bl	800fb9c <_ZN2ep7DisplayD1Ev>
 800fbf2:	687b      	ldr	r3, [r7, #4]
 800fbf4:	4618      	mov	r0, r3
 800fbf6:	3708      	adds	r7, #8
 800fbf8:	46bd      	mov	sp, r7
 800fbfa:	bd80      	pop	{r7, pc}
 800fbfc:	0801bea0 	.word	0x0801bea0

0800fc00 <_ZN2ep12DisplayFirstD0Ev>:
 800fc00:	b580      	push	{r7, lr}
 800fc02:	b082      	sub	sp, #8
 800fc04:	af00      	add	r7, sp, #0
 800fc06:	6078      	str	r0, [r7, #4]
 800fc08:	6878      	ldr	r0, [r7, #4]
 800fc0a:	f7ff ffe7 	bl	800fbdc <_ZN2ep12DisplayFirstD1Ev>
 800fc0e:	2114      	movs	r1, #20
 800fc10:	6878      	ldr	r0, [r7, #4]
 800fc12:	f006 facb 	bl	80161ac <_ZdlPvj>
 800fc16:	687b      	ldr	r3, [r7, #4]
 800fc18:	4618      	mov	r0, r3
 800fc1a:	3708      	adds	r7, #8
 800fc1c:	46bd      	mov	sp, r7
 800fc1e:	bd80      	pop	{r7, pc}

0800fc20 <_ZN2ep5PaintC1Ev>:
#include <cmath>
#include "paint.h"

namespace ep {

Paint::Paint():
 800fc20:	b480      	push	{r7}
 800fc22:	b083      	sub	sp, #12
 800fc24:	af00      	add	r7, sp, #0
 800fc26:	6078      	str	r0, [r7, #4]
    epd(nullptr),
    buffer(nullptr)
 800fc28:	687b      	ldr	r3, [r7, #4]
 800fc2a:	2200      	movs	r2, #0
 800fc2c:	601a      	str	r2, [r3, #0]
 800fc2e:	687b      	ldr	r3, [r7, #4]
 800fc30:	2200      	movs	r2, #0
 800fc32:	605a      	str	r2, [r3, #4]
{

}
 800fc34:	687b      	ldr	r3, [r7, #4]
 800fc36:	4618      	mov	r0, r3
 800fc38:	370c      	adds	r7, #12
 800fc3a:	46bd      	mov	sp, r7
 800fc3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc40:	4770      	bx	lr

0800fc42 <_ZN2ep5Paint10initializeEPNS_7DisplayE>:

void Paint::initialize(ep::Display * epd)
{
 800fc42:	b480      	push	{r7}
 800fc44:	b083      	sub	sp, #12
 800fc46:	af00      	add	r7, sp, #0
 800fc48:	6078      	str	r0, [r7, #4]
 800fc4a:	6039      	str	r1, [r7, #0]
    this->epd = epd;
 800fc4c:	687b      	ldr	r3, [r7, #4]
 800fc4e:	683a      	ldr	r2, [r7, #0]
 800fc50:	601a      	str	r2, [r3, #0]
}
 800fc52:	bf00      	nop
 800fc54:	370c      	adds	r7, #12
 800fc56:	46bd      	mov	sp, r7
 800fc58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc5c:	4770      	bx	lr

0800fc5e <_ZN2ep5Paint9setBufferEPhtttt>:
    width   :   The width of the picture
    Height  :   The height of the picture
    Color   :   Whether the picture is inverted
******************************************************************************/
void Paint::setBuffer(uint8_t * buffer, uint16_t Width, uint16_t Height, uint16_t Rotate, uint16_t Color)
{
 800fc5e:	b480      	push	{r7}
 800fc60:	b085      	sub	sp, #20
 800fc62:	af00      	add	r7, sp, #0
 800fc64:	60f8      	str	r0, [r7, #12]
 800fc66:	60b9      	str	r1, [r7, #8]
 800fc68:	4611      	mov	r1, r2
 800fc6a:	461a      	mov	r2, r3
 800fc6c:	460b      	mov	r3, r1
 800fc6e:	80fb      	strh	r3, [r7, #6]
 800fc70:	4613      	mov	r3, r2
 800fc72:	80bb      	strh	r3, [r7, #4]
    this->buffer = buffer;
 800fc74:	68fb      	ldr	r3, [r7, #12]
 800fc76:	68ba      	ldr	r2, [r7, #8]
 800fc78:	605a      	str	r2, [r3, #4]

    this->width = Width;
 800fc7a:	68fb      	ldr	r3, [r7, #12]
 800fc7c:	88fa      	ldrh	r2, [r7, #6]
 800fc7e:	811a      	strh	r2, [r3, #8]
    this->height = Height;
 800fc80:	68fb      	ldr	r3, [r7, #12]
 800fc82:	88ba      	ldrh	r2, [r7, #4]
 800fc84:	815a      	strh	r2, [r3, #10]

    this->widthMemory = Width;
 800fc86:	68fb      	ldr	r3, [r7, #12]
 800fc88:	88fa      	ldrh	r2, [r7, #6]
 800fc8a:	819a      	strh	r2, [r3, #12]
    this->heightMemory = Height;
 800fc8c:	68fb      	ldr	r3, [r7, #12]
 800fc8e:	88ba      	ldrh	r2, [r7, #4]
 800fc90:	81da      	strh	r2, [r3, #14]
    this->color = Color;
 800fc92:	68fb      	ldr	r3, [r7, #12]
 800fc94:	8bba      	ldrh	r2, [r7, #28]
 800fc96:	821a      	strh	r2, [r3, #16]
    this->widthByte = (Width % 8 == 0) ? (Width / 8) : (Width / 8 + 1);
 800fc98:	88fb      	ldrh	r3, [r7, #6]
 800fc9a:	f003 0307 	and.w	r3, r3, #7
 800fc9e:	2b00      	cmp	r3, #0
 800fca0:	d103      	bne.n	800fcaa <_ZN2ep5Paint9setBufferEPhtttt+0x4c>
 800fca2:	88fb      	ldrh	r3, [r7, #6]
 800fca4:	08db      	lsrs	r3, r3, #3
 800fca6:	b29b      	uxth	r3, r3
 800fca8:	e004      	b.n	800fcb4 <_ZN2ep5Paint9setBufferEPhtttt+0x56>
 800fcaa:	88fb      	ldrh	r3, [r7, #6]
 800fcac:	08db      	lsrs	r3, r3, #3
 800fcae:	b29b      	uxth	r3, r3
 800fcb0:	3301      	adds	r3, #1
 800fcb2:	b29b      	uxth	r3, r3
 800fcb4:	68fa      	ldr	r2, [r7, #12]
 800fcb6:	82d3      	strh	r3, [r2, #22]
    this->heightByte = Height;
 800fcb8:	68fb      	ldr	r3, [r7, #12]
 800fcba:	88ba      	ldrh	r2, [r7, #4]
 800fcbc:	831a      	strh	r2, [r3, #24]

    this->rotate = Rotate;
 800fcbe:	68fb      	ldr	r3, [r7, #12]
 800fcc0:	8b3a      	ldrh	r2, [r7, #24]
 800fcc2:	825a      	strh	r2, [r3, #18]

    this->mirror = MIRROR_NONE;
 800fcc4:	68fb      	ldr	r3, [r7, #12]
 800fcc6:	2200      	movs	r2, #0
 800fcc8:	829a      	strh	r2, [r3, #20]

    if (Rotate == EP_DISPLAY_ROTATE_0 || Rotate == EP_DISPLAY_ROTATE_180)
 800fcca:	8b3b      	ldrh	r3, [r7, #24]
 800fccc:	2b00      	cmp	r3, #0
 800fcce:	d002      	beq.n	800fcd6 <_ZN2ep5Paint9setBufferEPhtttt+0x78>
 800fcd0:	8b3b      	ldrh	r3, [r7, #24]
 800fcd2:	2bb4      	cmp	r3, #180	; 0xb4
 800fcd4:	d106      	bne.n	800fce4 <_ZN2ep5Paint9setBufferEPhtttt+0x86>
    {
        this->width = Width;
 800fcd6:	68fb      	ldr	r3, [r7, #12]
 800fcd8:	88fa      	ldrh	r2, [r7, #6]
 800fcda:	811a      	strh	r2, [r3, #8]
        this->height = Height;
 800fcdc:	68fb      	ldr	r3, [r7, #12]
 800fcde:	88ba      	ldrh	r2, [r7, #4]
 800fce0:	815a      	strh	r2, [r3, #10]
 800fce2:	e005      	b.n	800fcf0 <_ZN2ep5Paint9setBufferEPhtttt+0x92>
    }
    else
    {
        this->width = Height;
 800fce4:	68fb      	ldr	r3, [r7, #12]
 800fce6:	88ba      	ldrh	r2, [r7, #4]
 800fce8:	811a      	strh	r2, [r3, #8]
        this->height = Width;
 800fcea:	68fb      	ldr	r3, [r7, #12]
 800fcec:	88fa      	ldrh	r2, [r7, #6]
 800fcee:	815a      	strh	r2, [r3, #10]
    }

    this->pixelCount = width * height;
 800fcf0:	68fb      	ldr	r3, [r7, #12]
 800fcf2:	891a      	ldrh	r2, [r3, #8]
 800fcf4:	68fb      	ldr	r3, [r7, #12]
 800fcf6:	895b      	ldrh	r3, [r3, #10]
 800fcf8:	fb12 f303 	smulbb	r3, r2, r3
 800fcfc:	b29a      	uxth	r2, r3
 800fcfe:	68fb      	ldr	r3, [r7, #12]
 800fd00:	835a      	strh	r2, [r3, #26]
    this->bytesCount = pixelCount / 8;
 800fd02:	68fb      	ldr	r3, [r7, #12]
 800fd04:	8b5b      	ldrh	r3, [r3, #26]
 800fd06:	08db      	lsrs	r3, r3, #3
 800fd08:	b29a      	uxth	r2, r3
 800fd0a:	68fb      	ldr	r3, [r7, #12]
 800fd0c:	839a      	strh	r2, [r3, #28]

    this->buffer = buffer;
 800fd0e:	68fb      	ldr	r3, [r7, #12]
 800fd10:	68ba      	ldr	r2, [r7, #8]
 800fd12:	605a      	str	r2, [r3, #4]
}
 800fd14:	bf00      	nop
 800fd16:	3714      	adds	r7, #20
 800fd18:	46bd      	mov	sp, r7
 800fd1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd1e:	4770      	bx	lr

0800fd20 <_ZN2ep5Paint9setRotateEt>:
function:	Select buffer rotate
parameter:
    Rotate   :   0,90,180,270
******************************************************************************/
void Paint::setRotate(Rotation Rotate)
{
 800fd20:	b480      	push	{r7}
 800fd22:	b083      	sub	sp, #12
 800fd24:	af00      	add	r7, sp, #0
 800fd26:	6078      	str	r0, [r7, #4]
 800fd28:	460b      	mov	r3, r1
 800fd2a:	807b      	strh	r3, [r7, #2]
    if (Rotate == EP_DISPLAY_ROTATE_0 || Rotate == EP_DISPLAY_ROTATE_90 || Rotate == EP_DISPLAY_ROTATE_180 || Rotate == EP_DISPLAY_ROTATE_270)
 800fd2c:	887b      	ldrh	r3, [r7, #2]
 800fd2e:	2b00      	cmp	r3, #0
 800fd30:	d009      	beq.n	800fd46 <_ZN2ep5Paint9setRotateEt+0x26>
 800fd32:	887b      	ldrh	r3, [r7, #2]
 800fd34:	2b5a      	cmp	r3, #90	; 0x5a
 800fd36:	d006      	beq.n	800fd46 <_ZN2ep5Paint9setRotateEt+0x26>
 800fd38:	887b      	ldrh	r3, [r7, #2]
 800fd3a:	2bb4      	cmp	r3, #180	; 0xb4
 800fd3c:	d003      	beq.n	800fd46 <_ZN2ep5Paint9setRotateEt+0x26>
 800fd3e:	887b      	ldrh	r3, [r7, #2]
 800fd40:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 800fd44:	d102      	bne.n	800fd4c <_ZN2ep5Paint9setRotateEt+0x2c>
    {
        this->rotate = Rotate;
 800fd46:	687b      	ldr	r3, [r7, #4]
 800fd48:	887a      	ldrh	r2, [r7, #2]
 800fd4a:	825a      	strh	r2, [r3, #18]
    }
}
 800fd4c:	bf00      	nop
 800fd4e:	370c      	adds	r7, #12
 800fd50:	46bd      	mov	sp, r7
 800fd52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd56:	4770      	bx	lr

0800fd58 <_ZN2ep5Paint8setPixelEtttb>:
    Xpoint  :   At point X
    Ypoint  :   At point Y
    Color   :   Painted colors
******************************************************************************/
void Paint::setPixel(uint16_t Xpoint, uint16_t Ypoint, uint16_t Color, bool refresh)
{
 800fd58:	b580      	push	{r7, lr}
 800fd5a:	b088      	sub	sp, #32
 800fd5c:	af00      	add	r7, sp, #0
 800fd5e:	60f8      	str	r0, [r7, #12]
 800fd60:	4608      	mov	r0, r1
 800fd62:	4611      	mov	r1, r2
 800fd64:	461a      	mov	r2, r3
 800fd66:	4603      	mov	r3, r0
 800fd68:	817b      	strh	r3, [r7, #10]
 800fd6a:	460b      	mov	r3, r1
 800fd6c:	813b      	strh	r3, [r7, #8]
 800fd6e:	4613      	mov	r3, r2
 800fd70:	80fb      	strh	r3, [r7, #6]
    uint16_t X, Y;
    uint32_t Addr;
    uint8_t Rdata;
    if (Xpoint > this->width || Ypoint > this->height)
 800fd72:	68fb      	ldr	r3, [r7, #12]
 800fd74:	891b      	ldrh	r3, [r3, #8]
 800fd76:	897a      	ldrh	r2, [r7, #10]
 800fd78:	429a      	cmp	r2, r3
 800fd7a:	f200 80c0 	bhi.w	800fefe <_ZN2ep5Paint8setPixelEtttb+0x1a6>
 800fd7e:	68fb      	ldr	r3, [r7, #12]
 800fd80:	895b      	ldrh	r3, [r3, #10]
 800fd82:	893a      	ldrh	r2, [r7, #8]
 800fd84:	429a      	cmp	r2, r3
 800fd86:	f200 80ba 	bhi.w	800fefe <_ZN2ep5Paint8setPixelEtttb+0x1a6>
    {
        return;
    }

    switch (this->rotate)
 800fd8a:	68fb      	ldr	r3, [r7, #12]
 800fd8c:	8a5b      	ldrh	r3, [r3, #18]
 800fd8e:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 800fd92:	d029      	beq.n	800fde8 <_ZN2ep5Paint8setPixelEtttb+0x90>
 800fd94:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 800fd98:	dc30      	bgt.n	800fdfc <_ZN2ep5Paint8setPixelEtttb+0xa4>
 800fd9a:	2bb4      	cmp	r3, #180	; 0xb4
 800fd9c:	d015      	beq.n	800fdca <_ZN2ep5Paint8setPixelEtttb+0x72>
 800fd9e:	2bb4      	cmp	r3, #180	; 0xb4
 800fda0:	dc2c      	bgt.n	800fdfc <_ZN2ep5Paint8setPixelEtttb+0xa4>
 800fda2:	2b00      	cmp	r3, #0
 800fda4:	d002      	beq.n	800fdac <_ZN2ep5Paint8setPixelEtttb+0x54>
 800fda6:	2b5a      	cmp	r3, #90	; 0x5a
 800fda8:	d005      	beq.n	800fdb6 <_ZN2ep5Paint8setPixelEtttb+0x5e>
 800fdaa:	e027      	b.n	800fdfc <_ZN2ep5Paint8setPixelEtttb+0xa4>
    {
    case 0:
        X = Xpoint;
 800fdac:	897b      	ldrh	r3, [r7, #10]
 800fdae:	83fb      	strh	r3, [r7, #30]
        Y = Ypoint;
 800fdb0:	893b      	ldrh	r3, [r7, #8]
 800fdb2:	83bb      	strh	r3, [r7, #28]
        break;
 800fdb4:	e028      	b.n	800fe08 <_ZN2ep5Paint8setPixelEtttb+0xb0>
    case 90:
        X = this->widthMemory - Ypoint - 1;
 800fdb6:	68fb      	ldr	r3, [r7, #12]
 800fdb8:	899a      	ldrh	r2, [r3, #12]
 800fdba:	893b      	ldrh	r3, [r7, #8]
 800fdbc:	1ad3      	subs	r3, r2, r3
 800fdbe:	b29b      	uxth	r3, r3
 800fdc0:	3b01      	subs	r3, #1
 800fdc2:	83fb      	strh	r3, [r7, #30]
        Y = Xpoint;
 800fdc4:	897b      	ldrh	r3, [r7, #10]
 800fdc6:	83bb      	strh	r3, [r7, #28]
        break;
 800fdc8:	e01e      	b.n	800fe08 <_ZN2ep5Paint8setPixelEtttb+0xb0>
    case 180:
        X = this->widthMemory - Xpoint - 1;
 800fdca:	68fb      	ldr	r3, [r7, #12]
 800fdcc:	899a      	ldrh	r2, [r3, #12]
 800fdce:	897b      	ldrh	r3, [r7, #10]
 800fdd0:	1ad3      	subs	r3, r2, r3
 800fdd2:	b29b      	uxth	r3, r3
 800fdd4:	3b01      	subs	r3, #1
 800fdd6:	83fb      	strh	r3, [r7, #30]
        Y = this->heightMemory - Ypoint - 1;
 800fdd8:	68fb      	ldr	r3, [r7, #12]
 800fdda:	89da      	ldrh	r2, [r3, #14]
 800fddc:	893b      	ldrh	r3, [r7, #8]
 800fdde:	1ad3      	subs	r3, r2, r3
 800fde0:	b29b      	uxth	r3, r3
 800fde2:	3b01      	subs	r3, #1
 800fde4:	83bb      	strh	r3, [r7, #28]
        break;
 800fde6:	e00f      	b.n	800fe08 <_ZN2ep5Paint8setPixelEtttb+0xb0>
    case 270:
        X = Ypoint;
 800fde8:	893b      	ldrh	r3, [r7, #8]
 800fdea:	83fb      	strh	r3, [r7, #30]
        Y = this->heightMemory - Xpoint - 1;
 800fdec:	68fb      	ldr	r3, [r7, #12]
 800fdee:	89da      	ldrh	r2, [r3, #14]
 800fdf0:	897b      	ldrh	r3, [r7, #10]
 800fdf2:	1ad3      	subs	r3, r2, r3
 800fdf4:	b29b      	uxth	r3, r3
 800fdf6:	3b01      	subs	r3, #1
 800fdf8:	83bb      	strh	r3, [r7, #28]
        break;
 800fdfa:	e005      	b.n	800fe08 <_ZN2ep5Paint8setPixelEtttb+0xb0>
    default:
        assert(false);
 800fdfc:	4b44      	ldr	r3, [pc, #272]	; (800ff10 <_ZN2ep5Paint8setPixelEtttb+0x1b8>)
 800fdfe:	4a45      	ldr	r2, [pc, #276]	; (800ff14 <_ZN2ep5Paint8setPixelEtttb+0x1bc>)
 800fe00:	217d      	movs	r1, #125	; 0x7d
 800fe02:	4845      	ldr	r0, [pc, #276]	; (800ff18 <_ZN2ep5Paint8setPixelEtttb+0x1c0>)
 800fe04:	f006 fac6 	bl	8016394 <__assert_func>
        return;
    }

    switch (this->mirror)
 800fe08:	68fb      	ldr	r3, [r7, #12]
 800fe0a:	8a9b      	ldrh	r3, [r3, #20]
 800fe0c:	2b03      	cmp	r3, #3
 800fe0e:	d878      	bhi.n	800ff02 <_ZN2ep5Paint8setPixelEtttb+0x1aa>
 800fe10:	a201      	add	r2, pc, #4	; (adr r2, 800fe18 <_ZN2ep5Paint8setPixelEtttb+0xc0>)
 800fe12:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fe16:	bf00      	nop
 800fe18:	0800fe67 	.word	0x0800fe67
 800fe1c:	0800fe29 	.word	0x0800fe29
 800fe20:	0800fe39 	.word	0x0800fe39
 800fe24:	0800fe49 	.word	0x0800fe49
    {
    case MIRROR_NONE:
        break;
    case MIRROR_HORIZONTAL:
        X = this->widthMemory - X - 1;
 800fe28:	68fb      	ldr	r3, [r7, #12]
 800fe2a:	899a      	ldrh	r2, [r3, #12]
 800fe2c:	8bfb      	ldrh	r3, [r7, #30]
 800fe2e:	1ad3      	subs	r3, r2, r3
 800fe30:	b29b      	uxth	r3, r3
 800fe32:	3b01      	subs	r3, #1
 800fe34:	83fb      	strh	r3, [r7, #30]
        break;
 800fe36:	e017      	b.n	800fe68 <_ZN2ep5Paint8setPixelEtttb+0x110>
    case MIRROR_VERTICAL:
        Y = this->heightMemory - Y - 1;
 800fe38:	68fb      	ldr	r3, [r7, #12]
 800fe3a:	89da      	ldrh	r2, [r3, #14]
 800fe3c:	8bbb      	ldrh	r3, [r7, #28]
 800fe3e:	1ad3      	subs	r3, r2, r3
 800fe40:	b29b      	uxth	r3, r3
 800fe42:	3b01      	subs	r3, #1
 800fe44:	83bb      	strh	r3, [r7, #28]
        break;
 800fe46:	e00f      	b.n	800fe68 <_ZN2ep5Paint8setPixelEtttb+0x110>
    case MIRROR_ORIGIN:
        X = this->widthMemory - X - 1;
 800fe48:	68fb      	ldr	r3, [r7, #12]
 800fe4a:	899a      	ldrh	r2, [r3, #12]
 800fe4c:	8bfb      	ldrh	r3, [r7, #30]
 800fe4e:	1ad3      	subs	r3, r2, r3
 800fe50:	b29b      	uxth	r3, r3
 800fe52:	3b01      	subs	r3, #1
 800fe54:	83fb      	strh	r3, [r7, #30]
        Y = this->heightMemory - Y - 1;
 800fe56:	68fb      	ldr	r3, [r7, #12]
 800fe58:	89da      	ldrh	r2, [r3, #14]
 800fe5a:	8bbb      	ldrh	r3, [r7, #28]
 800fe5c:	1ad3      	subs	r3, r2, r3
 800fe5e:	b29b      	uxth	r3, r3
 800fe60:	3b01      	subs	r3, #1
 800fe62:	83bb      	strh	r3, [r7, #28]
        break;
 800fe64:	e000      	b.n	800fe68 <_ZN2ep5Paint8setPixelEtttb+0x110>
        break;
 800fe66:	bf00      	nop
    default:
        return;
    }

    if (X > this->widthMemory || Y > this->heightMemory)
 800fe68:	68fb      	ldr	r3, [r7, #12]
 800fe6a:	899b      	ldrh	r3, [r3, #12]
 800fe6c:	8bfa      	ldrh	r2, [r7, #30]
 800fe6e:	429a      	cmp	r2, r3
 800fe70:	d849      	bhi.n	800ff06 <_ZN2ep5Paint8setPixelEtttb+0x1ae>
 800fe72:	68fb      	ldr	r3, [r7, #12]
 800fe74:	89db      	ldrh	r3, [r3, #14]
 800fe76:	8bba      	ldrh	r2, [r7, #28]
 800fe78:	429a      	cmp	r2, r3
 800fe7a:	d844      	bhi.n	800ff06 <_ZN2ep5Paint8setPixelEtttb+0x1ae>
    {
        return;
    }

    Addr = X / 8 + Y * this->widthByte;
 800fe7c:	8bfb      	ldrh	r3, [r7, #30]
 800fe7e:	08db      	lsrs	r3, r3, #3
 800fe80:	b29b      	uxth	r3, r3
 800fe82:	4619      	mov	r1, r3
 800fe84:	8bbb      	ldrh	r3, [r7, #28]
 800fe86:	68fa      	ldr	r2, [r7, #12]
 800fe88:	8ad2      	ldrh	r2, [r2, #22]
 800fe8a:	fb02 f303 	mul.w	r3, r2, r3
 800fe8e:	440b      	add	r3, r1
 800fe90:	61bb      	str	r3, [r7, #24]
    Rdata = this->buffer[Addr];
 800fe92:	68fb      	ldr	r3, [r7, #12]
 800fe94:	685a      	ldr	r2, [r3, #4]
 800fe96:	69bb      	ldr	r3, [r7, #24]
 800fe98:	4413      	add	r3, r2
 800fe9a:	781b      	ldrb	r3, [r3, #0]
 800fe9c:	75fb      	strb	r3, [r7, #23]
    if (Color == EP_DISPLAY_BLACK)
 800fe9e:	88fb      	ldrh	r3, [r7, #6]
 800fea0:	2b00      	cmp	r3, #0
 800fea2:	d113      	bne.n	800fecc <_ZN2ep5Paint8setPixelEtttb+0x174>
        this->buffer[Addr] = Rdata & ~(0x80 >> (X % 8));
 800fea4:	8bfb      	ldrh	r3, [r7, #30]
 800fea6:	f003 0307 	and.w	r3, r3, #7
 800feaa:	2280      	movs	r2, #128	; 0x80
 800feac:	fa42 f303 	asr.w	r3, r2, r3
 800feb0:	b25b      	sxtb	r3, r3
 800feb2:	43db      	mvns	r3, r3
 800feb4:	b25a      	sxtb	r2, r3
 800feb6:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800feba:	4013      	ands	r3, r2
 800febc:	b259      	sxtb	r1, r3
 800febe:	68fb      	ldr	r3, [r7, #12]
 800fec0:	685a      	ldr	r2, [r3, #4]
 800fec2:	69bb      	ldr	r3, [r7, #24]
 800fec4:	4413      	add	r3, r2
 800fec6:	b2ca      	uxtb	r2, r1
 800fec8:	701a      	strb	r2, [r3, #0]
 800feca:	e010      	b.n	800feee <_ZN2ep5Paint8setPixelEtttb+0x196>
    else
        this->buffer[Addr] = Rdata | (0x80 >> (X % 8));
 800fecc:	8bfb      	ldrh	r3, [r7, #30]
 800fece:	f003 0307 	and.w	r3, r3, #7
 800fed2:	2280      	movs	r2, #128	; 0x80
 800fed4:	fa42 f303 	asr.w	r3, r2, r3
 800fed8:	b25a      	sxtb	r2, r3
 800feda:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800fede:	4313      	orrs	r3, r2
 800fee0:	b259      	sxtb	r1, r3
 800fee2:	68fb      	ldr	r3, [r7, #12]
 800fee4:	685a      	ldr	r2, [r3, #4]
 800fee6:	69bb      	ldr	r3, [r7, #24]
 800fee8:	4413      	add	r3, r2
 800feea:	b2ca      	uxtb	r2, r1
 800feec:	701a      	strb	r2, [r3, #0]

    if (refresh)
 800feee:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800fef2:	2b00      	cmp	r3, #0
 800fef4:	d008      	beq.n	800ff08 <_ZN2ep5Paint8setPixelEtttb+0x1b0>
    {
        update();
 800fef6:	68f8      	ldr	r0, [r7, #12]
 800fef8:	f000 f82a 	bl	800ff50 <_ZN2ep5Paint6updateEv>
 800fefc:	e004      	b.n	800ff08 <_ZN2ep5Paint8setPixelEtttb+0x1b0>
        return;
 800fefe:	bf00      	nop
 800ff00:	e002      	b.n	800ff08 <_ZN2ep5Paint8setPixelEtttb+0x1b0>
        return;
 800ff02:	bf00      	nop
 800ff04:	e000      	b.n	800ff08 <_ZN2ep5Paint8setPixelEtttb+0x1b0>
        return;
 800ff06:	bf00      	nop
    }
}
 800ff08:	3720      	adds	r7, #32
 800ff0a:	46bd      	mov	sp, r7
 800ff0c:	bd80      	pop	{r7, pc}
 800ff0e:	bf00      	nop
 800ff10:	08019af0 	.word	0x08019af0
 800ff14:	08019af8 	.word	0x08019af8
 800ff18:	08019b38 	.word	0x08019b38

0800ff1c <_ZN2ep5Paint5clearEhb>:
function:	Clear the color of the picture
parameter:
    Color   :   Painted colors
******************************************************************************/
void Paint::clear(uint8_t Color, bool refresh)
{
 800ff1c:	b580      	push	{r7, lr}
 800ff1e:	b082      	sub	sp, #8
 800ff20:	af00      	add	r7, sp, #0
 800ff22:	6078      	str	r0, [r7, #4]
 800ff24:	460b      	mov	r3, r1
 800ff26:	70fb      	strb	r3, [r7, #3]
 800ff28:	4613      	mov	r3, r2
 800ff2a:	70bb      	strb	r3, [r7, #2]
    memset(this->buffer, Color, bytesCount);
 800ff2c:	687b      	ldr	r3, [r7, #4]
 800ff2e:	6858      	ldr	r0, [r3, #4]
 800ff30:	78f9      	ldrb	r1, [r7, #3]
 800ff32:	687b      	ldr	r3, [r7, #4]
 800ff34:	8b9b      	ldrh	r3, [r3, #28]
 800ff36:	461a      	mov	r2, r3
 800ff38:	f006 fac4 	bl	80164c4 <memset>

    if (refresh)
 800ff3c:	78bb      	ldrb	r3, [r7, #2]
 800ff3e:	2b00      	cmp	r3, #0
 800ff40:	d002      	beq.n	800ff48 <_ZN2ep5Paint5clearEhb+0x2c>
    {
        update();
 800ff42:	6878      	ldr	r0, [r7, #4]
 800ff44:	f000 f804 	bl	800ff50 <_ZN2ep5Paint6updateEv>
    }
}
 800ff48:	bf00      	nop
 800ff4a:	3708      	adds	r7, #8
 800ff4c:	46bd      	mov	sp, r7
 800ff4e:	bd80      	pop	{r7, pc}

0800ff50 <_ZN2ep5Paint6updateEv>:
    }
    update();
}

void Paint::update()
{
 800ff50:	b580      	push	{r7, lr}
 800ff52:	b082      	sub	sp, #8
 800ff54:	af00      	add	r7, sp, #0
 800ff56:	6078      	str	r0, [r7, #4]
    epd->display(buffer);
 800ff58:	687b      	ldr	r3, [r7, #4]
 800ff5a:	6818      	ldr	r0, [r3, #0]
 800ff5c:	687b      	ldr	r3, [r7, #4]
 800ff5e:	681b      	ldr	r3, [r3, #0]
 800ff60:	681b      	ldr	r3, [r3, #0]
 800ff62:	330c      	adds	r3, #12
 800ff64:	681b      	ldr	r3, [r3, #0]
 800ff66:	687a      	ldr	r2, [r7, #4]
 800ff68:	6852      	ldr	r2, [r2, #4]
 800ff6a:	4611      	mov	r1, r2
 800ff6c:	4798      	blx	r3
}
 800ff6e:	bf00      	nop
 800ff70:	3708      	adds	r7, #8
 800ff72:	46bd      	mov	sp, r7
 800ff74:	bd80      	pop	{r7, pc}

0800ff76 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb>:
    Dot_Pixel	:	point size
    refresh		:	Send or not refresh command
******************************************************************************/
void Paint::drawPoint(uint16_t Xpoint, uint16_t Ypoint, uint16_t Color,
                      DOT_PIXEL Dot_Pixel, DOT_STYLE DOT_STYLE, bool refresh)
{
 800ff76:	b580      	push	{r7, lr}
 800ff78:	b088      	sub	sp, #32
 800ff7a:	af02      	add	r7, sp, #8
 800ff7c:	60f8      	str	r0, [r7, #12]
 800ff7e:	4608      	mov	r0, r1
 800ff80:	4611      	mov	r1, r2
 800ff82:	461a      	mov	r2, r3
 800ff84:	4603      	mov	r3, r0
 800ff86:	817b      	strh	r3, [r7, #10]
 800ff88:	460b      	mov	r3, r1
 800ff8a:	813b      	strh	r3, [r7, #8]
 800ff8c:	4613      	mov	r3, r2
 800ff8e:	80fb      	strh	r3, [r7, #6]
    int16_t XDir_Num, YDir_Num;
    if (Xpoint > this->width || Ypoint > this->height)
 800ff90:	68fb      	ldr	r3, [r7, #12]
 800ff92:	891b      	ldrh	r3, [r3, #8]
 800ff94:	897a      	ldrh	r2, [r7, #10]
 800ff96:	429a      	cmp	r2, r3
 800ff98:	f200 8092 	bhi.w	80100c0 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x14a>
 800ff9c:	68fb      	ldr	r3, [r7, #12]
 800ff9e:	895b      	ldrh	r3, [r3, #10]
 800ffa0:	893a      	ldrh	r2, [r7, #8]
 800ffa2:	429a      	cmp	r2, r3
 800ffa4:	f200 808c 	bhi.w	80100c0 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x14a>
    {
        return;
    }

    if (DOT_STYLE == DOT_FILL_AROUND)
 800ffa8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 800ffac:	2b01      	cmp	r3, #1
 800ffae:	d14d      	bne.n	801004c <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xd6>
    {
        for (XDir_Num = 0; XDir_Num < 2 * Dot_Pixel - 1; XDir_Num++)
 800ffb0:	2300      	movs	r3, #0
 800ffb2:	82fb      	strh	r3, [r7, #22]
 800ffb4:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800ffb8:	f897 3020 	ldrb.w	r3, [r7, #32]
 800ffbc:	005b      	lsls	r3, r3, #1
 800ffbe:	3b01      	subs	r3, #1
 800ffc0:	429a      	cmp	r2, r3
 800ffc2:	da75      	bge.n	80100b0 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x13a>
        {
            for (YDir_Num = 0; YDir_Num < 2 * Dot_Pixel - 1; YDir_Num++)
 800ffc4:	2300      	movs	r3, #0
 800ffc6:	82bb      	strh	r3, [r7, #20]
 800ffc8:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800ffcc:	f897 3020 	ldrb.w	r3, [r7, #32]
 800ffd0:	005b      	lsls	r3, r3, #1
 800ffd2:	3b01      	subs	r3, #1
 800ffd4:	429a      	cmp	r2, r3
 800ffd6:	da32      	bge.n	801003e <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xc8>
            {
                if (Xpoint + XDir_Num - Dot_Pixel < 0 || Ypoint + YDir_Num - Dot_Pixel < 0)
 800ffd8:	897a      	ldrh	r2, [r7, #10]
 800ffda:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800ffde:	441a      	add	r2, r3
 800ffe0:	f897 3020 	ldrb.w	r3, [r7, #32]
 800ffe4:	1ad3      	subs	r3, r2, r3
 800ffe6:	2b00      	cmp	r3, #0
 800ffe8:	db29      	blt.n	801003e <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xc8>
 800ffea:	893a      	ldrh	r2, [r7, #8]
 800ffec:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800fff0:	441a      	add	r2, r3
 800fff2:	f897 3020 	ldrb.w	r3, [r7, #32]
 800fff6:	1ad3      	subs	r3, r2, r3
 800fff8:	2b00      	cmp	r3, #0
 800fffa:	db20      	blt.n	801003e <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xc8>
                    break;
                setPixel(Xpoint + XDir_Num - Dot_Pixel, Ypoint + YDir_Num - Dot_Pixel, Color, refresh);
 800fffc:	8afa      	ldrh	r2, [r7, #22]
 800fffe:	897b      	ldrh	r3, [r7, #10]
 8010000:	4413      	add	r3, r2
 8010002:	b29a      	uxth	r2, r3
 8010004:	f897 3020 	ldrb.w	r3, [r7, #32]
 8010008:	b29b      	uxth	r3, r3
 801000a:	1ad3      	subs	r3, r2, r3
 801000c:	b299      	uxth	r1, r3
 801000e:	8aba      	ldrh	r2, [r7, #20]
 8010010:	893b      	ldrh	r3, [r7, #8]
 8010012:	4413      	add	r3, r2
 8010014:	b29a      	uxth	r2, r3
 8010016:	f897 3020 	ldrb.w	r3, [r7, #32]
 801001a:	b29b      	uxth	r3, r3
 801001c:	1ad3      	subs	r3, r2, r3
 801001e:	b29a      	uxth	r2, r3
 8010020:	88f8      	ldrh	r0, [r7, #6]
 8010022:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8010026:	9300      	str	r3, [sp, #0]
 8010028:	4603      	mov	r3, r0
 801002a:	68f8      	ldr	r0, [r7, #12]
 801002c:	f7ff fe94 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
            for (YDir_Num = 0; YDir_Num < 2 * Dot_Pixel - 1; YDir_Num++)
 8010030:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8010034:	b29b      	uxth	r3, r3
 8010036:	3301      	adds	r3, #1
 8010038:	b29b      	uxth	r3, r3
 801003a:	82bb      	strh	r3, [r7, #20]
 801003c:	e7c4      	b.n	800ffc8 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x52>
        for (XDir_Num = 0; XDir_Num < 2 * Dot_Pixel - 1; XDir_Num++)
 801003e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010042:	b29b      	uxth	r3, r3
 8010044:	3301      	adds	r3, #1
 8010046:	b29b      	uxth	r3, r3
 8010048:	82fb      	strh	r3, [r7, #22]
 801004a:	e7b3      	b.n	800ffb4 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x3e>
            }
        }
    }
    else
    {
        for (XDir_Num = 0; XDir_Num < Dot_Pixel; XDir_Num++)
 801004c:	2300      	movs	r3, #0
 801004e:	82fb      	strh	r3, [r7, #22]
 8010050:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8010054:	f897 3020 	ldrb.w	r3, [r7, #32]
 8010058:	429a      	cmp	r2, r3
 801005a:	da29      	bge.n	80100b0 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x13a>
        {
            for (YDir_Num = 0; YDir_Num < Dot_Pixel; YDir_Num++)
 801005c:	2300      	movs	r3, #0
 801005e:	82bb      	strh	r3, [r7, #20]
 8010060:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8010064:	f897 3020 	ldrb.w	r3, [r7, #32]
 8010068:	429a      	cmp	r2, r3
 801006a:	da1a      	bge.n	80100a2 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x12c>
            {
                setPixel(Xpoint + XDir_Num - 1, Ypoint + YDir_Num - 1, Color, refresh);
 801006c:	8afa      	ldrh	r2, [r7, #22]
 801006e:	897b      	ldrh	r3, [r7, #10]
 8010070:	4413      	add	r3, r2
 8010072:	b29b      	uxth	r3, r3
 8010074:	3b01      	subs	r3, #1
 8010076:	b299      	uxth	r1, r3
 8010078:	8aba      	ldrh	r2, [r7, #20]
 801007a:	893b      	ldrh	r3, [r7, #8]
 801007c:	4413      	add	r3, r2
 801007e:	b29b      	uxth	r3, r3
 8010080:	3b01      	subs	r3, #1
 8010082:	b29a      	uxth	r2, r3
 8010084:	88f8      	ldrh	r0, [r7, #6]
 8010086:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801008a:	9300      	str	r3, [sp, #0]
 801008c:	4603      	mov	r3, r0
 801008e:	68f8      	ldr	r0, [r7, #12]
 8010090:	f7ff fe62 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
            for (YDir_Num = 0; YDir_Num < Dot_Pixel; YDir_Num++)
 8010094:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8010098:	b29b      	uxth	r3, r3
 801009a:	3301      	adds	r3, #1
 801009c:	b29b      	uxth	r3, r3
 801009e:	82bb      	strh	r3, [r7, #20]
 80100a0:	e7de      	b.n	8010060 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xea>
        for (XDir_Num = 0; XDir_Num < Dot_Pixel; XDir_Num++)
 80100a2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80100a6:	b29b      	uxth	r3, r3
 80100a8:	3301      	adds	r3, #1
 80100aa:	b29b      	uxth	r3, r3
 80100ac:	82fb      	strh	r3, [r7, #22]
 80100ae:	e7cf      	b.n	8010050 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0xda>
            }
        }
    }

    if (refresh)
 80100b0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80100b4:	2b00      	cmp	r3, #0
 80100b6:	d004      	beq.n	80100c2 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x14c>
    {
        update();
 80100b8:	68f8      	ldr	r0, [r7, #12]
 80100ba:	f7ff ff49 	bl	800ff50 <_ZN2ep5Paint6updateEv>
 80100be:	e000      	b.n	80100c2 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb+0x14c>
        return;
 80100c0:	bf00      	nop
    }
}
 80100c2:	3718      	adds	r7, #24
 80100c4:	46bd      	mov	sp, r7
 80100c6:	bd80      	pop	{r7, pc}

080100c8 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb>:
    Color  		：	The color of the line segment
	refresh		:	Send or not refresh command
******************************************************************************/
void Paint::drawLine(uint16_t Xstart, uint16_t Ystart, uint16_t Xend, uint16_t Yend,
                     uint16_t Color, LINE_STYLE Line_Style, DOT_PIXEL Dot_Pixel, bool refresh)
{
 80100c8:	b580      	push	{r7, lr}
 80100ca:	b090      	sub	sp, #64	; 0x40
 80100cc:	af04      	add	r7, sp, #16
 80100ce:	60f8      	str	r0, [r7, #12]
 80100d0:	4608      	mov	r0, r1
 80100d2:	4611      	mov	r1, r2
 80100d4:	461a      	mov	r2, r3
 80100d6:	4603      	mov	r3, r0
 80100d8:	817b      	strh	r3, [r7, #10]
 80100da:	460b      	mov	r3, r1
 80100dc:	813b      	strh	r3, [r7, #8]
 80100de:	4613      	mov	r3, r2
 80100e0:	80fb      	strh	r3, [r7, #6]
    uint16_t Xpoint, Ypoint;
    int dx, dy;
    int XAddway, YAddway;
    int Esp;
    char Dotted_Len;
    if (Xstart > this->width || Ystart > this->height ||
 80100e2:	68fb      	ldr	r3, [r7, #12]
 80100e4:	891b      	ldrh	r3, [r3, #8]
 80100e6:	897a      	ldrh	r2, [r7, #10]
 80100e8:	429a      	cmp	r2, r3
 80100ea:	f200 80a5 	bhi.w	8010238 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x170>
 80100ee:	68fb      	ldr	r3, [r7, #12]
 80100f0:	895b      	ldrh	r3, [r3, #10]
 80100f2:	893a      	ldrh	r2, [r7, #8]
 80100f4:	429a      	cmp	r2, r3
 80100f6:	f200 809f 	bhi.w	8010238 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x170>
        Xend > this->width || Yend > this->height)
 80100fa:	68fb      	ldr	r3, [r7, #12]
 80100fc:	891b      	ldrh	r3, [r3, #8]
    if (Xstart > this->width || Ystart > this->height ||
 80100fe:	88fa      	ldrh	r2, [r7, #6]
 8010100:	429a      	cmp	r2, r3
 8010102:	f200 8099 	bhi.w	8010238 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x170>
        Xend > this->width || Yend > this->height)
 8010106:	68fb      	ldr	r3, [r7, #12]
 8010108:	895b      	ldrh	r3, [r3, #10]
 801010a:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801010c:	429a      	cmp	r2, r3
 801010e:	f200 8093 	bhi.w	8010238 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x170>
    {
        return;
    }

    Xpoint = Xstart;
 8010112:	897b      	ldrh	r3, [r7, #10]
 8010114:	85fb      	strh	r3, [r7, #46]	; 0x2e
    Ypoint = Ystart;
 8010116:	893b      	ldrh	r3, [r7, #8]
 8010118:	85bb      	strh	r3, [r7, #44]	; 0x2c
    dx = (int)Xend - (int)Xstart >= 0 ? Xend - Xstart : Xstart - Xend;
 801011a:	88fa      	ldrh	r2, [r7, #6]
 801011c:	897b      	ldrh	r3, [r7, #10]
 801011e:	1ad3      	subs	r3, r2, r3
 8010120:	2b00      	cmp	r3, #0
 8010122:	bfb8      	it	lt
 8010124:	425b      	neglt	r3, r3
 8010126:	623b      	str	r3, [r7, #32]
    dy = (int)Yend - (int)Ystart <= 0 ? Yend - Ystart : Ystart - Yend;
 8010128:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801012a:	893b      	ldrh	r3, [r7, #8]
 801012c:	1ad3      	subs	r3, r2, r3
 801012e:	2b00      	cmp	r3, #0
 8010130:	bfb8      	it	lt
 8010132:	425b      	neglt	r3, r3
 8010134:	425b      	negs	r3, r3
 8010136:	61fb      	str	r3, [r7, #28]

    // Increment direction, 1 is positive, -1 is counter;
    XAddway = Xstart < Xend ? 1 : -1;
 8010138:	897a      	ldrh	r2, [r7, #10]
 801013a:	88fb      	ldrh	r3, [r7, #6]
 801013c:	429a      	cmp	r2, r3
 801013e:	d201      	bcs.n	8010144 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x7c>
 8010140:	2301      	movs	r3, #1
 8010142:	e001      	b.n	8010148 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x80>
 8010144:	f04f 33ff 	mov.w	r3, #4294967295
 8010148:	61bb      	str	r3, [r7, #24]
    YAddway = Ystart < Yend ? 1 : -1;
 801014a:	893a      	ldrh	r2, [r7, #8]
 801014c:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801014e:	429a      	cmp	r2, r3
 8010150:	d201      	bcs.n	8010156 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x8e>
 8010152:	2301      	movs	r3, #1
 8010154:	e001      	b.n	801015a <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x92>
 8010156:	f04f 33ff 	mov.w	r3, #4294967295
 801015a:	617b      	str	r3, [r7, #20]

    //Cumulative error
    Esp = dx + dy;
 801015c:	6a3a      	ldr	r2, [r7, #32]
 801015e:	69fb      	ldr	r3, [r7, #28]
 8010160:	4413      	add	r3, r2
 8010162:	62bb      	str	r3, [r7, #40]	; 0x28
    Dotted_Len = 0;
 8010164:	2300      	movs	r3, #0
 8010166:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    for (;;)
    {
        Dotted_Len++;
 801016a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801016e:	3301      	adds	r3, #1
 8010170:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        //Painted dotted line, 2 point is really virtual
        if (Line_Style == LINE_STYLE_DOTTED && Dotted_Len % 3 == 0)
 8010174:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010178:	2b01      	cmp	r3, #1
 801017a:	d11e      	bne.n	80101ba <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0xf2>
 801017c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010180:	4b2f      	ldr	r3, [pc, #188]	; (8010240 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x178>)
 8010182:	fba3 1302 	umull	r1, r3, r3, r2
 8010186:	0859      	lsrs	r1, r3, #1
 8010188:	460b      	mov	r3, r1
 801018a:	005b      	lsls	r3, r3, #1
 801018c:	440b      	add	r3, r1
 801018e:	1ad3      	subs	r3, r2, r3
 8010190:	b2db      	uxtb	r3, r3
 8010192:	2b00      	cmp	r3, #0
 8010194:	d111      	bne.n	80101ba <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0xf2>
        {
            drawPoint(Xpoint, Ypoint, EP_DISPLAY_IMAGE_BACKGROUND, Dot_Pixel, DOT_STYLE_DFT, refresh);
 8010196:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8010198:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 801019a:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 801019e:	9302      	str	r3, [sp, #8]
 80101a0:	2301      	movs	r3, #1
 80101a2:	9301      	str	r3, [sp, #4]
 80101a4:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80101a8:	9300      	str	r3, [sp, #0]
 80101aa:	23ff      	movs	r3, #255	; 0xff
 80101ac:	68f8      	ldr	r0, [r7, #12]
 80101ae:	f7ff fee2 	bl	800ff76 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb>
            Dotted_Len = 0;
 80101b2:	2300      	movs	r3, #0
 80101b4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80101b8:	e00e      	b.n	80101d8 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x110>
        }
        else
        {
            drawPoint(Xpoint, Ypoint, Color, Dot_Pixel, DOT_STYLE_DFT, refresh);
 80101ba:	8fb8      	ldrh	r0, [r7, #60]	; 0x3c
 80101bc:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 80101be:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 80101c0:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80101c4:	9302      	str	r3, [sp, #8]
 80101c6:	2301      	movs	r3, #1
 80101c8:	9301      	str	r3, [sp, #4]
 80101ca:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80101ce:	9300      	str	r3, [sp, #0]
 80101d0:	4603      	mov	r3, r0
 80101d2:	68f8      	ldr	r0, [r7, #12]
 80101d4:	f7ff fecf 	bl	800ff76 <_ZN2ep5Paint9drawPointEttt9DOT_PIXEL9DOT_STYLEb>
        }
        if (2 * Esp >= dy)
 80101d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80101da:	005b      	lsls	r3, r3, #1
 80101dc:	69fa      	ldr	r2, [r7, #28]
 80101de:	429a      	cmp	r2, r3
 80101e0:	dc0c      	bgt.n	80101fc <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x134>
        {
            if (Xpoint == Xend)
 80101e2:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 80101e4:	88fb      	ldrh	r3, [r7, #6]
 80101e6:	429a      	cmp	r2, r3
 80101e8:	d01b      	beq.n	8010222 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x15a>
                break;
            Esp += dy;
 80101ea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80101ec:	69fb      	ldr	r3, [r7, #28]
 80101ee:	4413      	add	r3, r2
 80101f0:	62bb      	str	r3, [r7, #40]	; 0x28
            Xpoint += XAddway;
 80101f2:	69bb      	ldr	r3, [r7, #24]
 80101f4:	b29a      	uxth	r2, r3
 80101f6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80101f8:	4413      	add	r3, r2
 80101fa:	85fb      	strh	r3, [r7, #46]	; 0x2e
        }
        if (2 * Esp <= dx)
 80101fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80101fe:	005b      	lsls	r3, r3, #1
 8010200:	6a3a      	ldr	r2, [r7, #32]
 8010202:	429a      	cmp	r2, r3
 8010204:	dbb1      	blt.n	801016a <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0xa2>
        {
            if (Ypoint == Yend)
 8010206:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8010208:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801020a:	429a      	cmp	r2, r3
 801020c:	d00b      	beq.n	8010226 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x15e>
                break;
            Esp += dx;
 801020e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010210:	6a3b      	ldr	r3, [r7, #32]
 8010212:	4413      	add	r3, r2
 8010214:	62bb      	str	r3, [r7, #40]	; 0x28
            Ypoint += YAddway;
 8010216:	697b      	ldr	r3, [r7, #20]
 8010218:	b29a      	uxth	r2, r3
 801021a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801021c:	4413      	add	r3, r2
 801021e:	85bb      	strh	r3, [r7, #44]	; 0x2c
        Dotted_Len++;
 8010220:	e7a3      	b.n	801016a <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0xa2>
                break;
 8010222:	bf00      	nop
 8010224:	e000      	b.n	8010228 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x160>
                break;
 8010226:	bf00      	nop
        }
    }

    if (refresh)
 8010228:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 801022c:	2b00      	cmp	r3, #0
 801022e:	d004      	beq.n	801023a <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x172>
    {
        update();
 8010230:	68f8      	ldr	r0, [r7, #12]
 8010232:	f7ff fe8d 	bl	800ff50 <_ZN2ep5Paint6updateEv>
 8010236:	e000      	b.n	801023a <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb+0x172>
        return;
 8010238:	bf00      	nop
    }
}
 801023a:	3730      	adds	r7, #48	; 0x30
 801023c:	46bd      	mov	sp, r7
 801023e:	bd80      	pop	{r7, pc}
 8010240:	aaaaaaab 	.word	0xaaaaaaab

08010244 <_ZN2ep5Paint8drawCharEttcP6_tFontttb>:
    Color_Foreground : Select the foreground color of the character
    refresh			 :	Send or not refresh command
******************************************************************************/
void Paint::drawChar(uint16_t Xpoint, uint16_t Ypoint, const char Acsii_Char,
                     sFONT *Font, uint16_t Color_Background, uint16_t Color_Foreground, bool refresh)
{
 8010244:	b580      	push	{r7, lr}
 8010246:	b08a      	sub	sp, #40	; 0x28
 8010248:	af02      	add	r7, sp, #8
 801024a:	60f8      	str	r0, [r7, #12]
 801024c:	4608      	mov	r0, r1
 801024e:	4611      	mov	r1, r2
 8010250:	461a      	mov	r2, r3
 8010252:	4603      	mov	r3, r0
 8010254:	817b      	strh	r3, [r7, #10]
 8010256:	460b      	mov	r3, r1
 8010258:	813b      	strh	r3, [r7, #8]
 801025a:	4613      	mov	r3, r2
 801025c:	71fb      	strb	r3, [r7, #7]
    uint16_t Page, Column;
    uint32_t Char_Offset;
    const unsigned char *ptr;

    if (Xpoint > this->width || Ypoint > this->height)
 801025e:	68fb      	ldr	r3, [r7, #12]
 8010260:	891b      	ldrh	r3, [r3, #8]
 8010262:	897a      	ldrh	r2, [r7, #10]
 8010264:	429a      	cmp	r2, r3
 8010266:	f200 809f 	bhi.w	80103a8 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x164>
 801026a:	68fb      	ldr	r3, [r7, #12]
 801026c:	895b      	ldrh	r3, [r3, #10]
 801026e:	893a      	ldrh	r2, [r7, #8]
 8010270:	429a      	cmp	r2, r3
 8010272:	f200 8099 	bhi.w	80103a8 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x164>
    {
        return;
    }

    Char_Offset = (Acsii_Char - ' ') * Font->Height * (Font->Width / 8 + (Font->Width % 8 ? 1 : 0));
 8010276:	79fb      	ldrb	r3, [r7, #7]
 8010278:	3b20      	subs	r3, #32
 801027a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801027c:	88d2      	ldrh	r2, [r2, #6]
 801027e:	fb02 f303 	mul.w	r3, r2, r3
 8010282:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010284:	8892      	ldrh	r2, [r2, #4]
 8010286:	08d2      	lsrs	r2, r2, #3
 8010288:	b292      	uxth	r2, r2
 801028a:	4611      	mov	r1, r2
 801028c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801028e:	8892      	ldrh	r2, [r2, #4]
 8010290:	f002 0207 	and.w	r2, r2, #7
 8010294:	2a00      	cmp	r2, #0
 8010296:	d001      	beq.n	801029c <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x58>
 8010298:	2201      	movs	r2, #1
 801029a:	e000      	b.n	801029e <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x5a>
 801029c:	2200      	movs	r2, #0
 801029e:	440a      	add	r2, r1
 80102a0:	fb02 f303 	mul.w	r3, r2, r3
 80102a4:	617b      	str	r3, [r7, #20]
    ptr = &Font->table[Char_Offset];
 80102a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80102a8:	681a      	ldr	r2, [r3, #0]
 80102aa:	697b      	ldr	r3, [r7, #20]
 80102ac:	4413      	add	r3, r2
 80102ae:	61bb      	str	r3, [r7, #24]

    for (Page = 0; Page < Font->Height; Page++)
 80102b0:	2300      	movs	r3, #0
 80102b2:	83fb      	strh	r3, [r7, #30]
 80102b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80102b6:	88db      	ldrh	r3, [r3, #6]
 80102b8:	8bfa      	ldrh	r2, [r7, #30]
 80102ba:	429a      	cmp	r2, r3
 80102bc:	d26c      	bcs.n	8010398 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x154>
    {
        for (Column = 0; Column < Font->Width; Column++)
 80102be:	2300      	movs	r3, #0
 80102c0:	83bb      	strh	r3, [r7, #28]
 80102c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80102c4:	889b      	ldrh	r3, [r3, #4]
 80102c6:	8bba      	ldrh	r2, [r7, #28]
 80102c8:	429a      	cmp	r2, r3
 80102ca:	d258      	bcs.n	801037e <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x13a>
        {
            //To determine whether the font background color and screen background color is consistent
            if (EP_DISPLAY_FONT_BACKGROUND == Color_Background)
 80102cc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80102ce:	2bff      	cmp	r3, #255	; 0xff
 80102d0:	d11c      	bne.n	801030c <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0xc8>
            { //this process is to speed up the scan
                if (*ptr & (0x80 >> (Column % 8)))
 80102d2:	69bb      	ldr	r3, [r7, #24]
 80102d4:	781b      	ldrb	r3, [r3, #0]
 80102d6:	4619      	mov	r1, r3
 80102d8:	8bbb      	ldrh	r3, [r7, #28]
 80102da:	f003 0307 	and.w	r3, r3, #7
 80102de:	2280      	movs	r2, #128	; 0x80
 80102e0:	fa42 f303 	asr.w	r3, r2, r3
 80102e4:	400b      	ands	r3, r1
 80102e6:	2b00      	cmp	r3, #0
 80102e8:	d03d      	beq.n	8010366 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x122>
                    setPixel(Xpoint + Column, Ypoint + Page, Color_Foreground, refresh);
 80102ea:	897a      	ldrh	r2, [r7, #10]
 80102ec:	8bbb      	ldrh	r3, [r7, #28]
 80102ee:	4413      	add	r3, r2
 80102f0:	b299      	uxth	r1, r3
 80102f2:	893a      	ldrh	r2, [r7, #8]
 80102f4:	8bfb      	ldrh	r3, [r7, #30]
 80102f6:	4413      	add	r3, r2
 80102f8:	b29a      	uxth	r2, r3
 80102fa:	8e38      	ldrh	r0, [r7, #48]	; 0x30
 80102fc:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8010300:	9300      	str	r3, [sp, #0]
 8010302:	4603      	mov	r3, r0
 8010304:	68f8      	ldr	r0, [r7, #12]
 8010306:	f7ff fd27 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
 801030a:	e02c      	b.n	8010366 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x122>
            }
            else
            {
                if (*ptr & (0x80 >> (Column % 8)))
 801030c:	69bb      	ldr	r3, [r7, #24]
 801030e:	781b      	ldrb	r3, [r3, #0]
 8010310:	4619      	mov	r1, r3
 8010312:	8bbb      	ldrh	r3, [r7, #28]
 8010314:	f003 0307 	and.w	r3, r3, #7
 8010318:	2280      	movs	r2, #128	; 0x80
 801031a:	fa42 f303 	asr.w	r3, r2, r3
 801031e:	400b      	ands	r3, r1
 8010320:	2b00      	cmp	r3, #0
 8010322:	d010      	beq.n	8010346 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x102>
                {
                    setPixel(Xpoint + Column, Ypoint + Page, Color_Foreground, refresh);
 8010324:	897a      	ldrh	r2, [r7, #10]
 8010326:	8bbb      	ldrh	r3, [r7, #28]
 8010328:	4413      	add	r3, r2
 801032a:	b299      	uxth	r1, r3
 801032c:	893a      	ldrh	r2, [r7, #8]
 801032e:	8bfb      	ldrh	r3, [r7, #30]
 8010330:	4413      	add	r3, r2
 8010332:	b29a      	uxth	r2, r3
 8010334:	8e38      	ldrh	r0, [r7, #48]	; 0x30
 8010336:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801033a:	9300      	str	r3, [sp, #0]
 801033c:	4603      	mov	r3, r0
 801033e:	68f8      	ldr	r0, [r7, #12]
 8010340:	f7ff fd0a 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
 8010344:	e00f      	b.n	8010366 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x122>
                }
                else
                {
                    setPixel(Xpoint + Column, Ypoint + Page, Color_Background, refresh);
 8010346:	897a      	ldrh	r2, [r7, #10]
 8010348:	8bbb      	ldrh	r3, [r7, #28]
 801034a:	4413      	add	r3, r2
 801034c:	b299      	uxth	r1, r3
 801034e:	893a      	ldrh	r2, [r7, #8]
 8010350:	8bfb      	ldrh	r3, [r7, #30]
 8010352:	4413      	add	r3, r2
 8010354:	b29a      	uxth	r2, r3
 8010356:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
 8010358:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801035c:	9300      	str	r3, [sp, #0]
 801035e:	4603      	mov	r3, r0
 8010360:	68f8      	ldr	r0, [r7, #12]
 8010362:	f7ff fcf9 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
                }
            }
            //One pixel is 8 bits
            if (Column % 8 == 7)
 8010366:	8bbb      	ldrh	r3, [r7, #28]
 8010368:	f003 0307 	and.w	r3, r3, #7
 801036c:	2b07      	cmp	r3, #7
 801036e:	d102      	bne.n	8010376 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x132>
                ptr++;
 8010370:	69bb      	ldr	r3, [r7, #24]
 8010372:	3301      	adds	r3, #1
 8010374:	61bb      	str	r3, [r7, #24]
        for (Column = 0; Column < Font->Width; Column++)
 8010376:	8bbb      	ldrh	r3, [r7, #28]
 8010378:	3301      	adds	r3, #1
 801037a:	83bb      	strh	r3, [r7, #28]
 801037c:	e7a1      	b.n	80102c2 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x7e>
        } // Write a line
        if (Font->Width % 8 != 0)
 801037e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010380:	889b      	ldrh	r3, [r3, #4]
 8010382:	f003 0307 	and.w	r3, r3, #7
 8010386:	2b00      	cmp	r3, #0
 8010388:	d002      	beq.n	8010390 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x14c>
            ptr++;
 801038a:	69bb      	ldr	r3, [r7, #24]
 801038c:	3301      	adds	r3, #1
 801038e:	61bb      	str	r3, [r7, #24]
    for (Page = 0; Page < Font->Height; Page++)
 8010390:	8bfb      	ldrh	r3, [r7, #30]
 8010392:	3301      	adds	r3, #1
 8010394:	83fb      	strh	r3, [r7, #30]
 8010396:	e78d      	b.n	80102b4 <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x70>
    } // Write all

    if (refresh)
 8010398:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801039c:	2b00      	cmp	r3, #0
 801039e:	d004      	beq.n	80103aa <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x166>
    {
        update();
 80103a0:	68f8      	ldr	r0, [r7, #12]
 80103a2:	f7ff fdd5 	bl	800ff50 <_ZN2ep5Paint6updateEv>
 80103a6:	e000      	b.n	80103aa <_ZN2ep5Paint8drawCharEttcP6_tFontttb+0x166>
        return;
 80103a8:	bf00      	nop
    }
}
 80103aa:	3720      	adds	r7, #32
 80103ac:	46bd      	mov	sp, r7
 80103ae:	bd80      	pop	{r7, pc}

080103b0 <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb>:
    Color_Foreground : Select the foreground color of the character
    refresh			 :	Send or not refresh command
******************************************************************************/
void Paint::drawString(uint16_t Xstart, uint16_t Ystart, const char *pString,
                       sFONT *Font, uint16_t Color_Background, uint16_t Color_Foreground, bool refresh)
{
 80103b0:	b580      	push	{r7, lr}
 80103b2:	b08a      	sub	sp, #40	; 0x28
 80103b4:	af04      	add	r7, sp, #16
 80103b6:	60f8      	str	r0, [r7, #12]
 80103b8:	607b      	str	r3, [r7, #4]
 80103ba:	460b      	mov	r3, r1
 80103bc:	817b      	strh	r3, [r7, #10]
 80103be:	4613      	mov	r3, r2
 80103c0:	813b      	strh	r3, [r7, #8]
    uint16_t Xpoint = Xstart;
 80103c2:	897b      	ldrh	r3, [r7, #10]
 80103c4:	82fb      	strh	r3, [r7, #22]
    uint16_t Ypoint = Ystart;
 80103c6:	893b      	ldrh	r3, [r7, #8]
 80103c8:	82bb      	strh	r3, [r7, #20]

    if (Xstart > this->width || Ystart > this->height)
 80103ca:	68fb      	ldr	r3, [r7, #12]
 80103cc:	891b      	ldrh	r3, [r3, #8]
 80103ce:	897a      	ldrh	r2, [r7, #10]
 80103d0:	429a      	cmp	r2, r3
 80103d2:	d844      	bhi.n	801045e <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0xae>
 80103d4:	68fb      	ldr	r3, [r7, #12]
 80103d6:	895b      	ldrh	r3, [r3, #10]
 80103d8:	893a      	ldrh	r2, [r7, #8]
 80103da:	429a      	cmp	r2, r3
 80103dc:	d83f      	bhi.n	801045e <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0xae>
    {
        return;
    }

    while (*pString != '\0')
 80103de:	687b      	ldr	r3, [r7, #4]
 80103e0:	781b      	ldrb	r3, [r3, #0]
 80103e2:	2b00      	cmp	r3, #0
 80103e4:	d033      	beq.n	801044e <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0x9e>
    {
        //if X direction filled , reposition to(Xstart,Ypoint),Ypoint is Y direction plus the Height of the character
        if ((Xpoint + Font->Width) > this->width)
 80103e6:	8afb      	ldrh	r3, [r7, #22]
 80103e8:	6a3a      	ldr	r2, [r7, #32]
 80103ea:	8892      	ldrh	r2, [r2, #4]
 80103ec:	4413      	add	r3, r2
 80103ee:	68fa      	ldr	r2, [r7, #12]
 80103f0:	8912      	ldrh	r2, [r2, #8]
 80103f2:	4293      	cmp	r3, r2
 80103f4:	dd06      	ble.n	8010404 <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0x54>
        {
            Xpoint = Xstart;
 80103f6:	897b      	ldrh	r3, [r7, #10]
 80103f8:	82fb      	strh	r3, [r7, #22]
            Ypoint += Font->Height;
 80103fa:	6a3b      	ldr	r3, [r7, #32]
 80103fc:	88da      	ldrh	r2, [r3, #6]
 80103fe:	8abb      	ldrh	r3, [r7, #20]
 8010400:	4413      	add	r3, r2
 8010402:	82bb      	strh	r3, [r7, #20]
        }

        // If the Y direction is full, reposition to(Xstart, Ystart)
        if ((Ypoint + Font->Height) > this->height)
 8010404:	8abb      	ldrh	r3, [r7, #20]
 8010406:	6a3a      	ldr	r2, [r7, #32]
 8010408:	88d2      	ldrh	r2, [r2, #6]
 801040a:	4413      	add	r3, r2
 801040c:	68fa      	ldr	r2, [r7, #12]
 801040e:	8952      	ldrh	r2, [r2, #10]
 8010410:	4293      	cmp	r3, r2
 8010412:	dd03      	ble.n	801041c <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0x6c>
        {
            Xpoint = Xstart;
 8010414:	897b      	ldrh	r3, [r7, #10]
 8010416:	82fb      	strh	r3, [r7, #22]
            Ypoint = Ystart;
 8010418:	893b      	ldrh	r3, [r7, #8]
 801041a:	82bb      	strh	r3, [r7, #20]
        }
        drawChar(Xpoint, Ypoint, *pString, Font, Color_Background, Color_Foreground, false);
 801041c:	687b      	ldr	r3, [r7, #4]
 801041e:	7818      	ldrb	r0, [r3, #0]
 8010420:	8aba      	ldrh	r2, [r7, #20]
 8010422:	8af9      	ldrh	r1, [r7, #22]
 8010424:	2300      	movs	r3, #0
 8010426:	9303      	str	r3, [sp, #12]
 8010428:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801042a:	9302      	str	r3, [sp, #8]
 801042c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801042e:	9301      	str	r3, [sp, #4]
 8010430:	6a3b      	ldr	r3, [r7, #32]
 8010432:	9300      	str	r3, [sp, #0]
 8010434:	4603      	mov	r3, r0
 8010436:	68f8      	ldr	r0, [r7, #12]
 8010438:	f7ff ff04 	bl	8010244 <_ZN2ep5Paint8drawCharEttcP6_tFontttb>

        //The next character of the address
        pString++;
 801043c:	687b      	ldr	r3, [r7, #4]
 801043e:	3301      	adds	r3, #1
 8010440:	607b      	str	r3, [r7, #4]

        //The next word of the abscissa increases the font of the broadband
        Xpoint += Font->Width;
 8010442:	6a3b      	ldr	r3, [r7, #32]
 8010444:	889a      	ldrh	r2, [r3, #4]
 8010446:	8afb      	ldrh	r3, [r7, #22]
 8010448:	4413      	add	r3, r2
 801044a:	82fb      	strh	r3, [r7, #22]
    while (*pString != '\0')
 801044c:	e7c7      	b.n	80103de <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0x2e>
    }

    if (refresh)
 801044e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8010452:	2b00      	cmp	r3, #0
 8010454:	d004      	beq.n	8010460 <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0xb0>
    {
    	update();
 8010456:	68f8      	ldr	r0, [r7, #12]
 8010458:	f7ff fd7a 	bl	800ff50 <_ZN2ep5Paint6updateEv>
 801045c:	e000      	b.n	8010460 <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb+0xb0>
        return;
 801045e:	bf00      	nop
    }
}
 8010460:	3718      	adds	r7, #24
 8010462:	46bd      	mov	sp, r7
 8010464:	bd80      	pop	{r7, pc}

08010466 <_ZN2ep3GpiC1EP12GPIO_TypeDefm>:
 * @brief Initialize a new GPI object 
 * 
 * @param p1 Pin Number
 * @param port Port Name
 */
Gpi::Gpi(GPIO_TypeDef * port, uint32_t pin) : Gpio(port, pin)
 8010466:	b580      	push	{r7, lr}
 8010468:	b084      	sub	sp, #16
 801046a:	af00      	add	r7, sp, #0
 801046c:	60f8      	str	r0, [r7, #12]
 801046e:	60b9      	str	r1, [r7, #8]
 8010470:	607a      	str	r2, [r7, #4]
 8010472:	68fb      	ldr	r3, [r7, #12]
 8010474:	687a      	ldr	r2, [r7, #4]
 8010476:	68b9      	ldr	r1, [r7, #8]
 8010478:	4618      	mov	r0, r3
 801047a:	f000 f819 	bl	80104b0 <_ZN2ep4GpioC1EP12GPIO_TypeDefm>
{

}
 801047e:	68fb      	ldr	r3, [r7, #12]
 8010480:	4618      	mov	r0, r3
 8010482:	3710      	adds	r7, #16
 8010484:	46bd      	mov	sp, r7
 8010486:	bd80      	pop	{r7, pc}

08010488 <_ZN2ep3Gpi4readEv>:
 * @brief Read current pin state 
 * 
 * @return GPIO::PINSTATE (PIN_ON/PIN_OFF)
 */
GPIO_PinState Gpi::read()
{
 8010488:	b580      	push	{r7, lr}
 801048a:	b084      	sub	sp, #16
 801048c:	af00      	add	r7, sp, #0
 801048e:	6078      	str	r0, [r7, #4]
	GPIO_PinState retVal = HAL_GPIO_ReadPin(port, pin);
 8010490:	687b      	ldr	r3, [r7, #4]
 8010492:	681a      	ldr	r2, [r3, #0]
 8010494:	687b      	ldr	r3, [r7, #4]
 8010496:	685b      	ldr	r3, [r3, #4]
 8010498:	b29b      	uxth	r3, r3
 801049a:	4619      	mov	r1, r3
 801049c:	4610      	mov	r0, r2
 801049e:	f7f1 fba5 	bl	8001bec <HAL_GPIO_ReadPin>
 80104a2:	4603      	mov	r3, r0
 80104a4:	73fb      	strb	r3, [r7, #15]
    
    return retVal;
 80104a6:	7bfb      	ldrb	r3, [r7, #15]
}
 80104a8:	4618      	mov	r0, r3
 80104aa:	3710      	adds	r7, #16
 80104ac:	46bd      	mov	sp, r7
 80104ae:	bd80      	pop	{r7, pc}

080104b0 <_ZN2ep4GpioC1EP12GPIO_TypeDefm>:
 * @brief Construct a new GPIO object 
 * 
 * @param p1 Pin Number
 * @param port Port Name
 */
Gpio::Gpio(GPIO_TypeDef * port, uint32_t pin) :
 80104b0:	b480      	push	{r7}
 80104b2:	b085      	sub	sp, #20
 80104b4:	af00      	add	r7, sp, #0
 80104b6:	60f8      	str	r0, [r7, #12]
 80104b8:	60b9      	str	r1, [r7, #8]
 80104ba:	607a      	str	r2, [r7, #4]
 port(port),
 pin(pin)
 80104bc:	68fb      	ldr	r3, [r7, #12]
 80104be:	68ba      	ldr	r2, [r7, #8]
 80104c0:	601a      	str	r2, [r3, #0]
 80104c2:	68fb      	ldr	r3, [r7, #12]
 80104c4:	687a      	ldr	r2, [r7, #4]
 80104c6:	605a      	str	r2, [r3, #4]
{

}
 80104c8:	68fb      	ldr	r3, [r7, #12]
 80104ca:	4618      	mov	r0, r3
 80104cc:	3714      	adds	r7, #20
 80104ce:	46bd      	mov	sp, r7
 80104d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104d4:	4770      	bx	lr

080104d6 <_ZN2ep3GpoC1EP12GPIO_TypeDefm>:
 * @brief Construct a new Gpo object
 * 
 * @param p1 Pin number
 * @param port Port name
 */
Gpo::Gpo(GPIO_TypeDef * port, uint32_t pin) : Gpio(port, pin)
 80104d6:	b580      	push	{r7, lr}
 80104d8:	b084      	sub	sp, #16
 80104da:	af00      	add	r7, sp, #0
 80104dc:	60f8      	str	r0, [r7, #12]
 80104de:	60b9      	str	r1, [r7, #8]
 80104e0:	607a      	str	r2, [r7, #4]
 80104e2:	68fb      	ldr	r3, [r7, #12]
 80104e4:	687a      	ldr	r2, [r7, #4]
 80104e6:	68b9      	ldr	r1, [r7, #8]
 80104e8:	4618      	mov	r0, r3
 80104ea:	f7ff ffe1 	bl	80104b0 <_ZN2ep4GpioC1EP12GPIO_TypeDefm>
{

}
 80104ee:	68fb      	ldr	r3, [r7, #12]
 80104f0:	4618      	mov	r0, r3
 80104f2:	3710      	adds	r7, #16
 80104f4:	46bd      	mov	sp, r7
 80104f6:	bd80      	pop	{r7, pc}

080104f8 <_ZN2ep3Gpo2onEv>:
/**
 * @brief Turn output pin on
 * 
 */
void Gpo::on()
{
 80104f8:	b580      	push	{r7, lr}
 80104fa:	b082      	sub	sp, #8
 80104fc:	af00      	add	r7, sp, #0
 80104fe:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(port, pin, GPIO_PIN_SET);
 8010500:	687b      	ldr	r3, [r7, #4]
 8010502:	6818      	ldr	r0, [r3, #0]
 8010504:	687b      	ldr	r3, [r7, #4]
 8010506:	685b      	ldr	r3, [r3, #4]
 8010508:	b29b      	uxth	r3, r3
 801050a:	2201      	movs	r2, #1
 801050c:	4619      	mov	r1, r3
 801050e:	f7f1 fb85 	bl	8001c1c <HAL_GPIO_WritePin>
}
 8010512:	bf00      	nop
 8010514:	3708      	adds	r7, #8
 8010516:	46bd      	mov	sp, r7
 8010518:	bd80      	pop	{r7, pc}

0801051a <_ZN2ep3Gpo3offEv>:
/**
 * @brief Turn output pin off
 * 
 */
void Gpo::off()
{
 801051a:	b580      	push	{r7, lr}
 801051c:	b082      	sub	sp, #8
 801051e:	af00      	add	r7, sp, #0
 8010520:	6078      	str	r0, [r7, #4]
	HAL_GPIO_WritePin(port, pin, GPIO_PIN_RESET);
 8010522:	687b      	ldr	r3, [r7, #4]
 8010524:	6818      	ldr	r0, [r3, #0]
 8010526:	687b      	ldr	r3, [r7, #4]
 8010528:	685b      	ldr	r3, [r3, #4]
 801052a:	b29b      	uxth	r3, r3
 801052c:	2200      	movs	r2, #0
 801052e:	4619      	mov	r1, r3
 8010530:	f7f1 fb74 	bl	8001c1c <HAL_GPIO_WritePin>
}
 8010534:	bf00      	nop
 8010536:	3708      	adds	r7, #8
 8010538:	46bd      	mov	sp, r7
 801053a:	bd80      	pop	{r7, pc}

0801053c <_ZN18IMonochromeDisplay4SizeC1Eii>:
		 * @brief Constructor, initializes the width and height of a size.
		 *
		 * @param width 	The width.
		 * @param height 	The height.
		 */
		inline explicit Size( int width = 0 , int height = 0 ) : width( width ) , height( height ) {}
 801053c:	b480      	push	{r7}
 801053e:	b085      	sub	sp, #20
 8010540:	af00      	add	r7, sp, #0
 8010542:	60f8      	str	r0, [r7, #12]
 8010544:	60b9      	str	r1, [r7, #8]
 8010546:	607a      	str	r2, [r7, #4]
 8010548:	68fb      	ldr	r3, [r7, #12]
 801054a:	68ba      	ldr	r2, [r7, #8]
 801054c:	601a      	str	r2, [r3, #0]
 801054e:	68fb      	ldr	r3, [r7, #12]
 8010550:	687a      	ldr	r2, [r7, #4]
 8010552:	605a      	str	r2, [r3, #4]
 8010554:	68fb      	ldr	r3, [r7, #12]
 8010556:	4618      	mov	r0, r3
 8010558:	3714      	adds	r7, #20
 801055a:	46bd      	mov	sp, r7
 801055c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010560:	4770      	bx	lr
	...

08010564 <_ZN18IMonochromeDisplayC1Ev>:
		int height;		///< @brief The height.
	};

protected:
	// It is just an interface, so constructor and destructor should be not public.
	explicit IMonochromeDisplay() {}
 8010564:	b480      	push	{r7}
 8010566:	b083      	sub	sp, #12
 8010568:	af00      	add	r7, sp, #0
 801056a:	6078      	str	r0, [r7, #4]
 801056c:	4a04      	ldr	r2, [pc, #16]	; (8010580 <_ZN18IMonochromeDisplayC1Ev+0x1c>)
 801056e:	687b      	ldr	r3, [r7, #4]
 8010570:	601a      	str	r2, [r3, #0]
 8010572:	687b      	ldr	r3, [r7, #4]
 8010574:	4618      	mov	r0, r3
 8010576:	370c      	adds	r7, #12
 8010578:	46bd      	mov	sp, r7
 801057a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801057e:	4770      	bx	lr
 8010580:	0801d9c8 	.word	0x0801d9c8

08010584 <_ZN18IMonochromeDisplayD1Ev>:
	virtual ~IMonochromeDisplay() {}
 8010584:	b480      	push	{r7}
 8010586:	b083      	sub	sp, #12
 8010588:	af00      	add	r7, sp, #0
 801058a:	6078      	str	r0, [r7, #4]
 801058c:	4a04      	ldr	r2, [pc, #16]	; (80105a0 <_ZN18IMonochromeDisplayD1Ev+0x1c>)
 801058e:	687b      	ldr	r3, [r7, #4]
 8010590:	601a      	str	r2, [r3, #0]
 8010592:	687b      	ldr	r3, [r7, #4]
 8010594:	4618      	mov	r0, r3
 8010596:	370c      	adds	r7, #12
 8010598:	46bd      	mov	sp, r7
 801059a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801059e:	4770      	bx	lr
 80105a0:	0801d9c8 	.word	0x0801d9c8

080105a4 <_ZN18IMonochromeDisplayD0Ev>:
 80105a4:	b580      	push	{r7, lr}
 80105a6:	b082      	sub	sp, #8
 80105a8:	af00      	add	r7, sp, #0
 80105aa:	6078      	str	r0, [r7, #4]
 80105ac:	6878      	ldr	r0, [r7, #4]
 80105ae:	f7ff ffe9 	bl	8010584 <_ZN18IMonochromeDisplayD1Ev>
 80105b2:	2104      	movs	r1, #4
 80105b4:	6878      	ldr	r0, [r7, #4]
 80105b6:	f005 fdf9 	bl	80161ac <_ZdlPvj>
 80105ba:	687b      	ldr	r3, [r7, #4]
 80105bc:	4618      	mov	r0, r3
 80105be:	3708      	adds	r7, #8
 80105c0:	46bd      	mov	sp, r7
 80105c2:	bd80      	pop	{r7, pc}

080105c4 <_ZN18IMonochromeDisplay5clearENS_10PixelColorE>:
	 *
	 * This method is OPTIONAL.
	 *
	 * @param background Pixel color to use for background color.
	 */
	virtual void clear( PixelColor background = White ) { (void)(background); }
 80105c4:	b480      	push	{r7}
 80105c6:	b083      	sub	sp, #12
 80105c8:	af00      	add	r7, sp, #0
 80105ca:	6078      	str	r0, [r7, #4]
 80105cc:	460b      	mov	r3, r1
 80105ce:	70fb      	strb	r3, [r7, #3]
 80105d0:	bf00      	nop
 80105d2:	370c      	adds	r7, #12
 80105d4:	46bd      	mov	sp, r7
 80105d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105da:	4770      	bx	lr

080105dc <_ZN18IMonochromeDisplay18writeDisplayMemoryEjPKhj>:
	 *
	 * @param startAddress The start address inside the display memory.
	 * @param sourceBitmap Pointer to the data to be copied into the display buffer.
	 * @param numberOfBits The total number of bits to copy to the display.
	 */
	virtual void writeDisplayMemory( size_t startAddress , const uint8_t * const sourceBitmap ,
 80105dc:	b480      	push	{r7}
 80105de:	b085      	sub	sp, #20
 80105e0:	af00      	add	r7, sp, #0
 80105e2:	60f8      	str	r0, [r7, #12]
 80105e4:	60b9      	str	r1, [r7, #8]
 80105e6:	607a      	str	r2, [r7, #4]
 80105e8:	603b      	str	r3, [r7, #0]
									 size_t numberOfBits )
	{ (void)(startAddress); (void)(sourceBitmap); (void)(numberOfBits); }
 80105ea:	bf00      	nop
 80105ec:	3714      	adds	r7, #20
 80105ee:	46bd      	mov	sp, r7
 80105f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105f4:	4770      	bx	lr

080105f6 <_ZN18IMonochromeDisplay17readDisplayMemoryEjPhj>:
	 *
	 * @param startAddress 		The start address inside the display memory.
	 * @param destinationBitmap Pointer to the data to be copied into the display buffer.
	 * @param numberOfBits 		The total number of bits to copy to the display.
	 */
	virtual void readDisplayMemory( size_t startAddress , uint8_t * const destinationBitmap , size_t numberOfBits )
 80105f6:	b480      	push	{r7}
 80105f8:	b085      	sub	sp, #20
 80105fa:	af00      	add	r7, sp, #0
 80105fc:	60f8      	str	r0, [r7, #12]
 80105fe:	60b9      	str	r1, [r7, #8]
 8010600:	607a      	str	r2, [r7, #4]
 8010602:	603b      	str	r3, [r7, #0]
	{ (void)(startAddress); (void)(destinationBitmap); (void)(numberOfBits);}
 8010604:	bf00      	nop
 8010606:	3714      	adds	r7, #20
 8010608:	46bd      	mov	sp, r7
 801060a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801060e:	4770      	bx	lr

08010610 <_ZN18IMonochromeDisplay8drawLineERKNS_5PointES2_NS_10PixelColorE>:
	 *
	 * @param begin Start point of the line.
	 * @param end End point of the line.
	 * @param color The color the line should have.
	 */
	virtual void drawLine( const Point & begin , const Point & end , PixelColor color )
 8010610:	b480      	push	{r7}
 8010612:	b085      	sub	sp, #20
 8010614:	af00      	add	r7, sp, #0
 8010616:	60f8      	str	r0, [r7, #12]
 8010618:	60b9      	str	r1, [r7, #8]
 801061a:	607a      	str	r2, [r7, #4]
 801061c:	70fb      	strb	r3, [r7, #3]
	{ (void)(begin); (void)(end); (void)(color); }
 801061e:	bf00      	nop
 8010620:	3714      	adds	r7, #20
 8010622:	46bd      	mov	sp, r7
 8010624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010628:	4770      	bx	lr

0801062a <_ZN18IMonochromeDisplay13drawRectangleERKNS_5PointERKNS_4SizeENS_10PixelColorE>:
	 *
	 * @param topLeft 	Start point of the rectangle.
	 * @param size 		The dimensions of the rectangle.
	 * @param color 	The color the rectangle stroke should have.
	 */
	virtual void drawRectangle( const Point & topLeft , const Size & size , PixelColor color )
 801062a:	b480      	push	{r7}
 801062c:	b085      	sub	sp, #20
 801062e:	af00      	add	r7, sp, #0
 8010630:	60f8      	str	r0, [r7, #12]
 8010632:	60b9      	str	r1, [r7, #8]
 8010634:	607a      	str	r2, [r7, #4]
 8010636:	70fb      	strb	r3, [r7, #3]
	{ (void)(topLeft); (void)(size); (void)(color); }
 8010638:	bf00      	nop
 801063a:	3714      	adds	r7, #20
 801063c:	46bd      	mov	sp, r7
 801063e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010642:	4770      	bx	lr

08010644 <_ZN18IMonochromeDisplay13fillRectangleERKNS_5PointERKNS_4SizeENS_10PixelColorE>:
	 *
	 * @param topLeft 	Start point of the rectangle.
	 * @param size 		The dimensions of the rectangle.
	 * @param color 	The color the rectangle fill should have.
	 */
	virtual void fillRectangle( const Point & topLeft , const Size & size , PixelColor color )
 8010644:	b480      	push	{r7}
 8010646:	b085      	sub	sp, #20
 8010648:	af00      	add	r7, sp, #0
 801064a:	60f8      	str	r0, [r7, #12]
 801064c:	60b9      	str	r1, [r7, #8]
 801064e:	607a      	str	r2, [r7, #4]
 8010650:	70fb      	strb	r3, [r7, #3]
	{ (void)(topLeft); (void)(size); (void)(color); }
 8010652:	bf00      	nop
 8010654:	3714      	adds	r7, #20
 8010656:	46bd      	mov	sp, r7
 8010658:	f85d 7b04 	ldr.w	r7, [sp], #4
 801065c:	4770      	bx	lr

0801065e <_ZN18IMonochromeDisplay11drawEllipseERKNS_5PointERKNS_4SizeENS_10PixelColorE>:
	 *
	 * @param topLeft 	Start point of the ellipse.
	 * @param size 		The dimensions of the ellipse.
	 * @param color 	The color the ellipse stroke should have.
	 */
	virtual void drawEllipse( const Point & topLeft , const Size & size , PixelColor color )
 801065e:	b480      	push	{r7}
 8010660:	b085      	sub	sp, #20
 8010662:	af00      	add	r7, sp, #0
 8010664:	60f8      	str	r0, [r7, #12]
 8010666:	60b9      	str	r1, [r7, #8]
 8010668:	607a      	str	r2, [r7, #4]
 801066a:	70fb      	strb	r3, [r7, #3]
	{ (void)(topLeft); (void)(size); (void)(color); }
 801066c:	bf00      	nop
 801066e:	3714      	adds	r7, #20
 8010670:	46bd      	mov	sp, r7
 8010672:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010676:	4770      	bx	lr

08010678 <_ZN18IMonochromeDisplay11fillEllipseERKNS_5PointERKNS_4SizeENS_10PixelColorE>:
	 *
	 * @param topLeft 	Start point of the ellipse.
	 * @param size 		The dimensions of the ellipse.
	 * @param color 	The color the ellipse fill should have.
	 */
	virtual void fillEllipse( const Point & topLeft , const Size & size , PixelColor color )
 8010678:	b480      	push	{r7}
 801067a:	b085      	sub	sp, #20
 801067c:	af00      	add	r7, sp, #0
 801067e:	60f8      	str	r0, [r7, #12]
 8010680:	60b9      	str	r1, [r7, #8]
 8010682:	607a      	str	r2, [r7, #4]
 8010684:	70fb      	strb	r3, [r7, #3]
	{ (void)(topLeft); (void)(size); (void)(color); }
 8010686:	bf00      	nop
 8010688:	3714      	adds	r7, #20
 801068a:	46bd      	mov	sp, r7
 801068c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010690:	4770      	bx	lr

08010692 <_ZN18IMonochromeDisplay8drawTextERKNS_5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_10PixelColorE>:
	 *
	 * @param topLeft 	Start point of the text to display.
	 * @param text 		The text to render to the display.
	 * @param color 	The color the ellipse fill should have.
	 */
	virtual void drawText( const Point & topLeft , const std::string & text , PixelColor color )
 8010692:	b480      	push	{r7}
 8010694:	b085      	sub	sp, #20
 8010696:	af00      	add	r7, sp, #0
 8010698:	60f8      	str	r0, [r7, #12]
 801069a:	60b9      	str	r1, [r7, #8]
 801069c:	607a      	str	r2, [r7, #4]
 801069e:	70fb      	strb	r3, [r7, #3]
	{ (void)(topLeft); (void)(text); (void)(color); }
 80106a0:	bf00      	nop
 80106a2:	3714      	adds	r7, #20
 80106a4:	46bd      	mov	sp, r7
 80106a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80106aa:	4770      	bx	lr

080106ac <_ZN2ep12DisplayFirstC1Ev>:
    DisplayFirst() = default;
 80106ac:	b580      	push	{r7, lr}
 80106ae:	b082      	sub	sp, #8
 80106b0:	af00      	add	r7, sp, #0
 80106b2:	6078      	str	r0, [r7, #4]
 80106b4:	687b      	ldr	r3, [r7, #4]
 80106b6:	4618      	mov	r0, r3
 80106b8:	f7ff f852 	bl	800f760 <_ZN2ep7DisplayC1Ev>
 80106bc:	4a03      	ldr	r2, [pc, #12]	; (80106cc <_ZN2ep12DisplayFirstC1Ev+0x20>)
 80106be:	687b      	ldr	r3, [r7, #4]
 80106c0:	601a      	str	r2, [r3, #0]
 80106c2:	687b      	ldr	r3, [r7, #4]
 80106c4:	4618      	mov	r0, r3
 80106c6:	3708      	adds	r7, #8
 80106c8:	46bd      	mov	sp, r7
 80106ca:	bd80      	pop	{r7, pc}
 80106cc:	0801bea0 	.word	0x0801bea0

080106d0 <_ZN17MonochromeDisplayC1Ev>:
#include "eplib/display_ssd1681.h"
#include "monochromedisplay.h"

extern "C" SPI_HandleTypeDef hspi2;         // Defined in main.c

MonochromeDisplay::MonochromeDisplay() :
 80106d0:	b590      	push	{r4, r7, lr}
 80106d2:	b083      	sub	sp, #12
 80106d4:	af00      	add	r7, sp, #0
 80106d6:	6078      	str	r0, [r7, #4]
 pinDC(DISP_DATA_GPIO_Port, DISP_DATA_Pin),
 pinBusy(DISP_BUSY_GPIO_Port, DISP_BUSY_Pin),
 pinReset(DISP_RESET_GPIO_Port, DISP_RESET_Pin),
 display(nullptr)
 80106d8:	687b      	ldr	r3, [r7, #4]
 80106da:	4618      	mov	r0, r3
 80106dc:	f7ff ff42 	bl	8010564 <_ZN18IMonochromeDisplayC1Ev>
 80106e0:	4a22      	ldr	r2, [pc, #136]	; (801076c <_ZN17MonochromeDisplayC1Ev+0x9c>)
 80106e2:	687b      	ldr	r3, [r7, #4]
 80106e4:	601a      	str	r2, [r3, #0]
 80106e6:	687b      	ldr	r3, [r7, #4]
 80106e8:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 80106ec:	330c      	adds	r3, #12
 80106ee:	f44f 7200 	mov.w	r2, #512	; 0x200
 80106f2:	f04f 4190 	mov.w	r1, #1207959552	; 0x48000000
 80106f6:	4618      	mov	r0, r3
 80106f8:	f7ff feed 	bl	80104d6 <_ZN2ep3GpoC1EP12GPIO_TypeDefm>
 80106fc:	687b      	ldr	r3, [r7, #4]
 80106fe:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 8010702:	3314      	adds	r3, #20
 8010704:	2240      	movs	r2, #64	; 0x40
 8010706:	491a      	ldr	r1, [pc, #104]	; (8010770 <_ZN17MonochromeDisplayC1Ev+0xa0>)
 8010708:	4618      	mov	r0, r3
 801070a:	f7ff feac 	bl	8010466 <_ZN2ep3GpiC1EP12GPIO_TypeDefm>
 801070e:	687b      	ldr	r3, [r7, #4]
 8010710:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 8010714:	331c      	adds	r3, #28
 8010716:	2280      	movs	r2, #128	; 0x80
 8010718:	4916      	ldr	r1, [pc, #88]	; (8010774 <_ZN17MonochromeDisplayC1Ev+0xa4>)
 801071a:	4618      	mov	r0, r3
 801071c:	f7ff fedb 	bl	80104d6 <_ZN2ep3GpoC1EP12GPIO_TypeDefm>
 8010720:	687b      	ldr	r3, [r7, #4]
 8010722:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010726:	461a      	mov	r2, r3
 8010728:	2300      	movs	r3, #0
 801072a:	f8c2 33a4 	str.w	r3, [r2, #932]	; 0x3a4
 801072e:	687b      	ldr	r3, [r7, #4]
 8010730:	f503 539d 	add.w	r3, r3, #5024	; 0x13a0
 8010734:	3308      	adds	r3, #8
 8010736:	4618      	mov	r0, r3
 8010738:	f7ff fa72 	bl	800fc20 <_ZN2ep5PaintC1Ev>
{
    rotation = EP_DISPLAY_ROTATE_0;
 801073c:	687b      	ldr	r3, [r7, #4]
 801073e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010742:	2200      	movs	r2, #0
 8010744:	f8a3 23c8 	strh.w	r2, [r3, #968]	; 0x3c8

#ifdef DISPLAY_DRIVER_SSD1608
    display = new ep::DisplayFirst;
 8010748:	2014      	movs	r0, #20
 801074a:	f005 fd42 	bl	80161d2 <_Znwj>
 801074e:	4603      	mov	r3, r0
 8010750:	461c      	mov	r4, r3
 8010752:	4620      	mov	r0, r4
 8010754:	f7ff ffaa 	bl	80106ac <_ZN2ep12DisplayFirstC1Ev>
 8010758:	687b      	ldr	r3, [r7, #4]
 801075a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801075e:	f8c3 43a4 	str.w	r4, [r3, #932]	; 0x3a4
#elif DISPLAY_DRIVER_SSD1681
    display = new ep::DisplaySecond;
#else
    #error "Please specify a display driver in the project settings!"
#endif
}
 8010762:	687b      	ldr	r3, [r7, #4]
 8010764:	4618      	mov	r0, r3
 8010766:	370c      	adds	r7, #12
 8010768:	46bd      	mov	sp, r7
 801076a:	bd90      	pop	{r4, r7, pc}
 801076c:	0801d978 	.word	0x0801d978
 8010770:	48000400 	.word	0x48000400
 8010774:	48000800 	.word	0x48000800

08010778 <_ZN17MonochromeDisplayD1Ev>:

MonochromeDisplay::~MonochromeDisplay()
 8010778:	b580      	push	{r7, lr}
 801077a:	b082      	sub	sp, #8
 801077c:	af00      	add	r7, sp, #0
 801077e:	6078      	str	r0, [r7, #4]
 8010780:	4a0b      	ldr	r2, [pc, #44]	; (80107b0 <_ZN17MonochromeDisplayD1Ev+0x38>)
 8010782:	687b      	ldr	r3, [r7, #4]
 8010784:	601a      	str	r2, [r3, #0]
{
    delete display;
 8010786:	687b      	ldr	r3, [r7, #4]
 8010788:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801078c:	f8d3 33a4 	ldr.w	r3, [r3, #932]	; 0x3a4
 8010790:	2b00      	cmp	r3, #0
 8010792:	d004      	beq.n	801079e <_ZN17MonochromeDisplayD1Ev+0x26>
 8010794:	681a      	ldr	r2, [r3, #0]
 8010796:	3204      	adds	r2, #4
 8010798:	6812      	ldr	r2, [r2, #0]
 801079a:	4618      	mov	r0, r3
 801079c:	4790      	blx	r2
MonochromeDisplay::~MonochromeDisplay()
 801079e:	687b      	ldr	r3, [r7, #4]
 80107a0:	4618      	mov	r0, r3
 80107a2:	f7ff feef 	bl	8010584 <_ZN18IMonochromeDisplayD1Ev>
}
 80107a6:	687b      	ldr	r3, [r7, #4]
 80107a8:	4618      	mov	r0, r3
 80107aa:	3708      	adds	r7, #8
 80107ac:	46bd      	mov	sp, r7
 80107ae:	bd80      	pop	{r7, pc}
 80107b0:	0801d978 	.word	0x0801d978

080107b4 <_ZN17MonochromeDisplayD0Ev>:
MonochromeDisplay::~MonochromeDisplay()
 80107b4:	b580      	push	{r7, lr}
 80107b6:	b082      	sub	sp, #8
 80107b8:	af00      	add	r7, sp, #0
 80107ba:	6078      	str	r0, [r7, #4]
}
 80107bc:	6878      	ldr	r0, [r7, #4]
 80107be:	f7ff ffdb 	bl	8010778 <_ZN17MonochromeDisplayD1Ev>
 80107c2:	f241 31cc 	movw	r1, #5068	; 0x13cc
 80107c6:	6878      	ldr	r0, [r7, #4]
 80107c8:	f005 fcf0 	bl	80161ac <_ZdlPvj>
 80107cc:	687b      	ldr	r3, [r7, #4]
 80107ce:	4618      	mov	r0, r3
 80107d0:	3708      	adds	r7, #8
 80107d2:	46bd      	mov	sp, r7
 80107d4:	bd80      	pop	{r7, pc}

080107d6 <_ZNK17MonochromeDisplay10resolutionEv>:

IMonochromeDisplay::Size MonochromeDisplay::resolution() const
{
 80107d6:	b580      	push	{r7, lr}
 80107d8:	b082      	sub	sp, #8
 80107da:	af00      	add	r7, sp, #0
 80107dc:	6078      	str	r0, [r7, #4]
 80107de:	6039      	str	r1, [r7, #0]
	return Size(Width, Height);
 80107e0:	22c8      	movs	r2, #200	; 0xc8
 80107e2:	21c8      	movs	r1, #200	; 0xc8
 80107e4:	6878      	ldr	r0, [r7, #4]
 80107e6:	f7ff fea9 	bl	801053c <_ZN18IMonochromeDisplay4SizeC1Eii>
}
 80107ea:	6878      	ldr	r0, [r7, #4]
 80107ec:	3708      	adds	r7, #8
 80107ee:	46bd      	mov	sp, r7
 80107f0:	bd80      	pop	{r7, pc}

080107f2 <_ZNK17MonochromeDisplay25acceleratedDrawingMethodsEv>:

IMonochromeDisplay::AcceleratedDrawingMethods MonochromeDisplay::acceleratedDrawingMethods() const
{
 80107f2:	b580      	push	{r7, lr}
 80107f4:	b084      	sub	sp, #16
 80107f6:	af00      	add	r7, sp, #0
 80107f8:	6078      	str	r0, [r7, #4]
	AcceleratedDrawingMethods accels;

	memset(&accels, 0, sizeof(AcceleratedDrawingMethods));
 80107fa:	f107 030c 	add.w	r3, r7, #12
 80107fe:	2204      	movs	r2, #4
 8010800:	2100      	movs	r1, #0
 8010802:	4618      	mov	r0, r3
 8010804:	f005 fe5e 	bl	80164c4 <memset>

	accels.clearAccelerated = 1;
 8010808:	7b3b      	ldrb	r3, [r7, #12]
 801080a:	f043 0301 	orr.w	r3, r3, #1
 801080e:	733b      	strb	r3, [r7, #12]
	accels.drawLineAccelerated = 1;
 8010810:	7b3b      	ldrb	r3, [r7, #12]
 8010812:	f043 0304 	orr.w	r3, r3, #4
 8010816:	733b      	strb	r3, [r7, #12]
	accels.drawTextAccelerated = 1;
 8010818:	7b3b      	ldrb	r3, [r7, #12]
 801081a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801081e:	733b      	strb	r3, [r7, #12]

	return accels;
 8010820:	68fb      	ldr	r3, [r7, #12]
}
 8010822:	4618      	mov	r0, r3
 8010824:	3710      	adds	r7, #16
 8010826:	46bd      	mov	sp, r7
 8010828:	bd80      	pop	{r7, pc}
	...

0801082c <_ZN17MonochromeDisplay10initializeEv>:

bool MonochromeDisplay::initialize()
{
 801082c:	b580      	push	{r7, lr}
 801082e:	b084      	sub	sp, #16
 8010830:	af02      	add	r7, sp, #8
 8010832:	6078      	str	r0, [r7, #4]
    rotation = EP_DISPLAY_ROTATE_270;   // Turn by 270° for the DeSEm Nucleo STM32L476 hardware
 8010834:	687b      	ldr	r3, [r7, #4]
 8010836:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801083a:	f44f 7287 	mov.w	r2, #270	; 0x10e
 801083e:	f8a3 23c8 	strh.w	r2, [r3, #968]	; 0x3c8

    display->initialize(&hspi2, &pinDC, &pinBusy, &pinReset);
 8010842:	687b      	ldr	r3, [r7, #4]
 8010844:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010848:	f8d3 03a4 	ldr.w	r0, [r3, #932]	; 0x3a4
 801084c:	687b      	ldr	r3, [r7, #4]
 801084e:	f503 529c 	add.w	r2, r3, #4992	; 0x1380
 8010852:	320c      	adds	r2, #12
 8010854:	687b      	ldr	r3, [r7, #4]
 8010856:	f503 519c 	add.w	r1, r3, #4992	; 0x1380
 801085a:	3114      	adds	r1, #20
 801085c:	687b      	ldr	r3, [r7, #4]
 801085e:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 8010862:	331c      	adds	r3, #28
 8010864:	9300      	str	r3, [sp, #0]
 8010866:	460b      	mov	r3, r1
 8010868:	4925      	ldr	r1, [pc, #148]	; (8010900 <_ZN17MonochromeDisplay10initializeEv+0xd4>)
 801086a:	f7fe ff9b 	bl	800f7a4 <_ZN2ep7Display10initializeEP19__SPI_HandleTypeDefPNS_3GpoEPNS_3GpiES4_>
    painter.initialize(display);
 801086e:	687b      	ldr	r3, [r7, #4]
 8010870:	f503 539d 	add.w	r3, r3, #5024	; 0x13a0
 8010874:	3308      	adds	r3, #8
 8010876:	687a      	ldr	r2, [r7, #4]
 8010878:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 801087c:	f8d2 23a4 	ldr.w	r2, [r2, #932]	; 0x3a4
 8010880:	4611      	mov	r1, r2
 8010882:	4618      	mov	r0, r3
 8010884:	f7ff f9dd 	bl	800fc42 <_ZN2ep5Paint10initializeEPNS_7DisplayE>

    painter.setRotate(rotation);
 8010888:	687b      	ldr	r3, [r7, #4]
 801088a:	f503 539d 	add.w	r3, r3, #5024	; 0x13a0
 801088e:	3308      	adds	r3, #8
 8010890:	687a      	ldr	r2, [r7, #4]
 8010892:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8010896:	f8b2 23c8 	ldrh.w	r2, [r2, #968]	; 0x3c8
 801089a:	4611      	mov	r1, r2
 801089c:	4618      	mov	r0, r3
 801089e:	f7ff fa3f 	bl	800fd20 <_ZN2ep5Paint9setRotateEt>

    painter.setBuffer(_lcdBuffer, Width, Height, rotation, EP_DISPLAY_WHITE);
 80108a2:	687b      	ldr	r3, [r7, #4]
 80108a4:	f503 509d 	add.w	r0, r3, #5024	; 0x13a0
 80108a8:	3008      	adds	r0, #8
 80108aa:	687b      	ldr	r3, [r7, #4]
 80108ac:	1d19      	adds	r1, r3, #4
 80108ae:	687b      	ldr	r3, [r7, #4]
 80108b0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80108b4:	f8b3 33c8 	ldrh.w	r3, [r3, #968]	; 0x3c8
 80108b8:	22ff      	movs	r2, #255	; 0xff
 80108ba:	9201      	str	r2, [sp, #4]
 80108bc:	9300      	str	r3, [sp, #0]
 80108be:	23c8      	movs	r3, #200	; 0xc8
 80108c0:	22c8      	movs	r2, #200	; 0xc8
 80108c2:	f7ff f9cc 	bl	800fc5e <_ZN2ep5Paint9setBufferEPhtttt>

	clear();                            // Clear ePaper display (all pixels to white)
 80108c6:	687b      	ldr	r3, [r7, #4]
 80108c8:	681b      	ldr	r3, [r3, #0]
 80108ca:	3324      	adds	r3, #36	; 0x24
 80108cc:	681b      	ldr	r3, [r3, #0]
 80108ce:	f04f 31ff 	mov.w	r1, #4294967295
 80108d2:	6878      	ldr	r0, [r7, #4]
 80108d4:	4798      	blx	r3
	display->setLUTShortRefresh();       // Change to fast refresh
 80108d6:	687b      	ldr	r3, [r7, #4]
 80108d8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80108dc:	f8d3 23a4 	ldr.w	r2, [r3, #932]	; 0x3a4
 80108e0:	687b      	ldr	r3, [r7, #4]
 80108e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80108e6:	f8d3 33a4 	ldr.w	r3, [r3, #932]	; 0x3a4
 80108ea:	681b      	ldr	r3, [r3, #0]
 80108ec:	3314      	adds	r3, #20
 80108ee:	681b      	ldr	r3, [r3, #0]
 80108f0:	4610      	mov	r0, r2
 80108f2:	4798      	blx	r3

	return true;
 80108f4:	2301      	movs	r3, #1
}
 80108f6:	4618      	mov	r0, r3
 80108f8:	3708      	adds	r7, #8
 80108fa:	46bd      	mov	sp, r7
 80108fc:	bd80      	pop	{r7, pc}
 80108fe:	bf00      	nop
 8010900:	200000e8 	.word	0x200000e8

08010904 <_ZN17MonochromeDisplay6enableEv>:

bool MonochromeDisplay::enable()
{
 8010904:	b480      	push	{r7}
 8010906:	b083      	sub	sp, #12
 8010908:	af00      	add	r7, sp, #0
 801090a:	6078      	str	r0, [r7, #4]
	return true;    // ePaper display always on
 801090c:	2301      	movs	r3, #1
}
 801090e:	4618      	mov	r0, r3
 8010910:	370c      	adds	r7, #12
 8010912:	46bd      	mov	sp, r7
 8010914:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010918:	4770      	bx	lr

0801091a <_ZN17MonochromeDisplay7disableEv>:

bool MonochromeDisplay::disable()
{
 801091a:	b480      	push	{r7}
 801091c:	b083      	sub	sp, #12
 801091e:	af00      	add	r7, sp, #0
 8010920:	6078      	str	r0, [r7, #4]
	return true;    // ePaper display always on
 8010922:	2301      	movs	r3, #1
}
 8010924:	4618      	mov	r0, r3
 8010926:	370c      	adds	r7, #12
 8010928:	46bd      	mov	sp, r7
 801092a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801092e:	4770      	bx	lr

08010930 <_ZN17MonochromeDisplay5pixelERKN18IMonochromeDisplay5PointE>:

IMonochromeDisplay::PixelColor MonochromeDisplay::pixel(const Point & point)
{
 8010930:	b480      	push	{r7}
 8010932:	b083      	sub	sp, #12
 8010934:	af00      	add	r7, sp, #0
 8010936:	6078      	str	r0, [r7, #4]
 8010938:	6039      	str	r1, [r7, #0]
    // TODO: Returning right pixel is not easy for the ePaper display
    //       because internally the display can be rotated and even mirrored
    // painter.pixel(point);
    return White;
 801093a:	f04f 33ff 	mov.w	r3, #4294967295
}
 801093e:	4618      	mov	r0, r3
 8010940:	370c      	adds	r7, #12
 8010942:	46bd      	mov	sp, r7
 8010944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010948:	4770      	bx	lr

0801094a <_ZN17MonochromeDisplay8setPixelERKN18IMonochromeDisplay5PointENS0_10PixelColorE>:

void MonochromeDisplay::setPixel(const Point & point , PixelColor color)
{
 801094a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801094c:	b087      	sub	sp, #28
 801094e:	af02      	add	r7, sp, #8
 8010950:	60f8      	str	r0, [r7, #12]
 8010952:	60b9      	str	r1, [r7, #8]
 8010954:	4613      	mov	r3, r2
 8010956:	71fb      	strb	r3, [r7, #7]
    painter.setPixel(point.x, point.y, toEpDisplayColor(color), false);
 8010958:	68fb      	ldr	r3, [r7, #12]
 801095a:	f503 549d 	add.w	r4, r3, #5024	; 0x13a0
 801095e:	3408      	adds	r4, #8
 8010960:	68bb      	ldr	r3, [r7, #8]
 8010962:	681b      	ldr	r3, [r3, #0]
 8010964:	b29d      	uxth	r5, r3
 8010966:	68bb      	ldr	r3, [r7, #8]
 8010968:	685b      	ldr	r3, [r3, #4]
 801096a:	b29e      	uxth	r6, r3
 801096c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8010970:	4619      	mov	r1, r3
 8010972:	68f8      	ldr	r0, [r7, #12]
 8010974:	f000 f898 	bl	8010aa8 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE>
 8010978:	4603      	mov	r3, r0
 801097a:	461a      	mov	r2, r3
 801097c:	2300      	movs	r3, #0
 801097e:	9300      	str	r3, [sp, #0]
 8010980:	4613      	mov	r3, r2
 8010982:	4632      	mov	r2, r6
 8010984:	4629      	mov	r1, r5
 8010986:	4620      	mov	r0, r4
 8010988:	f7ff f9e6 	bl	800fd58 <_ZN2ep5Paint8setPixelEtttb>
}
 801098c:	bf00      	nop
 801098e:	3714      	adds	r7, #20
 8010990:	46bd      	mov	sp, r7
 8010992:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010994 <_ZN17MonochromeDisplay5clearEN18IMonochromeDisplay10PixelColorE>:

void MonochromeDisplay::clear(PixelColor background /* = White */)
{
 8010994:	b590      	push	{r4, r7, lr}
 8010996:	b083      	sub	sp, #12
 8010998:	af00      	add	r7, sp, #0
 801099a:	6078      	str	r0, [r7, #4]
 801099c:	460b      	mov	r3, r1
 801099e:	70fb      	strb	r3, [r7, #3]
	painter.clear(toEpDisplayColor(background));
 80109a0:	687b      	ldr	r3, [r7, #4]
 80109a2:	f503 549d 	add.w	r4, r3, #5024	; 0x13a0
 80109a6:	3408      	adds	r4, #8
 80109a8:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80109ac:	4619      	mov	r1, r3
 80109ae:	6878      	ldr	r0, [r7, #4]
 80109b0:	f000 f87a 	bl	8010aa8 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE>
 80109b4:	4603      	mov	r3, r0
 80109b6:	b2db      	uxtb	r3, r3
 80109b8:	2201      	movs	r2, #1
 80109ba:	4619      	mov	r1, r3
 80109bc:	4620      	mov	r0, r4
 80109be:	f7ff faad 	bl	800ff1c <_ZN2ep5Paint5clearEhb>
}
 80109c2:	bf00      	nop
 80109c4:	370c      	adds	r7, #12
 80109c6:	46bd      	mov	sp, r7
 80109c8:	bd90      	pop	{r4, r7, pc}

080109ca <_ZN17MonochromeDisplay8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>:

void MonochromeDisplay::drawLine(const Point & begin, const Point & end, PixelColor color)
{
 80109ca:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80109ce:	b08b      	sub	sp, #44	; 0x2c
 80109d0:	af06      	add	r7, sp, #24
 80109d2:	60f8      	str	r0, [r7, #12]
 80109d4:	60b9      	str	r1, [r7, #8]
 80109d6:	607a      	str	r2, [r7, #4]
 80109d8:	70fb      	strb	r3, [r7, #3]
    painter.drawLine(begin.x, begin.y, end.x, end.y, toEpDisplayColor(color), LINE_STYLE_SOLID, DOT_PIXEL_2X2, false);
 80109da:	68fb      	ldr	r3, [r7, #12]
 80109dc:	f503 549d 	add.w	r4, r3, #5024	; 0x13a0
 80109e0:	3408      	adds	r4, #8
 80109e2:	68bb      	ldr	r3, [r7, #8]
 80109e4:	681b      	ldr	r3, [r3, #0]
 80109e6:	b29e      	uxth	r6, r3
 80109e8:	68bb      	ldr	r3, [r7, #8]
 80109ea:	685b      	ldr	r3, [r3, #4]
 80109ec:	fa1f f883 	uxth.w	r8, r3
 80109f0:	687b      	ldr	r3, [r7, #4]
 80109f2:	681b      	ldr	r3, [r3, #0]
 80109f4:	fa1f f983 	uxth.w	r9, r3
 80109f8:	687b      	ldr	r3, [r7, #4]
 80109fa:	685b      	ldr	r3, [r3, #4]
 80109fc:	b29d      	uxth	r5, r3
 80109fe:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8010a02:	4619      	mov	r1, r3
 8010a04:	68f8      	ldr	r0, [r7, #12]
 8010a06:	f000 f84f 	bl	8010aa8 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE>
 8010a0a:	4603      	mov	r3, r0
 8010a0c:	461a      	mov	r2, r3
 8010a0e:	2300      	movs	r3, #0
 8010a10:	9304      	str	r3, [sp, #16]
 8010a12:	2302      	movs	r3, #2
 8010a14:	9303      	str	r3, [sp, #12]
 8010a16:	2300      	movs	r3, #0
 8010a18:	9302      	str	r3, [sp, #8]
 8010a1a:	9201      	str	r2, [sp, #4]
 8010a1c:	9500      	str	r5, [sp, #0]
 8010a1e:	464b      	mov	r3, r9
 8010a20:	4642      	mov	r2, r8
 8010a22:	4631      	mov	r1, r6
 8010a24:	4620      	mov	r0, r4
 8010a26:	f7ff fb4f 	bl	80100c8 <_ZN2ep5Paint8drawLineEttttt10LINE_STYLE9DOT_PIXELb>
    painter.update();
 8010a2a:	68fb      	ldr	r3, [r7, #12]
 8010a2c:	f503 539d 	add.w	r3, r3, #5024	; 0x13a0
 8010a30:	3308      	adds	r3, #8
 8010a32:	4618      	mov	r0, r3
 8010a34:	f7ff fa8c 	bl	800ff50 <_ZN2ep5Paint6updateEv>
}
 8010a38:	bf00      	nop
 8010a3a:	3714      	adds	r7, #20
 8010a3c:	46bd      	mov	sp, r7
 8010a3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

08010a44 <_ZN17MonochromeDisplay8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE>:

void MonochromeDisplay::drawText(const Point & topLeft , const std::string & text, PixelColor color)
{
 8010a44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010a48:	b088      	sub	sp, #32
 8010a4a:	af04      	add	r7, sp, #16
 8010a4c:	60f8      	str	r0, [r7, #12]
 8010a4e:	60b9      	str	r1, [r7, #8]
 8010a50:	607a      	str	r2, [r7, #4]
 8010a52:	70fb      	strb	r3, [r7, #3]
    painter.drawString(topLeft.x, topLeft.y, text.c_str(), &Font24, EP_DISPLAY_WHITE, toEpDisplayColor(color), true);
 8010a54:	68fb      	ldr	r3, [r7, #12]
 8010a56:	f503 549d 	add.w	r4, r3, #5024	; 0x13a0
 8010a5a:	3408      	adds	r4, #8
 8010a5c:	68bb      	ldr	r3, [r7, #8]
 8010a5e:	681b      	ldr	r3, [r3, #0]
 8010a60:	b29d      	uxth	r5, r3
 8010a62:	68bb      	ldr	r3, [r7, #8]
 8010a64:	685b      	ldr	r3, [r3, #4]
 8010a66:	b29e      	uxth	r6, r3
 8010a68:	6878      	ldr	r0, [r7, #4]
 8010a6a:	f005 fc32 	bl	80162d2 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv>
 8010a6e:	4680      	mov	r8, r0
 8010a70:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8010a74:	4619      	mov	r1, r3
 8010a76:	68f8      	ldr	r0, [r7, #12]
 8010a78:	f000 f816 	bl	8010aa8 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE>
 8010a7c:	4603      	mov	r3, r0
 8010a7e:	461a      	mov	r2, r3
 8010a80:	2301      	movs	r3, #1
 8010a82:	9303      	str	r3, [sp, #12]
 8010a84:	9202      	str	r2, [sp, #8]
 8010a86:	23ff      	movs	r3, #255	; 0xff
 8010a88:	9301      	str	r3, [sp, #4]
 8010a8a:	4b06      	ldr	r3, [pc, #24]	; (8010aa4 <_ZN17MonochromeDisplay8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE+0x60>)
 8010a8c:	9300      	str	r3, [sp, #0]
 8010a8e:	4643      	mov	r3, r8
 8010a90:	4632      	mov	r2, r6
 8010a92:	4629      	mov	r1, r5
 8010a94:	4620      	mov	r0, r4
 8010a96:	f7ff fc8b 	bl	80103b0 <_ZN2ep5Paint10drawStringEttPKcP6_tFontttb>
}
 8010a9a:	bf00      	nop
 8010a9c:	3710      	adds	r7, #16
 8010a9e:	46bd      	mov	sp, r7
 8010aa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010aa4:	2000000c 	.word	0x2000000c

08010aa8 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE>:
{
	painter.update();
}

uint16_t MonochromeDisplay::toEpDisplayColor(PixelColor pixelColor)
{
 8010aa8:	b480      	push	{r7}
 8010aaa:	b083      	sub	sp, #12
 8010aac:	af00      	add	r7, sp, #0
 8010aae:	6078      	str	r0, [r7, #4]
 8010ab0:	460b      	mov	r3, r1
 8010ab2:	70fb      	strb	r3, [r7, #3]
    return (pixelColor == IMonochromeDisplay::White) ? EP_DISPLAY_WHITE : EP_DISPLAY_BLACK;
 8010ab4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8010ab8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010abc:	d101      	bne.n	8010ac2 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE+0x1a>
 8010abe:	23ff      	movs	r3, #255	; 0xff
 8010ac0:	e000      	b.n	8010ac4 <_ZN17MonochromeDisplay16toEpDisplayColorEN18IMonochromeDisplay10PixelColorE+0x1c>
 8010ac2:	2300      	movs	r3, #0
}
 8010ac4:	4618      	mov	r0, r3
 8010ac6:	370c      	adds	r7, #12
 8010ac8:	46bd      	mov	sp, r7
 8010aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ace:	4770      	bx	lr

08010ad0 <_Z41__static_initialization_and_destruction_0ii>:
 8010ad0:	b580      	push	{r7, lr}
 8010ad2:	b088      	sub	sp, #32
 8010ad4:	af00      	add	r7, sp, #0
 8010ad6:	6078      	str	r0, [r7, #4]
 8010ad8:	6039      	str	r1, [r7, #0]
 8010ada:	687b      	ldr	r3, [r7, #4]
 8010adc:	2b01      	cmp	r3, #1
 8010ade:	d122      	bne.n	8010b26 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8010ae0:	683b      	ldr	r3, [r7, #0]
 8010ae2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010ae6:	4293      	cmp	r3, r2
 8010ae8:	d11d      	bne.n	8010b26 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8010aea:	4b18      	ldr	r3, [pc, #96]	; (8010b4c <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8010aec:	681b      	ldr	r3, [r3, #0]
 8010aee:	613b      	str	r3, [r7, #16]
 8010af0:	f107 0310 	add.w	r3, r7, #16
 8010af4:	60bb      	str	r3, [r7, #8]
 8010af6:	2304      	movs	r3, #4
 8010af8:	60fb      	str	r3, [r7, #12]
 8010afa:	f107 0308 	add.w	r3, r7, #8
 8010afe:	e893 0006 	ldmia.w	r3, {r1, r2}
 8010b02:	4813      	ldr	r0, [pc, #76]	; (8010b50 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8010b04:	f7f6 f916 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8010b08:	4b12      	ldr	r3, [pc, #72]	; (8010b54 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8010b0a:	681b      	ldr	r3, [r3, #0]
 8010b0c:	61fb      	str	r3, [r7, #28]
 8010b0e:	f107 031c 	add.w	r3, r7, #28
 8010b12:	617b      	str	r3, [r7, #20]
 8010b14:	2304      	movs	r3, #4
 8010b16:	61bb      	str	r3, [r7, #24]
 8010b18:	f107 0314 	add.w	r3, r7, #20
 8010b1c:	e893 0006 	ldmia.w	r3, {r1, r2}
 8010b20:	480d      	ldr	r0, [pc, #52]	; (8010b58 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8010b22:	f7f6 f907 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8010b26:	687b      	ldr	r3, [r7, #4]
 8010b28:	2b00      	cmp	r3, #0
 8010b2a:	d10a      	bne.n	8010b42 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8010b2c:	683b      	ldr	r3, [r7, #0]
 8010b2e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010b32:	4293      	cmp	r3, r2
 8010b34:	d105      	bne.n	8010b42 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8010b36:	4808      	ldr	r0, [pc, #32]	; (8010b58 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8010b38:	f7f6 fa46 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8010b3c:	4804      	ldr	r0, [pc, #16]	; (8010b50 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8010b3e:	f7f6 fa43 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8010b42:	bf00      	nop
 8010b44:	3720      	adds	r7, #32
 8010b46:	46bd      	mov	sp, r7
 8010b48:	bd80      	pop	{r7, pc}
 8010b4a:	bf00      	nop
 8010b4c:	08019cb4 	.word	0x08019cb4
 8010b50:	20001bd4 	.word	0x20001bd4
 8010b54:	08019cb8 	.word	0x08019cb8
 8010b58:	20001bdc 	.word	0x20001bdc

08010b5c <_GLOBAL__sub_I__ZN17MonochromeDisplayC2Ev>:
 8010b5c:	b580      	push	{r7, lr}
 8010b5e:	af00      	add	r7, sp, #0
 8010b60:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8010b64:	2001      	movs	r0, #1
 8010b66:	f7ff ffb3 	bl	8010ad0 <_Z41__static_initialization_and_destruction_0ii>
 8010b6a:	bd80      	pop	{r7, pc}

08010b6c <_GLOBAL__sub_D__ZN17MonochromeDisplayC2Ev>:
 8010b6c:	b580      	push	{r7, lr}
 8010b6e:	af00      	add	r7, sp, #0
 8010b70:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8010b74:	2000      	movs	r0, #0
 8010b76:	f7ff ffab 	bl	8010ad0 <_Z41__static_initialization_and_destruction_0ii>
 8010b7a:	bd80      	pop	{r7, pc}

08010b7c <_ZN13SimpleDisplayC1Ev>:
#include "gui/MonochromeDisplayPainter"
#include "simpledisplay.h"

SimpleDisplay::SimpleDisplay()
 8010b7c:	b580      	push	{r7, lr}
 8010b7e:	b082      	sub	sp, #8
 8010b80:	af00      	add	r7, sp, #0
 8010b82:	6078      	str	r0, [r7, #4]
 8010b84:	687b      	ldr	r3, [r7, #4]
 8010b86:	4618      	mov	r0, r3
 8010b88:	f7ff fda2 	bl	80106d0 <_ZN17MonochromeDisplayC1Ev>
 8010b8c:	4a03      	ldr	r2, [pc, #12]	; (8010b9c <_ZN13SimpleDisplayC1Ev+0x20>)
 8010b8e:	687b      	ldr	r3, [r7, #4]
 8010b90:	601a      	str	r2, [r3, #0]
{
}
 8010b92:	687b      	ldr	r3, [r7, #4]
 8010b94:	4618      	mov	r0, r3
 8010b96:	3708      	adds	r7, #8
 8010b98:	46bd      	mov	sp, r7
 8010b9a:	bd80      	pop	{r7, pc}
 8010b9c:	0801da18 	.word	0x0801da18

08010ba0 <_ZN13SimpleDisplayD1Ev>:

SimpleDisplay::~SimpleDisplay()
 8010ba0:	b580      	push	{r7, lr}
 8010ba2:	b082      	sub	sp, #8
 8010ba4:	af00      	add	r7, sp, #0
 8010ba6:	6078      	str	r0, [r7, #4]
 8010ba8:	4a05      	ldr	r2, [pc, #20]	; (8010bc0 <_ZN13SimpleDisplayD1Ev+0x20>)
 8010baa:	687b      	ldr	r3, [r7, #4]
 8010bac:	601a      	str	r2, [r3, #0]
 8010bae:	687b      	ldr	r3, [r7, #4]
 8010bb0:	4618      	mov	r0, r3
 8010bb2:	f7ff fde1 	bl	8010778 <_ZN17MonochromeDisplayD1Ev>
{
}
 8010bb6:	687b      	ldr	r3, [r7, #4]
 8010bb8:	4618      	mov	r0, r3
 8010bba:	3708      	adds	r7, #8
 8010bbc:	46bd      	mov	sp, r7
 8010bbe:	bd80      	pop	{r7, pc}
 8010bc0:	0801da18 	.word	0x0801da18

08010bc4 <_ZN13SimpleDisplayD0Ev>:
SimpleDisplay::~SimpleDisplay()
 8010bc4:	b580      	push	{r7, lr}
 8010bc6:	b082      	sub	sp, #8
 8010bc8:	af00      	add	r7, sp, #0
 8010bca:	6078      	str	r0, [r7, #4]
}
 8010bcc:	6878      	ldr	r0, [r7, #4]
 8010bce:	f7ff ffe7 	bl	8010ba0 <_ZN13SimpleDisplayD1Ev>
 8010bd2:	f241 31cc 	movw	r1, #5068	; 0x13cc
 8010bd6:	6878      	ldr	r0, [r7, #4]
 8010bd8:	f005 fae8 	bl	80161ac <_ZdlPvj>
 8010bdc:	687b      	ldr	r3, [r7, #4]
 8010bde:	4618      	mov	r0, r3
 8010be0:	3708      	adds	r7, #8
 8010be2:	46bd      	mov	sp, r7
 8010be4:	bd80      	pop	{r7, pc}

08010be6 <_ZN13SimpleDisplay10initializeEv>:

bool SimpleDisplay::initialize()
{
 8010be6:	b580      	push	{r7, lr}
 8010be8:	b082      	sub	sp, #8
 8010bea:	af00      	add	r7, sp, #0
 8010bec:	6078      	str	r0, [r7, #4]
	return BaseClass::initialize();
 8010bee:	687b      	ldr	r3, [r7, #4]
 8010bf0:	4618      	mov	r0, r3
 8010bf2:	f7ff fe1b 	bl	801082c <_ZN17MonochromeDisplay10initializeEv>
 8010bf6:	4603      	mov	r3, r0
}
 8010bf8:	4618      	mov	r0, r3
 8010bfa:	3708      	adds	r7, #8
 8010bfc:	46bd      	mov	sp, r7
 8010bfe:	bd80      	pop	{r7, pc}

08010c00 <_ZN13SimpleDisplay5clearEv>:

void SimpleDisplay::clear()
{
 8010c00:	b580      	push	{r7, lr}
 8010c02:	b088      	sub	sp, #32
 8010c04:	af00      	add	r7, sp, #0
 8010c06:	6078      	str	r0, [r7, #4]
	MonochromeDisplayPainter painter(this, false);
 8010c08:	6879      	ldr	r1, [r7, #4]
 8010c0a:	f107 030c 	add.w	r3, r7, #12
 8010c0e:	2200      	movs	r2, #0
 8010c10:	4618      	mov	r0, r3
 8010c12:	f7fc ff87 	bl	800db24 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb>
	painter.clear();
 8010c16:	f107 030c 	add.w	r3, r7, #12
 8010c1a:	f04f 31ff 	mov.w	r1, #4294967295
 8010c1e:	4618      	mov	r0, r3
 8010c20:	f7fd f80e 	bl	800dc40 <_ZN24MonochromeDisplayPainter5clearEN18IMonochromeDisplay10PixelColorE>
	painter.end();
 8010c24:	f107 030c 	add.w	r3, r7, #12
 8010c28:	4618      	mov	r0, r3
 8010c2a:	f7fc ffdf 	bl	800dbec <_ZN24MonochromeDisplayPainter3endEv>
	MonochromeDisplayPainter painter(this, false);
 8010c2e:	f107 030c 	add.w	r3, r7, #12
 8010c32:	4618      	mov	r0, r3
 8010c34:	f7fc ff9e 	bl	800db74 <_ZN24MonochromeDisplayPainterD1Ev>
}
 8010c38:	bf00      	nop
 8010c3a:	3720      	adds	r7, #32
 8010c3c:	46bd      	mov	sp, r7
 8010c3e:	bd80      	pop	{r7, pc}

08010c40 <_ZN13SimpleDisplay8drawTextEPKctt>:
	painter.drawRectangle(Point(0, row * 8), Size(SimpleDisplay::X_MAX, 8), IMonochromeDisplay::White, IMonochromeDisplay::White);
	painter.end();
}

void SimpleDisplay::drawText(const char * str, uint16_t col, uint16_t row)
{
 8010c40:	b580      	push	{r7, lr}
 8010c42:	b092      	sub	sp, #72	; 0x48
 8010c44:	af00      	add	r7, sp, #0
 8010c46:	60f8      	str	r0, [r7, #12]
 8010c48:	60b9      	str	r1, [r7, #8]
 8010c4a:	4611      	mov	r1, r2
 8010c4c:	461a      	mov	r2, r3
 8010c4e:	460b      	mov	r3, r1
 8010c50:	80fb      	strh	r3, [r7, #6]
 8010c52:	4613      	mov	r3, r2
 8010c54:	80bb      	strh	r3, [r7, #4]
	MonochromeDisplayPainter painter(this, false);
 8010c56:	68f9      	ldr	r1, [r7, #12]
 8010c58:	f107 0310 	add.w	r3, r7, #16
 8010c5c:	2200      	movs	r2, #0
 8010c5e:	4618      	mov	r0, r3
 8010c60:	f7fc ff60 	bl	800db24 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb>
	painter.begin(this);
 8010c64:	68fa      	ldr	r2, [r7, #12]
 8010c66:	f107 0310 	add.w	r3, r7, #16
 8010c6a:	4611      	mov	r1, r2
 8010c6c:	4618      	mov	r0, r3
 8010c6e:	f7fc ffa3 	bl	800dbb8 <_ZN24MonochromeDisplayPainter5beginEP18IMonochromeDisplay>
	painter.drawText(IMonochromeDisplay::Point(col, row*8), str, IMonochromeDisplay::Black);
 8010c72:	88f9      	ldrh	r1, [r7, #6]
 8010c74:	88bb      	ldrh	r3, [r7, #4]
 8010c76:	00da      	lsls	r2, r3, #3
 8010c78:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8010c7c:	4618      	mov	r0, r3
 8010c7e:	f7fc ff3d 	bl	800dafc <_ZN18IMonochromeDisplay5PointC1Eii>
 8010c82:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8010c86:	4618      	mov	r0, r3
 8010c88:	f005 fab9 	bl	80161fe <_ZNSaIcEC1Ev>
 8010c8c:	f107 0244 	add.w	r2, r7, #68	; 0x44
 8010c90:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010c94:	68b9      	ldr	r1, [r7, #8]
 8010c96:	4618      	mov	r0, r3
 8010c98:	f005 fb42 	bl	8016320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_>
 8010c9c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8010ca0:	f107 0124 	add.w	r1, r7, #36	; 0x24
 8010ca4:	f107 0010 	add.w	r0, r7, #16
 8010ca8:	2301      	movs	r3, #1
 8010caa:	f7fd fafd 	bl	800e2a8 <_ZN24MonochromeDisplayPainter8drawTextERKN18IMonochromeDisplay5PointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_10PixelColorE>
 8010cae:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010cb2:	4618      	mov	r0, r3
 8010cb4:	f005 fafd 	bl	80162b2 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev>
 8010cb8:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8010cbc:	4618      	mov	r0, r3
 8010cbe:	f005 fa9f 	bl	8016200 <_ZNSaIcED1Ev>
	painter.end();
 8010cc2:	f107 0310 	add.w	r3, r7, #16
 8010cc6:	4618      	mov	r0, r3
 8010cc8:	f7fc ff90 	bl	800dbec <_ZN24MonochromeDisplayPainter3endEv>
	MonochromeDisplayPainter painter(this, false);
 8010ccc:	f107 0310 	add.w	r3, r7, #16
 8010cd0:	4618      	mov	r0, r3
 8010cd2:	f7fc ff4f 	bl	800db74 <_ZN24MonochromeDisplayPainterD1Ev>
}
 8010cd6:	bf00      	nop
 8010cd8:	3748      	adds	r7, #72	; 0x48
 8010cda:	46bd      	mov	sp, r7
 8010cdc:	bd80      	pop	{r7, pc}

08010cde <_ZN13SimpleDisplay8drawLineERKN18IMonochromeDisplay5PointES3_>:

void SimpleDisplay::drawLine(const SimpleDisplay::Point & begin, const SimpleDisplay::Point & end)
{
 8010cde:	b580      	push	{r7, lr}
 8010ce0:	b08a      	sub	sp, #40	; 0x28
 8010ce2:	af00      	add	r7, sp, #0
 8010ce4:	60f8      	str	r0, [r7, #12]
 8010ce6:	60b9      	str	r1, [r7, #8]
 8010ce8:	607a      	str	r2, [r7, #4]
	MonochromeDisplayPainter painter(this, false);
 8010cea:	68f9      	ldr	r1, [r7, #12]
 8010cec:	f107 0314 	add.w	r3, r7, #20
 8010cf0:	2200      	movs	r2, #0
 8010cf2:	4618      	mov	r0, r3
 8010cf4:	f7fc ff16 	bl	800db24 <_ZN24MonochromeDisplayPainterC1EP18IMonochromeDisplayb>
	painter.begin(this);
 8010cf8:	68fa      	ldr	r2, [r7, #12]
 8010cfa:	f107 0314 	add.w	r3, r7, #20
 8010cfe:	4611      	mov	r1, r2
 8010d00:	4618      	mov	r0, r3
 8010d02:	f7fc ff59 	bl	800dbb8 <_ZN24MonochromeDisplayPainter5beginEP18IMonochromeDisplay>
	painter.drawLine(begin, end, IMonochromeDisplay::Black);
 8010d06:	f107 0014 	add.w	r0, r7, #20
 8010d0a:	2301      	movs	r3, #1
 8010d0c:	687a      	ldr	r2, [r7, #4]
 8010d0e:	68b9      	ldr	r1, [r7, #8]
 8010d10:	f7fd f896 	bl	800de40 <_ZN24MonochromeDisplayPainter8drawLineERKN18IMonochromeDisplay5PointES3_NS0_10PixelColorE>
	painter.end();
 8010d14:	f107 0314 	add.w	r3, r7, #20
 8010d18:	4618      	mov	r0, r3
 8010d1a:	f7fc ff67 	bl	800dbec <_ZN24MonochromeDisplayPainter3endEv>
	MonochromeDisplayPainter painter(this, false);
 8010d1e:	f107 0314 	add.w	r3, r7, #20
 8010d22:	4618      	mov	r0, r3
 8010d24:	f7fc ff26 	bl	800db74 <_ZN24MonochromeDisplayPainterD1Ev>
}
 8010d28:	bf00      	nop
 8010d2a:	3728      	adds	r7, #40	; 0x28
 8010d2c:	46bd      	mov	sp, r7
 8010d2e:	bd80      	pop	{r7, pc}

08010d30 <_Z41__static_initialization_and_destruction_0ii>:
{
	MonochromeDisplayPainter painter(this, false);
	painter.begin(this);
	painter.drawRectangle(topLeft, size, IMonochromeDisplay::Black, (fill) ? IMonochromeDisplay::Black : IMonochromeDisplay::Undefined);
	painter.end();
}
 8010d30:	b580      	push	{r7, lr}
 8010d32:	b088      	sub	sp, #32
 8010d34:	af00      	add	r7, sp, #0
 8010d36:	6078      	str	r0, [r7, #4]
 8010d38:	6039      	str	r1, [r7, #0]
 8010d3a:	687b      	ldr	r3, [r7, #4]
 8010d3c:	2b01      	cmp	r3, #1
 8010d3e:	d122      	bne.n	8010d86 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8010d40:	683b      	ldr	r3, [r7, #0]
 8010d42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010d46:	4293      	cmp	r3, r2
 8010d48:	d11d      	bne.n	8010d86 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8010d4a:	4b18      	ldr	r3, [pc, #96]	; (8010dac <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8010d4c:	681b      	ldr	r3, [r3, #0]
 8010d4e:	613b      	str	r3, [r7, #16]
 8010d50:	f107 0310 	add.w	r3, r7, #16
 8010d54:	60bb      	str	r3, [r7, #8]
 8010d56:	2304      	movs	r3, #4
 8010d58:	60fb      	str	r3, [r7, #12]
 8010d5a:	f107 0308 	add.w	r3, r7, #8
 8010d5e:	e893 0006 	ldmia.w	r3, {r1, r2}
 8010d62:	4813      	ldr	r0, [pc, #76]	; (8010db0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8010d64:	f7f5 ffe6 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8010d68:	4b12      	ldr	r3, [pc, #72]	; (8010db4 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8010d6a:	681b      	ldr	r3, [r3, #0]
 8010d6c:	61fb      	str	r3, [r7, #28]
 8010d6e:	f107 031c 	add.w	r3, r7, #28
 8010d72:	617b      	str	r3, [r7, #20]
 8010d74:	2304      	movs	r3, #4
 8010d76:	61bb      	str	r3, [r7, #24]
 8010d78:	f107 0314 	add.w	r3, r7, #20
 8010d7c:	e893 0006 	ldmia.w	r3, {r1, r2}
 8010d80:	480d      	ldr	r0, [pc, #52]	; (8010db8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8010d82:	f7f5 ffd7 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8010d86:	687b      	ldr	r3, [r7, #4]
 8010d88:	2b00      	cmp	r3, #0
 8010d8a:	d10a      	bne.n	8010da2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8010d8c:	683b      	ldr	r3, [r7, #0]
 8010d8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010d92:	4293      	cmp	r3, r2
 8010d94:	d105      	bne.n	8010da2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8010d96:	4808      	ldr	r0, [pc, #32]	; (8010db8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8010d98:	f7f6 f916 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8010d9c:	4804      	ldr	r0, [pc, #16]	; (8010db0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8010d9e:	f7f6 f913 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8010da2:	bf00      	nop
 8010da4:	3720      	adds	r7, #32
 8010da6:	46bd      	mov	sp, r7
 8010da8:	bd80      	pop	{r7, pc}
 8010daa:	bf00      	nop
 8010dac:	08019da4 	.word	0x08019da4
 8010db0:	20001be4 	.word	0x20001be4
 8010db4:	08019da8 	.word	0x08019da8
 8010db8:	20001bec 	.word	0x20001bec

08010dbc <_GLOBAL__sub_I__ZN13SimpleDisplayC2Ev>:
 8010dbc:	b580      	push	{r7, lr}
 8010dbe:	af00      	add	r7, sp, #0
 8010dc0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8010dc4:	2001      	movs	r0, #1
 8010dc6:	f7ff ffb3 	bl	8010d30 <_Z41__static_initialization_and_destruction_0ii>
 8010dca:	bd80      	pop	{r7, pc}

08010dcc <_GLOBAL__sub_D__ZN13SimpleDisplayC2Ev>:
 8010dcc:	b580      	push	{r7, lr}
 8010dce:	af00      	add	r7, sp, #0
 8010dd0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8010dd4:	2000      	movs	r0, #0
 8010dd6:	f7ff ffab 	bl	8010d30 <_Z41__static_initialization_and_destruction_0ii>
 8010dda:	bd80      	pop	{r7, pc}

08010ddc <_ZN3phy7AddressILj4EEaSERKS1_>:
class Address
 8010ddc:	b480      	push	{r7}
 8010dde:	b083      	sub	sp, #12
 8010de0:	af00      	add	r7, sp, #0
 8010de2:	6078      	str	r0, [r7, #4]
 8010de4:	6039      	str	r1, [r7, #0]
 8010de6:	687b      	ldr	r3, [r7, #4]
 8010de8:	1d19      	adds	r1, r3, #4
 8010dea:	2203      	movs	r2, #3
 8010dec:	683b      	ldr	r3, [r7, #0]
 8010dee:	3304      	adds	r3, #4
 8010df0:	2a00      	cmp	r2, #0
 8010df2:	db05      	blt.n	8010e00 <_ZN3phy7AddressILj4EEaSERKS1_+0x24>
 8010df4:	7818      	ldrb	r0, [r3, #0]
 8010df6:	7008      	strb	r0, [r1, #0]
 8010df8:	3101      	adds	r1, #1
 8010dfa:	3301      	adds	r3, #1
 8010dfc:	3a01      	subs	r2, #1
 8010dfe:	e7f7      	b.n	8010df0 <_ZN3phy7AddressILj4EEaSERKS1_+0x14>
 8010e00:	687b      	ldr	r3, [r7, #4]
 8010e02:	4618      	mov	r0, r3
 8010e04:	370c      	adds	r7, #12
 8010e06:	46bd      	mov	sp, r7
 8010e08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e0c:	4770      	bx	lr
	...

08010e10 <_ZN3phy7AddressILj4EEC1ERKS1_>:
 8010e10:	b480      	push	{r7}
 8010e12:	b083      	sub	sp, #12
 8010e14:	af00      	add	r7, sp, #0
 8010e16:	6078      	str	r0, [r7, #4]
 8010e18:	6039      	str	r1, [r7, #0]
 8010e1a:	4a07      	ldr	r2, [pc, #28]	; (8010e38 <_ZN3phy7AddressILj4EEC1ERKS1_+0x28>)
 8010e1c:	687b      	ldr	r3, [r7, #4]
 8010e1e:	601a      	str	r2, [r3, #0]
 8010e20:	687b      	ldr	r3, [r7, #4]
 8010e22:	683a      	ldr	r2, [r7, #0]
 8010e24:	6852      	ldr	r2, [r2, #4]
 8010e26:	605a      	str	r2, [r3, #4]
 8010e28:	687b      	ldr	r3, [r7, #4]
 8010e2a:	4618      	mov	r0, r3
 8010e2c:	370c      	adds	r7, #12
 8010e2e:	46bd      	mov	sp, r7
 8010e30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e34:	4770      	bx	lr
 8010e36:	bf00      	nop
 8010e38:	0801b8d4 	.word	0x0801b8d4

08010e3c <_ZNK7desenet5FrameixEj>:
        const uint8_t & operator[](size_t index) const { return buffer_[index]; }	///< Byte access (read-only) to buffer
 8010e3c:	b580      	push	{r7, lr}
 8010e3e:	b082      	sub	sp, #8
 8010e40:	af00      	add	r7, sp, #0
 8010e42:	6078      	str	r0, [r7, #4]
 8010e44:	6039      	str	r1, [r7, #0]
 8010e46:	687b      	ldr	r3, [r7, #4]
 8010e48:	6839      	ldr	r1, [r7, #0]
 8010e4a:	4618      	mov	r0, r3
 8010e4c:	f7f8 f92a 	bl	80090a4 <_ZNK3hei12SharedBufferIhEixEj>
 8010e50:	4603      	mov	r3, r0
 8010e52:	4618      	mov	r0, r3
 8010e54:	3708      	adds	r7, #8
 8010e56:	46bd      	mov	sp, r7
 8010e58:	bd80      	pop	{r7, pc}

08010e5a <_ZN7desenet5FrameixEj>:
        uint8_t & operator[]( size_t index ) { return buffer_[index]; }				///< Byte access (write) to buffer
 8010e5a:	b580      	push	{r7, lr}
 8010e5c:	b082      	sub	sp, #8
 8010e5e:	af00      	add	r7, sp, #0
 8010e60:	6078      	str	r0, [r7, #4]
 8010e62:	6039      	str	r1, [r7, #0]
 8010e64:	687b      	ldr	r3, [r7, #4]
 8010e66:	6839      	ldr	r1, [r7, #0]
 8010e68:	4618      	mov	r0, r3
 8010e6a:	f7f5 ff97 	bl	8006d9c <_ZN3hei12SharedBufferIhEixEj>
 8010e6e:	4603      	mov	r3, r0
 8010e70:	4618      	mov	r0, r3
 8010e72:	3708      	adds	r7, #8
 8010e74:	46bd      	mov	sp, r7
 8010e76:	bd80      	pop	{r7, pc}

08010e78 <_ZNK6NrfSpi13isInitializedEv>:
public:
	NrfSpi(Spi & spi);
	virtual ~NrfSpi();

	bool initialize();													///< Initializes the NrfSpi. Should be called after construction.
	inline bool isInitialized() const { return _bInitialized; }			///< Returns true if the #initialize method was already called.
 8010e78:	b480      	push	{r7}
 8010e7a:	b083      	sub	sp, #12
 8010e7c:	af00      	add	r7, sp, #0
 8010e7e:	6078      	str	r0, [r7, #4]
 8010e80:	687b      	ldr	r3, [r7, #4]
 8010e82:	791b      	ldrb	r3, [r3, #4]
 8010e84:	4618      	mov	r0, r3
 8010e86:	370c      	adds	r7, #12
 8010e88:	46bd      	mov	sp, r7
 8010e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e8e:	4770      	bx	lr

08010e90 <_ZNK6NrfSpi15featuresEnabledEv>:

	tStatus writeRegister(eNrfRegister reg, tRegister value);				///< Writes a value to the transceivers register
	tStatus writeRegister(eNrfRegister reg, const tAddress & address);		///< Writes an address to the transceivers register

	bool activateFeatures(bool enable);										///< Activates some features of the transceiver chip
	inline bool featuresEnabled() const { return _bNrfFeaturesEnabled; }	///< Returns true if the features of the transceiver are enabled
 8010e90:	b480      	push	{r7}
 8010e92:	b083      	sub	sp, #12
 8010e94:	af00      	add	r7, sp, #0
 8010e96:	6078      	str	r0, [r7, #4]
 8010e98:	687b      	ldr	r3, [r7, #4]
 8010e9a:	7b1b      	ldrb	r3, [r3, #12]
 8010e9c:	4618      	mov	r0, r3
 8010e9e:	370c      	adds	r7, #12
 8010ea0:	46bd      	mov	sp, r7
 8010ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ea6:	4770      	bx	lr

08010ea8 <_ZNK6NrfSpi6sDelayEm>:

protected:
	#define CSN_TIME      2
	#define CE_HIGH_TIME  10000

	inline void sDelay(unsigned long a) const { while (--a!=0); }
 8010ea8:	b480      	push	{r7}
 8010eaa:	b083      	sub	sp, #12
 8010eac:	af00      	add	r7, sp, #0
 8010eae:	6078      	str	r0, [r7, #4]
 8010eb0:	6039      	str	r1, [r7, #0]
 8010eb2:	683b      	ldr	r3, [r7, #0]
 8010eb4:	3b01      	subs	r3, #1
 8010eb6:	603b      	str	r3, [r7, #0]
 8010eb8:	683b      	ldr	r3, [r7, #0]
 8010eba:	2b00      	cmp	r3, #0
 8010ebc:	bf14      	ite	ne
 8010ebe:	2301      	movne	r3, #1
 8010ec0:	2300      	moveq	r3, #0
 8010ec2:	b2db      	uxtb	r3, r3
 8010ec4:	2b00      	cmp	r3, #0
 8010ec6:	d000      	beq.n	8010eca <_ZNK6NrfSpi6sDelayEm+0x22>
 8010ec8:	e7f3      	b.n	8010eb2 <_ZNK6NrfSpi6sDelayEm+0xa>
 8010eca:	bf00      	nop
 8010ecc:	370c      	adds	r7, #12
 8010ece:	46bd      	mov	sp, r7
 8010ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ed4:	4770      	bx	lr

08010ed6 <_ZNK6NrfSpi8enableCSEv>:
	inline void enableCS() const { sDelay(CSN_TIME); HAL_GPIO_WritePin(NRF_CS_GPIO_Port, NRF_CS_Pin, GPIO_PIN_RESET); }		///< Selects transceiver
 8010ed6:	b580      	push	{r7, lr}
 8010ed8:	b082      	sub	sp, #8
 8010eda:	af00      	add	r7, sp, #0
 8010edc:	6078      	str	r0, [r7, #4]
 8010ede:	2102      	movs	r1, #2
 8010ee0:	6878      	ldr	r0, [r7, #4]
 8010ee2:	f7ff ffe1 	bl	8010ea8 <_ZNK6NrfSpi6sDelayEm>
 8010ee6:	2200      	movs	r2, #0
 8010ee8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8010eec:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8010ef0:	f7f0 fe94 	bl	8001c1c <HAL_GPIO_WritePin>
 8010ef4:	bf00      	nop
 8010ef6:	3708      	adds	r7, #8
 8010ef8:	46bd      	mov	sp, r7
 8010efa:	bd80      	pop	{r7, pc}

08010efc <_ZNK6NrfSpi9disableCSEv>:
	inline void disableCS() const { HAL_GPIO_WritePin(NRF_CS_GPIO_Port, NRF_CS_Pin, GPIO_PIN_SET); }						///< Releases transceiver
 8010efc:	b580      	push	{r7, lr}
 8010efe:	b082      	sub	sp, #8
 8010f00:	af00      	add	r7, sp, #0
 8010f02:	6078      	str	r0, [r7, #4]
 8010f04:	2201      	movs	r2, #1
 8010f06:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8010f0a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8010f0e:	f7f0 fe85 	bl	8001c1c <HAL_GPIO_WritePin>
 8010f12:	bf00      	nop
 8010f14:	3708      	adds	r7, #8
 8010f16:	46bd      	mov	sp, r7
 8010f18:	bd80      	pop	{r7, pc}

08010f1a <_ZN6NrfSpi3spiEv>:
	inline void disableCE() const { HAL_GPIO_WritePin(NRF_CE_GPIO_Port, NRF_CE_Pin, GPIO_PIN_RESET); }

	tStatus sendByte(unsigned char data);

private:
	inline Spi & spi() { return _spi; }
 8010f1a:	b480      	push	{r7}
 8010f1c:	b083      	sub	sp, #12
 8010f1e:	af00      	add	r7, sp, #0
 8010f20:	6078      	str	r0, [r7, #4]
 8010f22:	687b      	ldr	r3, [r7, #4]
 8010f24:	689b      	ldr	r3, [r3, #8]
 8010f26:	4618      	mov	r0, r3
 8010f28:	370c      	adds	r7, #12
 8010f2a:	46bd      	mov	sp, r7
 8010f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f30:	4770      	bx	lr
	...

08010f34 <_ZN6NrfSpiC1ER3Spi>:
#include "desenet/frame.h"
#include "nrfspi.h"

using desenet::Frame;

NrfSpi::NrfSpi(Spi & spi)
 8010f34:	b480      	push	{r7}
 8010f36:	b083      	sub	sp, #12
 8010f38:	af00      	add	r7, sp, #0
 8010f3a:	6078      	str	r0, [r7, #4]
 8010f3c:	6039      	str	r1, [r7, #0]
 : _bInitialized(false),
   _spi(spi),
   _bNrfFeaturesEnabled(false)
 8010f3e:	4a09      	ldr	r2, [pc, #36]	; (8010f64 <_ZN6NrfSpiC1ER3Spi+0x30>)
 8010f40:	687b      	ldr	r3, [r7, #4]
 8010f42:	601a      	str	r2, [r3, #0]
 8010f44:	687b      	ldr	r3, [r7, #4]
 8010f46:	2200      	movs	r2, #0
 8010f48:	711a      	strb	r2, [r3, #4]
 8010f4a:	687b      	ldr	r3, [r7, #4]
 8010f4c:	683a      	ldr	r2, [r7, #0]
 8010f4e:	609a      	str	r2, [r3, #8]
 8010f50:	687b      	ldr	r3, [r7, #4]
 8010f52:	2200      	movs	r2, #0
 8010f54:	731a      	strb	r2, [r3, #12]
{

}
 8010f56:	687b      	ldr	r3, [r7, #4]
 8010f58:	4618      	mov	r0, r3
 8010f5a:	370c      	adds	r7, #12
 8010f5c:	46bd      	mov	sp, r7
 8010f5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f62:	4770      	bx	lr
 8010f64:	0801da68 	.word	0x0801da68

08010f68 <_ZN6NrfSpiD1Ev>:

NrfSpi::~NrfSpi()
 8010f68:	b480      	push	{r7}
 8010f6a:	b083      	sub	sp, #12
 8010f6c:	af00      	add	r7, sp, #0
 8010f6e:	6078      	str	r0, [r7, #4]
 8010f70:	4a04      	ldr	r2, [pc, #16]	; (8010f84 <_ZN6NrfSpiD1Ev+0x1c>)
 8010f72:	687b      	ldr	r3, [r7, #4]
 8010f74:	601a      	str	r2, [r3, #0]
{

}
 8010f76:	687b      	ldr	r3, [r7, #4]
 8010f78:	4618      	mov	r0, r3
 8010f7a:	370c      	adds	r7, #12
 8010f7c:	46bd      	mov	sp, r7
 8010f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f82:	4770      	bx	lr
 8010f84:	0801da68 	.word	0x0801da68

08010f88 <_ZN6NrfSpiD0Ev>:
NrfSpi::~NrfSpi()
 8010f88:	b580      	push	{r7, lr}
 8010f8a:	b082      	sub	sp, #8
 8010f8c:	af00      	add	r7, sp, #0
 8010f8e:	6078      	str	r0, [r7, #4]
}
 8010f90:	6878      	ldr	r0, [r7, #4]
 8010f92:	f7ff ffe9 	bl	8010f68 <_ZN6NrfSpiD1Ev>
 8010f96:	2110      	movs	r1, #16
 8010f98:	6878      	ldr	r0, [r7, #4]
 8010f9a:	f005 f907 	bl	80161ac <_ZdlPvj>
 8010f9e:	687b      	ldr	r3, [r7, #4]
 8010fa0:	4618      	mov	r0, r3
 8010fa2:	3708      	adds	r7, #8
 8010fa4:	46bd      	mov	sp, r7
 8010fa6:	bd80      	pop	{r7, pc}

08010fa8 <_ZN6NrfSpi10initializeEv>:

bool NrfSpi::initialize()
{
 8010fa8:	b580      	push	{r7, lr}
 8010faa:	b082      	sub	sp, #8
 8010fac:	af00      	add	r7, sp, #0
 8010fae:	6078      	str	r0, [r7, #4]
	if (!isInitialized())
 8010fb0:	6878      	ldr	r0, [r7, #4]
 8010fb2:	f7ff ff61 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 8010fb6:	4603      	mov	r3, r0
 8010fb8:	f083 0301 	eor.w	r3, r3, #1
 8010fbc:	b2db      	uxtb	r3, r3
 8010fbe:	2b00      	cmp	r3, #0
 8010fc0:	d00b      	beq.n	8010fda <_ZN6NrfSpi10initializeEv+0x32>
	{
		_bInitialized = true;
 8010fc2:	687b      	ldr	r3, [r7, #4]
 8010fc4:	2201      	movs	r2, #1
 8010fc6:	711a      	strb	r2, [r3, #4]

		spi().initialize();
 8010fc8:	6878      	ldr	r0, [r7, #4]
 8010fca:	f7ff ffa6 	bl	8010f1a <_ZN6NrfSpi3spiEv>
 8010fce:	4603      	mov	r3, r0
 8010fd0:	4618      	mov	r0, r3
 8010fd2:	f002 fbbb 	bl	801374c <_ZN3Spi10initializeEv>

		return true;
 8010fd6:	2301      	movs	r3, #1
 8010fd8:	e000      	b.n	8010fdc <_ZN6NrfSpi10initializeEv+0x34>
	}
	return false;
 8010fda:	2300      	movs	r3, #0
}
 8010fdc:	4618      	mov	r0, r3
 8010fde:	3708      	adds	r7, #8
 8010fe0:	46bd      	mov	sp, r7
 8010fe2:	bd80      	pop	{r7, pc}

08010fe4 <_ZN6NrfSpi6statusEv>:

NrfSpi::tStatus NrfSpi::status()
{
 8010fe4:	b580      	push	{r7, lr}
 8010fe6:	b082      	sub	sp, #8
 8010fe8:	af00      	add	r7, sp, #0
 8010fea:	6078      	str	r0, [r7, #4]
	return sendCmd(NrfSpi::NOP);
 8010fec:	21ff      	movs	r1, #255	; 0xff
 8010fee:	6878      	ldr	r0, [r7, #4]
 8010ff0:	f000 f806 	bl	8011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>
 8010ff4:	4603      	mov	r3, r0
}
 8010ff6:	4618      	mov	r0, r3
 8010ff8:	3708      	adds	r7, #8
 8010ffa:	46bd      	mov	sp, r7
 8010ffc:	bd80      	pop	{r7, pc}
	...

08011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>:

NrfSpi::tStatus NrfSpi::sendCmd(eNrfSpiCmd cmd)
{
 8011000:	b580      	push	{r7, lr}
 8011002:	b084      	sub	sp, #16
 8011004:	af00      	add	r7, sp, #0
 8011006:	6078      	str	r0, [r7, #4]
 8011008:	460b      	mov	r3, r1
 801100a:	70fb      	strb	r3, [r7, #3]
	tStatus status = 0x00;
 801100c:	2300      	movs	r3, #0
 801100e:	73fb      	strb	r3, [r7, #15]

	assert(cmd != R_RX_PAYLOAD);			// Use readFrame() instead
 8011010:	78fb      	ldrb	r3, [r7, #3]
 8011012:	2b61      	cmp	r3, #97	; 0x61
 8011014:	d105      	bne.n	8011022 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x22>
 8011016:	4b40      	ldr	r3, [pc, #256]	; (8011118 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x118>)
 8011018:	4a40      	ldr	r2, [pc, #256]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 801101a:	2129      	movs	r1, #41	; 0x29
 801101c:	4840      	ldr	r0, [pc, #256]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 801101e:	f005 f9b9 	bl	8016394 <__assert_func>
	assert(cmd != W_TX_PAYLOAD);			// Use sendFrame() instead
 8011022:	78fb      	ldrb	r3, [r7, #3]
 8011024:	2ba0      	cmp	r3, #160	; 0xa0
 8011026:	d105      	bne.n	8011034 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x34>
 8011028:	4b3e      	ldr	r3, [pc, #248]	; (8011124 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x124>)
 801102a:	4a3c      	ldr	r2, [pc, #240]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 801102c:	212a      	movs	r1, #42	; 0x2a
 801102e:	483c      	ldr	r0, [pc, #240]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 8011030:	f005 f9b0 	bl	8016394 <__assert_func>
	assert(cmd != W_REGISTER);				// Use writeRegister() methods instead
 8011034:	78fb      	ldrb	r3, [r7, #3]
 8011036:	2b01      	cmp	r3, #1
 8011038:	d105      	bne.n	8011046 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x46>
 801103a:	4b3b      	ldr	r3, [pc, #236]	; (8011128 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x128>)
 801103c:	4a37      	ldr	r2, [pc, #220]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 801103e:	212b      	movs	r1, #43	; 0x2b
 8011040:	4837      	ldr	r0, [pc, #220]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 8011042:	f005 f9a7 	bl	8016394 <__assert_func>
	assert(cmd != R_REGISTER);				// Use readRegister() methods instead
 8011046:	78fb      	ldrb	r3, [r7, #3]
 8011048:	2b00      	cmp	r3, #0
 801104a:	d105      	bne.n	8011058 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x58>
 801104c:	4b37      	ldr	r3, [pc, #220]	; (801112c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x12c>)
 801104e:	4a33      	ldr	r2, [pc, #204]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 8011050:	212c      	movs	r1, #44	; 0x2c
 8011052:	4833      	ldr	r0, [pc, #204]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 8011054:	f005 f99e 	bl	8016394 <__assert_func>
	assert(cmd != W_ACK_PAYLOAD);
 8011058:	78fb      	ldrb	r3, [r7, #3]
 801105a:	2ba1      	cmp	r3, #161	; 0xa1
 801105c:	d105      	bne.n	801106a <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x6a>
 801105e:	4b34      	ldr	r3, [pc, #208]	; (8011130 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x130>)
 8011060:	4a2e      	ldr	r2, [pc, #184]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 8011062:	212d      	movs	r1, #45	; 0x2d
 8011064:	482e      	ldr	r0, [pc, #184]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 8011066:	f005 f995 	bl	8016394 <__assert_func>
	assert(cmd != W_TX_PAYLOAD_NO_ACK);
 801106a:	78fb      	ldrb	r3, [r7, #3]
 801106c:	2bb0      	cmp	r3, #176	; 0xb0
 801106e:	d105      	bne.n	801107c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x7c>
 8011070:	4b30      	ldr	r3, [pc, #192]	; (8011134 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x134>)
 8011072:	4a2a      	ldr	r2, [pc, #168]	; (801111c <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x11c>)
 8011074:	212e      	movs	r1, #46	; 0x2e
 8011076:	482a      	ldr	r0, [pc, #168]	; (8011120 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x120>)
 8011078:	f005 f98c 	bl	8016394 <__assert_func>

	enableCS();
 801107c:	6878      	ldr	r0, [r7, #4]
 801107e:	f7ff ff2a 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	switch (cmd)
 8011082:	78fb      	ldrb	r3, [r7, #3]
 8011084:	2bff      	cmp	r3, #255	; 0xff
 8011086:	d01c      	beq.n	80110c2 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0xc2>
 8011088:	2bff      	cmp	r3, #255	; 0xff
 801108a:	dc3d      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 801108c:	2be3      	cmp	r3, #227	; 0xe3
 801108e:	dc3b      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 8011090:	2be1      	cmp	r3, #225	; 0xe1
 8011092:	da16      	bge.n	80110c2 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0xc2>
 8011094:	2bb0      	cmp	r3, #176	; 0xb0
 8011096:	d036      	beq.n	8011106 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x106>
 8011098:	2bb0      	cmp	r3, #176	; 0xb0
 801109a:	dc35      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 801109c:	2ba1      	cmp	r3, #161	; 0xa1
 801109e:	dc33      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 80110a0:	2ba0      	cmp	r3, #160	; 0xa0
 80110a2:	da30      	bge.n	8011106 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x106>
 80110a4:	2b61      	cmp	r3, #97	; 0x61
 80110a6:	d02e      	beq.n	8011106 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x106>
 80110a8:	2b61      	cmp	r3, #97	; 0x61
 80110aa:	dc2d      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 80110ac:	2b60      	cmp	r3, #96	; 0x60
 80110ae:	d01c      	beq.n	80110ea <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0xea>
 80110b0:	2b60      	cmp	r3, #96	; 0x60
 80110b2:	dc29      	bgt.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
 80110b4:	2b01      	cmp	r3, #1
 80110b6:	dc01      	bgt.n	80110bc <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0xbc>
 80110b8:	2b00      	cmp	r3, #0
	case W_REGISTER:
	case R_REGISTER:
	case W_ACK_PAYLOAD:
	case W_TX_PAYLOAD_NO_ACK:
		// To nothing
		break;
 80110ba:	e024      	b.n	8011106 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x106>
	switch (cmd)
 80110bc:	2b50      	cmp	r3, #80	; 0x50
 80110be:	d008      	beq.n	80110d2 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0xd2>
 80110c0:	e022      	b.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
		status = sendByte(cmd);
 80110c2:	78fb      	ldrb	r3, [r7, #3]
 80110c4:	4619      	mov	r1, r3
 80110c6:	6878      	ldr	r0, [r7, #4]
 80110c8:	f000 fad8 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80110cc:	4603      	mov	r3, r0
 80110ce:	73fb      	strb	r3, [r7, #15]
		break;
 80110d0:	e01a      	b.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
		status = sendByte(cmd);
 80110d2:	78fb      	ldrb	r3, [r7, #3]
 80110d4:	4619      	mov	r1, r3
 80110d6:	6878      	ldr	r0, [r7, #4]
 80110d8:	f000 fad0 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80110dc:	4603      	mov	r3, r0
 80110de:	73fb      	strb	r3, [r7, #15]
		sendByte(ACTIVATE_DATA);
 80110e0:	2173      	movs	r1, #115	; 0x73
 80110e2:	6878      	ldr	r0, [r7, #4]
 80110e4:	f000 faca 	bl	801167c <_ZN6NrfSpi8sendByteEh>
		break;
 80110e8:	e00e      	b.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
		status = sendByte(cmd);
 80110ea:	78fb      	ldrb	r3, [r7, #3]
 80110ec:	4619      	mov	r1, r3
 80110ee:	6878      	ldr	r0, [r7, #4]
 80110f0:	f000 fac4 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80110f4:	4603      	mov	r3, r0
 80110f6:	73fb      	strb	r3, [r7, #15]
		status = sendByte(NOP);
 80110f8:	21ff      	movs	r1, #255	; 0xff
 80110fa:	6878      	ldr	r0, [r7, #4]
 80110fc:	f000 fabe 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 8011100:	4603      	mov	r3, r0
 8011102:	73fb      	strb	r3, [r7, #15]
		break;
 8011104:	e000      	b.n	8011108 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE+0x108>
		break;
 8011106:	bf00      	nop
	}

	disableCS();
 8011108:	6878      	ldr	r0, [r7, #4]
 801110a:	f7ff fef7 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 801110e:	7bfb      	ldrb	r3, [r7, #15]
}
 8011110:	4618      	mov	r0, r3
 8011112:	3710      	adds	r7, #16
 8011114:	46bd      	mov	sp, r7
 8011116:	bd80      	pop	{r7, pc}
 8011118:	08019dac 	.word	0x08019dac
 801111c:	08019dc0 	.word	0x08019dc0
 8011120:	08019df4 	.word	0x08019df4
 8011124:	08019e88 	.word	0x08019e88
 8011128:	08019e9c 	.word	0x08019e9c
 801112c:	08019eb0 	.word	0x08019eb0
 8011130:	08019ec4 	.word	0x08019ec4
 8011134:	08019edc 	.word	0x08019edc

08011138 <_ZN6NrfSpi9sendFrameERKN7desenet5FrameE>:
/**
 * Sends a frame to the destination node. Use TX_ADDR register to
 * set the address for the destination node.
 */
NrfSpi::tStatus NrfSpi::sendFrame(const Frame & frame)
{
 8011138:	b580      	push	{r7, lr}
 801113a:	b084      	sub	sp, #16
 801113c:	af00      	add	r7, sp, #0
 801113e:	6078      	str	r0, [r7, #4]
 8011140:	6039      	str	r1, [r7, #0]
	tStatus status = 0x00;
 8011142:	2300      	movs	r3, #0
 8011144:	72fb      	strb	r3, [r7, #11]

	enableCS();
 8011146:	6878      	ldr	r0, [r7, #4]
 8011148:	f7ff fec5 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	status = sendByte(W_TX_PAYLOAD);
 801114c:	21a0      	movs	r1, #160	; 0xa0
 801114e:	6878      	ldr	r0, [r7, #4]
 8011150:	f000 fa94 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 8011154:	4603      	mov	r3, r0
 8011156:	72fb      	strb	r3, [r7, #11]

	for (size_t i = 0; i < frame.length(); i++)
 8011158:	2300      	movs	r3, #0
 801115a:	60fb      	str	r3, [r7, #12]
 801115c:	6838      	ldr	r0, [r7, #0]
 801115e:	f7f7 fdc9 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8011162:	4602      	mov	r2, r0
 8011164:	68fb      	ldr	r3, [r7, #12]
 8011166:	4293      	cmp	r3, r2
 8011168:	bf34      	ite	cc
 801116a:	2301      	movcc	r3, #1
 801116c:	2300      	movcs	r3, #0
 801116e:	b2db      	uxtb	r3, r3
 8011170:	2b00      	cmp	r3, #0
 8011172:	d00d      	beq.n	8011190 <_ZN6NrfSpi9sendFrameERKN7desenet5FrameE+0x58>
	{
		sendByte(frame[i]);
 8011174:	68f9      	ldr	r1, [r7, #12]
 8011176:	6838      	ldr	r0, [r7, #0]
 8011178:	f7ff fe60 	bl	8010e3c <_ZNK7desenet5FrameixEj>
 801117c:	4603      	mov	r3, r0
 801117e:	781b      	ldrb	r3, [r3, #0]
 8011180:	4619      	mov	r1, r3
 8011182:	6878      	ldr	r0, [r7, #4]
 8011184:	f000 fa7a 	bl	801167c <_ZN6NrfSpi8sendByteEh>
	for (size_t i = 0; i < frame.length(); i++)
 8011188:	68fb      	ldr	r3, [r7, #12]
 801118a:	3301      	adds	r3, #1
 801118c:	60fb      	str	r3, [r7, #12]
 801118e:	e7e5      	b.n	801115c <_ZN6NrfSpi9sendFrameERKN7desenet5FrameE+0x24>
	}

	disableCS();
 8011190:	6878      	ldr	r0, [r7, #4]
 8011192:	f7ff feb3 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 8011196:	7afb      	ldrb	r3, [r7, #11]
}
 8011198:	4618      	mov	r0, r3
 801119a:	3710      	adds	r7, #16
 801119c:	46bd      	mov	sp, r7
 801119e:	bd80      	pop	{r7, pc}

080111a0 <_ZN6NrfSpi8transmitEPKhRKj>:
/**
 * Sends the buffer to the destination node. Use TX_ADDR register to
 * set the address for the destination node.
 */
NrfSpi::tStatus NrfSpi::transmit(const uint8_t * const buffer, const std::size_t & length)
{
 80111a0:	b580      	push	{r7, lr}
 80111a2:	b086      	sub	sp, #24
 80111a4:	af00      	add	r7, sp, #0
 80111a6:	60f8      	str	r0, [r7, #12]
 80111a8:	60b9      	str	r1, [r7, #8]
 80111aa:	607a      	str	r2, [r7, #4]
	tStatus status = 0x00;
 80111ac:	2300      	movs	r3, #0
 80111ae:	74fb      	strb	r3, [r7, #19]

	enableCS();
 80111b0:	68f8      	ldr	r0, [r7, #12]
 80111b2:	f7ff fe90 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	status = sendByte(W_TX_PAYLOAD);
 80111b6:	21a0      	movs	r1, #160	; 0xa0
 80111b8:	68f8      	ldr	r0, [r7, #12]
 80111ba:	f000 fa5f 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80111be:	4603      	mov	r3, r0
 80111c0:	74fb      	strb	r3, [r7, #19]

	for (size_t i = 0; i < length; i++)
 80111c2:	2300      	movs	r3, #0
 80111c4:	617b      	str	r3, [r7, #20]
 80111c6:	687b      	ldr	r3, [r7, #4]
 80111c8:	681b      	ldr	r3, [r3, #0]
 80111ca:	697a      	ldr	r2, [r7, #20]
 80111cc:	429a      	cmp	r2, r3
 80111ce:	d20b      	bcs.n	80111e8 <_ZN6NrfSpi8transmitEPKhRKj+0x48>
	{
		sendByte(buffer[i]);
 80111d0:	68ba      	ldr	r2, [r7, #8]
 80111d2:	697b      	ldr	r3, [r7, #20]
 80111d4:	4413      	add	r3, r2
 80111d6:	781b      	ldrb	r3, [r3, #0]
 80111d8:	4619      	mov	r1, r3
 80111da:	68f8      	ldr	r0, [r7, #12]
 80111dc:	f000 fa4e 	bl	801167c <_ZN6NrfSpi8sendByteEh>
	for (size_t i = 0; i < length; i++)
 80111e0:	697b      	ldr	r3, [r7, #20]
 80111e2:	3301      	adds	r3, #1
 80111e4:	617b      	str	r3, [r7, #20]
 80111e6:	e7ee      	b.n	80111c6 <_ZN6NrfSpi8transmitEPKhRKj+0x26>
	}

	disableCS();
 80111e8:	68f8      	ldr	r0, [r7, #12]
 80111ea:	f7ff fe87 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 80111ee:	7cfb      	ldrb	r3, [r7, #19]
}
 80111f0:	4618      	mov	r0, r3
 80111f2:	3718      	adds	r7, #24
 80111f4:	46bd      	mov	sp, r7
 80111f6:	bd80      	pop	{r7, pc}

080111f8 <_ZN6NrfSpi9readFrameERN7desenet5FrameE>:

NrfSpi::tStatus NrfSpi::readFrame(Frame & frame)
{
 80111f8:	b590      	push	{r4, r7, lr}
 80111fa:	b085      	sub	sp, #20
 80111fc:	af00      	add	r7, sp, #0
 80111fe:	6078      	str	r0, [r7, #4]
 8011200:	6039      	str	r1, [r7, #0]
	tStatus status = 0x00;
 8011202:	2300      	movs	r3, #0
 8011204:	72fb      	strb	r3, [r7, #11]

	assert(frame.length());		// Please specify how many bytes you want to read
 8011206:	6838      	ldr	r0, [r7, #0]
 8011208:	f7f7 fd74 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 801120c:	4603      	mov	r3, r0
 801120e:	2b00      	cmp	r3, #0
 8011210:	d105      	bne.n	801121e <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x26>
 8011212:	4b1b      	ldr	r3, [pc, #108]	; (8011280 <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x88>)
 8011214:	4a1b      	ldr	r2, [pc, #108]	; (8011284 <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x8c>)
 8011216:	217e      	movs	r1, #126	; 0x7e
 8011218:	481b      	ldr	r0, [pc, #108]	; (8011288 <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x90>)
 801121a:	f005 f8bb 	bl	8016394 <__assert_func>

	enableCS();
 801121e:	6878      	ldr	r0, [r7, #4]
 8011220:	f7ff fe59 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	status = sendByte(R_RX_PAYLOAD);
 8011224:	2161      	movs	r1, #97	; 0x61
 8011226:	6878      	ldr	r0, [r7, #4]
 8011228:	f000 fa28 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 801122c:	4603      	mov	r3, r0
 801122e:	72fb      	strb	r3, [r7, #11]

	for (size_t i = 0; i < frame.length() - Frame::HEADER_SIZE; i++)
 8011230:	2300      	movs	r3, #0
 8011232:	60fb      	str	r3, [r7, #12]
 8011234:	6838      	ldr	r0, [r7, #0]
 8011236:	f7f7 fd5d 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 801123a:	4603      	mov	r3, r0
 801123c:	3b05      	subs	r3, #5
 801123e:	68fa      	ldr	r2, [r7, #12]
 8011240:	429a      	cmp	r2, r3
 8011242:	bf34      	ite	cc
 8011244:	2301      	movcc	r3, #1
 8011246:	2300      	movcs	r3, #0
 8011248:	b2db      	uxtb	r3, r3
 801124a:	2b00      	cmp	r3, #0
 801124c:	d010      	beq.n	8011270 <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x78>
	{
		frame[Frame::HEADER_SIZE + i] = sendByte(NOP);
 801124e:	68fb      	ldr	r3, [r7, #12]
 8011250:	3305      	adds	r3, #5
 8011252:	4619      	mov	r1, r3
 8011254:	6838      	ldr	r0, [r7, #0]
 8011256:	f7ff fe00 	bl	8010e5a <_ZN7desenet5FrameixEj>
 801125a:	4604      	mov	r4, r0
 801125c:	21ff      	movs	r1, #255	; 0xff
 801125e:	6878      	ldr	r0, [r7, #4]
 8011260:	f000 fa0c 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 8011264:	4603      	mov	r3, r0
 8011266:	7023      	strb	r3, [r4, #0]
	for (size_t i = 0; i < frame.length() - Frame::HEADER_SIZE; i++)
 8011268:	68fb      	ldr	r3, [r7, #12]
 801126a:	3301      	adds	r3, #1
 801126c:	60fb      	str	r3, [r7, #12]
 801126e:	e7e1      	b.n	8011234 <_ZN6NrfSpi9readFrameERN7desenet5FrameE+0x3c>
	}

	disableCS();
 8011270:	6878      	ldr	r0, [r7, #4]
 8011272:	f7ff fe43 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 8011276:	7afb      	ldrb	r3, [r7, #11]
}
 8011278:	4618      	mov	r0, r3
 801127a:	3714      	adds	r7, #20
 801127c:	46bd      	mov	sp, r7
 801127e:	bd90      	pop	{r4, r7, pc}
 8011280:	08019ef8 	.word	0x08019ef8
 8011284:	08019f08 	.word	0x08019f08
 8011288:	08019df4 	.word	0x08019df4

0801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>:

NrfSpi::tRegister NrfSpi::readRegister(eNrfRegister reg)
{
 801128c:	b580      	push	{r7, lr}
 801128e:	b084      	sub	sp, #16
 8011290:	af00      	add	r7, sp, #0
 8011292:	6078      	str	r0, [r7, #4]
 8011294:	460b      	mov	r3, r1
 8011296:	70fb      	strb	r3, [r7, #3]
	tRegister value;

	// All but not these registers are allowed
	assert(!(reg == TX_ADDR || (reg >= RX_ADDR_P0 && reg <= RX_ADDR_P5)));
 8011298:	78fb      	ldrb	r3, [r7, #3]
 801129a:	2b10      	cmp	r3, #16
 801129c:	d005      	beq.n	80112aa <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x1e>
 801129e:	78fb      	ldrb	r3, [r7, #3]
 80112a0:	2b09      	cmp	r3, #9
 80112a2:	d908      	bls.n	80112b6 <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x2a>
 80112a4:	78fb      	ldrb	r3, [r7, #3]
 80112a6:	2b0f      	cmp	r3, #15
 80112a8:	d805      	bhi.n	80112b6 <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x2a>
 80112aa:	4b0e      	ldr	r3, [pc, #56]	; (80112e4 <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x58>)
 80112ac:	4a0e      	ldr	r2, [pc, #56]	; (80112e8 <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x5c>)
 80112ae:	2192      	movs	r1, #146	; 0x92
 80112b0:	480e      	ldr	r0, [pc, #56]	; (80112ec <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE+0x60>)
 80112b2:	f005 f86f 	bl	8016394 <__assert_func>
 80112b6:	bf00      	nop

	enableCS();
 80112b8:	6878      	ldr	r0, [r7, #4]
 80112ba:	f7ff fe0c 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	sendByte((R_REGISTER << 5) | reg);
 80112be:	78fb      	ldrb	r3, [r7, #3]
 80112c0:	4619      	mov	r1, r3
 80112c2:	6878      	ldr	r0, [r7, #4]
 80112c4:	f000 f9da 	bl	801167c <_ZN6NrfSpi8sendByteEh>
	value = sendByte(NOP);
 80112c8:	21ff      	movs	r1, #255	; 0xff
 80112ca:	6878      	ldr	r0, [r7, #4]
 80112cc:	f000 f9d6 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80112d0:	4603      	mov	r3, r0
 80112d2:	73fb      	strb	r3, [r7, #15]

	disableCS();
 80112d4:	6878      	ldr	r0, [r7, #4]
 80112d6:	f7ff fe11 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return value;
 80112da:	7bfb      	ldrb	r3, [r7, #15]
}
 80112dc:	4618      	mov	r0, r3
 80112de:	3710      	adds	r7, #16
 80112e0:	46bd      	mov	sp, r7
 80112e2:	bd80      	pop	{r7, pc}
 80112e4:	08019f3c 	.word	0x08019f3c
 80112e8:	08019f7c 	.word	0x08019f7c
 80112ec:	08019df4 	.word	0x08019df4

080112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>:
	disableCS();
	return status;
}

NrfSpi::tStatus NrfSpi::writeRegister(eNrfRegister reg, tRegister value)
{
 80112f0:	b580      	push	{r7, lr}
 80112f2:	b084      	sub	sp, #16
 80112f4:	af00      	add	r7, sp, #0
 80112f6:	6078      	str	r0, [r7, #4]
 80112f8:	460b      	mov	r3, r1
 80112fa:	70fb      	strb	r3, [r7, #3]
 80112fc:	4613      	mov	r3, r2
 80112fe:	70bb      	strb	r3, [r7, #2]
	tStatus status = 0x00;
 8011300:	2300      	movs	r3, #0
 8011302:	73fb      	strb	r3, [r7, #15]

	// All but not these registers are allowed
	assert(!(reg == TX_ADDR || (reg >= RX_ADDR_P0 && reg <= RX_ADDR_P5)));
 8011304:	78fb      	ldrb	r3, [r7, #3]
 8011306:	2b10      	cmp	r3, #16
 8011308:	d005      	beq.n	8011316 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x26>
 801130a:	78fb      	ldrb	r3, [r7, #3]
 801130c:	2b09      	cmp	r3, #9
 801130e:	d908      	bls.n	8011322 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x32>
 8011310:	78fb      	ldrb	r3, [r7, #3]
 8011312:	2b0f      	cmp	r3, #15
 8011314:	d805      	bhi.n	8011322 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x32>
 8011316:	4b10      	ldr	r3, [pc, #64]	; (8011358 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x68>)
 8011318:	4a10      	ldr	r2, [pc, #64]	; (801135c <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x6c>)
 801131a:	21b5      	movs	r1, #181	; 0xb5
 801131c:	4810      	ldr	r0, [pc, #64]	; (8011360 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh+0x70>)
 801131e:	f005 f839 	bl	8016394 <__assert_func>
 8011322:	bf00      	nop

	enableCS();
 8011324:	6878      	ldr	r0, [r7, #4]
 8011326:	f7ff fdd6 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	status = sendByte((W_REGISTER << 5) | reg);
 801132a:	78fb      	ldrb	r3, [r7, #3]
 801132c:	f043 0320 	orr.w	r3, r3, #32
 8011330:	b2db      	uxtb	r3, r3
 8011332:	4619      	mov	r1, r3
 8011334:	6878      	ldr	r0, [r7, #4]
 8011336:	f000 f9a1 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 801133a:	4603      	mov	r3, r0
 801133c:	73fb      	strb	r3, [r7, #15]
	sendByte(value);
 801133e:	78bb      	ldrb	r3, [r7, #2]
 8011340:	4619      	mov	r1, r3
 8011342:	6878      	ldr	r0, [r7, #4]
 8011344:	f000 f99a 	bl	801167c <_ZN6NrfSpi8sendByteEh>

	disableCS();
 8011348:	6878      	ldr	r0, [r7, #4]
 801134a:	f7ff fdd7 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 801134e:	7bfb      	ldrb	r3, [r7, #15]
}
 8011350:	4618      	mov	r0, r3
 8011352:	3710      	adds	r7, #16
 8011354:	46bd      	mov	sp, r7
 8011356:	bd80      	pop	{r7, pc}
 8011358:	08019f3c 	.word	0x08019f3c
 801135c:	0801a048 	.word	0x0801a048
 8011360:	08019df4 	.word	0x08019df4

08011364 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE>:

NrfSpi::tStatus NrfSpi::writeRegister(eNrfRegister reg, const tAddress & address)
{
 8011364:	b580      	push	{r7, lr}
 8011366:	b086      	sub	sp, #24
 8011368:	af00      	add	r7, sp, #0
 801136a:	60f8      	str	r0, [r7, #12]
 801136c:	460b      	mov	r3, r1
 801136e:	607a      	str	r2, [r7, #4]
 8011370:	72fb      	strb	r3, [r7, #11]
	tStatus status = 0x00;
 8011372:	2300      	movs	r3, #0
 8011374:	74fb      	strb	r3, [r7, #19]

	// Only these registers are allowed
	assert(reg == TX_ADDR || (reg >= RX_ADDR_P0 && reg <= RX_ADDR_P5));
 8011376:	7afb      	ldrb	r3, [r7, #11]
 8011378:	2b10      	cmp	r3, #16
 801137a:	d00b      	beq.n	8011394 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x30>
 801137c:	7afb      	ldrb	r3, [r7, #11]
 801137e:	2b09      	cmp	r3, #9
 8011380:	d902      	bls.n	8011388 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x24>
 8011382:	7afb      	ldrb	r3, [r7, #11]
 8011384:	2b0f      	cmp	r3, #15
 8011386:	d905      	bls.n	8011394 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x30>
 8011388:	4b1a      	ldr	r3, [pc, #104]	; (80113f4 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x90>)
 801138a:	4a1b      	ldr	r2, [pc, #108]	; (80113f8 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x94>)
 801138c:	21c5      	movs	r1, #197	; 0xc5
 801138e:	481b      	ldr	r0, [pc, #108]	; (80113fc <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x98>)
 8011390:	f005 f800 	bl	8016394 <__assert_func>

	enableCS();
 8011394:	68f8      	ldr	r0, [r7, #12]
 8011396:	f7ff fd9e 	bl	8010ed6 <_ZNK6NrfSpi8enableCSEv>

	status = sendByte((W_REGISTER << 5) | reg);
 801139a:	7afb      	ldrb	r3, [r7, #11]
 801139c:	f043 0320 	orr.w	r3, r3, #32
 80113a0:	b2db      	uxtb	r3, r3
 80113a2:	4619      	mov	r1, r3
 80113a4:	68f8      	ldr	r0, [r7, #12]
 80113a6:	f000 f969 	bl	801167c <_ZN6NrfSpi8sendByteEh>
 80113aa:	4603      	mov	r3, r0
 80113ac:	74fb      	strb	r3, [r7, #19]
	for (size_t i = 0; i < address.addressSize(); i++)
 80113ae:	2300      	movs	r3, #0
 80113b0:	617b      	str	r3, [r7, #20]
 80113b2:	f7f7 ff39 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 80113b6:	4602      	mov	r2, r0
 80113b8:	697b      	ldr	r3, [r7, #20]
 80113ba:	4293      	cmp	r3, r2
 80113bc:	bf34      	ite	cc
 80113be:	2301      	movcc	r3, #1
 80113c0:	2300      	movcs	r3, #0
 80113c2:	b2db      	uxtb	r3, r3
 80113c4:	2b00      	cmp	r3, #0
 80113c6:	d00d      	beq.n	80113e4 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x80>
	{
		sendByte(address[i]);
 80113c8:	6979      	ldr	r1, [r7, #20]
 80113ca:	6878      	ldr	r0, [r7, #4]
 80113cc:	f000 f96a 	bl	80116a4 <_ZNK3phy7AddressILj4EEixEj>
 80113d0:	4603      	mov	r3, r0
 80113d2:	781b      	ldrb	r3, [r3, #0]
 80113d4:	4619      	mov	r1, r3
 80113d6:	68f8      	ldr	r0, [r7, #12]
 80113d8:	f000 f950 	bl	801167c <_ZN6NrfSpi8sendByteEh>
	for (size_t i = 0; i < address.addressSize(); i++)
 80113dc:	697b      	ldr	r3, [r7, #20]
 80113de:	3301      	adds	r3, #1
 80113e0:	617b      	str	r3, [r7, #20]
 80113e2:	e7e6      	b.n	80113b2 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE+0x4e>
	}

	disableCS();
 80113e4:	68f8      	ldr	r0, [r7, #12]
 80113e6:	f7ff fd89 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
	return status;
 80113ea:	7cfb      	ldrb	r3, [r7, #19]
}
 80113ec:	4618      	mov	r0, r3
 80113ee:	3718      	adds	r7, #24
 80113f0:	46bd      	mov	sp, r7
 80113f2:	bd80      	pop	{r7, pc}
 80113f4:	08019fbc 	.word	0x08019fbc
 80113f8:	0801a098 	.word	0x0801a098
 80113fc:	08019df4 	.word	0x08019df4

08011400 <_ZN6NrfSpi16activateFeaturesEb>:

bool NrfSpi::activateFeatures(bool enable)
{
 8011400:	b580      	push	{r7, lr}
 8011402:	b082      	sub	sp, #8
 8011404:	af00      	add	r7, sp, #0
 8011406:	6078      	str	r0, [r7, #4]
 8011408:	460b      	mov	r3, r1
 801140a:	70fb      	strb	r3, [r7, #3]
	// Check if not already in this state
	if (_bNrfFeaturesEnabled != enable)
 801140c:	687b      	ldr	r3, [r7, #4]
 801140e:	7b1b      	ldrb	r3, [r3, #12]
 8011410:	78fa      	ldrb	r2, [r7, #3]
 8011412:	429a      	cmp	r2, r3
 8011414:	d008      	beq.n	8011428 <_ZN6NrfSpi16activateFeaturesEb+0x28>
	{
		sendCmd(NrfSpi::ACTIVATE);
 8011416:	2150      	movs	r1, #80	; 0x50
 8011418:	6878      	ldr	r0, [r7, #4]
 801141a:	f7ff fdf1 	bl	8011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>
		_bNrfFeaturesEnabled = enable;
 801141e:	687b      	ldr	r3, [r7, #4]
 8011420:	78fa      	ldrb	r2, [r7, #3]
 8011422:	731a      	strb	r2, [r3, #12]
		return true;
 8011424:	2301      	movs	r3, #1
 8011426:	e000      	b.n	801142a <_ZN6NrfSpi16activateFeaturesEb+0x2a>
	}
	return false;
 8011428:	2300      	movs	r3, #0
}
 801142a:	4618      	mov	r0, r3
 801142c:	3708      	adds	r7, #8
 801142e:	46bd      	mov	sp, r7
 8011430:	bd80      	pop	{r7, pc}
	...

08011434 <_ZN6NrfSpi20getRXFramePipeNumberEv>:

unsigned char NrfSpi::getRXFramePipeNumber()
{
 8011434:	b580      	push	{r7, lr}
 8011436:	b084      	sub	sp, #16
 8011438:	af00      	add	r7, sp, #0
 801143a:	6078      	str	r0, [r7, #4]
	unsigned char pipeNumber;
	tStatus status = NrfSpi::status();
 801143c:	6878      	ldr	r0, [r7, #4]
 801143e:	f7ff fdd1 	bl	8010fe4 <_ZN6NrfSpi6statusEv>
 8011442:	4603      	mov	r3, r0
 8011444:	73fb      	strb	r3, [r7, #15]

	// Extract RX_P_NO field
	pipeNumber = ((status >> 1) & 0x07);
 8011446:	7bfb      	ldrb	r3, [r7, #15]
 8011448:	085b      	lsrs	r3, r3, #1
 801144a:	b2db      	uxtb	r3, r3
 801144c:	f003 0307 	and.w	r3, r3, #7
 8011450:	73bb      	strb	r3, [r7, #14]

	if (!(pipeNumber == 0x07 || pipeNumber == 0x06))
 8011452:	7bbb      	ldrb	r3, [r7, #14]
 8011454:	2b07      	cmp	r3, #7
 8011456:	d004      	beq.n	8011462 <_ZN6NrfSpi20getRXFramePipeNumberEv+0x2e>
 8011458:	7bbb      	ldrb	r3, [r7, #14]
 801145a:	2b06      	cmp	r3, #6
 801145c:	d001      	beq.n	8011462 <_ZN6NrfSpi20getRXFramePipeNumberEv+0x2e>
	{
		return pipeNumber;
 801145e:	7bbb      	ldrb	r3, [r7, #14]
 8011460:	e005      	b.n	801146e <_ZN6NrfSpi20getRXFramePipeNumberEv+0x3a>
	}
	assert(false);	// Call this method only when you are sure there is a packet available
 8011462:	4b05      	ldr	r3, [pc, #20]	; (8011478 <_ZN6NrfSpi20getRXFramePipeNumberEv+0x44>)
 8011464:	4a05      	ldr	r2, [pc, #20]	; (801147c <_ZN6NrfSpi20getRXFramePipeNumberEv+0x48>)
 8011466:	21eb      	movs	r1, #235	; 0xeb
 8011468:	4805      	ldr	r0, [pc, #20]	; (8011480 <_ZN6NrfSpi20getRXFramePipeNumberEv+0x4c>)
 801146a:	f004 ff93 	bl	8016394 <__assert_func>
	return 0xFF;
}
 801146e:	4618      	mov	r0, r3
 8011470:	3710      	adds	r7, #16
 8011472:	46bd      	mov	sp, r7
 8011474:	bd80      	pop	{r7, pc}
 8011476:	bf00      	nop
 8011478:	0801a0e8 	.word	0x0801a0e8
 801147c:	0801a0f0 	.word	0x0801a0f0
 8011480:	08019df4 	.word	0x08019df4

08011484 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh>:

size_t NrfSpi::getRXFramePaylpoadSize(uint8_t pipeNumber)
{
 8011484:	b580      	push	{r7, lr}
 8011486:	b082      	sub	sp, #8
 8011488:	af00      	add	r7, sp, #0
 801148a:	6078      	str	r0, [r7, #4]
 801148c:	460b      	mov	r3, r1
 801148e:	70fb      	strb	r3, [r7, #3]
	assert(pipeNumber < 6);
 8011490:	78fb      	ldrb	r3, [r7, #3]
 8011492:	2b05      	cmp	r3, #5
 8011494:	d905      	bls.n	80114a2 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x1e>
 8011496:	4b10      	ldr	r3, [pc, #64]	; (80114d8 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x54>)
 8011498:	4a10      	ldr	r2, [pc, #64]	; (80114dc <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x58>)
 801149a:	21f1      	movs	r1, #241	; 0xf1
 801149c:	4810      	ldr	r0, [pc, #64]	; (80114e0 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x5c>)
 801149e:	f004 ff79 	bl	8016394 <__assert_func>

	if (!featuresEnabled())
 80114a2:	6878      	ldr	r0, [r7, #4]
 80114a4:	f7ff fcf4 	bl	8010e90 <_ZNK6NrfSpi15featuresEnabledEv>
 80114a8:	4603      	mov	r3, r0
 80114aa:	f083 0301 	eor.w	r3, r3, #1
 80114ae:	b2db      	uxtb	r3, r3
 80114b0:	2b00      	cmp	r3, #0
 80114b2:	d008      	beq.n	80114c6 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x42>
	{
		return readRegister((NrfSpi::eNrfRegister)(RX_PW_P0 + pipeNumber));
 80114b4:	78fb      	ldrb	r3, [r7, #3]
 80114b6:	3311      	adds	r3, #17
 80114b8:	b2db      	uxtb	r3, r3
 80114ba:	4619      	mov	r1, r3
 80114bc:	6878      	ldr	r0, [r7, #4]
 80114be:	f7ff fee5 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 80114c2:	4603      	mov	r3, r0
 80114c4:	e004      	b.n	80114d0 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh+0x4c>
	}
	else
	{
		// DPL. Read value of next frame in RX FIFO by reading the R_RX_PL_WID register
		return sendCmd(R_RX_PL_WID);
 80114c6:	2160      	movs	r1, #96	; 0x60
 80114c8:	6878      	ldr	r0, [r7, #4]
 80114ca:	f7ff fd99 	bl	8011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>
 80114ce:	4603      	mov	r3, r0
	}
}
 80114d0:	4618      	mov	r0, r3
 80114d2:	3708      	adds	r7, #8
 80114d4:	46bd      	mov	sp, r7
 80114d6:	bd80      	pop	{r7, pc}
 80114d8:	0801a120 	.word	0x0801a120
 80114dc:	0801a130 	.word	0x0801a130
 80114e0:	08019df4 	.word	0x08019df4

080114e4 <_ZN6NrfSpi14enableDataPipeEhb>:

/**
 * Upon startup pipes 0 and 1 are activated by default.
 */
void NrfSpi::enableDataPipe(uint8_t pipeMask, bool enable)
{
 80114e4:	b580      	push	{r7, lr}
 80114e6:	b084      	sub	sp, #16
 80114e8:	af00      	add	r7, sp, #0
 80114ea:	6078      	str	r0, [r7, #4]
 80114ec:	460b      	mov	r3, r1
 80114ee:	70fb      	strb	r3, [r7, #3]
 80114f0:	4613      	mov	r3, r2
 80114f2:	70bb      	strb	r3, [r7, #2]
	tRegister registerValue = readRegister(EN_RXADDR);
 80114f4:	2102      	movs	r1, #2
 80114f6:	6878      	ldr	r0, [r7, #4]
 80114f8:	f7ff fec8 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 80114fc:	4603      	mov	r3, r0
 80114fe:	73fb      	strb	r3, [r7, #15]

	assert((pipeMask & 0x3F) == pipeMask);		// Bits 6 and 7 shouldn't be touched
 8011500:	78fb      	ldrb	r3, [r7, #3]
 8011502:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8011506:	78fb      	ldrb	r3, [r7, #3]
 8011508:	429a      	cmp	r2, r3
 801150a:	d006      	beq.n	801151a <_ZN6NrfSpi14enableDataPipeEhb+0x36>
 801150c:	4b10      	ldr	r3, [pc, #64]	; (8011550 <_ZN6NrfSpi14enableDataPipeEhb+0x6c>)
 801150e:	4a11      	ldr	r2, [pc, #68]	; (8011554 <_ZN6NrfSpi14enableDataPipeEhb+0x70>)
 8011510:	f240 1105 	movw	r1, #261	; 0x105
 8011514:	4810      	ldr	r0, [pc, #64]	; (8011558 <_ZN6NrfSpi14enableDataPipeEhb+0x74>)
 8011516:	f004 ff3d 	bl	8016394 <__assert_func>

	if (enable)
 801151a:	78bb      	ldrb	r3, [r7, #2]
 801151c:	2b00      	cmp	r3, #0
 801151e:	d004      	beq.n	801152a <_ZN6NrfSpi14enableDataPipeEhb+0x46>
	{
		registerValue |= pipeMask;
 8011520:	7bfa      	ldrb	r2, [r7, #15]
 8011522:	78fb      	ldrb	r3, [r7, #3]
 8011524:	4313      	orrs	r3, r2
 8011526:	73fb      	strb	r3, [r7, #15]
 8011528:	e008      	b.n	801153c <_ZN6NrfSpi14enableDataPipeEhb+0x58>
	}
	else
	{
		registerValue &= ~pipeMask;
 801152a:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801152e:	43db      	mvns	r3, r3
 8011530:	b25a      	sxtb	r2, r3
 8011532:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8011536:	4013      	ands	r3, r2
 8011538:	b25b      	sxtb	r3, r3
 801153a:	73fb      	strb	r3, [r7, #15]
	}

	writeRegister(EN_RXADDR, registerValue);
 801153c:	7bfb      	ldrb	r3, [r7, #15]
 801153e:	461a      	mov	r2, r3
 8011540:	2102      	movs	r1, #2
 8011542:	6878      	ldr	r0, [r7, #4]
 8011544:	f7ff fed4 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 8011548:	bf00      	nop
 801154a:	3710      	adds	r7, #16
 801154c:	46bd      	mov	sp, r7
 801154e:	bd80      	pop	{r7, pc}
 8011550:	0801a160 	.word	0x0801a160
 8011554:	0801a180 	.word	0x0801a180
 8011558:	08019df4 	.word	0x08019df4

0801155c <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb>:
/**
 * Upon startup auto-acknowledgment for pipe 0 and pipe 1 are enabled by
 * default.
 */
void NrfSpi::enableAutoAcknowledgementForPipe(uint8_t pipeMask, bool enable)
{
 801155c:	b580      	push	{r7, lr}
 801155e:	b084      	sub	sp, #16
 8011560:	af00      	add	r7, sp, #0
 8011562:	6078      	str	r0, [r7, #4]
 8011564:	460b      	mov	r3, r1
 8011566:	70fb      	strb	r3, [r7, #3]
 8011568:	4613      	mov	r3, r2
 801156a:	70bb      	strb	r3, [r7, #2]
	tRegister registerValue = readRegister(EN_AA);
 801156c:	2101      	movs	r1, #1
 801156e:	6878      	ldr	r0, [r7, #4]
 8011570:	f7ff fe8c 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011574:	4603      	mov	r3, r0
 8011576:	73fb      	strb	r3, [r7, #15]

	assert((pipeMask & 0x3F) == pipeMask);		// Bits 6 and 7 shouldn't be touched
 8011578:	78fb      	ldrb	r3, [r7, #3]
 801157a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 801157e:	78fb      	ldrb	r3, [r7, #3]
 8011580:	429a      	cmp	r2, r3
 8011582:	d006      	beq.n	8011592 <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x36>
 8011584:	4b10      	ldr	r3, [pc, #64]	; (80115c8 <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x6c>)
 8011586:	4a11      	ldr	r2, [pc, #68]	; (80115cc <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x70>)
 8011588:	f240 111b 	movw	r1, #283	; 0x11b
 801158c:	4810      	ldr	r0, [pc, #64]	; (80115d0 <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x74>)
 801158e:	f004 ff01 	bl	8016394 <__assert_func>

	if (enable)
 8011592:	78bb      	ldrb	r3, [r7, #2]
 8011594:	2b00      	cmp	r3, #0
 8011596:	d004      	beq.n	80115a2 <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x46>
	{
		registerValue |= pipeMask;
 8011598:	7bfa      	ldrb	r2, [r7, #15]
 801159a:	78fb      	ldrb	r3, [r7, #3]
 801159c:	4313      	orrs	r3, r2
 801159e:	73fb      	strb	r3, [r7, #15]
 80115a0:	e008      	b.n	80115b4 <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb+0x58>
	}
	else
	{
		registerValue &= ~pipeMask;
 80115a2:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80115a6:	43db      	mvns	r3, r3
 80115a8:	b25a      	sxtb	r2, r3
 80115aa:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80115ae:	4013      	ands	r3, r2
 80115b0:	b25b      	sxtb	r3, r3
 80115b2:	73fb      	strb	r3, [r7, #15]
	}

	writeRegister(EN_AA, registerValue);
 80115b4:	7bfb      	ldrb	r3, [r7, #15]
 80115b6:	461a      	mov	r2, r3
 80115b8:	2101      	movs	r1, #1
 80115ba:	6878      	ldr	r0, [r7, #4]
 80115bc:	f7ff fe98 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 80115c0:	bf00      	nop
 80115c2:	3710      	adds	r7, #16
 80115c4:	46bd      	mov	sp, r7
 80115c6:	bd80      	pop	{r7, pc}
 80115c8:	0801a160 	.word	0x0801a160
 80115cc:	0801a1ac 	.word	0x0801a1ac
 80115d0:	08019df4 	.word	0x08019df4

080115d4 <_ZN6NrfSpi29enableDynamicTxAcknowledgmentEb>:
 * Enables feature that gives ability to transmit frames without receiving an acknowledgment.
 * After setting this feature you can send frames over the W_TX_PAYLOAD_NOACK register. This
 * will automatically set the NO_ACK bit in the frame being send.
 */
void NrfSpi::enableDynamicTxAcknowledgment(bool enable)
{
 80115d4:	b580      	push	{r7, lr}
 80115d6:	b084      	sub	sp, #16
 80115d8:	af00      	add	r7, sp, #0
 80115da:	6078      	str	r0, [r7, #4]
 80115dc:	460b      	mov	r3, r1
 80115de:	70fb      	strb	r3, [r7, #3]
	NrfSpi::tRegister reg;

	if (!featuresEnabled())
 80115e0:	6878      	ldr	r0, [r7, #4]
 80115e2:	f7ff fc55 	bl	8010e90 <_ZNK6NrfSpi15featuresEnabledEv>
 80115e6:	4603      	mov	r3, r0
 80115e8:	f083 0301 	eor.w	r3, r3, #1
 80115ec:	b2db      	uxtb	r3, r3
 80115ee:	2b00      	cmp	r3, #0
 80115f0:	d003      	beq.n	80115fa <_ZN6NrfSpi29enableDynamicTxAcknowledgmentEb+0x26>
	{
		activateFeatures(true);
 80115f2:	2101      	movs	r1, #1
 80115f4:	6878      	ldr	r0, [r7, #4]
 80115f6:	f7ff ff03 	bl	8011400 <_ZN6NrfSpi16activateFeaturesEb>
	}

	reg = readRegister(NrfSpi::FEATURE);
 80115fa:	211d      	movs	r1, #29
 80115fc:	6878      	ldr	r0, [r7, #4]
 80115fe:	f7ff fe45 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011602:	4603      	mov	r3, r0
 8011604:	73fb      	strb	r3, [r7, #15]

	if (enable)
 8011606:	78fb      	ldrb	r3, [r7, #3]
 8011608:	2b00      	cmp	r3, #0
 801160a:	d004      	beq.n	8011616 <_ZN6NrfSpi29enableDynamicTxAcknowledgmentEb+0x42>
	{
		reg |= FEATURE_REG_EN_DYN_ACK;
 801160c:	7bfb      	ldrb	r3, [r7, #15]
 801160e:	f043 0301 	orr.w	r3, r3, #1
 8011612:	73fb      	strb	r3, [r7, #15]
 8011614:	e003      	b.n	801161e <_ZN6NrfSpi29enableDynamicTxAcknowledgmentEb+0x4a>
	}
	else
	{
		reg &= ~FEATURE_REG_EN_DYN_ACK;
 8011616:	7bfb      	ldrb	r3, [r7, #15]
 8011618:	f023 0301 	bic.w	r3, r3, #1
 801161c:	73fb      	strb	r3, [r7, #15]
	}

	writeRegister(NrfSpi::FEATURE, reg);
 801161e:	7bfb      	ldrb	r3, [r7, #15]
 8011620:	461a      	mov	r2, r3
 8011622:	211d      	movs	r1, #29
 8011624:	6878      	ldr	r0, [r7, #4]
 8011626:	f7ff fe63 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 801162a:	bf00      	nop
 801162c:	3710      	adds	r7, #16
 801162e:	46bd      	mov	sp, r7
 8011630:	bd80      	pop	{r7, pc}

08011632 <_ZN6NrfSpi11rxFifoEmptyEv>:

bool NrfSpi::rxFifoEmpty()
{
 8011632:	b580      	push	{r7, lr}
 8011634:	b084      	sub	sp, #16
 8011636:	af00      	add	r7, sp, #0
 8011638:	6078      	str	r0, [r7, #4]
	const NrfSpi::tRegister reg = readRegister(NrfSpi::FIFO_STATUS);
 801163a:	2117      	movs	r1, #23
 801163c:	6878      	ldr	r0, [r7, #4]
 801163e:	f7ff fe25 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011642:	4603      	mov	r3, r0
 8011644:	73fb      	strb	r3, [r7, #15]

	return ((reg & FIFO_STATUS_RX_EMPTY) == FIFO_STATUS_RX_EMPTY) ? true : false;
 8011646:	7bfb      	ldrb	r3, [r7, #15]
 8011648:	f003 0301 	and.w	r3, r3, #1
 801164c:	b2db      	uxtb	r3, r3
}
 801164e:	4618      	mov	r0, r3
 8011650:	3710      	adds	r7, #16
 8011652:	46bd      	mov	sp, r7
 8011654:	bd80      	pop	{r7, pc}

08011656 <_ZN6NrfSpi10rxFifoFullEv>:

	return ((reg & FIFO_STATUS_TX_EMPTY) == FIFO_STATUS_TX_EMPTY) ? true : false;
}

bool NrfSpi::rxFifoFull()
{
 8011656:	b580      	push	{r7, lr}
 8011658:	b084      	sub	sp, #16
 801165a:	af00      	add	r7, sp, #0
 801165c:	6078      	str	r0, [r7, #4]
	const NrfSpi::tRegister reg = readRegister(NrfSpi::FIFO_STATUS);
 801165e:	2117      	movs	r1, #23
 8011660:	6878      	ldr	r0, [r7, #4]
 8011662:	f7ff fe13 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011666:	4603      	mov	r3, r0
 8011668:	73fb      	strb	r3, [r7, #15]

	return ((reg & FIFO_STATUS_RX_FULL) == FIFO_STATUS_RX_FULL) ? true : false;
 801166a:	7bfb      	ldrb	r3, [r7, #15]
 801166c:	105b      	asrs	r3, r3, #1
 801166e:	f003 0301 	and.w	r3, r3, #1
 8011672:	b2db      	uxtb	r3, r3
}
 8011674:	4618      	mov	r0, r3
 8011676:	3710      	adds	r7, #16
 8011678:	46bd      	mov	sp, r7
 801167a:	bd80      	pop	{r7, pc}

0801167c <_ZN6NrfSpi8sendByteEh>:
{
	return readRegister(NrfSpi::RPD);
}

NrfSpi::tStatus NrfSpi::sendByte(unsigned char data)
{
 801167c:	b580      	push	{r7, lr}
 801167e:	b082      	sub	sp, #8
 8011680:	af00      	add	r7, sp, #0
 8011682:	6078      	str	r0, [r7, #4]
 8011684:	460b      	mov	r3, r1
 8011686:	70fb      	strb	r3, [r7, #3]
	return spi().sendByte(data);
 8011688:	6878      	ldr	r0, [r7, #4]
 801168a:	f7ff fc46 	bl	8010f1a <_ZN6NrfSpi3spiEv>
 801168e:	4602      	mov	r2, r0
 8011690:	78fb      	ldrb	r3, [r7, #3]
 8011692:	4619      	mov	r1, r3
 8011694:	4610      	mov	r0, r2
 8011696:	f002 f871 	bl	801377c <_ZN3Spi8sendByteEh>
 801169a:	4603      	mov	r3, r0
}
 801169c:	4618      	mov	r0, r3
 801169e:	3708      	adds	r7, #8
 80116a0:	46bd      	mov	sp, r7
 80116a2:	bd80      	pop	{r7, pc}

080116a4 <_ZNK3phy7AddressILj4EEixEj>:
	const uint8_t & operator[]( size_t index ) const
 80116a4:	b580      	push	{r7, lr}
 80116a6:	b084      	sub	sp, #16
 80116a8:	af00      	add	r7, sp, #0
 80116aa:	6078      	str	r0, [r7, #4]
 80116ac:	6039      	str	r1, [r7, #0]
		assert( index < size );
 80116ae:	683b      	ldr	r3, [r7, #0]
 80116b0:	2b03      	cmp	r3, #3
 80116b2:	d905      	bls.n	80116c0 <_ZNK3phy7AddressILj4EEixEj+0x1c>
 80116b4:	4b0b      	ldr	r3, [pc, #44]	; (80116e4 <_ZNK3phy7AddressILj4EEixEj+0x40>)
 80116b6:	4a0c      	ldr	r2, [pc, #48]	; (80116e8 <_ZNK3phy7AddressILj4EEixEj+0x44>)
 80116b8:	2168      	movs	r1, #104	; 0x68
 80116ba:	480c      	ldr	r0, [pc, #48]	; (80116ec <_ZNK3phy7AddressILj4EEixEj+0x48>)
 80116bc:	f004 fe6a 	bl	8016394 <__assert_func>
		return _address[std::min( index , size - 1 )];
 80116c0:	2303      	movs	r3, #3
 80116c2:	60fb      	str	r3, [r7, #12]
 80116c4:	f107 020c 	add.w	r2, r7, #12
 80116c8:	463b      	mov	r3, r7
 80116ca:	4611      	mov	r1, r2
 80116cc:	4618      	mov	r0, r3
 80116ce:	f7f9 f956 	bl	800a97e <_ZSt3minIjERKT_S2_S2_>
 80116d2:	4603      	mov	r3, r0
 80116d4:	681b      	ldr	r3, [r3, #0]
 80116d6:	687a      	ldr	r2, [r7, #4]
 80116d8:	4413      	add	r3, r2
 80116da:	3304      	adds	r3, #4
	}
 80116dc:	4618      	mov	r0, r3
 80116de:	3710      	adds	r7, #16
 80116e0:	46bd      	mov	sp, r7
 80116e2:	bd80      	pop	{r7, pc}
 80116e4:	0801a2d4 	.word	0x0801a2d4
 80116e8:	0801a364 	.word	0x0801a364
 80116ec:	0801a260 	.word	0x0801a260

080116f0 <_Z41__static_initialization_and_destruction_0ii>:
 80116f0:	b580      	push	{r7, lr}
 80116f2:	b088      	sub	sp, #32
 80116f4:	af00      	add	r7, sp, #0
 80116f6:	6078      	str	r0, [r7, #4]
 80116f8:	6039      	str	r1, [r7, #0]
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	2b01      	cmp	r3, #1
 80116fe:	d122      	bne.n	8011746 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8011700:	683b      	ldr	r3, [r7, #0]
 8011702:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8011706:	4293      	cmp	r3, r2
 8011708:	d11d      	bne.n	8011746 <_Z41__static_initialization_and_destruction_0ii+0x56>
 801170a:	4b18      	ldr	r3, [pc, #96]	; (801176c <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 801170c:	681b      	ldr	r3, [r3, #0]
 801170e:	613b      	str	r3, [r7, #16]
 8011710:	f107 0310 	add.w	r3, r7, #16
 8011714:	60bb      	str	r3, [r7, #8]
 8011716:	2304      	movs	r3, #4
 8011718:	60fb      	str	r3, [r7, #12]
 801171a:	f107 0308 	add.w	r3, r7, #8
 801171e:	e893 0006 	ldmia.w	r3, {r1, r2}
 8011722:	4813      	ldr	r0, [pc, #76]	; (8011770 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8011724:	f7f5 fb06 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8011728:	4b12      	ldr	r3, [pc, #72]	; (8011774 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 801172a:	681b      	ldr	r3, [r3, #0]
 801172c:	61fb      	str	r3, [r7, #28]
 801172e:	f107 031c 	add.w	r3, r7, #28
 8011732:	617b      	str	r3, [r7, #20]
 8011734:	2304      	movs	r3, #4
 8011736:	61bb      	str	r3, [r7, #24]
 8011738:	f107 0314 	add.w	r3, r7, #20
 801173c:	e893 0006 	ldmia.w	r3, {r1, r2}
 8011740:	480d      	ldr	r0, [pc, #52]	; (8011778 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8011742:	f7f5 faf7 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8011746:	687b      	ldr	r3, [r7, #4]
 8011748:	2b00      	cmp	r3, #0
 801174a:	d10a      	bne.n	8011762 <_Z41__static_initialization_and_destruction_0ii+0x72>
 801174c:	683b      	ldr	r3, [r7, #0]
 801174e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8011752:	4293      	cmp	r3, r2
 8011754:	d105      	bne.n	8011762 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8011756:	4808      	ldr	r0, [pc, #32]	; (8011778 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8011758:	f7f5 fc36 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 801175c:	4804      	ldr	r0, [pc, #16]	; (8011770 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 801175e:	f7f5 fc33 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8011762:	bf00      	nop
 8011764:	3720      	adds	r7, #32
 8011766:	46bd      	mov	sp, r7
 8011768:	bd80      	pop	{r7, pc}
 801176a:	bf00      	nop
 801176c:	0801a3f0 	.word	0x0801a3f0
 8011770:	20001bf4 	.word	0x20001bf4
 8011774:	0801a3f4 	.word	0x0801a3f4
 8011778:	20001bfc 	.word	0x20001bfc

0801177c <_GLOBAL__sub_I__ZN6NrfSpiC2ER3Spi>:
 801177c:	b580      	push	{r7, lr}
 801177e:	af00      	add	r7, sp, #0
 8011780:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8011784:	2001      	movs	r0, #1
 8011786:	f7ff ffb3 	bl	80116f0 <_Z41__static_initialization_and_destruction_0ii>
 801178a:	bd80      	pop	{r7, pc}

0801178c <_GLOBAL__sub_D__ZN6NrfSpiC2ER3Spi>:
 801178c:	b580      	push	{r7, lr}
 801178e:	af00      	add	r7, sp, #0
 8011790:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8011794:	2000      	movs	r0, #0
 8011796:	f7ff ffab 	bl	80116f0 <_Z41__static_initialization_and_destruction_0ii>
 801179a:	bd80      	pop	{r7, pc}

0801179c <_ZN15IPhyTransceiverC1Ev>:
 */
class IPhyTransceiver
{
protected:
	// It is just an interface, so constructor and destructor should nor be public.
	IPhyTransceiver() {}
 801179c:	b480      	push	{r7}
 801179e:	b083      	sub	sp, #12
 80117a0:	af00      	add	r7, sp, #0
 80117a2:	6078      	str	r0, [r7, #4]
 80117a4:	4a04      	ldr	r2, [pc, #16]	; (80117b8 <_ZN15IPhyTransceiverC1Ev+0x1c>)
 80117a6:	687b      	ldr	r3, [r7, #4]
 80117a8:	601a      	str	r2, [r3, #0]
 80117aa:	687b      	ldr	r3, [r7, #4]
 80117ac:	4618      	mov	r0, r3
 80117ae:	370c      	adds	r7, #12
 80117b0:	46bd      	mov	sp, r7
 80117b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80117b6:	4770      	bx	lr
 80117b8:	0801dae0 	.word	0x0801dae0

080117bc <_ZN15IPhyTransceiverD1Ev>:
	virtual ~IPhyTransceiver() {}
 80117bc:	b480      	push	{r7}
 80117be:	b083      	sub	sp, #12
 80117c0:	af00      	add	r7, sp, #0
 80117c2:	6078      	str	r0, [r7, #4]
 80117c4:	4a04      	ldr	r2, [pc, #16]	; (80117d8 <_ZN15IPhyTransceiverD1Ev+0x1c>)
 80117c6:	687b      	ldr	r3, [r7, #4]
 80117c8:	601a      	str	r2, [r3, #0]
 80117ca:	687b      	ldr	r3, [r7, #4]
 80117cc:	4618      	mov	r0, r3
 80117ce:	370c      	adds	r7, #12
 80117d0:	46bd      	mov	sp, r7
 80117d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80117d6:	4770      	bx	lr
 80117d8:	0801dae0 	.word	0x0801dae0

080117dc <_ZN15IPhyTransceiverD0Ev>:
 80117dc:	b580      	push	{r7, lr}
 80117de:	b082      	sub	sp, #8
 80117e0:	af00      	add	r7, sp, #0
 80117e2:	6078      	str	r0, [r7, #4]
 80117e4:	6878      	ldr	r0, [r7, #4]
 80117e6:	f7ff ffe9 	bl	80117bc <_ZN15IPhyTransceiverD1Ev>
 80117ea:	2104      	movs	r1, #4
 80117ec:	6878      	ldr	r0, [r7, #4]
 80117ee:	f004 fcdd 	bl	80161ac <_ZdlPvj>
 80117f2:	687b      	ldr	r3, [r7, #4]
 80117f4:	4618      	mov	r0, r3
 80117f6:	3708      	adds	r7, #8
 80117f8:	46bd      	mov	sp, r7
 80117fa:	bd80      	pop	{r7, pc}

080117fc <_ZNK6NrfSpi8enableCEEv>:
	inline void enableCE() const { HAL_GPIO_WritePin(NRF_CE_GPIO_Port, NRF_CE_Pin, GPIO_PIN_SET); sDelay(CE_HIGH_TIME); }
 80117fc:	b580      	push	{r7, lr}
 80117fe:	b082      	sub	sp, #8
 8011800:	af00      	add	r7, sp, #0
 8011802:	6078      	str	r0, [r7, #4]
 8011804:	2201      	movs	r2, #1
 8011806:	2104      	movs	r1, #4
 8011808:	4805      	ldr	r0, [pc, #20]	; (8011820 <_ZNK6NrfSpi8enableCEEv+0x24>)
 801180a:	f7f0 fa07 	bl	8001c1c <HAL_GPIO_WritePin>
 801180e:	f242 7110 	movw	r1, #10000	; 0x2710
 8011812:	6878      	ldr	r0, [r7, #4]
 8011814:	f7ff fb48 	bl	8010ea8 <_ZNK6NrfSpi6sDelayEm>
 8011818:	bf00      	nop
 801181a:	3708      	adds	r7, #8
 801181c:	46bd      	mov	sp, r7
 801181e:	bd80      	pop	{r7, pc}
 8011820:	48000c00 	.word	0x48000c00

08011824 <_ZNK6NrfSpi9disableCEEv>:
	inline void disableCE() const { HAL_GPIO_WritePin(NRF_CE_GPIO_Port, NRF_CE_Pin, GPIO_PIN_RESET); }
 8011824:	b580      	push	{r7, lr}
 8011826:	b082      	sub	sp, #8
 8011828:	af00      	add	r7, sp, #0
 801182a:	6078      	str	r0, [r7, #4]
 801182c:	2200      	movs	r2, #0
 801182e:	2104      	movs	r1, #4
 8011830:	4803      	ldr	r0, [pc, #12]	; (8011840 <_ZNK6NrfSpi9disableCEEv+0x1c>)
 8011832:	f7f0 f9f3 	bl	8001c1c <HAL_GPIO_WritePin>
 8011836:	bf00      	nop
 8011838:	3708      	adds	r7, #8
 801183a:	46bd      	mov	sp, r7
 801183c:	bd80      	pop	{r7, pc}
 801183e:	bf00      	nop
 8011840:	48000c00 	.word	0x48000c00

08011844 <_ZN5board14NrfTransceiver11flushTxFifoEv>:
	void setDestinationAddress(tAddress address);
	void setReceptionAddress(uint8_t pipeIndex, const tAddress & rxAddress);
	void setAddressWidth(unsigned char widthInByte);
	bool activateFeatures(bool enable);
	void enableDPL(bool enable, unsigned char pipeMask = 0x00);
	inline void flushTxFifo() { NrfSpi::sendCmd(NrfSpi::FLUSH_TX); }
 8011844:	b580      	push	{r7, lr}
 8011846:	b082      	sub	sp, #8
 8011848:	af00      	add	r7, sp, #0
 801184a:	6078      	str	r0, [r7, #4]
 801184c:	687b      	ldr	r3, [r7, #4]
 801184e:	3304      	adds	r3, #4
 8011850:	21e1      	movs	r1, #225	; 0xe1
 8011852:	4618      	mov	r0, r3
 8011854:	f7ff fbd4 	bl	8011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>
 8011858:	bf00      	nop
 801185a:	3708      	adds	r7, #8
 801185c:	46bd      	mov	sp, r7
 801185e:	bd80      	pop	{r7, pc}

08011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>:
	inline void flushRxFifo() { NrfSpi::sendCmd(NrfSpi::FLUSH_RX); }
 8011860:	b580      	push	{r7, lr}
 8011862:	b082      	sub	sp, #8
 8011864:	af00      	add	r7, sp, #0
 8011866:	6078      	str	r0, [r7, #4]
 8011868:	687b      	ldr	r3, [r7, #4]
 801186a:	3304      	adds	r3, #4
 801186c:	21e2      	movs	r1, #226	; 0xe2
 801186e:	4618      	mov	r0, r3
 8011870:	f7ff fbc6 	bl	8011000 <_ZN6NrfSpi7sendCmdENS_10eNrfSpiCmdE>
 8011874:	bf00      	nop
 8011876:	3708      	adds	r7, #8
 8011878:	46bd      	mov	sp, r7
 801187a:	bd80      	pop	{r7, pc}

0801187c <_ZN5board14NrfTransceiver8observerEv>:

	inline IPhyObserver & observer() { return *_pObserver; }
 801187c:	b480      	push	{r7}
 801187e:	b083      	sub	sp, #12
 8011880:	af00      	add	r7, sp, #0
 8011882:	6078      	str	r0, [r7, #4]
 8011884:	687b      	ldr	r3, [r7, #4]
 8011886:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011888:	4618      	mov	r0, r3
 801188a:	370c      	adds	r7, #12
 801188c:	46bd      	mov	sp, r7
 801188e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011892:	4770      	bx	lr

08011894 <_ZN5board14NrfTransceiverC1Ev>:
using board::NrfTransceiver;

static const size_t MaximalPayloadSize = 32;
NrfTransceiver * NrfTransceiver::_pInstance(nullptr);

NrfTransceiver::NrfTransceiver()
 8011894:	b5b0      	push	{r4, r5, r7, lr}
 8011896:	b082      	sub	sp, #8
 8011898:	af00      	add	r7, sp, #0
 801189a:	6078      	str	r0, [r7, #4]
 : NrfSpi(Spi::instance(2 /* SPI3 */)),
   _bInitialized(false),
   _channel(2),			// Reset value given by register reset value (RF_CH register)
   _pObserver(NULL),
   _bEnabled(false),
   _autoAck(true)		// Per default enabled by the NrfTransceiver hardware
 801189c:	687b      	ldr	r3, [r7, #4]
 801189e:	4618      	mov	r0, r3
 80118a0:	f7ff ff7c 	bl	801179c <_ZN15IPhyTransceiverC1Ev>
 80118a4:	687b      	ldr	r3, [r7, #4]
 80118a6:	1d1c      	adds	r4, r3, #4
 80118a8:	2002      	movs	r0, #2
 80118aa:	f001 fea5 	bl	80135f8 <_ZN3Spi8instanceEh>
 80118ae:	4603      	mov	r3, r0
 80118b0:	4619      	mov	r1, r3
 80118b2:	4620      	mov	r0, r4
 80118b4:	f7ff fb3e 	bl	8010f34 <_ZN6NrfSpiC1ER3Spi>
 80118b8:	687b      	ldr	r3, [r7, #4]
 80118ba:	3314      	adds	r3, #20
 80118bc:	2100      	movs	r1, #0
 80118be:	4618      	mov	r0, r3
 80118c0:	f002 fc30 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 80118c4:	4a1c      	ldr	r2, [pc, #112]	; (8011938 <_ZN5board14NrfTransceiverC1Ev+0xa4>)
 80118c6:	687b      	ldr	r3, [r7, #4]
 80118c8:	601a      	str	r2, [r3, #0]
 80118ca:	4a1c      	ldr	r2, [pc, #112]	; (801193c <_ZN5board14NrfTransceiverC1Ev+0xa8>)
 80118cc:	687b      	ldr	r3, [r7, #4]
 80118ce:	605a      	str	r2, [r3, #4]
 80118d0:	4a1b      	ldr	r2, [pc, #108]	; (8011940 <_ZN5board14NrfTransceiverC1Ev+0xac>)
 80118d2:	687b      	ldr	r3, [r7, #4]
 80118d4:	615a      	str	r2, [r3, #20]
 80118d6:	687b      	ldr	r3, [r7, #4]
 80118d8:	2200      	movs	r2, #0
 80118da:	f883 2020 	strb.w	r2, [r3, #32]
 80118de:	687b      	ldr	r3, [r7, #4]
 80118e0:	2202      	movs	r2, #2
 80118e2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	2200      	movs	r2, #0
 80118ea:	625a      	str	r2, [r3, #36]	; 0x24
 80118ec:	687b      	ldr	r3, [r7, #4]
 80118ee:	2200      	movs	r2, #0
 80118f0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 80118f4:	687b      	ldr	r3, [r7, #4]
 80118f6:	2201      	movs	r2, #1
 80118f8:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 80118fc:	687b      	ldr	r3, [r7, #4]
 80118fe:	332c      	adds	r3, #44	; 0x2c
 8011900:	2405      	movs	r4, #5
 8011902:	461d      	mov	r5, r3
 8011904:	2c00      	cmp	r4, #0
 8011906:	db05      	blt.n	8011914 <_ZN5board14NrfTransceiverC1Ev+0x80>
 8011908:	4628      	mov	r0, r5
 801190a:	f7f7 fc57 	bl	80091bc <_ZN3phy7AddressILj4EEC1Ev>
 801190e:	3508      	adds	r5, #8
 8011910:	3c01      	subs	r4, #1
 8011912:	e7f7      	b.n	8011904 <_ZN5board14NrfTransceiverC1Ev+0x70>
{
	assert(!_pInstance);		// Only one instance allowed
 8011914:	4b0b      	ldr	r3, [pc, #44]	; (8011944 <_ZN5board14NrfTransceiverC1Ev+0xb0>)
 8011916:	681b      	ldr	r3, [r3, #0]
 8011918:	2b00      	cmp	r3, #0
 801191a:	d005      	beq.n	8011928 <_ZN5board14NrfTransceiverC1Ev+0x94>
 801191c:	4b0a      	ldr	r3, [pc, #40]	; (8011948 <_ZN5board14NrfTransceiverC1Ev+0xb4>)
 801191e:	4a0b      	ldr	r2, [pc, #44]	; (801194c <_ZN5board14NrfTransceiverC1Ev+0xb8>)
 8011920:	211e      	movs	r1, #30
 8011922:	480b      	ldr	r0, [pc, #44]	; (8011950 <_ZN5board14NrfTransceiverC1Ev+0xbc>)
 8011924:	f004 fd36 	bl	8016394 <__assert_func>
	_pInstance = this;
 8011928:	4a06      	ldr	r2, [pc, #24]	; (8011944 <_ZN5board14NrfTransceiverC1Ev+0xb0>)
 801192a:	687b      	ldr	r3, [r7, #4]
 801192c:	6013      	str	r3, [r2, #0]
}
 801192e:	687b      	ldr	r3, [r7, #4]
 8011930:	4618      	mov	r0, r3
 8011932:	3708      	adds	r7, #8
 8011934:	46bd      	mov	sp, r7
 8011936:	bdb0      	pop	{r4, r5, r7, pc}
 8011938:	0801da78 	.word	0x0801da78
 801193c:	0801daac 	.word	0x0801daac
 8011940:	0801dabc 	.word	0x0801dabc
 8011944:	20001c14 	.word	0x20001c14
 8011948:	0801a3f8 	.word	0x0801a3f8
 801194c:	0801a404 	.word	0x0801a404
 8011950:	0801a42c 	.word	0x0801a42c

08011954 <_ZN5board14NrfTransceiverD1Ev>:

NrfTransceiver::~NrfTransceiver()
 8011954:	b590      	push	{r4, r7, lr}
 8011956:	b083      	sub	sp, #12
 8011958:	af00      	add	r7, sp, #0
 801195a:	6078      	str	r0, [r7, #4]
 801195c:	4a16      	ldr	r2, [pc, #88]	; (80119b8 <_ZN5board14NrfTransceiverD1Ev+0x64>)
 801195e:	687b      	ldr	r3, [r7, #4]
 8011960:	601a      	str	r2, [r3, #0]
 8011962:	4a16      	ldr	r2, [pc, #88]	; (80119bc <_ZN5board14NrfTransceiverD1Ev+0x68>)
 8011964:	687b      	ldr	r3, [r7, #4]
 8011966:	605a      	str	r2, [r3, #4]
 8011968:	4a15      	ldr	r2, [pc, #84]	; (80119c0 <_ZN5board14NrfTransceiverD1Ev+0x6c>)
 801196a:	687b      	ldr	r3, [r7, #4]
 801196c:	615a      	str	r2, [r3, #20]
 801196e:	687b      	ldr	r3, [r7, #4]
 8011970:	332c      	adds	r3, #44	; 0x2c
 8011972:	2b00      	cmp	r3, #0
 8011974:	d00d      	beq.n	8011992 <_ZN5board14NrfTransceiverD1Ev+0x3e>
 8011976:	687b      	ldr	r3, [r7, #4]
 8011978:	332c      	adds	r3, #44	; 0x2c
 801197a:	f103 0430 	add.w	r4, r3, #48	; 0x30
 801197e:	687b      	ldr	r3, [r7, #4]
 8011980:	332c      	adds	r3, #44	; 0x2c
 8011982:	429c      	cmp	r4, r3
 8011984:	d005      	beq.n	8011992 <_ZN5board14NrfTransceiverD1Ev+0x3e>
 8011986:	3c08      	subs	r4, #8
 8011988:	6823      	ldr	r3, [r4, #0]
 801198a:	681b      	ldr	r3, [r3, #0]
 801198c:	4620      	mov	r0, r4
 801198e:	4798      	blx	r3
 8011990:	e7f5      	b.n	801197e <_ZN5board14NrfTransceiverD1Ev+0x2a>
 8011992:	687b      	ldr	r3, [r7, #4]
 8011994:	3314      	adds	r3, #20
 8011996:	4618      	mov	r0, r3
 8011998:	f002 fbe6 	bl	8014168 <_ZN10XFReactiveD1Ev>
 801199c:	687b      	ldr	r3, [r7, #4]
 801199e:	3304      	adds	r3, #4
 80119a0:	4618      	mov	r0, r3
 80119a2:	f7ff fae1 	bl	8010f68 <_ZN6NrfSpiD1Ev>
 80119a6:	687b      	ldr	r3, [r7, #4]
 80119a8:	4618      	mov	r0, r3
 80119aa:	f7ff ff07 	bl	80117bc <_ZN15IPhyTransceiverD1Ev>
{

}
 80119ae:	687b      	ldr	r3, [r7, #4]
 80119b0:	4618      	mov	r0, r3
 80119b2:	370c      	adds	r7, #12
 80119b4:	46bd      	mov	sp, r7
 80119b6:	bd90      	pop	{r4, r7, pc}
 80119b8:	0801da78 	.word	0x0801da78
 80119bc:	0801daac 	.word	0x0801daac
 80119c0:	0801dabc 	.word	0x0801dabc

080119c4 <_ZThn4_N5board14NrfTransceiverD1Ev>:
	virtual ~NrfTransceiver();
 80119c4:	f1a0 0004 	sub.w	r0, r0, #4
 80119c8:	f7ff bfc4 	b.w	8011954 <_ZN5board14NrfTransceiverD1Ev>

080119cc <_ZThn20_N5board14NrfTransceiverD1Ev>:
 80119cc:	f1a0 0014 	sub.w	r0, r0, #20
 80119d0:	f7ff bfc0 	b.w	8011954 <_ZN5board14NrfTransceiverD1Ev>

080119d4 <_ZN5board14NrfTransceiverD0Ev>:
NrfTransceiver::~NrfTransceiver()
 80119d4:	b580      	push	{r7, lr}
 80119d6:	b082      	sub	sp, #8
 80119d8:	af00      	add	r7, sp, #0
 80119da:	6078      	str	r0, [r7, #4]
}
 80119dc:	6878      	ldr	r0, [r7, #4]
 80119de:	f7ff ffb9 	bl	8011954 <_ZN5board14NrfTransceiverD1Ev>
 80119e2:	215c      	movs	r1, #92	; 0x5c
 80119e4:	6878      	ldr	r0, [r7, #4]
 80119e6:	f004 fbe1 	bl	80161ac <_ZdlPvj>
 80119ea:	687b      	ldr	r3, [r7, #4]
 80119ec:	4618      	mov	r0, r3
 80119ee:	3708      	adds	r7, #8
 80119f0:	46bd      	mov	sp, r7
 80119f2:	bd80      	pop	{r7, pc}

080119f4 <_ZThn20_N5board14NrfTransceiverD0Ev>:
 80119f4:	f1a0 0014 	sub.w	r0, r0, #20
 80119f8:	f7ff bfec 	b.w	80119d4 <_ZN5board14NrfTransceiverD0Ev>

080119fc <_ZThn4_N5board14NrfTransceiverD0Ev>:
 80119fc:	f1a0 0004 	sub.w	r0, r0, #4
 8011a00:	f7ff bfe8 	b.w	80119d4 <_ZN5board14NrfTransceiverD0Ev>

08011a04 <_ZN5board14NrfTransceiver10initializeEv>:

bool NrfTransceiver::initialize()
{
 8011a04:	b590      	push	{r4, r7, lr}
 8011a06:	b083      	sub	sp, #12
 8011a08:	af00      	add	r7, sp, #0
 8011a0a:	6078      	str	r0, [r7, #4]
	if (!_bInitialized)
 8011a0c:	687b      	ldr	r3, [r7, #4]
 8011a0e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8011a12:	f083 0301 	eor.w	r3, r3, #1
 8011a16:	b2db      	uxtb	r3, r3
 8011a18:	2b00      	cmp	r3, #0
 8011a1a:	d079      	beq.n	8011b10 <_ZN5board14NrfTransceiver10initializeEv+0x10c>
	{
		_bInitialized = true;
 8011a1c:	687b      	ldr	r3, [r7, #4]
 8011a1e:	2201      	movs	r2, #1
 8011a20:	f883 2020 	strb.w	r2, [r3, #32]
#if !(NRFTRANSCEIVER_TRACE_VERBOSE != 0)
		Trace::outln("Nrf: Verbose Trace disabled");
#endif

		// Initialize SPI used for NrfTransceiver
		NrfSpi::initialize();
 8011a24:	687b      	ldr	r3, [r7, #4]
 8011a26:	3304      	adds	r3, #4
 8011a28:	4618      	mov	r0, r3
 8011a2a:	f7ff fabd 	bl	8010fa8 <_ZN6NrfSpi10initializeEv>

		//
		// Now the nRF transceiver can be accessed correctly
		//

		NrfSpi::disableCS();		// Release transceiver
 8011a2e:	687b      	ldr	r3, [r7, #4]
 8011a30:	3304      	adds	r3, #4
 8011a32:	4618      	mov	r0, r3
 8011a34:	f7ff fa62 	bl	8010efc <_ZNK6NrfSpi9disableCSEv>
		NrfSpi::disableCE();		// Discard transmission
 8011a38:	687b      	ldr	r3, [r7, #4]
 8011a3a:	3304      	adds	r3, #4
 8011a3c:	4618      	mov	r0, r3
 8011a3e:	f7ff fef1 	bl	8011824 <_ZNK6NrfSpi9disableCEEv>

		// Reset FIFOs
		flushTxFifo();
 8011a42:	6878      	ldr	r0, [r7, #4]
 8011a44:	f7ff fefe 	bl	8011844 <_ZN5board14NrfTransceiver11flushTxFifoEv>
		flushRxFifo();
 8011a48:	6878      	ldr	r0, [r7, #4]
 8011a4a:	f7ff ff09 	bl	8011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>

		// Reset NRF IRQ status bits
		NrfSpi::writeRegister(NrfSpi::STATUS, (NrfSpi::STATUS_REG_RX_DR | NrfSpi::STATUS_REG_TX_DS | NrfSpi::STATUS_REG_MAX_RT));
 8011a4e:	687b      	ldr	r3, [r7, #4]
 8011a50:	3304      	adds	r3, #4
 8011a52:	2270      	movs	r2, #112	; 0x70
 8011a54:	2107      	movs	r1, #7
 8011a56:	4618      	mov	r0, r3
 8011a58:	f7ff fc4a 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>

		// Set address width used
		setAddressWidth(tAddress::addressSize());
 8011a5c:	f7f7 fbe4 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 8011a60:	4603      	mov	r3, r0
 8011a62:	b2db      	uxtb	r3, r3
 8011a64:	4619      	mov	r1, r3
 8011a66:	6878      	ldr	r0, [r7, #4]
 8011a68:	f000 faa2 	bl	8011fb0 <_ZN5board14NrfTransceiver15setAddressWidthEh>
		assert((size_t)(NrfSpi::readRegister(NrfSpi::SETUP_AW) + 2) == tAddress::addressSize());
 8011a6c:	687b      	ldr	r3, [r7, #4]
 8011a6e:	3304      	adds	r3, #4
 8011a70:	2103      	movs	r1, #3
 8011a72:	4618      	mov	r0, r3
 8011a74:	f7ff fc0a 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011a78:	4603      	mov	r3, r0
 8011a7a:	3302      	adds	r3, #2
 8011a7c:	461c      	mov	r4, r3
 8011a7e:	f7f7 fbd3 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 8011a82:	4603      	mov	r3, r0
 8011a84:	429c      	cmp	r4, r3
 8011a86:	d005      	beq.n	8011a94 <_ZN5board14NrfTransceiver10initializeEv+0x90>
 8011a88:	4b24      	ldr	r3, [pc, #144]	; (8011b1c <_ZN5board14NrfTransceiver10initializeEv+0x118>)
 8011a8a:	4a25      	ldr	r2, [pc, #148]	; (8011b20 <_ZN5board14NrfTransceiver10initializeEv+0x11c>)
 8011a8c:	2144      	movs	r1, #68	; 0x44
 8011a8e:	4825      	ldr	r0, [pc, #148]	; (8011b24 <_ZN5board14NrfTransceiver10initializeEv+0x120>)
 8011a90:	f004 fc80 	bl	8016394 <__assert_func>

		activateFeatures(true);
 8011a94:	2101      	movs	r1, #1
 8011a96:	6878      	ldr	r0, [r7, #4]
 8011a98:	f000 fab4 	bl	8012004 <_ZN5board14NrfTransceiver16activateFeaturesEb>
		enableDPL(true, 0x03);		// Enable dynamic payload size for pipe 0 and 1
 8011a9c:	2203      	movs	r2, #3
 8011a9e:	2101      	movs	r1, #1
 8011aa0:	6878      	ldr	r0, [r7, #4]
 8011aa2:	f000 fac1 	bl	8012028 <_ZN5board14NrfTransceiver9enableDPLEbh>
		assert((NrfSpi::readRegister(NrfSpi::FEATURE) & NrfSpi::FEATURE_REG_EN_DPL) == FEATURE_REG_EN_DPL);
 8011aa6:	687b      	ldr	r3, [r7, #4]
 8011aa8:	3304      	adds	r3, #4
 8011aaa:	211d      	movs	r1, #29
 8011aac:	4618      	mov	r0, r3
 8011aae:	f7ff fbed 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8011ab2:	4603      	mov	r3, r0
 8011ab4:	f003 0304 	and.w	r3, r3, #4
 8011ab8:	2b04      	cmp	r3, #4
 8011aba:	d005      	beq.n	8011ac8 <_ZN5board14NrfTransceiver10initializeEv+0xc4>
 8011abc:	4b1a      	ldr	r3, [pc, #104]	; (8011b28 <_ZN5board14NrfTransceiver10initializeEv+0x124>)
 8011abe:	4a18      	ldr	r2, [pc, #96]	; (8011b20 <_ZN5board14NrfTransceiver10initializeEv+0x11c>)
 8011ac0:	2148      	movs	r1, #72	; 0x48
 8011ac2:	4818      	ldr	r0, [pc, #96]	; (8011b24 <_ZN5board14NrfTransceiver10initializeEv+0x120>)
 8011ac4:	f004 fc66 	bl	8016394 <__assert_func>

		// Enable feature that gives ability to transmit frames without receiving an acknowledgment
		NrfSpi::enableDynamicTxAcknowledgment(true);
 8011ac8:	687b      	ldr	r3, [r7, #4]
 8011aca:	3304      	adds	r3, #4
 8011acc:	2101      	movs	r1, #1
 8011ace:	4618      	mov	r0, r3
 8011ad0:	f7ff fd80 	bl	80115d4 <_ZN6NrfSpi29enableDynamicTxAcknowledgmentEb>

		// Basic configuration for CONFIG register: Enable CRC
		NrfSpi::writeRegister(NrfSpi::CONFIG, NrfSpi::CONFIG_REG_EN_CRC);
 8011ad4:	687b      	ldr	r3, [r7, #4]
 8011ad6:	3304      	adds	r3, #4
 8011ad8:	2208      	movs	r2, #8
 8011ada:	2100      	movs	r1, #0
 8011adc:	4618      	mov	r0, r3
 8011ade:	f7ff fc07 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>

		// Initialized pipes according application needs
		_initializePipes();
 8011ae2:	687b      	ldr	r3, [r7, #4]
 8011ae4:	681b      	ldr	r3, [r3, #0]
 8011ae6:	3324      	adds	r3, #36	; 0x24
 8011ae8:	681b      	ldr	r3, [r3, #0]
 8011aea:	6878      	ldr	r0, [r7, #4]
 8011aec:	4798      	blx	r3

		// Initialize and enable IRQ for the NRF_IRQ line (GPIO RC9)
		_initNrfTransceiverIrq();
 8011aee:	6878      	ldr	r0, [r7, #4]
 8011af0:	f000 f81c 	bl	8011b2c <_ZNK5board14NrfTransceiver22_initNrfTransceiverIrqEv>

		// Set (again) hardware default values of the Nrf chip
		setRadioChannel(2);
 8011af4:	687b      	ldr	r3, [r7, #4]
 8011af6:	681b      	ldr	r3, [r3, #0]
 8011af8:	3318      	adds	r3, #24
 8011afa:	681b      	ldr	r3, [r3, #0]
 8011afc:	2102      	movs	r1, #2
 8011afe:	6878      	ldr	r0, [r7, #4]
 8011b00:	4798      	blx	r3

		// Enable transceiver (and enter RX mode)
		setMode(Active);
 8011b02:	687b      	ldr	r3, [r7, #4]
 8011b04:	681b      	ldr	r3, [r3, #0]
 8011b06:	3310      	adds	r3, #16
 8011b08:	681b      	ldr	r3, [r3, #0]
 8011b0a:	2102      	movs	r1, #2
 8011b0c:	6878      	ldr	r0, [r7, #4]
 8011b0e:	4798      	blx	r3
	}

	return true;
 8011b10:	2301      	movs	r3, #1
}
 8011b12:	4618      	mov	r0, r3
 8011b14:	370c      	adds	r7, #12
 8011b16:	46bd      	mov	sp, r7
 8011b18:	bd90      	pop	{r4, r7, pc}
 8011b1a:	bf00      	nop
 8011b1c:	0801a4c8 	.word	0x0801a4c8
 8011b20:	0801a518 	.word	0x0801a518
 8011b24:	0801a42c 	.word	0x0801a42c
 8011b28:	0801a54c 	.word	0x0801a54c

08011b2c <_ZNK5board14NrfTransceiver22_initNrfTransceiverIrqEv>:

void NrfTransceiver::_initNrfTransceiverIrq() const
{
 8011b2c:	b480      	push	{r7}
 8011b2e:	b083      	sub	sp, #12
 8011b30:	af00      	add	r7, sp, #0
 8011b32:	6078      	str	r0, [r7, #4]

}
 8011b34:	bf00      	nop
 8011b36:	370c      	adds	r7, #12
 8011b38:	46bd      	mov	sp, r7
 8011b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b3e:	4770      	bx	lr

08011b40 <_ZN5board14NrfTransceiver16_initializePipesEv>:

void NrfTransceiver::_initializePipes()
{
 8011b40:	b580      	push	{r7, lr}
 8011b42:	b084      	sub	sp, #16
 8011b44:	af00      	add	r7, sp, #0
 8011b46:	6078      	str	r0, [r7, #4]
	setDestinationAddress(SENSOR_ADDRESS);

#else // DESENET_SENSOR_NODE
	// Configure pipe 0
	// Used to receive sensor data
	NrfSpi::enableDataPipe(0x01, true);
 8011b48:	687b      	ldr	r3, [r7, #4]
 8011b4a:	3304      	adds	r3, #4
 8011b4c:	2201      	movs	r2, #1
 8011b4e:	2101      	movs	r1, #1
 8011b50:	4618      	mov	r0, r3
 8011b52:	f7ff fcc7 	bl	80114e4 <_ZN6NrfSpi14enableDataPipeEhb>
	// Set reception address to listen on
	setReceptionAddress(0, SENSOR_ADDRESS);
 8011b56:	4a1b      	ldr	r2, [pc, #108]	; (8011bc4 <_ZN5board14NrfTransceiver16_initializePipesEv+0x84>)
 8011b58:	2100      	movs	r1, #0
 8011b5a:	6878      	ldr	r0, [r7, #4]
 8011b5c:	f000 fa06 	bl	8011f6c <_ZN5board14NrfTransceiver19setReceptionAddressEhRKN3phy7AddressILj4EEE>
	// Disable auto-ack for pipe 0. Sensor does only listen on this
	// pipe for beacons, but does not acknowledge them.
	NrfSpi::enableAutoAcknowledgementForPipe(0x01, false);
 8011b60:	687b      	ldr	r3, [r7, #4]
 8011b62:	3304      	adds	r3, #4
 8011b64:	2200      	movs	r2, #0
 8011b66:	2101      	movs	r1, #1
 8011b68:	4618      	mov	r0, r3
 8011b6a:	f7ff fcf7 	bl	801155c <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb>

	// Configure pipe 1
	// Enable pipe 1
	NrfSpi::enableDataPipe(0x02, false);
 8011b6e:	687b      	ldr	r3, [r7, #4]
 8011b70:	3304      	adds	r3, #4
 8011b72:	2200      	movs	r2, #0
 8011b74:	2102      	movs	r1, #2
 8011b76:	4618      	mov	r0, r3
 8011b78:	f7ff fcb4 	bl	80114e4 <_ZN6NrfSpi14enableDataPipeEhb>
	// Set reception address to listen on
	setReceptionAddress(1, GATEWAY_ADDRESS);
 8011b7c:	4a12      	ldr	r2, [pc, #72]	; (8011bc8 <_ZN5board14NrfTransceiver16_initializePipesEv+0x88>)
 8011b7e:	2101      	movs	r1, #1
 8011b80:	6878      	ldr	r0, [r7, #4]
 8011b82:	f000 f9f3 	bl	8011f6c <_ZN5board14NrfTransceiver19setReceptionAddressEhRKN3phy7AddressILj4EEE>
	// Disable auto-ack for pipe 1. Sensor does only listen on this
	// pipe for sensor data from other sensor.
	NrfSpi::enableAutoAcknowledgementForPipe(0x02, false);
 8011b86:	687b      	ldr	r3, [r7, #4]
 8011b88:	3304      	adds	r3, #4
 8011b8a:	2200      	movs	r2, #0
 8011b8c:	2102      	movs	r1, #2
 8011b8e:	4618      	mov	r0, r3
 8011b90:	f7ff fce4 	bl	801155c <_ZN6NrfSpi32enableAutoAcknowledgementForPipeEhb>

	// Set TX address used when sending sensor data frames
	setDestinationAddress(GATEWAY_ADDRESS);
 8011b94:	f107 0308 	add.w	r3, r7, #8
 8011b98:	490b      	ldr	r1, [pc, #44]	; (8011bc8 <_ZN5board14NrfTransceiver16_initializePipesEv+0x88>)
 8011b9a:	4618      	mov	r0, r3
 8011b9c:	f7ff f938 	bl	8010e10 <_ZN3phy7AddressILj4EEC1ERKS1_>
 8011ba0:	f107 0308 	add.w	r3, r7, #8
 8011ba4:	4619      	mov	r1, r3
 8011ba6:	6878      	ldr	r0, [r7, #4]
 8011ba8:	f000 f9d0 	bl	8011f4c <_ZN5board14NrfTransceiver21setDestinationAddressEN3phy7AddressILj4EEE>
 8011bac:	f107 0308 	add.w	r3, r7, #8
 8011bb0:	4618      	mov	r0, r3
 8011bb2:	f7f5 fa09 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>

	enterRXMode();	// Start listening
 8011bb6:	6878      	ldr	r0, [r7, #4]
 8011bb8:	f000 fb48 	bl	801224c <_ZN5board14NrfTransceiver11enterRXModeEv>
#endif
}
 8011bbc:	bf00      	nop
 8011bbe:	3710      	adds	r7, #16
 8011bc0:	46bd      	mov	sp, r7
 8011bc2:	bd80      	pop	{r7, pc}
 8011bc4:	20001c0c 	.word	0x20001c0c
 8011bc8:	20001c04 	.word	0x20001c04

08011bcc <__tcf_0>:
 * nRF24L01 chip is lowering the NRF_IRQ line.
 * The code insight this method is executed in an ISR!
 */
void NrfTransceiver::onIrq()
{
	static XFStaticEvent irqEvent( 0 , this );
 8011bcc:	b580      	push	{r7, lr}
 8011bce:	af00      	add	r7, sp, #0
 8011bd0:	4801      	ldr	r0, [pc, #4]	; (8011bd8 <__tcf_0+0xc>)
 8011bd2:	f002 fbef 	bl	80143b4 <_ZN13XFStaticEventD1Ev>
 8011bd6:	bd80      	pop	{r7, pc}
 8011bd8:	20001c18 	.word	0x20001c18

08011bdc <_ZN5board14NrfTransceiver5onIrqEv>:
{
 8011bdc:	b580      	push	{r7, lr}
 8011bde:	b082      	sub	sp, #8
 8011be0:	af00      	add	r7, sp, #0
 8011be2:	6078      	str	r0, [r7, #4]
	static XFStaticEvent irqEvent( 0 , this );
 8011be4:	4b1c      	ldr	r3, [pc, #112]	; (8011c58 <_ZN5board14NrfTransceiver5onIrqEv+0x7c>)
 8011be6:	781b      	ldrb	r3, [r3, #0]
 8011be8:	f3bf 8f5b 	dmb	ish
 8011bec:	b2db      	uxtb	r3, r3
 8011bee:	f003 0301 	and.w	r3, r3, #1
 8011bf2:	2b00      	cmp	r3, #0
 8011bf4:	bf0c      	ite	eq
 8011bf6:	2301      	moveq	r3, #1
 8011bf8:	2300      	movne	r3, #0
 8011bfa:	b2db      	uxtb	r3, r3
 8011bfc:	2b00      	cmp	r3, #0
 8011bfe:	d017      	beq.n	8011c30 <_ZN5board14NrfTransceiver5onIrqEv+0x54>
 8011c00:	4815      	ldr	r0, [pc, #84]	; (8011c58 <_ZN5board14NrfTransceiver5onIrqEv+0x7c>)
 8011c02:	f004 fad7 	bl	80161b4 <__cxa_guard_acquire>
 8011c06:	4603      	mov	r3, r0
 8011c08:	2b00      	cmp	r3, #0
 8011c0a:	bf14      	ite	ne
 8011c0c:	2301      	movne	r3, #1
 8011c0e:	2300      	moveq	r3, #0
 8011c10:	b2db      	uxtb	r3, r3
 8011c12:	2b00      	cmp	r3, #0
 8011c14:	d00c      	beq.n	8011c30 <_ZN5board14NrfTransceiver5onIrqEv+0x54>
 8011c16:	687b      	ldr	r3, [r7, #4]
 8011c18:	3314      	adds	r3, #20
 8011c1a:	461a      	mov	r2, r3
 8011c1c:	2100      	movs	r1, #0
 8011c1e:	480f      	ldr	r0, [pc, #60]	; (8011c5c <_ZN5board14NrfTransceiver5onIrqEv+0x80>)
 8011c20:	f002 fbac 	bl	801437c <_ZN13XFStaticEventC1EiP11IXFReactive>
 8011c24:	480e      	ldr	r0, [pc, #56]	; (8011c60 <_ZN5board14NrfTransceiver5onIrqEv+0x84>)
 8011c26:	f004 fbd3 	bl	80163d0 <atexit>
 8011c2a:	480b      	ldr	r0, [pc, #44]	; (8011c58 <_ZN5board14NrfTransceiver5onIrqEv+0x7c>)
 8011c2c:	f004 face 	bl	80161cc <__cxa_guard_release>

	enterISR();
 8011c30:	4b0c      	ldr	r3, [pc, #48]	; (8011c64 <_ZN5board14NrfTransceiver5onIrqEv+0x88>)
 8011c32:	2201      	movs	r2, #1
 8011c34:	701a      	strb	r2, [r3, #0]
	pushEvent( &irqEvent );
 8011c36:	687b      	ldr	r3, [r7, #4]
 8011c38:	f103 0214 	add.w	r2, r3, #20
 8011c3c:	687b      	ldr	r3, [r7, #4]
 8011c3e:	695b      	ldr	r3, [r3, #20]
 8011c40:	330c      	adds	r3, #12
 8011c42:	681b      	ldr	r3, [r3, #0]
 8011c44:	4905      	ldr	r1, [pc, #20]	; (8011c5c <_ZN5board14NrfTransceiver5onIrqEv+0x80>)
 8011c46:	4610      	mov	r0, r2
 8011c48:	4798      	blx	r3
	exitISR();
 8011c4a:	4b06      	ldr	r3, [pc, #24]	; (8011c64 <_ZN5board14NrfTransceiver5onIrqEv+0x88>)
 8011c4c:	2200      	movs	r2, #0
 8011c4e:	701a      	strb	r2, [r3, #0]
}
 8011c50:	bf00      	nop
 8011c52:	3708      	adds	r7, #8
 8011c54:	46bd      	mov	sp, r7
 8011c56:	bd80      	pop	{r7, pc}
 8011c58:	20001c2c 	.word	0x20001c2c
 8011c5c:	20001c18 	.word	0x20001c18
 8011c60:	08011bcd 	.word	0x08011bcd
 8011c64:	20001dd4 	.word	0x20001dd4

08011c68 <_ZN5board14NrfTransceiver12processEventEv>:

EventStatus NrfTransceiver::processEvent()
{
 8011c68:	b590      	push	{r4, r7, lr}
 8011c6a:	b08b      	sub	sp, #44	; 0x2c
 8011c6c:	af00      	add	r7, sp, #0
 8011c6e:	6078      	str	r0, [r7, #4]
	unsigned char status = NrfSpi::status();
 8011c70:	687b      	ldr	r3, [r7, #4]
 8011c72:	3304      	adds	r3, #4
 8011c74:	4618      	mov	r0, r3
 8011c76:	f7ff f9b5 	bl	8010fe4 <_ZN6NrfSpi6statusEv>
 8011c7a:	4603      	mov	r3, r0
 8011c7c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	if (!NrfSpi::isInitialized())
 8011c80:	687b      	ldr	r3, [r7, #4]
 8011c82:	3304      	adds	r3, #4
 8011c84:	4618      	mov	r0, r3
 8011c86:	f7ff f8f7 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 8011c8a:	4603      	mov	r3, r0
 8011c8c:	f083 0301 	eor.w	r3, r3, #1
 8011c90:	b2db      	uxtb	r3, r3
 8011c92:	2b00      	cmp	r3, #0
 8011c94:	d007      	beq.n	8011ca6 <_ZN5board14NrfTransceiver12processEventEv+0x3e>
	{
		return EventStatus::NotConsumed;
 8011c96:	f107 0318 	add.w	r3, r7, #24
 8011c9a:	2102      	movs	r1, #2
 8011c9c:	4618      	mov	r0, r3
 8011c9e:	f7f4 fe99 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 8011ca2:	7e3b      	ldrb	r3, [r7, #24]
 8011ca4:	e13f      	b.n	8011f26 <_ZN5board14NrfTransceiver12processEventEv+0x2be>
	}

	while (!rxFifoEmpty())
 8011ca6:	687b      	ldr	r3, [r7, #4]
 8011ca8:	3304      	adds	r3, #4
 8011caa:	4618      	mov	r0, r3
 8011cac:	f7ff fcc1 	bl	8011632 <_ZN6NrfSpi11rxFifoEmptyEv>
 8011cb0:	4603      	mov	r3, r0
 8011cb2:	f083 0301 	eor.w	r3, r3, #1
 8011cb6:	b2db      	uxtb	r3, r3
 8011cb8:	2b00      	cmp	r3, #0
 8011cba:	f000 80a4 	beq.w	8011e06 <_ZN5board14NrfTransceiver12processEventEv+0x19e>
	{
		const uint8_t pipe = NrfSpi::getRXFramePipeNumber();
 8011cbe:	687b      	ldr	r3, [r7, #4]
 8011cc0:	3304      	adds	r3, #4
 8011cc2:	4618      	mov	r0, r3
 8011cc4:	f7ff fbb6 	bl	8011434 <_ZN6NrfSpi20getRXFramePipeNumberEv>
 8011cc8:	4603      	mov	r3, r0
 8011cca:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26

		// Only continue if a pipe is valid
		if (pipe <= 5)
 8011cce:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8011cd2:	2b05      	cmp	r3, #5
 8011cd4:	d879      	bhi.n	8011dca <_ZN5board14NrfTransceiver12processEventEv+0x162>
		{
			size_t size = NrfSpi::getRXFramePaylpoadSize(pipe);
 8011cd6:	687b      	ldr	r3, [r7, #4]
 8011cd8:	3304      	adds	r3, #4
 8011cda:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 8011cde:	4611      	mov	r1, r2
 8011ce0:	4618      	mov	r0, r3
 8011ce2:	f7ff fbcf 	bl	8011484 <_ZN6NrfSpi22getRXFramePaylpoadSizeEh>
 8011ce6:	6238      	str	r0, [r7, #32]

			if (size > MaximalPayloadSize)
 8011ce8:	6a3b      	ldr	r3, [r7, #32]
 8011cea:	2b20      	cmp	r3, #32
 8011cec:	d903      	bls.n	8011cf6 <_ZN5board14NrfTransceiver12processEventEv+0x8e>
			{
				// Check size. It must not exceed 32 bytes.

				// As explained in the R_RX_PL_WID section. Flush
				// the RX FIFO if this happen.
				flushRxFifo();
 8011cee:	6878      	ldr	r0, [r7, #4]
 8011cf0:	f7ff fdb6 	bl	8011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>
 8011cf4:	e069      	b.n	8011dca <_ZN5board14NrfTransceiver12processEventEv+0x162>
			}
			else if (size == 0)
 8011cf6:	6a3b      	ldr	r3, [r7, #32]
 8011cf8:	2b00      	cmp	r3, #0
 8011cfa:	d103      	bne.n	8011d04 <_ZN5board14NrfTransceiver12processEventEv+0x9c>
			{
				flushRxFifo();
 8011cfc:	6878      	ldr	r0, [r7, #4]
 8011cfe:	f7ff fdaf 	bl	8011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>
 8011d02:	e062      	b.n	8011dca <_ZN5board14NrfTransceiver12processEventEv+0x162>
			}
			else
			{
				Frame frame(Frame::HEADER_SIZE + size);
 8011d04:	6a3b      	ldr	r3, [r7, #32]
 8011d06:	1d5a      	adds	r2, r3, #5
 8011d08:	f107 0308 	add.w	r3, r7, #8
 8011d0c:	4611      	mov	r1, r2
 8011d0e:	4618      	mov	r0, r3
 8011d10:	f7f6 fffc 	bl	8008d0c <_ZN7desenet5FrameC1Ej>

				if (frame.isValid())
 8011d14:	f107 0308 	add.w	r3, r7, #8
 8011d18:	4618      	mov	r0, r3
 8011d1a:	f7f7 f866 	bl	8008dea <_ZNK7desenet5Frame7isValidEv>
 8011d1e:	4603      	mov	r3, r0
 8011d20:	2b00      	cmp	r3, #0
 8011d22:	d04a      	beq.n	8011dba <_ZN5board14NrfTransceiver12processEventEv+0x152>
				{
					// Add RX address to frame
					_rxAddress[pipe].copyTo(frame.buffer());
 8011d24:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8011d28:	3305      	adds	r3, #5
 8011d2a:	00db      	lsls	r3, r3, #3
 8011d2c:	687a      	ldr	r2, [r7, #4]
 8011d2e:	4413      	add	r3, r2
 8011d30:	1d1c      	adds	r4, r3, #4
 8011d32:	f107 0308 	add.w	r3, r7, #8
 8011d36:	4618      	mov	r0, r3
 8011d38:	f7f6 fe8b 	bl	8008a52 <_ZN7desenet5Frame6bufferEv>
 8011d3c:	4603      	mov	r3, r0
 8011d3e:	4619      	mov	r1, r3
 8011d40:	4620      	mov	r0, r4
 8011d42:	f000 fbdb 	bl	80124fc <_ZNK3phy7AddressILj4EE6copyToEPh>
					// Add payload size to frame (right after RX address)
					frame[Address::addressSize()] = size;
 8011d46:	f7f7 fa6f 	bl	8009228 <_ZN3phy7AddressILj4EE11addressSizeEv>
 8011d4a:	4602      	mov	r2, r0
 8011d4c:	f107 0308 	add.w	r3, r7, #8
 8011d50:	4611      	mov	r1, r2
 8011d52:	4618      	mov	r0, r3
 8011d54:	f7ff f881 	bl	8010e5a <_ZN7desenet5FrameixEj>
 8011d58:	4603      	mov	r3, r0
 8011d5a:	6a3a      	ldr	r2, [r7, #32]
 8011d5c:	b2d2      	uxtb	r2, r2
 8011d5e:	701a      	strb	r2, [r3, #0]

					// Read payload data
					NrfSpi::readFrame(frame);
 8011d60:	687b      	ldr	r3, [r7, #4]
 8011d62:	3304      	adds	r3, #4
 8011d64:	f107 0208 	add.w	r2, r7, #8
 8011d68:	4611      	mov	r1, r2
 8011d6a:	4618      	mov	r0, r3
 8011d6c:	f7ff fa44 	bl	80111f8 <_ZN6NrfSpi9readFrameERN7desenet5FrameE>

#if (NRFTRANSCEIVER_TRACE_VERBOSE != 0)	// Not even vall frame.toString()
					traceOut("Nrf: RX Frame (size %d): %s", frame.length(), frame.toString());
 8011d70:	f107 0308 	add.w	r3, r7, #8
 8011d74:	4618      	mov	r0, r3
 8011d76:	f7f6 ffbd 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8011d7a:	4604      	mov	r4, r0
 8011d7c:	f107 0308 	add.w	r3, r7, #8
 8011d80:	4618      	mov	r0, r3
 8011d82:	f7f7 f92b 	bl	8008fdc <_ZNK7desenet5Frame8toStringEv>
 8011d86:	4603      	mov	r3, r0
 8011d88:	461a      	mov	r2, r3
 8011d8a:	4621      	mov	r1, r4
 8011d8c:	4868      	ldr	r0, [pc, #416]	; (8011f30 <_ZN5board14NrfTransceiver12processEventEv+0x2c8>)
 8011d8e:	f000 f999 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>
#endif // #if (NRFTRANSCEIVER_TRACE_VERBOSE != 0)

					if (_pObserver)
 8011d92:	687b      	ldr	r3, [r7, #4]
 8011d94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011d96:	2b00      	cmp	r3, #0
 8011d98:	d00b      	beq.n	8011db2 <_ZN5board14NrfTransceiver12processEventEv+0x14a>
					{
						observer().onReceive(frame);
 8011d9a:	6878      	ldr	r0, [r7, #4]
 8011d9c:	f7ff fd6e 	bl	801187c <_ZN5board14NrfTransceiver8observerEv>
 8011da0:	4603      	mov	r3, r0
 8011da2:	681a      	ldr	r2, [r3, #0]
 8011da4:	3208      	adds	r2, #8
 8011da6:	6812      	ldr	r2, [r2, #0]
 8011da8:	f107 0108 	add.w	r1, r7, #8
 8011dac:	4618      	mov	r0, r3
 8011dae:	4790      	blx	r2
 8011db0:	e006      	b.n	8011dc0 <_ZN5board14NrfTransceiver12processEventEv+0x158>
					}
					else
					{
						traceOut("Nrf Irq: Observer not set");
 8011db2:	4860      	ldr	r0, [pc, #384]	; (8011f34 <_ZN5board14NrfTransceiver12processEventEv+0x2cc>)
 8011db4:	f000 f986 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>
 8011db8:	e002      	b.n	8011dc0 <_ZN5board14NrfTransceiver12processEventEv+0x158>
				else
				{
					// The RX frames needs to be read or removed
					// Otherwise the transceiver will again rise the
					// IRQ line!
					flushRxFifo();
 8011dba:	6878      	ldr	r0, [r7, #4]
 8011dbc:	f7ff fd50 	bl	8011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>
				Frame frame(Frame::HEADER_SIZE + size);
 8011dc0:	f107 0308 	add.w	r3, r7, #8
 8011dc4:	4618      	mov	r0, r3
 8011dc6:	f7f7 ff92 	bl	8009cee <_ZN7desenet5FrameD1Ev>
				}
			}
		}

		status = NrfSpi::status();
 8011dca:	687b      	ldr	r3, [r7, #4]
 8011dcc:	3304      	adds	r3, #4
 8011dce:	4618      	mov	r0, r3
 8011dd0:	f7ff f908 	bl	8010fe4 <_ZN6NrfSpi6statusEv>
 8011dd4:	4603      	mov	r3, r0
 8011dd6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

		if ((status & NrfSpi::STATUS_REG_RX_DR) == NrfSpi::STATUS_REG_RX_DR)
 8011dda:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011dde:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011de2:	2b00      	cmp	r3, #0
 8011de4:	f43f af5f 	beq.w	8011ca6 <_ZN5board14NrfTransceiver12processEventEv+0x3e>
		{
			// Clear RX_DR bit in status register
			status = NrfSpi::writeRegister(NrfSpi::STATUS, (status | NrfSpi::STATUS_REG_RX_DR));
 8011de8:	687b      	ldr	r3, [r7, #4]
 8011dea:	1d18      	adds	r0, r3, #4
 8011dec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011df0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011df4:	b2db      	uxtb	r3, r3
 8011df6:	461a      	mov	r2, r3
 8011df8:	2107      	movs	r1, #7
 8011dfa:	f7ff fa79 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
 8011dfe:	4603      	mov	r3, r0
 8011e00:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	while (!rxFifoEmpty())
 8011e04:	e74f      	b.n	8011ca6 <_ZN5board14NrfTransceiver12processEventEv+0x3e>
		}
	}

	status = NrfSpi::status();
 8011e06:	687b      	ldr	r3, [r7, #4]
 8011e08:	3304      	adds	r3, #4
 8011e0a:	4618      	mov	r0, r3
 8011e0c:	f7ff f8ea 	bl	8010fe4 <_ZN6NrfSpi6statusEv>
 8011e10:	4603      	mov	r3, r0
 8011e12:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	// There are rare cases where the RX FIFO is empty and the RX_DR status flag still high.
	if ((status & NrfSpi::STATUS_REG_RX_DR) == NrfSpi::STATUS_REG_RX_DR)
 8011e16:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011e1e:	2b00      	cmp	r3, #0
 8011e20:	d00d      	beq.n	8011e3e <_ZN5board14NrfTransceiver12processEventEv+0x1d6>
	{
		// Clear RX_DR bit in status register
		status = NrfSpi::writeRegister(NrfSpi::STATUS, (status | NrfSpi::STATUS_REG_RX_DR));
 8011e22:	687b      	ldr	r3, [r7, #4]
 8011e24:	1d18      	adds	r0, r3, #4
 8011e26:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e2a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011e2e:	b2db      	uxtb	r3, r3
 8011e30:	461a      	mov	r2, r3
 8011e32:	2107      	movs	r1, #7
 8011e34:	f7ff fa5c 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
 8011e38:	4603      	mov	r3, r0
 8011e3a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	}

	if ((status & NrfSpi::STATUS_REG_TX_FULL) == NrfSpi::STATUS_REG_TX_FULL)
 8011e3e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e42:	f003 0301 	and.w	r3, r3, #1
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d005      	beq.n	8011e56 <_ZN5board14NrfTransceiver12processEventEv+0x1ee>
	{
		// Flush TX FIFO
		flushTxFifo();
 8011e4a:	6878      	ldr	r0, [r7, #4]
 8011e4c:	f7ff fcfa 	bl	8011844 <_ZN5board14NrfTransceiver11flushTxFifoEv>
		traceOut("irq:FLUSH_TX");
 8011e50:	4839      	ldr	r0, [pc, #228]	; (8011f38 <_ZN5board14NrfTransceiver12processEventEv+0x2d0>)
 8011e52:	f000 f937 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>
	}

	if ((status & NrfSpi::STATUS_REG_TX_DS) == NrfSpi::STATUS_REG_TX_DS)	// Data send
 8011e56:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e5a:	f003 0320 	and.w	r3, r3, #32
 8011e5e:	2b00      	cmp	r3, #0
 8011e60:	d01d      	beq.n	8011e9e <_ZN5board14NrfTransceiver12processEventEv+0x236>
	{
		traceOut("irq::TX_DS");
 8011e62:	4836      	ldr	r0, [pc, #216]	; (8011f3c <_ZN5board14NrfTransceiver12processEventEv+0x2d4>)
 8011e64:	f000 f92e 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>

		// Clear TX_DS bit in status register
		status = NrfSpi::writeRegister(NrfSpi::STATUS, (status | NrfSpi::STATUS_REG_TX_DS));
 8011e68:	687b      	ldr	r3, [r7, #4]
 8011e6a:	1d18      	adds	r0, r3, #4
 8011e6c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e70:	f043 0320 	orr.w	r3, r3, #32
 8011e74:	b2db      	uxtb	r3, r3
 8011e76:	461a      	mov	r2, r3
 8011e78:	2107      	movs	r1, #7
 8011e7a:	f7ff fa39 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
 8011e7e:	4603      	mov	r3, r0
 8011e80:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

		observer().onSendStatus(IPhyObserver::Delivered);
 8011e84:	6878      	ldr	r0, [r7, #4]
 8011e86:	f7ff fcf9 	bl	801187c <_ZN5board14NrfTransceiver8observerEv>
 8011e8a:	4603      	mov	r3, r0
 8011e8c:	681a      	ldr	r2, [r3, #0]
 8011e8e:	320c      	adds	r2, #12
 8011e90:	6812      	ldr	r2, [r2, #0]
 8011e92:	2101      	movs	r1, #1
 8011e94:	4618      	mov	r0, r3
 8011e96:	4790      	blx	r2

		// Change from TX to RX mode
		enterRXMode();
 8011e98:	6878      	ldr	r0, [r7, #4]
 8011e9a:	f000 f9d7 	bl	801224c <_ZN5board14NrfTransceiver11enterRXModeEv>
	}

	if ((status & NrfSpi::STATUS_REG_MAX_RT) == NrfSpi::STATUS_REG_MAX_RT)	// Reached maximum retries
 8011e9e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011ea2:	f003 0310 	and.w	r3, r3, #16
 8011ea6:	2b00      	cmp	r3, #0
 8011ea8:	d020      	beq.n	8011eec <_ZN5board14NrfTransceiver12processEventEv+0x284>
	{
		traceOut("irq:MAX_RT");
 8011eaa:	4825      	ldr	r0, [pc, #148]	; (8011f40 <_ZN5board14NrfTransceiver12processEventEv+0x2d8>)
 8011eac:	f000 f90a 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>

		// Discard frame by flushing TX fifo
		// See nRF24L01 datasheet on page 43, last paragraph
		flushTxFifo();
 8011eb0:	6878      	ldr	r0, [r7, #4]
 8011eb2:	f7ff fcc7 	bl	8011844 <_ZN5board14NrfTransceiver11flushTxFifoEv>

		// Clear max RT
		status = NrfSpi::writeRegister(NrfSpi::STATUS, (status | NrfSpi::STATUS_REG_MAX_RT));
 8011eb6:	687b      	ldr	r3, [r7, #4]
 8011eb8:	1d18      	adds	r0, r3, #4
 8011eba:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011ebe:	f043 0310 	orr.w	r3, r3, #16
 8011ec2:	b2db      	uxtb	r3, r3
 8011ec4:	461a      	mov	r2, r3
 8011ec6:	2107      	movs	r1, #7
 8011ec8:	f7ff fa12 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
 8011ecc:	4603      	mov	r3, r0
 8011ece:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

		observer().onSendStatus(IPhyObserver::NotDelivered);
 8011ed2:	6878      	ldr	r0, [r7, #4]
 8011ed4:	f7ff fcd2 	bl	801187c <_ZN5board14NrfTransceiver8observerEv>
 8011ed8:	4603      	mov	r3, r0
 8011eda:	681a      	ldr	r2, [r3, #0]
 8011edc:	320c      	adds	r2, #12
 8011ede:	6812      	ldr	r2, [r2, #0]
 8011ee0:	2103      	movs	r1, #3
 8011ee2:	4618      	mov	r0, r3
 8011ee4:	4790      	blx	r2

		// Change from TX to RX mode
		enterRXMode();
 8011ee6:	6878      	ldr	r0, [r7, #4]
 8011ee8:	f000 f9b0 	bl	801224c <_ZN5board14NrfTransceiver11enterRXModeEv>
	}

	if (NrfSpi::rxFifoFull() && ((status & NrfSpi::STATUS_REG_RX_DR) != NrfSpi::STATUS_REG_RX_DR))
 8011eec:	687b      	ldr	r3, [r7, #4]
 8011eee:	3304      	adds	r3, #4
 8011ef0:	4618      	mov	r0, r3
 8011ef2:	f7ff fbb0 	bl	8011656 <_ZN6NrfSpi10rxFifoFullEv>
 8011ef6:	4603      	mov	r3, r0
 8011ef8:	2b00      	cmp	r3, #0
 8011efa:	d007      	beq.n	8011f0c <_ZN5board14NrfTransceiver12processEventEv+0x2a4>
 8011efc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011f00:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011f04:	2b00      	cmp	r3, #0
 8011f06:	d101      	bne.n	8011f0c <_ZN5board14NrfTransceiver12processEventEv+0x2a4>
 8011f08:	2301      	movs	r3, #1
 8011f0a:	e000      	b.n	8011f0e <_ZN5board14NrfTransceiver12processEventEv+0x2a6>
 8011f0c:	2300      	movs	r3, #0
 8011f0e:	2b00      	cmp	r3, #0
 8011f10:	d002      	beq.n	8011f18 <_ZN5board14NrfTransceiver12processEventEv+0x2b0>
	{
		// Flush RX FIFO
		flushRxFifo();
 8011f12:	6878      	ldr	r0, [r7, #4]
 8011f14:	f7ff fca4 	bl	8011860 <_ZN5board14NrfTransceiver11flushRxFifoEv>
	}

	return EventStatus::Consumed;
 8011f18:	f107 031c 	add.w	r3, r7, #28
 8011f1c:	2101      	movs	r1, #1
 8011f1e:	4618      	mov	r0, r3
 8011f20:	f7f4 fd58 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 8011f24:	7f3b      	ldrb	r3, [r7, #28]
}
 8011f26:	4618      	mov	r0, r3
 8011f28:	372c      	adds	r7, #44	; 0x2c
 8011f2a:	46bd      	mov	sp, r7
 8011f2c:	bd90      	pop	{r4, r7, pc}
 8011f2e:	bf00      	nop
 8011f30:	0801a5a8 	.word	0x0801a5a8
 8011f34:	0801a5c4 	.word	0x0801a5c4
 8011f38:	0801a5e0 	.word	0x0801a5e0
 8011f3c:	0801a5f0 	.word	0x0801a5f0
 8011f40:	0801a5fc 	.word	0x0801a5fc

08011f44 <_ZThn20_N5board14NrfTransceiver12processEventEv>:
	EventStatus processEvent();
 8011f44:	f1a0 0014 	sub.w	r0, r0, #20
 8011f48:	f7ff be8e 	b.w	8011c68 <_ZN5board14NrfTransceiver12processEventEv>

08011f4c <_ZN5board14NrfTransceiver21setDestinationAddressEN3phy7AddressILj4EEE>:

void NrfTransceiver::setDestinationAddress(tAddress address)
{
 8011f4c:	b580      	push	{r7, lr}
 8011f4e:	b082      	sub	sp, #8
 8011f50:	af00      	add	r7, sp, #0
 8011f52:	6078      	str	r0, [r7, #4]
 8011f54:	6039      	str	r1, [r7, #0]
	NrfSpi::writeRegister(NrfSpi::TX_ADDR, address);
 8011f56:	687b      	ldr	r3, [r7, #4]
 8011f58:	3304      	adds	r3, #4
 8011f5a:	683a      	ldr	r2, [r7, #0]
 8011f5c:	2110      	movs	r1, #16
 8011f5e:	4618      	mov	r0, r3
 8011f60:	f7ff fa00 	bl	8011364 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE>
}
 8011f64:	bf00      	nop
 8011f66:	3708      	adds	r7, #8
 8011f68:	46bd      	mov	sp, r7
 8011f6a:	bd80      	pop	{r7, pc}

08011f6c <_ZN5board14NrfTransceiver19setReceptionAddressEhRKN3phy7AddressILj4EEE>:

void NrfTransceiver::setReceptionAddress(uint8_t pipeIndex, const tAddress & rxAddress)
{
 8011f6c:	b580      	push	{r7, lr}
 8011f6e:	b084      	sub	sp, #16
 8011f70:	af00      	add	r7, sp, #0
 8011f72:	60f8      	str	r0, [r7, #12]
 8011f74:	460b      	mov	r3, r1
 8011f76:	607a      	str	r2, [r7, #4]
 8011f78:	72fb      	strb	r3, [r7, #11]
	if (pipeIndex <= 6)
 8011f7a:	7afb      	ldrb	r3, [r7, #11]
 8011f7c:	2b06      	cmp	r3, #6
 8011f7e:	d812      	bhi.n	8011fa6 <_ZN5board14NrfTransceiver19setReceptionAddressEhRKN3phy7AddressILj4EEE+0x3a>
	{
		NrfSpi::writeRegister(static_cast<NrfSpi::eNrfRegister>(NrfSpi::RX_ADDR_P0 + pipeIndex), rxAddress);
 8011f80:	68fb      	ldr	r3, [r7, #12]
 8011f82:	1d18      	adds	r0, r3, #4
 8011f84:	7afb      	ldrb	r3, [r7, #11]
 8011f86:	330a      	adds	r3, #10
 8011f88:	b2db      	uxtb	r3, r3
 8011f8a:	687a      	ldr	r2, [r7, #4]
 8011f8c:	4619      	mov	r1, r3
 8011f8e:	f7ff f9e9 	bl	8011364 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterERKN3phy7AddressILj4EEE>

		_rxAddress[pipeIndex] = rxAddress;
 8011f92:	7afb      	ldrb	r3, [r7, #11]
 8011f94:	3305      	adds	r3, #5
 8011f96:	00db      	lsls	r3, r3, #3
 8011f98:	68fa      	ldr	r2, [r7, #12]
 8011f9a:	4413      	add	r3, r2
 8011f9c:	3304      	adds	r3, #4
 8011f9e:	6879      	ldr	r1, [r7, #4]
 8011fa0:	4618      	mov	r0, r3
 8011fa2:	f7fe ff1b 	bl	8010ddc <_ZN3phy7AddressILj4EEaSERKS1_>
	}
}
 8011fa6:	bf00      	nop
 8011fa8:	3710      	adds	r7, #16
 8011faa:	46bd      	mov	sp, r7
 8011fac:	bd80      	pop	{r7, pc}
	...

08011fb0 <_ZN5board14NrfTransceiver15setAddressWidthEh>:

void NrfTransceiver::setAddressWidth(unsigned char widthInByte)
{
 8011fb0:	b580      	push	{r7, lr}
 8011fb2:	b082      	sub	sp, #8
 8011fb4:	af00      	add	r7, sp, #0
 8011fb6:	6078      	str	r0, [r7, #4]
 8011fb8:	460b      	mov	r3, r1
 8011fba:	70fb      	strb	r3, [r7, #3]
	assert(widthInByte == 3 || widthInByte == 4 || widthInByte == 5);
 8011fbc:	78fb      	ldrb	r3, [r7, #3]
 8011fbe:	2b03      	cmp	r3, #3
 8011fc0:	d00c      	beq.n	8011fdc <_ZN5board14NrfTransceiver15setAddressWidthEh+0x2c>
 8011fc2:	78fb      	ldrb	r3, [r7, #3]
 8011fc4:	2b04      	cmp	r3, #4
 8011fc6:	d009      	beq.n	8011fdc <_ZN5board14NrfTransceiver15setAddressWidthEh+0x2c>
 8011fc8:	78fb      	ldrb	r3, [r7, #3]
 8011fca:	2b05      	cmp	r3, #5
 8011fcc:	d006      	beq.n	8011fdc <_ZN5board14NrfTransceiver15setAddressWidthEh+0x2c>
 8011fce:	4b0a      	ldr	r3, [pc, #40]	; (8011ff8 <_ZN5board14NrfTransceiver15setAddressWidthEh+0x48>)
 8011fd0:	4a0a      	ldr	r2, [pc, #40]	; (8011ffc <_ZN5board14NrfTransceiver15setAddressWidthEh+0x4c>)
 8011fd2:	f240 1133 	movw	r1, #307	; 0x133
 8011fd6:	480a      	ldr	r0, [pc, #40]	; (8012000 <_ZN5board14NrfTransceiver15setAddressWidthEh+0x50>)
 8011fd8:	f004 f9dc 	bl	8016394 <__assert_func>

	NrfSpi::writeRegister(NrfSpi::SETUP_AW, widthInByte - 2);
 8011fdc:	687b      	ldr	r3, [r7, #4]
 8011fde:	1d18      	adds	r0, r3, #4
 8011fe0:	78fb      	ldrb	r3, [r7, #3]
 8011fe2:	3b02      	subs	r3, #2
 8011fe4:	b2db      	uxtb	r3, r3
 8011fe6:	461a      	mov	r2, r3
 8011fe8:	2103      	movs	r1, #3
 8011fea:	f7ff f981 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 8011fee:	bf00      	nop
 8011ff0:	3708      	adds	r7, #8
 8011ff2:	46bd      	mov	sp, r7
 8011ff4:	bd80      	pop	{r7, pc}
 8011ff6:	bf00      	nop
 8011ff8:	0801a608 	.word	0x0801a608
 8011ffc:	0801a644 	.word	0x0801a644
 8012000:	0801a42c 	.word	0x0801a42c

08012004 <_ZN5board14NrfTransceiver16activateFeaturesEb>:

bool NrfTransceiver::activateFeatures(bool enable)
{
 8012004:	b580      	push	{r7, lr}
 8012006:	b082      	sub	sp, #8
 8012008:	af00      	add	r7, sp, #0
 801200a:	6078      	str	r0, [r7, #4]
 801200c:	460b      	mov	r3, r1
 801200e:	70fb      	strb	r3, [r7, #3]
	return NrfSpi::activateFeatures(enable);
 8012010:	687b      	ldr	r3, [r7, #4]
 8012012:	3304      	adds	r3, #4
 8012014:	78fa      	ldrb	r2, [r7, #3]
 8012016:	4611      	mov	r1, r2
 8012018:	4618      	mov	r0, r3
 801201a:	f7ff f9f1 	bl	8011400 <_ZN6NrfSpi16activateFeaturesEb>
 801201e:	4603      	mov	r3, r0
}
 8012020:	4618      	mov	r0, r3
 8012022:	3708      	adds	r7, #8
 8012024:	46bd      	mov	sp, r7
 8012026:	bd80      	pop	{r7, pc}

08012028 <_ZN5board14NrfTransceiver9enableDPLEbh>:
 *  - You need to enable first call activateFeatues() in order to use
 *    the DPL feature.
 *  - You also need to enable <em>Enhanced ShockBurst</em>.
 */
void NrfTransceiver::enableDPL(bool enable, unsigned char pipeMask /* = 0x00 */)
{
 8012028:	b580      	push	{r7, lr}
 801202a:	b084      	sub	sp, #16
 801202c:	af00      	add	r7, sp, #0
 801202e:	6078      	str	r0, [r7, #4]
 8012030:	460b      	mov	r3, r1
 8012032:	70fb      	strb	r3, [r7, #3]
 8012034:	4613      	mov	r3, r2
 8012036:	70bb      	strb	r3, [r7, #2]
	NrfSpi::tRegister reg;
	assert(_bNrfFeaturesEnabled);	// Call activateFeatues first
 8012038:	687b      	ldr	r3, [r7, #4]
 801203a:	7c1b      	ldrb	r3, [r3, #16]
 801203c:	2b00      	cmp	r3, #0
 801203e:	d106      	bne.n	801204e <_ZN5board14NrfTransceiver9enableDPLEbh+0x26>
 8012040:	4b1c      	ldr	r3, [pc, #112]	; (80120b4 <_ZN5board14NrfTransceiver9enableDPLEbh+0x8c>)
 8012042:	4a1d      	ldr	r2, [pc, #116]	; (80120b8 <_ZN5board14NrfTransceiver9enableDPLEbh+0x90>)
 8012044:	f240 114b 	movw	r1, #331	; 0x14b
 8012048:	481c      	ldr	r0, [pc, #112]	; (80120bc <_ZN5board14NrfTransceiver9enableDPLEbh+0x94>)
 801204a:	f004 f9a3 	bl	8016394 <__assert_func>

	reg = NrfSpi::readRegister(FEATURE);
 801204e:	687b      	ldr	r3, [r7, #4]
 8012050:	3304      	adds	r3, #4
 8012052:	211d      	movs	r1, #29
 8012054:	4618      	mov	r0, r3
 8012056:	f7ff f919 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 801205a:	4603      	mov	r3, r0
 801205c:	73fb      	strb	r3, [r7, #15]

	if (enable)
 801205e:	78fb      	ldrb	r3, [r7, #3]
 8012060:	2b00      	cmp	r3, #0
 8012062:	d00e      	beq.n	8012082 <_ZN5board14NrfTransceiver9enableDPLEbh+0x5a>
	{
		assert(pipeMask);		// Set at least to 0x01 (DPL on pipe0)
 8012064:	78bb      	ldrb	r3, [r7, #2]
 8012066:	2b00      	cmp	r3, #0
 8012068:	d106      	bne.n	8012078 <_ZN5board14NrfTransceiver9enableDPLEbh+0x50>
 801206a:	4b15      	ldr	r3, [pc, #84]	; (80120c0 <_ZN5board14NrfTransceiver9enableDPLEbh+0x98>)
 801206c:	4a12      	ldr	r2, [pc, #72]	; (80120b8 <_ZN5board14NrfTransceiver9enableDPLEbh+0x90>)
 801206e:	f240 1151 	movw	r1, #337	; 0x151
 8012072:	4812      	ldr	r0, [pc, #72]	; (80120bc <_ZN5board14NrfTransceiver9enableDPLEbh+0x94>)
 8012074:	f004 f98e 	bl	8016394 <__assert_func>

		reg |= FEATURE_REG_EN_DPL;
 8012078:	7bfb      	ldrb	r3, [r7, #15]
 801207a:	f043 0304 	orr.w	r3, r3, #4
 801207e:	73fb      	strb	r3, [r7, #15]
 8012080:	e003      	b.n	801208a <_ZN5board14NrfTransceiver9enableDPLEbh+0x62>
	}
	else
	{
		reg &= ~FEATURE_REG_EN_DPL;
 8012082:	7bfb      	ldrb	r3, [r7, #15]
 8012084:	f023 0304 	bic.w	r3, r3, #4
 8012088:	73fb      	strb	r3, [r7, #15]
	}

	NrfSpi::writeRegister(FEATURE, reg);
 801208a:	687b      	ldr	r3, [r7, #4]
 801208c:	3304      	adds	r3, #4
 801208e:	7bfa      	ldrb	r2, [r7, #15]
 8012090:	211d      	movs	r1, #29
 8012092:	4618      	mov	r0, r3
 8012094:	f7ff f92c 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>

	if (enable)
 8012098:	78fb      	ldrb	r3, [r7, #3]
 801209a:	2b00      	cmp	r3, #0
 801209c:	d006      	beq.n	80120ac <_ZN5board14NrfTransceiver9enableDPLEbh+0x84>
	{
		// Enable DPL on corresponding pipes
		NrfSpi::writeRegister(NrfSpi::DYNPD, pipeMask);
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	3304      	adds	r3, #4
 80120a2:	78ba      	ldrb	r2, [r7, #2]
 80120a4:	211c      	movs	r1, #28
 80120a6:	4618      	mov	r0, r3
 80120a8:	f7ff f922 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
	}
}
 80120ac:	bf00      	nop
 80120ae:	3710      	adds	r7, #16
 80120b0:	46bd      	mov	sp, r7
 80120b2:	bd80      	pop	{r7, pc}
 80120b4:	0801a680 	.word	0x0801a680
 80120b8:	0801a698 	.word	0x0801a698
 80120bc:	0801a42c 	.word	0x0801a42c
 80120c0:	0801a6d4 	.word	0x0801a6d4

080120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>:

void NrfTransceiver::traceOut(const char * const format, ...)
{
 80120c4:	b40f      	push	{r0, r1, r2, r3}
 80120c6:	b580      	push	{r7, lr}
 80120c8:	b082      	sub	sp, #8
 80120ca:	af00      	add	r7, sp, #0
#if (NRFTRANSCEIVER_TRACE_VERBOSE != 0)
	static char str[256];

	va_list args;

	va_start(args, format);
 80120cc:	f107 0314 	add.w	r3, r7, #20
 80120d0:	607b      	str	r3, [r7, #4]
	vsiprintf(str, format, args);
 80120d2:	687a      	ldr	r2, [r7, #4]
 80120d4:	6939      	ldr	r1, [r7, #16]
 80120d6:	480d      	ldr	r0, [pc, #52]	; (801210c <_ZN5board14NrfTransceiver8traceOutEPKcz+0x48>)
 80120d8:	f004 fe88 	bl	8016dec <vsiprintf>
	va_end(args);

	assert(strlen(str) < 256);		// Uups! str is too small
 80120dc:	480b      	ldr	r0, [pc, #44]	; (801210c <_ZN5board14NrfTransceiver8traceOutEPKcz+0x48>)
 80120de:	f7ee f8c7 	bl	8000270 <strlen>
 80120e2:	4603      	mov	r3, r0
 80120e4:	2bff      	cmp	r3, #255	; 0xff
 80120e6:	d906      	bls.n	80120f6 <_ZN5board14NrfTransceiver8traceOutEPKcz+0x32>
 80120e8:	4b09      	ldr	r3, [pc, #36]	; (8012110 <_ZN5board14NrfTransceiver8traceOutEPKcz+0x4c>)
 80120ea:	4a0a      	ldr	r2, [pc, #40]	; (8012114 <_ZN5board14NrfTransceiver8traceOutEPKcz+0x50>)
 80120ec:	f44f 71b7 	mov.w	r1, #366	; 0x16e
 80120f0:	4809      	ldr	r0, [pc, #36]	; (8012118 <_ZN5board14NrfTransceiver8traceOutEPKcz+0x54>)
 80120f2:	f004 f94f 	bl	8016394 <__assert_func>

	Trace::outln(str);
 80120f6:	4805      	ldr	r0, [pc, #20]	; (801210c <_ZN5board14NrfTransceiver8traceOutEPKcz+0x48>)
 80120f8:	f7fd faa8 	bl	800f64c <_ZN5Trace5outlnEPKcz>
#else
	UNUSED(format);
#endif
}
 80120fc:	bf00      	nop
 80120fe:	3708      	adds	r7, #8
 8012100:	46bd      	mov	sp, r7
 8012102:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8012106:	b004      	add	sp, #16
 8012108:	4770      	bx	lr
 801210a:	bf00      	nop
 801210c:	20001c30 	.word	0x20001c30
 8012110:	0801a6e0 	.word	0x0801a6e0
 8012114:	0801a6f4 	.word	0x0801a6f4
 8012118:	0801a42c 	.word	0x0801a42c

0801211c <_ZNK5board14NrfTransceiver4modeEv>:

IPhyTransceiver::Mode NrfTransceiver::mode() const
{
 801211c:	b480      	push	{r7}
 801211e:	b083      	sub	sp, #12
 8012120:	af00      	add	r7, sp, #0
 8012122:	6078      	str	r0, [r7, #4]
	return (_bEnabled) ? Active : Inactive;
 8012124:	687b      	ldr	r3, [r7, #4]
 8012126:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801212a:	2b00      	cmp	r3, #0
 801212c:	d001      	beq.n	8012132 <_ZNK5board14NrfTransceiver4modeEv+0x16>
 801212e:	2302      	movs	r3, #2
 8012130:	e000      	b.n	8012134 <_ZNK5board14NrfTransceiver4modeEv+0x18>
 8012132:	2301      	movs	r3, #1
}
 8012134:	4618      	mov	r0, r3
 8012136:	370c      	adds	r7, #12
 8012138:	46bd      	mov	sp, r7
 801213a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801213e:	4770      	bx	lr

08012140 <_ZN5board14NrfTransceiver7setModeEN15IPhyTransceiver4ModeE>:

bool NrfTransceiver::setMode(Mode mode)
{
 8012140:	b580      	push	{r7, lr}
 8012142:	b082      	sub	sp, #8
 8012144:	af00      	add	r7, sp, #0
 8012146:	6078      	str	r0, [r7, #4]
 8012148:	460b      	mov	r3, r1
 801214a:	70fb      	strb	r3, [r7, #3]
	assert(NrfSpi::isInitialized());	// Call initialize() first!
 801214c:	687b      	ldr	r3, [r7, #4]
 801214e:	3304      	adds	r3, #4
 8012150:	4618      	mov	r0, r3
 8012152:	f7fe fe91 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 8012156:	4603      	mov	r3, r0
 8012158:	2b00      	cmp	r3, #0
 801215a:	d106      	bne.n	801216a <_ZN5board14NrfTransceiver7setModeEN15IPhyTransceiver4ModeE+0x2a>
 801215c:	4b0a      	ldr	r3, [pc, #40]	; (8012188 <_ZN5board14NrfTransceiver7setModeEN15IPhyTransceiver4ModeE+0x48>)
 801215e:	4a0b      	ldr	r2, [pc, #44]	; (801218c <_ZN5board14NrfTransceiver7setModeEN15IPhyTransceiver4ModeE+0x4c>)
 8012160:	f240 117d 	movw	r1, #381	; 0x17d
 8012164:	480a      	ldr	r0, [pc, #40]	; (8012190 <_ZN5board14NrfTransceiver7setModeEN15IPhyTransceiver4ModeE+0x50>)
 8012166:	f004 f915 	bl	8016394 <__assert_func>

	return enableTransceiver((mode == Active) ? true : false);
 801216a:	78fb      	ldrb	r3, [r7, #3]
 801216c:	2b02      	cmp	r3, #2
 801216e:	bf0c      	ite	eq
 8012170:	2301      	moveq	r3, #1
 8012172:	2300      	movne	r3, #0
 8012174:	b2db      	uxtb	r3, r3
 8012176:	4619      	mov	r1, r3
 8012178:	6878      	ldr	r0, [r7, #4]
 801217a:	f000 f80b 	bl	8012194 <_ZN5board14NrfTransceiver17enableTransceiverEb>
 801217e:	4603      	mov	r3, r0
}
 8012180:	4618      	mov	r0, r3
 8012182:	3708      	adds	r7, #8
 8012184:	46bd      	mov	sp, r7
 8012186:	bd80      	pop	{r7, pc}
 8012188:	0801a734 	.word	0x0801a734
 801218c:	0801a74c 	.word	0x0801a74c
 8012190:	0801a42c 	.word	0x0801a42c

08012194 <_ZN5board14NrfTransceiver17enableTransceiverEb>:

bool NrfTransceiver::enableTransceiver(bool bEnable)
{
 8012194:	b580      	push	{r7, lr}
 8012196:	b084      	sub	sp, #16
 8012198:	af00      	add	r7, sp, #0
 801219a:	6078      	str	r0, [r7, #4]
 801219c:	460b      	mov	r3, r1
 801219e:	70fb      	strb	r3, [r7, #3]
	if (_bEnabled != bEnable)
 80121a0:	687b      	ldr	r3, [r7, #4]
 80121a2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80121a6:	78fa      	ldrb	r2, [r7, #3]
 80121a8:	429a      	cmp	r2, r3
 80121aa:	d02f      	beq.n	801220c <_ZN5board14NrfTransceiver17enableTransceiverEb+0x78>
	{
		unsigned char config;

		_bEnabled = bEnable;
 80121ac:	687b      	ldr	r3, [r7, #4]
 80121ae:	78fa      	ldrb	r2, [r7, #3]
 80121b0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

		config = NrfSpi::readRegister(NrfSpi::CONFIG);
 80121b4:	687b      	ldr	r3, [r7, #4]
 80121b6:	3304      	adds	r3, #4
 80121b8:	2100      	movs	r1, #0
 80121ba:	4618      	mov	r0, r3
 80121bc:	f7ff f866 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 80121c0:	4603      	mov	r3, r0
 80121c2:	73fb      	strb	r3, [r7, #15]

		if (bEnable)
 80121c4:	78fb      	ldrb	r3, [r7, #3]
 80121c6:	2b00      	cmp	r3, #0
 80121c8:	d010      	beq.n	80121ec <_ZN5board14NrfTransceiver17enableTransceiverEb+0x58>
		{
			// power-up, RX
			config |= NrfSpi::CONFIG_REG_PWR_UP |
 80121ca:	7bfb      	ldrb	r3, [r7, #15]
 80121cc:	f043 0303 	orr.w	r3, r3, #3
 80121d0:	73fb      	strb	r3, [r7, #15]
					  NrfSpi::CONFIG_REG_PRIM_RX;
			NrfSpi::writeRegister(NrfSpi::CONFIG, config);
 80121d2:	687b      	ldr	r3, [r7, #4]
 80121d4:	3304      	adds	r3, #4
 80121d6:	7bfa      	ldrb	r2, [r7, #15]
 80121d8:	2100      	movs	r1, #0
 80121da:	4618      	mov	r0, r3
 80121dc:	f7ff f888 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>

			// Enable transceiver
			NrfSpi::enableCE();
 80121e0:	687b      	ldr	r3, [r7, #4]
 80121e2:	3304      	adds	r3, #4
 80121e4:	4618      	mov	r0, r3
 80121e6:	f7ff fb09 	bl	80117fc <_ZNK6NrfSpi8enableCEEv>
 80121ea:	e00f      	b.n	801220c <_ZN5board14NrfTransceiver17enableTransceiverEb+0x78>
		}
		else
		{
			// Power down the chip
			config &= ~NrfSpi::CONFIG_REG_PWR_UP;
 80121ec:	7bfb      	ldrb	r3, [r7, #15]
 80121ee:	f023 0302 	bic.w	r3, r3, #2
 80121f2:	73fb      	strb	r3, [r7, #15]
			NrfSpi::writeRegister(NrfSpi::CONFIG, config);
 80121f4:	687b      	ldr	r3, [r7, #4]
 80121f6:	3304      	adds	r3, #4
 80121f8:	7bfa      	ldrb	r2, [r7, #15]
 80121fa:	2100      	movs	r1, #0
 80121fc:	4618      	mov	r0, r3
 80121fe:	f7ff f877 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>

			// Disable transceiver
			NrfSpi::disableCE();
 8012202:	687b      	ldr	r3, [r7, #4]
 8012204:	3304      	adds	r3, #4
 8012206:	4618      	mov	r0, r3
 8012208:	f7ff fb0c 	bl	8011824 <_ZNK6NrfSpi9disableCEEv>
		}

		// read
		//config = NrfSpi::readRegister(NrfSpi::CONFIG);
	}
	return true;
 801220c:	2301      	movs	r3, #1
}
 801220e:	4618      	mov	r0, r3
 8012210:	3710      	adds	r7, #16
 8012212:	46bd      	mov	sp, r7
 8012214:	bd80      	pop	{r7, pc}

08012216 <_ZN5board14NrfTransceiver11enterTXModeEv>:

void NrfTransceiver::enterTXMode()
{
 8012216:	b580      	push	{r7, lr}
 8012218:	b084      	sub	sp, #16
 801221a:	af00      	add	r7, sp, #0
 801221c:	6078      	str	r0, [r7, #4]
	unsigned char config;

	// Enter TX mode
	config = NrfSpi::readRegister(NrfSpi::CONFIG);
 801221e:	687b      	ldr	r3, [r7, #4]
 8012220:	3304      	adds	r3, #4
 8012222:	2100      	movs	r1, #0
 8012224:	4618      	mov	r0, r3
 8012226:	f7ff f831 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 801222a:	4603      	mov	r3, r0
 801222c:	73fb      	strb	r3, [r7, #15]
	config &= ~NrfSpi::CONFIG_REG_PRIM_RX;		// Clear PRIM_RX_BIT to enter TX mode
 801222e:	7bfb      	ldrb	r3, [r7, #15]
 8012230:	f023 0301 	bic.w	r3, r3, #1
 8012234:	73fb      	strb	r3, [r7, #15]
	// Write new value to config register
    NrfSpi::writeRegister(NrfSpi::CONFIG, config);
 8012236:	687b      	ldr	r3, [r7, #4]
 8012238:	3304      	adds	r3, #4
 801223a:	7bfa      	ldrb	r2, [r7, #15]
 801223c:	2100      	movs	r1, #0
 801223e:	4618      	mov	r0, r3
 8012240:	f7ff f856 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 8012244:	bf00      	nop
 8012246:	3710      	adds	r7, #16
 8012248:	46bd      	mov	sp, r7
 801224a:	bd80      	pop	{r7, pc}

0801224c <_ZN5board14NrfTransceiver11enterRXModeEv>:

void NrfTransceiver::enterRXMode()
{
 801224c:	b580      	push	{r7, lr}
 801224e:	b084      	sub	sp, #16
 8012250:	af00      	add	r7, sp, #0
 8012252:	6078      	str	r0, [r7, #4]
	unsigned char config;

	// Enter RX mode
	config = NrfSpi::readRegister(NrfSpi::CONFIG);
 8012254:	687b      	ldr	r3, [r7, #4]
 8012256:	3304      	adds	r3, #4
 8012258:	2100      	movs	r1, #0
 801225a:	4618      	mov	r0, r3
 801225c:	f7ff f816 	bl	801128c <_ZN6NrfSpi12readRegisterENS_12eNrfRegisterE>
 8012260:	4603      	mov	r3, r0
 8012262:	73fb      	strb	r3, [r7, #15]
	config |= NrfSpi::CONFIG_REG_PRIM_RX;		// Set PRIM_RX_BIT to enter RX mode
 8012264:	7bfb      	ldrb	r3, [r7, #15]
 8012266:	f043 0301 	orr.w	r3, r3, #1
 801226a:	73fb      	strb	r3, [r7, #15]
	// Write new value to config register
    NrfSpi::writeRegister(NrfSpi::CONFIG, config);
 801226c:	687b      	ldr	r3, [r7, #4]
 801226e:	3304      	adds	r3, #4
 8012270:	7bfa      	ldrb	r2, [r7, #15]
 8012272:	2100      	movs	r1, #0
 8012274:	4618      	mov	r0, r3
 8012276:	f7ff f83b 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
}
 801227a:	bf00      	nop
 801227c:	3710      	adds	r7, #16
 801227e:	46bd      	mov	sp, r7
 8012280:	bd80      	pop	{r7, pc}

08012282 <_ZNK5board14NrfTransceiver12radioChannelEv>:

IPhyTransceiver::RadioChannel NrfTransceiver::radioChannel() const
{
 8012282:	b480      	push	{r7}
 8012284:	b083      	sub	sp, #12
 8012286:	af00      	add	r7, sp, #0
 8012288:	6078      	str	r0, [r7, #4]
	return _channel;
 801228a:	687b      	ldr	r3, [r7, #4]
 801228c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
}
 8012290:	4618      	mov	r0, r3
 8012292:	370c      	adds	r7, #12
 8012294:	46bd      	mov	sp, r7
 8012296:	f85d 7b04 	ldr.w	r7, [sp], #4
 801229a:	4770      	bx	lr

0801229c <_ZN5board14NrfTransceiver15setRadioChannelEh>:

bool NrfTransceiver::setRadioChannel(RadioChannel channel)
{
 801229c:	b580      	push	{r7, lr}
 801229e:	b082      	sub	sp, #8
 80122a0:	af00      	add	r7, sp, #0
 80122a2:	6078      	str	r0, [r7, #4]
 80122a4:	460b      	mov	r3, r1
 80122a6:	70fb      	strb	r3, [r7, #3]
	assert(NrfSpi::isInitialized());	// Call initialize() first!
 80122a8:	687b      	ldr	r3, [r7, #4]
 80122aa:	3304      	adds	r3, #4
 80122ac:	4618      	mov	r0, r3
 80122ae:	f7fe fde3 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 80122b2:	4603      	mov	r3, r0
 80122b4:	2b00      	cmp	r3, #0
 80122b6:	d106      	bne.n	80122c6 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x2a>
 80122b8:	4b14      	ldr	r3, [pc, #80]	; (801230c <_ZN5board14NrfTransceiver15setRadioChannelEh+0x70>)
 80122ba:	4a15      	ldr	r2, [pc, #84]	; (8012310 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x74>)
 80122bc:	f240 11c3 	movw	r1, #451	; 0x1c3
 80122c0:	4814      	ldr	r0, [pc, #80]	; (8012314 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x78>)
 80122c2:	f004 f867 	bl	8016394 <__assert_func>

	// Only values from 0 to 125 are allowed
	if (channel < 126)
 80122c6:	78fb      	ldrb	r3, [r7, #3]
 80122c8:	2b7d      	cmp	r3, #125	; 0x7d
 80122ca:	d819      	bhi.n	8012300 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x64>
	{
		if (_channel != channel)
 80122cc:	687b      	ldr	r3, [r7, #4]
 80122ce:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80122d2:	78fa      	ldrb	r2, [r7, #3]
 80122d4:	429a      	cmp	r2, r3
 80122d6:	d011      	beq.n	80122fc <_ZN5board14NrfTransceiver15setRadioChannelEh+0x60>
		{
			_channel = channel;
 80122d8:	687b      	ldr	r3, [r7, #4]
 80122da:	78fa      	ldrb	r2, [r7, #3]
 80122dc:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

			traceOut("Nrf: Changed radio channel: %d", _channel);
 80122e0:	687b      	ldr	r3, [r7, #4]
 80122e2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80122e6:	4619      	mov	r1, r3
 80122e8:	480b      	ldr	r0, [pc, #44]	; (8012318 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x7c>)
 80122ea:	f7ff feeb 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>

			NrfSpi::writeRegister(NrfSpi::RF_CH, channel);
 80122ee:	687b      	ldr	r3, [r7, #4]
 80122f0:	3304      	adds	r3, #4
 80122f2:	78fa      	ldrb	r2, [r7, #3]
 80122f4:	2105      	movs	r1, #5
 80122f6:	4618      	mov	r0, r3
 80122f8:	f7fe fffa 	bl	80112f0 <_ZN6NrfSpi13writeRegisterENS_12eNrfRegisterEh>
		}
		return true;
 80122fc:	2301      	movs	r3, #1
 80122fe:	e000      	b.n	8012302 <_ZN5board14NrfTransceiver15setRadioChannelEh+0x66>
	}
	return false;
 8012300:	2300      	movs	r3, #0
}
 8012302:	4618      	mov	r0, r3
 8012304:	3708      	adds	r7, #8
 8012306:	46bd      	mov	sp, r7
 8012308:	bd80      	pop	{r7, pc}
 801230a:	bf00      	nop
 801230c:	0801a734 	.word	0x0801a734
 8012310:	0801a790 	.word	0x0801a790
 8012314:	0801a42c 	.word	0x0801a42c
 8012318:	0801a7e4 	.word	0x0801a7e4

0801231c <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver>:

bool NrfTransceiver::setObserver(const IPhyObserver & observer)
{
 801231c:	b580      	push	{r7, lr}
 801231e:	b082      	sub	sp, #8
 8012320:	af00      	add	r7, sp, #0
 8012322:	6078      	str	r0, [r7, #4]
 8012324:	6039      	str	r1, [r7, #0]
	if (!_pObserver)
 8012326:	687b      	ldr	r3, [r7, #4]
 8012328:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801232a:	2b00      	cmp	r3, #0
 801232c:	d10f      	bne.n	801234e <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x32>
	{
		_pObserver = const_cast<IPhyObserver*>(&observer);
 801232e:	687b      	ldr	r3, [r7, #4]
 8012330:	683a      	ldr	r2, [r7, #0]
 8012332:	625a      	str	r2, [r3, #36]	; 0x24
		assert(_pObserver);
 8012334:	687b      	ldr	r3, [r7, #4]
 8012336:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012338:	2b00      	cmp	r3, #0
 801233a:	d106      	bne.n	801234a <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x2e>
 801233c:	4b06      	ldr	r3, [pc, #24]	; (8012358 <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x3c>)
 801233e:	4a07      	ldr	r2, [pc, #28]	; (801235c <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x40>)
 8012340:	f44f 71ed 	mov.w	r1, #474	; 0x1da
 8012344:	4806      	ldr	r0, [pc, #24]	; (8012360 <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x44>)
 8012346:	f004 f825 	bl	8016394 <__assert_func>
		return true;
 801234a:	2301      	movs	r3, #1
 801234c:	e000      	b.n	8012350 <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver+0x34>
	}
	return false;
 801234e:	2300      	movs	r3, #0
}
 8012350:	4618      	mov	r0, r3
 8012352:	3708      	adds	r7, #8
 8012354:	46bd      	mov	sp, r7
 8012356:	bd80      	pop	{r7, pc}
 8012358:	0801a804 	.word	0x0801a804
 801235c:	0801a810 	.word	0x0801a810
 8012360:	0801a42c 	.word	0x0801a42c

08012364 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE>:

bool NrfTransceiver::send(const Frame & frame)
{
 8012364:	b590      	push	{r4, r7, lr}
 8012366:	b087      	sub	sp, #28
 8012368:	af00      	add	r7, sp, #0
 801236a:	6078      	str	r0, [r7, #4]
 801236c:	6039      	str	r1, [r7, #0]
	unsigned char status;

	UNUSED(status);

	assert(NrfSpi::isInitialized());	// Call initialize() first!
 801236e:	687b      	ldr	r3, [r7, #4]
 8012370:	3304      	adds	r3, #4
 8012372:	4618      	mov	r0, r3
 8012374:	f7fe fd80 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 8012378:	4603      	mov	r3, r0
 801237a:	2b00      	cmp	r3, #0
 801237c:	d106      	bne.n	801238c <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0x28>
 801237e:	4b28      	ldr	r3, [pc, #160]	; (8012420 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xbc>)
 8012380:	4a28      	ldr	r2, [pc, #160]	; (8012424 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xc0>)
 8012382:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
 8012386:	4828      	ldr	r0, [pc, #160]	; (8012428 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xc4>)
 8012388:	f004 f804 	bl	8016394 <__assert_func>

	if (!frame.length())
 801238c:	6838      	ldr	r0, [r7, #0]
 801238e:	f7f6 fcb1 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8012392:	4603      	mov	r3, r0
 8012394:	2b00      	cmp	r3, #0
 8012396:	bf0c      	ite	eq
 8012398:	2301      	moveq	r3, #1
 801239a:	2300      	movne	r3, #0
 801239c:	b2db      	uxtb	r3, r3
 801239e:	2b00      	cmp	r3, #0
 80123a0:	d006      	beq.n	80123b0 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0x4c>
	{
		assert(false);	// Really wont to send frame with zero length?!
 80123a2:	4b22      	ldr	r3, [pc, #136]	; (801242c <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xc8>)
 80123a4:	4a1f      	ldr	r2, [pc, #124]	; (8012424 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xc0>)
 80123a6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
 80123aa:	481f      	ldr	r0, [pc, #124]	; (8012428 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xc4>)
 80123ac:	f003 fff2 	bl	8016394 <__assert_func>
		return false;
	}

	// Set destination address
	setDestinationAddress(frame.destination());
 80123b0:	f107 030c 	add.w	r3, r7, #12
 80123b4:	6839      	ldr	r1, [r7, #0]
 80123b6:	4618      	mov	r0, r3
 80123b8:	f7f6 fd64 	bl	8008e84 <_ZNK7desenet5Frame11destinationEv>
 80123bc:	f107 030c 	add.w	r3, r7, #12
 80123c0:	4619      	mov	r1, r3
 80123c2:	6878      	ldr	r0, [r7, #4]
 80123c4:	f7ff fdc2 	bl	8011f4c <_ZN5board14NrfTransceiver21setDestinationAddressEN3phy7AddressILj4EEE>
 80123c8:	f107 030c 	add.w	r3, r7, #12
 80123cc:	4618      	mov	r0, r3
 80123ce:	f7f4 fdfb 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>

	traceOut("Nrf: TX Frame (size %d): %s", frame.length(), frame.toString());
 80123d2:	6838      	ldr	r0, [r7, #0]
 80123d4:	f7f6 fc8e 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 80123d8:	4604      	mov	r4, r0
 80123da:	6838      	ldr	r0, [r7, #0]
 80123dc:	f7f6 fdfe 	bl	8008fdc <_ZNK7desenet5Frame8toStringEv>
 80123e0:	4603      	mov	r3, r0
 80123e2:	461a      	mov	r2, r3
 80123e4:	4621      	mov	r1, r4
 80123e6:	4812      	ldr	r0, [pc, #72]	; (8012430 <_ZN5board14NrfTransceiver4sendERKN7desenet5FrameE+0xcc>)
 80123e8:	f7ff fe6c 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>

	NrfSpi::disableCE();
 80123ec:	687b      	ldr	r3, [r7, #4]
 80123ee:	3304      	adds	r3, #4
 80123f0:	4618      	mov	r0, r3
 80123f2:	f7ff fa17 	bl	8011824 <_ZNK6NrfSpi9disableCEEv>

	// Send payload - send any data
	status = NrfSpi::sendFrame(frame);
 80123f6:	687b      	ldr	r3, [r7, #4]
 80123f8:	3304      	adds	r3, #4
 80123fa:	6839      	ldr	r1, [r7, #0]
 80123fc:	4618      	mov	r0, r3
 80123fe:	f7fe fe9b 	bl	8011138 <_ZN6NrfSpi9sendFrameERKN7desenet5FrameE>
 8012402:	4603      	mov	r3, r0
 8012404:	75fb      	strb	r3, [r7, #23]

    enterTXMode();
 8012406:	6878      	ldr	r0, [r7, #4]
 8012408:	f7ff ff05 	bl	8012216 <_ZN5board14NrfTransceiver11enterTXModeEv>

	// Enable CE -> Starts the transmission
    NrfSpi::enableCE();
 801240c:	687b      	ldr	r3, [r7, #4]
 801240e:	3304      	adds	r3, #4
 8012410:	4618      	mov	r0, r3
 8012412:	f7ff f9f3 	bl	80117fc <_ZNK6NrfSpi8enableCEEv>

	return true;
 8012416:	2301      	movs	r3, #1
}
 8012418:	4618      	mov	r0, r3
 801241a:	371c      	adds	r7, #28
 801241c:	46bd      	mov	sp, r7
 801241e:	bd90      	pop	{r4, r7, pc}
 8012420:	0801a734 	.word	0x0801a734
 8012424:	0801a858 	.word	0x0801a858
 8012428:	0801a42c 	.word	0x0801a42c
 801242c:	0801a898 	.word	0x0801a898
 8012430:	0801a8a0 	.word	0x0801a8a0

08012434 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj>:

bool NrfTransceiver::transmit(const tAddress & destinationAddress, const uint8_t * const buffer, const std::size_t & length)
{
 8012434:	b590      	push	{r4, r7, lr}
 8012436:	b089      	sub	sp, #36	; 0x24
 8012438:	af00      	add	r7, sp, #0
 801243a:	60f8      	str	r0, [r7, #12]
 801243c:	60b9      	str	r1, [r7, #8]
 801243e:	607a      	str	r2, [r7, #4]
 8012440:	603b      	str	r3, [r7, #0]
	unsigned char status;
	UNUSED(status);		// Make compiler happy

	assert(NrfSpi::isInitialized());	// Call initialize() first!
 8012442:	68fb      	ldr	r3, [r7, #12]
 8012444:	3304      	adds	r3, #4
 8012446:	4618      	mov	r0, r3
 8012448:	f7fe fd16 	bl	8010e78 <_ZNK6NrfSpi13isInitializedEv>
 801244c:	4603      	mov	r3, r0
 801244e:	2b00      	cmp	r3, #0
 8012450:	d106      	bne.n	8012460 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0x2c>
 8012452:	4b25      	ldr	r3, [pc, #148]	; (80124e8 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xb4>)
 8012454:	4a25      	ldr	r2, [pc, #148]	; (80124ec <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xb8>)
 8012456:	f240 2105 	movw	r1, #517	; 0x205
 801245a:	4825      	ldr	r0, [pc, #148]	; (80124f0 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xbc>)
 801245c:	f003 ff9a 	bl	8016394 <__assert_func>

	if (!length)
 8012460:	683b      	ldr	r3, [r7, #0]
 8012462:	681b      	ldr	r3, [r3, #0]
 8012464:	2b00      	cmp	r3, #0
 8012466:	d106      	bne.n	8012476 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0x42>
	{
		assert(false);	// Really wont to send frame with zero length?!
 8012468:	4b22      	ldr	r3, [pc, #136]	; (80124f4 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xc0>)
 801246a:	4a20      	ldr	r2, [pc, #128]	; (80124ec <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xb8>)
 801246c:	f240 2109 	movw	r1, #521	; 0x209
 8012470:	481f      	ldr	r0, [pc, #124]	; (80124f0 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xbc>)
 8012472:	f003 ff8f 	bl	8016394 <__assert_func>
		return false;
	}

	// Set destination address
	setDestinationAddress(destinationAddress);
 8012476:	f107 0314 	add.w	r3, r7, #20
 801247a:	68b9      	ldr	r1, [r7, #8]
 801247c:	4618      	mov	r0, r3
 801247e:	f7fe fcc7 	bl	8010e10 <_ZN3phy7AddressILj4EEC1ERKS1_>
 8012482:	f107 0314 	add.w	r3, r7, #20
 8012486:	4619      	mov	r1, r3
 8012488:	68f8      	ldr	r0, [r7, #12]
 801248a:	f7ff fd5f 	bl	8011f4c <_ZN5board14NrfTransceiver21setDestinationAddressEN3phy7AddressILj4EEE>
 801248e:	f107 0314 	add.w	r3, r7, #20
 8012492:	4618      	mov	r0, r3
 8012494:	f7f4 fd98 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>

	traceOut("Nrf: TX Frame (size %d): %s", length, Frame::toString(buffer, length));
 8012498:	683b      	ldr	r3, [r7, #0]
 801249a:	681c      	ldr	r4, [r3, #0]
 801249c:	6839      	ldr	r1, [r7, #0]
 801249e:	6878      	ldr	r0, [r7, #4]
 80124a0:	f7f6 fdb6 	bl	8009010 <_ZN7desenet5Frame8toStringEPKhRKj>
 80124a4:	4603      	mov	r3, r0
 80124a6:	461a      	mov	r2, r3
 80124a8:	4621      	mov	r1, r4
 80124aa:	4813      	ldr	r0, [pc, #76]	; (80124f8 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj+0xc4>)
 80124ac:	f7ff fe0a 	bl	80120c4 <_ZN5board14NrfTransceiver8traceOutEPKcz>

	NrfSpi::disableCE();
 80124b0:	68fb      	ldr	r3, [r7, #12]
 80124b2:	3304      	adds	r3, #4
 80124b4:	4618      	mov	r0, r3
 80124b6:	f7ff f9b5 	bl	8011824 <_ZNK6NrfSpi9disableCEEv>

	// Send payload - send any data
	status = NrfSpi::transmit(buffer, length);
 80124ba:	68fb      	ldr	r3, [r7, #12]
 80124bc:	3304      	adds	r3, #4
 80124be:	683a      	ldr	r2, [r7, #0]
 80124c0:	6879      	ldr	r1, [r7, #4]
 80124c2:	4618      	mov	r0, r3
 80124c4:	f7fe fe6c 	bl	80111a0 <_ZN6NrfSpi8transmitEPKhRKj>
 80124c8:	4603      	mov	r3, r0
 80124ca:	77fb      	strb	r3, [r7, #31]

    enterTXMode();		// Start transmission
 80124cc:	68f8      	ldr	r0, [r7, #12]
 80124ce:	f7ff fea2 	bl	8012216 <_ZN5board14NrfTransceiver11enterTXModeEv>

	// Enable CE -> Starts the transmission
    NrfSpi::enableCE();
 80124d2:	68fb      	ldr	r3, [r7, #12]
 80124d4:	3304      	adds	r3, #4
 80124d6:	4618      	mov	r0, r3
 80124d8:	f7ff f990 	bl	80117fc <_ZNK6NrfSpi8enableCEEv>

	return true;
 80124dc:	2301      	movs	r3, #1
}
 80124de:	4618      	mov	r0, r3
 80124e0:	3724      	adds	r7, #36	; 0x24
 80124e2:	46bd      	mov	sp, r7
 80124e4:	bd90      	pop	{r4, r7, pc}
 80124e6:	bf00      	nop
 80124e8:	0801a734 	.word	0x0801a734
 80124ec:	0801a8bc 	.word	0x0801a8bc
 80124f0:	0801a42c 	.word	0x0801a42c
 80124f4:	0801a898 	.word	0x0801a898
 80124f8:	0801a8a0 	.word	0x0801a8a0

080124fc <_ZNK3phy7AddressILj4EE6copyToEPh>:
	void copyTo( uint8_t * const to ) const
 80124fc:	b580      	push	{r7, lr}
 80124fe:	b082      	sub	sp, #8
 8012500:	af00      	add	r7, sp, #0
 8012502:	6078      	str	r0, [r7, #4]
 8012504:	6039      	str	r1, [r7, #0]
		assert( to );
 8012506:	683b      	ldr	r3, [r7, #0]
 8012508:	2b00      	cmp	r3, #0
 801250a:	d105      	bne.n	8012518 <_ZNK3phy7AddressILj4EE6copyToEPh+0x1c>
 801250c:	4b09      	ldr	r3, [pc, #36]	; (8012534 <_ZNK3phy7AddressILj4EE6copyToEPh+0x38>)
 801250e:	4a0a      	ldr	r2, [pc, #40]	; (8012538 <_ZNK3phy7AddressILj4EE6copyToEPh+0x3c>)
 8012510:	2183      	movs	r1, #131	; 0x83
 8012512:	480a      	ldr	r0, [pc, #40]	; (801253c <_ZNK3phy7AddressILj4EE6copyToEPh+0x40>)
 8012514:	f003 ff3e 	bl	8016394 <__assert_func>
		if ( to )
 8012518:	683b      	ldr	r3, [r7, #0]
 801251a:	2b00      	cmp	r3, #0
 801251c:	d005      	beq.n	801252a <_ZNK3phy7AddressILj4EE6copyToEPh+0x2e>
					reinterpret_cast<const void *>( _address ) , size );
 801251e:	687b      	ldr	r3, [r7, #4]
 8012520:	3304      	adds	r3, #4
 8012522:	681b      	ldr	r3, [r3, #0]
 8012524:	461a      	mov	r2, r3
			memcpy( reinterpret_cast<void *>( to ) ,
 8012526:	683b      	ldr	r3, [r7, #0]
 8012528:	601a      	str	r2, [r3, #0]
	}
 801252a:	bf00      	nop
 801252c:	3708      	adds	r7, #8
 801252e:	46bd      	mov	sp, r7
 8012530:	bd80      	pop	{r7, pc}
 8012532:	bf00      	nop
 8012534:	0801a9fc 	.word	0x0801a9fc
 8012538:	0801aa00 	.word	0x0801aa00
 801253c:	0801a988 	.word	0x0801a988

08012540 <_Z41__static_initialization_and_destruction_0ii>:
 8012540:	b580      	push	{r7, lr}
 8012542:	b088      	sub	sp, #32
 8012544:	af00      	add	r7, sp, #0
 8012546:	6078      	str	r0, [r7, #4]
 8012548:	6039      	str	r1, [r7, #0]
 801254a:	687b      	ldr	r3, [r7, #4]
 801254c:	2b01      	cmp	r3, #1
 801254e:	d122      	bne.n	8012596 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8012550:	683b      	ldr	r3, [r7, #0]
 8012552:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8012556:	4293      	cmp	r3, r2
 8012558:	d11d      	bne.n	8012596 <_Z41__static_initialization_and_destruction_0ii+0x56>
 801255a:	4b18      	ldr	r3, [pc, #96]	; (80125bc <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 801255c:	681b      	ldr	r3, [r3, #0]
 801255e:	613b      	str	r3, [r7, #16]
 8012560:	f107 0310 	add.w	r3, r7, #16
 8012564:	60bb      	str	r3, [r7, #8]
 8012566:	2304      	movs	r3, #4
 8012568:	60fb      	str	r3, [r7, #12]
 801256a:	f107 0308 	add.w	r3, r7, #8
 801256e:	e893 0006 	ldmia.w	r3, {r1, r2}
 8012572:	4813      	ldr	r0, [pc, #76]	; (80125c0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8012574:	f7f4 fbde 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8012578:	4b12      	ldr	r3, [pc, #72]	; (80125c4 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 801257a:	681b      	ldr	r3, [r3, #0]
 801257c:	61fb      	str	r3, [r7, #28]
 801257e:	f107 031c 	add.w	r3, r7, #28
 8012582:	617b      	str	r3, [r7, #20]
 8012584:	2304      	movs	r3, #4
 8012586:	61bb      	str	r3, [r7, #24]
 8012588:	f107 0314 	add.w	r3, r7, #20
 801258c:	e893 0006 	ldmia.w	r3, {r1, r2}
 8012590:	480d      	ldr	r0, [pc, #52]	; (80125c8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8012592:	f7f4 fbcf 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8012596:	687b      	ldr	r3, [r7, #4]
 8012598:	2b00      	cmp	r3, #0
 801259a:	d10a      	bne.n	80125b2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 801259c:	683b      	ldr	r3, [r7, #0]
 801259e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80125a2:	4293      	cmp	r3, r2
 80125a4:	d105      	bne.n	80125b2 <_Z41__static_initialization_and_destruction_0ii+0x72>
 80125a6:	4808      	ldr	r0, [pc, #32]	; (80125c8 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 80125a8:	f7f4 fd0e 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 80125ac:	4804      	ldr	r0, [pc, #16]	; (80125c0 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 80125ae:	f7f4 fd0b 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 80125b2:	bf00      	nop
 80125b4:	3720      	adds	r7, #32
 80125b6:	46bd      	mov	sp, r7
 80125b8:	bd80      	pop	{r7, pc}
 80125ba:	bf00      	nop
 80125bc:	0801aa68 	.word	0x0801aa68
 80125c0:	20001c04 	.word	0x20001c04
 80125c4:	0801aa6c 	.word	0x0801aa6c
 80125c8:	20001c0c 	.word	0x20001c0c

080125cc <_GLOBAL__sub_I__ZN5board14NrfTransceiver10_pInstanceE>:
 80125cc:	b580      	push	{r7, lr}
 80125ce:	af00      	add	r7, sp, #0
 80125d0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80125d4:	2001      	movs	r0, #1
 80125d6:	f7ff ffb3 	bl	8012540 <_Z41__static_initialization_and_destruction_0ii>
 80125da:	bd80      	pop	{r7, pc}

080125dc <_GLOBAL__sub_D__ZN5board14NrfTransceiver10_pInstanceE>:
 80125dc:	b580      	push	{r7, lr}
 80125de:	af00      	add	r7, sp, #0
 80125e0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80125e4:	2000      	movs	r0, #0
 80125e6:	f7ff ffab 	bl	8012540 <_Z41__static_initialization_and_destruction_0ii>
 80125ea:	bd80      	pop	{r7, pc}

080125ec <_ZNKSt14_Function_base8_M_emptyEv>:
    bool _M_empty() const { return !_M_manager; }
 80125ec:	b480      	push	{r7}
 80125ee:	b083      	sub	sp, #12
 80125f0:	af00      	add	r7, sp, #0
 80125f2:	6078      	str	r0, [r7, #4]
 80125f4:	687b      	ldr	r3, [r7, #4]
 80125f6:	689b      	ldr	r3, [r3, #8]
 80125f8:	2b00      	cmp	r3, #0
 80125fa:	bf0c      	ite	eq
 80125fc:	2301      	moveq	r3, #1
 80125fe:	2300      	movne	r3, #0
 8012600:	b2db      	uxtb	r3, r3
 8012602:	4618      	mov	r0, r3
 8012604:	370c      	adds	r7, #12
 8012606:	46bd      	mov	sp, r7
 8012608:	f85d 7b04 	ldr.w	r7, [sp], #4
 801260c:	4770      	bx	lr
	...

08012610 <_ZN7desenet22NetworkInterfaceDriverC1Ev>:
         * @return  List of network interface driver descriptors.
         */
        static DescriptorList interfaceDescriptors();

    protected:
        NetworkInterfaceDriver() {}
 8012610:	b480      	push	{r7}
 8012612:	b083      	sub	sp, #12
 8012614:	af00      	add	r7, sp, #0
 8012616:	6078      	str	r0, [r7, #4]
 8012618:	4a04      	ldr	r2, [pc, #16]	; (801262c <_ZN7desenet22NetworkInterfaceDriverC1Ev+0x1c>)
 801261a:	687b      	ldr	r3, [r7, #4]
 801261c:	601a      	str	r2, [r3, #0]
 801261e:	687b      	ldr	r3, [r7, #4]
 8012620:	4618      	mov	r0, r3
 8012622:	370c      	adds	r7, #12
 8012624:	46bd      	mov	sp, r7
 8012626:	f85d 7b04 	ldr.w	r7, [sp], #4
 801262a:	4770      	bx	lr
 801262c:	0801b9c4 	.word	0x0801b9c4

08012630 <_ZN12IPhyObserverC1Ev>:
 */
class IPhyObserver
{
protected:
	// It is just an interface, so constructor and destructor should be not public.
	explicit IPhyObserver() {}
 8012630:	b480      	push	{r7}
 8012632:	b083      	sub	sp, #12
 8012634:	af00      	add	r7, sp, #0
 8012636:	6078      	str	r0, [r7, #4]
 8012638:	4a04      	ldr	r2, [pc, #16]	; (801264c <_ZN12IPhyObserverC1Ev+0x1c>)
 801263a:	687b      	ldr	r3, [r7, #4]
 801263c:	601a      	str	r2, [r3, #0]
 801263e:	687b      	ldr	r3, [r7, #4]
 8012640:	4618      	mov	r0, r3
 8012642:	370c      	adds	r7, #12
 8012644:	46bd      	mov	sp, r7
 8012646:	f85d 7b04 	ldr.w	r7, [sp], #4
 801264a:	4770      	bx	lr
 801264c:	0801db78 	.word	0x0801db78

08012650 <__tcf_0>:
 */
desenet::NetworkInterfaceDriver * instanciateNic(uint32_t address, const std::string & name)
{
	UNUSED(address); UNUSED(name);

	static NrfTransceiverDriver nrfTransceiverDriver;
 8012650:	b580      	push	{r7, lr}
 8012652:	af00      	add	r7, sp, #0
 8012654:	4801      	ldr	r0, [pc, #4]	; (801265c <__tcf_0+0xc>)
 8012656:	f000 f869 	bl	801272c <_ZN7desenet20NrfTransceiverDriverD1Ev>
 801265a:	bd80      	pop	{r7, pc}
 801265c:	20001d40 	.word	0x20001d40

08012660 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>:
{
 8012660:	b580      	push	{r7, lr}
 8012662:	b082      	sub	sp, #8
 8012664:	af00      	add	r7, sp, #0
 8012666:	6078      	str	r0, [r7, #4]
 8012668:	6039      	str	r1, [r7, #0]
	static NrfTransceiverDriver nrfTransceiverDriver;
 801266a:	4b13      	ldr	r3, [pc, #76]	; (80126b8 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x58>)
 801266c:	781b      	ldrb	r3, [r3, #0]
 801266e:	f3bf 8f5b 	dmb	ish
 8012672:	b2db      	uxtb	r3, r3
 8012674:	f003 0301 	and.w	r3, r3, #1
 8012678:	2b00      	cmp	r3, #0
 801267a:	bf0c      	ite	eq
 801267c:	2301      	moveq	r3, #1
 801267e:	2300      	movne	r3, #0
 8012680:	b2db      	uxtb	r3, r3
 8012682:	2b00      	cmp	r3, #0
 8012684:	d013      	beq.n	80126ae <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x4e>
 8012686:	480c      	ldr	r0, [pc, #48]	; (80126b8 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x58>)
 8012688:	f003 fd94 	bl	80161b4 <__cxa_guard_acquire>
 801268c:	4603      	mov	r3, r0
 801268e:	2b00      	cmp	r3, #0
 8012690:	bf14      	ite	ne
 8012692:	2301      	movne	r3, #1
 8012694:	2300      	moveq	r3, #0
 8012696:	b2db      	uxtb	r3, r3
 8012698:	2b00      	cmp	r3, #0
 801269a:	d008      	beq.n	80126ae <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x4e>
 801269c:	4807      	ldr	r0, [pc, #28]	; (80126bc <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x5c>)
 801269e:	f000 f811 	bl	80126c4 <_ZN7desenet20NrfTransceiverDriverC1Ev>
 80126a2:	4807      	ldr	r0, [pc, #28]	; (80126c0 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x60>)
 80126a4:	f003 fe94 	bl	80163d0 <atexit>
 80126a8:	4803      	ldr	r0, [pc, #12]	; (80126b8 <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x58>)
 80126aa:	f003 fd8f 	bl	80161cc <__cxa_guard_release>

	return &nrfTransceiverDriver;
 80126ae:	4b03      	ldr	r3, [pc, #12]	; (80126bc <_Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x5c>)
}
 80126b0:	4618      	mov	r0, r3
 80126b2:	3708      	adds	r7, #8
 80126b4:	46bd      	mov	sp, r7
 80126b6:	bd80      	pop	{r7, pc}
 80126b8:	20001dbc 	.word	0x20001dbc
 80126bc:	20001d40 	.word	0x20001d40
 80126c0:	08012651 	.word	0x08012651

080126c4 <_ZN7desenet20NrfTransceiverDriverC1Ev>:

NrfTransceiverDriver::NrfTransceiverDriver()
 80126c4:	b580      	push	{r7, lr}
 80126c6:	b082      	sub	sp, #8
 80126c8:	af00      	add	r7, sp, #0
 80126ca:	6078      	str	r0, [r7, #4]
 : _initialized(false),
   _receiveCallbackHandler(nullptr)
 80126cc:	687b      	ldr	r3, [r7, #4]
 80126ce:	4618      	mov	r0, r3
 80126d0:	f7ff ff9e 	bl	8012610 <_ZN7desenet22NetworkInterfaceDriverC1Ev>
 80126d4:	687b      	ldr	r3, [r7, #4]
 80126d6:	3304      	adds	r3, #4
 80126d8:	4618      	mov	r0, r3
 80126da:	f7f7 fcc1 	bl	800a060 <_ZN7desenet22NetworkInterfaceDriver10DescriptorC1Ev>
 80126de:	687b      	ldr	r3, [r7, #4]
 80126e0:	3308      	adds	r3, #8
 80126e2:	4618      	mov	r0, r3
 80126e4:	f7ff ffa4 	bl	8012630 <_ZN12IPhyObserverC1Ev>
 80126e8:	4a0d      	ldr	r2, [pc, #52]	; (8012720 <_ZN7desenet20NrfTransceiverDriverC1Ev+0x5c>)
 80126ea:	687b      	ldr	r3, [r7, #4]
 80126ec:	601a      	str	r2, [r3, #0]
 80126ee:	4a0d      	ldr	r2, [pc, #52]	; (8012724 <_ZN7desenet20NrfTransceiverDriverC1Ev+0x60>)
 80126f0:	687b      	ldr	r3, [r7, #4]
 80126f2:	605a      	str	r2, [r3, #4]
 80126f4:	4a0c      	ldr	r2, [pc, #48]	; (8012728 <_ZN7desenet20NrfTransceiverDriverC1Ev+0x64>)
 80126f6:	687b      	ldr	r3, [r7, #4]
 80126f8:	609a      	str	r2, [r3, #8]
 80126fa:	687b      	ldr	r3, [r7, #4]
 80126fc:	2200      	movs	r2, #0
 80126fe:	731a      	strb	r2, [r3, #12]
 8012700:	687b      	ldr	r3, [r7, #4]
 8012702:	3310      	adds	r3, #16
 8012704:	4618      	mov	r0, r3
 8012706:	f7ff f8c5 	bl	8011894 <_ZN5board14NrfTransceiverC1Ev>
 801270a:	687b      	ldr	r3, [r7, #4]
 801270c:	336c      	adds	r3, #108	; 0x6c
 801270e:	2100      	movs	r1, #0
 8012710:	4618      	mov	r0, r3
 8012712:	f000 f95f 	bl	80129d4 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1EDn>
{

}
 8012716:	687b      	ldr	r3, [r7, #4]
 8012718:	4618      	mov	r0, r3
 801271a:	3708      	adds	r7, #8
 801271c:	46bd      	mov	sp, r7
 801271e:	bd80      	pop	{r7, pc}
 8012720:	0801db0c 	.word	0x0801db0c
 8012724:	0801db44 	.word	0x0801db44
 8012728:	0801db60 	.word	0x0801db60

0801272c <_ZN7desenet20NrfTransceiverDriverD1Ev>:

NrfTransceiverDriver::~NrfTransceiverDriver()
 801272c:	b580      	push	{r7, lr}
 801272e:	b082      	sub	sp, #8
 8012730:	af00      	add	r7, sp, #0
 8012732:	6078      	str	r0, [r7, #4]
 8012734:	4a07      	ldr	r2, [pc, #28]	; (8012754 <_ZN7desenet20NrfTransceiverDriverD1Ev+0x28>)
 8012736:	687b      	ldr	r3, [r7, #4]
 8012738:	601a      	str	r2, [r3, #0]
 801273a:	4a07      	ldr	r2, [pc, #28]	; (8012758 <_ZN7desenet20NrfTransceiverDriverD1Ev+0x2c>)
 801273c:	687b      	ldr	r3, [r7, #4]
 801273e:	605a      	str	r2, [r3, #4]
 8012740:	4a06      	ldr	r2, [pc, #24]	; (801275c <_ZN7desenet20NrfTransceiverDriverD1Ev+0x30>)
 8012742:	687b      	ldr	r3, [r7, #4]
 8012744:	609a      	str	r2, [r3, #8]
{
	assert(false);	// Instance should never be deleted
 8012746:	4b06      	ldr	r3, [pc, #24]	; (8012760 <_ZN7desenet20NrfTransceiverDriverD1Ev+0x34>)
 8012748:	4a06      	ldr	r2, [pc, #24]	; (8012764 <_ZN7desenet20NrfTransceiverDriverD1Ev+0x38>)
 801274a:	211d      	movs	r1, #29
 801274c:	4806      	ldr	r0, [pc, #24]	; (8012768 <_ZN7desenet20NrfTransceiverDriverD1Ev+0x3c>)
 801274e:	f003 fe21 	bl	8016394 <__assert_func>
 8012752:	bf00      	nop
 8012754:	0801db0c 	.word	0x0801db0c
 8012758:	0801db44 	.word	0x0801db44
 801275c:	0801db60 	.word	0x0801db60
 8012760:	0801aa70 	.word	0x0801aa70
 8012764:	0801aa78 	.word	0x0801aa78
 8012768:	0801aab8 	.word	0x0801aab8

0801276c <_ZThn4_N7desenet20NrfTransceiverDriverD1Ev>:
							 public NetworkInterfaceDriver::Descriptor,
							 protected IPhyObserver
{
public:
	NrfTransceiverDriver();
	virtual ~NrfTransceiverDriver();
 801276c:	f1a0 0004 	sub.w	r0, r0, #4
 8012770:	f7ff bfdc 	b.w	801272c <_ZN7desenet20NrfTransceiverDriverD1Ev>

08012774 <_ZThn8_N7desenet20NrfTransceiverDriverD1Ev>:
 8012774:	f1a0 0008 	sub.w	r0, r0, #8
 8012778:	f7ff bfd8 	b.w	801272c <_ZN7desenet20NrfTransceiverDriverD1Ev>

0801277c <_ZN7desenet20NrfTransceiverDriverD0Ev>:
NrfTransceiverDriver::~NrfTransceiverDriver()
 801277c:	b580      	push	{r7, lr}
 801277e:	b082      	sub	sp, #8
 8012780:	af00      	add	r7, sp, #0
 8012782:	6078      	str	r0, [r7, #4]
}
 8012784:	6878      	ldr	r0, [r7, #4]
 8012786:	f7ff ffd1 	bl	801272c <_ZN7desenet20NrfTransceiverDriverD1Ev>
 801278a:	217c      	movs	r1, #124	; 0x7c
 801278c:	6878      	ldr	r0, [r7, #4]
 801278e:	f003 fd0d 	bl	80161ac <_ZdlPvj>
 8012792:	687b      	ldr	r3, [r7, #4]
 8012794:	4618      	mov	r0, r3
 8012796:	3708      	adds	r7, #8
 8012798:	46bd      	mov	sp, r7
 801279a:	bd80      	pop	{r7, pc}

0801279c <_ZThn8_N7desenet20NrfTransceiverDriverD0Ev>:
 801279c:	f1a0 0008 	sub.w	r0, r0, #8
 80127a0:	f7ff bfec 	b.w	801277c <_ZN7desenet20NrfTransceiverDriverD0Ev>

080127a4 <_ZThn4_N7desenet20NrfTransceiverDriverD0Ev>:
 80127a4:	f1a0 0004 	sub.w	r0, r0, #4
 80127a8:	f7ff bfe8 	b.w	801277c <_ZN7desenet20NrfTransceiverDriverD0Ev>

080127ac <_ZN7desenet20NrfTransceiverDriver10initializeEv>:

bool NrfTransceiverDriver::initialize()
{
 80127ac:	b580      	push	{r7, lr}
 80127ae:	b082      	sub	sp, #8
 80127b0:	af00      	add	r7, sp, #0
 80127b2:	6078      	str	r0, [r7, #4]
	if (!_initialized)
 80127b4:	687b      	ldr	r3, [r7, #4]
 80127b6:	7b1b      	ldrb	r3, [r3, #12]
 80127b8:	f083 0301 	eor.w	r3, r3, #1
 80127bc:	b2db      	uxtb	r3, r3
 80127be:	2b00      	cmp	r3, #0
 80127c0:	d010      	beq.n	80127e4 <_ZN7desenet20NrfTransceiverDriver10initializeEv+0x38>
	{
		_transceiver.initialize();
 80127c2:	687b      	ldr	r3, [r7, #4]
 80127c4:	3310      	adds	r3, #16
 80127c6:	4618      	mov	r0, r3
 80127c8:	f7ff f91c 	bl	8011a04 <_ZN5board14NrfTransceiver10initializeEv>
		_transceiver.setObserver(*this);
 80127cc:	687b      	ldr	r3, [r7, #4]
 80127ce:	f103 0210 	add.w	r2, r3, #16
 80127d2:	687b      	ldr	r3, [r7, #4]
 80127d4:	3308      	adds	r3, #8
 80127d6:	4619      	mov	r1, r3
 80127d8:	4610      	mov	r0, r2
 80127da:	f7ff fd9f 	bl	801231c <_ZN5board14NrfTransceiver11setObserverERK12IPhyObserver>
		_initialized = true;
 80127de:	687b      	ldr	r3, [r7, #4]
 80127e0:	2201      	movs	r2, #1
 80127e2:	731a      	strb	r2, [r3, #12]
	}
	return true;
 80127e4:	2301      	movs	r3, #1
}
 80127e6:	4618      	mov	r0, r3
 80127e8:	3708      	adds	r7, #8
 80127ea:	46bd      	mov	sp, r7
 80127ec:	bd80      	pop	{r7, pc}

080127ee <_ZNK7desenet20NrfTransceiverDriver13isInitializedEv>:

bool NrfTransceiverDriver::isInitialized() const
{
 80127ee:	b480      	push	{r7}
 80127f0:	b083      	sub	sp, #12
 80127f2:	af00      	add	r7, sp, #0
 80127f4:	6078      	str	r0, [r7, #4]
	return _initialized;
 80127f6:	687b      	ldr	r3, [r7, #4]
 80127f8:	7b1b      	ldrb	r3, [r3, #12]
}
 80127fa:	4618      	mov	r0, r3
 80127fc:	370c      	adds	r7, #12
 80127fe:	46bd      	mov	sp, r7
 8012800:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012804:	4770      	bx	lr
	...

08012808 <_ZNK7desenet20NrfTransceiverDriver12localAddressEv>:

std::array<std::uint8_t, 4> NrfTransceiverDriver::localAddress() const
{
 8012808:	b580      	push	{r7, lr}
 801280a:	b084      	sub	sp, #16
 801280c:	af00      	add	r7, sp, #0
 801280e:	6078      	str	r0, [r7, #4]
	std::array<std::uint8_t, 4> address;
#if (DESENET_GATEWAY_NODE != 0)
  GATEWAY_ADDRESS.copyTo(address.data());
#else
  SENSOR_ADDRESS.copyTo(address.data());
 8012810:	f107 0308 	add.w	r3, r7, #8
 8012814:	4618      	mov	r0, r3
 8012816:	f000 f8eb 	bl	80129f0 <_ZNSt5arrayIhLj4EE4dataEv>
 801281a:	4603      	mov	r3, r0
 801281c:	4619      	mov	r1, r3
 801281e:	480b      	ldr	r0, [pc, #44]	; (801284c <_ZNK7desenet20NrfTransceiverDriver12localAddressEv+0x44>)
 8012820:	f7ff fe6c 	bl	80124fc <_ZNK3phy7AddressILj4EE6copyToEPh>
#endif
  return address;
 8012824:	68bb      	ldr	r3, [r7, #8]
 8012826:	60fb      	str	r3, [r7, #12]
 8012828:	2300      	movs	r3, #0
 801282a:	7b3a      	ldrb	r2, [r7, #12]
 801282c:	f362 0307 	bfi	r3, r2, #0, #8
 8012830:	7b7a      	ldrb	r2, [r7, #13]
 8012832:	f362 230f 	bfi	r3, r2, #8, #8
 8012836:	7bba      	ldrb	r2, [r7, #14]
 8012838:	f362 4317 	bfi	r3, r2, #16, #8
 801283c:	7bfa      	ldrb	r2, [r7, #15]
 801283e:	f362 631f 	bfi	r3, r2, #24, #8
}
 8012842:	4618      	mov	r0, r3
 8012844:	3710      	adds	r7, #16
 8012846:	46bd      	mov	sp, r7
 8012848:	bd80      	pop	{r7, pc}
 801284a:	bf00      	nop
 801284c:	20001d38 	.word	0x20001d38

08012850 <_ZN7desenet20NrfTransceiverDriver8transmitEPKhj>:

bool NrfTransceiverDriver::transmit(const std::uint8_t * const buffer, const std::size_t length)
{
 8012850:	b580      	push	{r7, lr}
 8012852:	b086      	sub	sp, #24
 8012854:	af00      	add	r7, sp, #0
 8012856:	60f8      	str	r0, [r7, #12]
 8012858:	60b9      	str	r1, [r7, #8]
 801285a:	607a      	str	r2, [r7, #4]
	// Cut away the frame header. It is automatically added by the nrf chip
	_transceiver.transmit(GATEWAY_ADDRESS, buffer + Frame::HEADER_SIZE, length - Frame::HEADER_SIZE);
 801285c:	68fb      	ldr	r3, [r7, #12]
 801285e:	f103 0010 	add.w	r0, r3, #16
 8012862:	68bb      	ldr	r3, [r7, #8]
 8012864:	1d5a      	adds	r2, r3, #5
 8012866:	687b      	ldr	r3, [r7, #4]
 8012868:	3b05      	subs	r3, #5
 801286a:	617b      	str	r3, [r7, #20]
 801286c:	f107 0314 	add.w	r3, r7, #20
 8012870:	4903      	ldr	r1, [pc, #12]	; (8012880 <_ZN7desenet20NrfTransceiverDriver8transmitEPKhj+0x30>)
 8012872:	f7ff fddf 	bl	8012434 <_ZN5board14NrfTransceiver8transmitERKN3phy7AddressILj4EEEPKhRKj>
	return true;
 8012876:	2301      	movs	r3, #1
}
 8012878:	4618      	mov	r0, r3
 801287a:	3718      	adds	r7, #24
 801287c:	46bd      	mov	sp, r7
 801287e:	bd80      	pop	{r7, pc}
 8012880:	20001d30 	.word	0x20001d30

08012884 <_ZN7desenet20NrfTransceiverDriver19setReceptionHandlerESt8functionIFvRNS_22NetworkInterfaceDriverEmPKhjEE>:

void NrfTransceiverDriver::setReceptionHandler(ReceptionCallbackHandler handler /* = nullptr */)
{
 8012884:	b580      	push	{r7, lr}
 8012886:	b082      	sub	sp, #8
 8012888:	af00      	add	r7, sp, #0
 801288a:	6078      	str	r0, [r7, #4]
 801288c:	6039      	str	r1, [r7, #0]
	_receiveCallbackHandler = handler;
 801288e:	687b      	ldr	r3, [r7, #4]
 8012890:	336c      	adds	r3, #108	; 0x6c
 8012892:	6839      	ldr	r1, [r7, #0]
 8012894:	4618      	mov	r0, r3
 8012896:	f000 f8b8 	bl	8012a0a <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEaSERKS6_>
}
 801289a:	bf00      	nop
 801289c:	3708      	adds	r7, #8
 801289e:	46bd      	mov	sp, r7
 80128a0:	bd80      	pop	{r7, pc}
	...

080128a4 <_ZNK7desenet20NrfTransceiverDriver10identifierB5cxx11Ev>:

std::string NrfTransceiverDriver::identifier() const
{
 80128a4:	b580      	push	{r7, lr}
 80128a6:	b084      	sub	sp, #16
 80128a8:	af00      	add	r7, sp, #0
 80128aa:	6078      	str	r0, [r7, #4]
 80128ac:	6039      	str	r1, [r7, #0]
	return "nrf0";
 80128ae:	f107 030c 	add.w	r3, r7, #12
 80128b2:	4618      	mov	r0, r3
 80128b4:	f003 fca3 	bl	80161fe <_ZNSaIcEC1Ev>
 80128b8:	f107 030c 	add.w	r3, r7, #12
 80128bc:	461a      	mov	r2, r3
 80128be:	4906      	ldr	r1, [pc, #24]	; (80128d8 <_ZNK7desenet20NrfTransceiverDriver10identifierB5cxx11Ev+0x34>)
 80128c0:	6878      	ldr	r0, [r7, #4]
 80128c2:	f003 fd2d 	bl	8016320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_>
 80128c6:	f107 030c 	add.w	r3, r7, #12
 80128ca:	4618      	mov	r0, r3
 80128cc:	f003 fc98 	bl	8016200 <_ZNSaIcED1Ev>
}
 80128d0:	6878      	ldr	r0, [r7, #4]
 80128d2:	3710      	adds	r7, #16
 80128d4:	46bd      	mov	sp, r7
 80128d6:	bd80      	pop	{r7, pc}
 80128d8:	0801ab50 	.word	0x0801ab50

080128dc <_ZThn4_NK7desenet20NrfTransceiverDriver10identifierB5cxx11Ev>:

	// NetworkInterfaceDriver interface implementation
public:
	virtual std::string identifier() const;
 80128dc:	f1a1 0104 	sub.w	r1, r1, #4
 80128e0:	f7ff bfe0 	b.w	80128a4 <_ZNK7desenet20NrfTransceiverDriver10identifierB5cxx11Ev>

080128e4 <_ZNK7desenet20NrfTransceiverDriver12friendlyNameB5cxx11Ev>:

std::string NrfTransceiverDriver::friendlyName() const
{
 80128e4:	b580      	push	{r7, lr}
 80128e6:	b084      	sub	sp, #16
 80128e8:	af00      	add	r7, sp, #0
 80128ea:	6078      	str	r0, [r7, #4]
 80128ec:	6039      	str	r1, [r7, #0]
	return "nrf0";
 80128ee:	f107 030c 	add.w	r3, r7, #12
 80128f2:	4618      	mov	r0, r3
 80128f4:	f003 fc83 	bl	80161fe <_ZNSaIcEC1Ev>
 80128f8:	f107 030c 	add.w	r3, r7, #12
 80128fc:	461a      	mov	r2, r3
 80128fe:	4906      	ldr	r1, [pc, #24]	; (8012918 <_ZNK7desenet20NrfTransceiverDriver12friendlyNameB5cxx11Ev+0x34>)
 8012900:	6878      	ldr	r0, [r7, #4]
 8012902:	f003 fd0d 	bl	8016320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_>
 8012906:	f107 030c 	add.w	r3, r7, #12
 801290a:	4618      	mov	r0, r3
 801290c:	f003 fc78 	bl	8016200 <_ZNSaIcED1Ev>
}
 8012910:	6878      	ldr	r0, [r7, #4]
 8012912:	3710      	adds	r7, #16
 8012914:	46bd      	mov	sp, r7
 8012916:	bd80      	pop	{r7, pc}
 8012918:	0801ab50 	.word	0x0801ab50

0801291c <_ZThn4_NK7desenet20NrfTransceiverDriver12friendlyNameB5cxx11Ev>:
	virtual bool transmit(const std::uint8_t *const buffer, const std::size_t length);
	virtual void setReceptionHandler(ReceptionCallbackHandler handler = nullptr);

	// NetworkInterfaceDriver::Descriptor interface implementation
public:
	virtual std::string friendlyName() const;
 801291c:	f1a1 0104 	sub.w	r1, r1, #4
 8012920:	f7ff bfe0 	b.w	80128e4 <_ZNK7desenet20NrfTransceiverDriver12friendlyNameB5cxx11Ev>

08012924 <_ZNK7desenet20NrfTransceiverDriver11instanciateEv>:

desenet::NetworkInterfaceDriver * NrfTransceiverDriver::instanciate() const
{
 8012924:	b480      	push	{r7}
 8012926:	b083      	sub	sp, #12
 8012928:	af00      	add	r7, sp, #0
 801292a:	6078      	str	r0, [r7, #4]
	return const_cast<NrfTransceiverDriver *>(this);
 801292c:	687b      	ldr	r3, [r7, #4]
}
 801292e:	4618      	mov	r0, r3
 8012930:	370c      	adds	r7, #12
 8012932:	46bd      	mov	sp, r7
 8012934:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012938:	4770      	bx	lr

0801293a <_ZThn4_NK7desenet20NrfTransceiverDriver11instanciateEv>:
	virtual desenet::NetworkInterfaceDriver * instanciate() const;
 801293a:	f1a0 0004 	sub.w	r0, r0, #4
 801293e:	f7ff bff1 	b.w	8012924 <_ZNK7desenet20NrfTransceiverDriver11instanciateEv>
	...

08012944 <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE>:

void NrfTransceiverDriver::onReceive(const Frame & frame)
{
 8012944:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012946:	b087      	sub	sp, #28
 8012948:	af02      	add	r7, sp, #8
 801294a:	6078      	str	r0, [r7, #4]
 801294c:	6039      	str	r1, [r7, #0]
	assert(_receiveCallbackHandler);
 801294e:	687b      	ldr	r3, [r7, #4]
 8012950:	336c      	adds	r3, #108	; 0x6c
 8012952:	4618      	mov	r0, r3
 8012954:	f000 f874 	bl	8012a40 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEcvbEv>
 8012958:	4603      	mov	r3, r0
 801295a:	2b00      	cmp	r3, #0
 801295c:	d105      	bne.n	801296a <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE+0x26>
 801295e:	4b10      	ldr	r3, [pc, #64]	; (80129a0 <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE+0x5c>)
 8012960:	4a10      	ldr	r2, [pc, #64]	; (80129a4 <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE+0x60>)
 8012962:	2158      	movs	r1, #88	; 0x58
 8012964:	4810      	ldr	r0, [pc, #64]	; (80129a8 <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE+0x64>)
 8012966:	f003 fd15 	bl	8016394 <__assert_func>

	const uint32_t receptionTime = NetworkTimeProvider::currentNetworkTime();
 801296a:	f7f8 f924 	bl	800abb6 <_ZN7desenet19NetworkTimeProvider18currentNetworkTimeEv>
 801296e:	60f8      	str	r0, [r7, #12]

	_receiveCallbackHandler(*this, receptionTime, frame.buffer(), frame.length());
 8012970:	687b      	ldr	r3, [r7, #4]
 8012972:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 8012976:	687d      	ldr	r5, [r7, #4]
 8012978:	6838      	ldr	r0, [r7, #0]
 801297a:	f7f6 f877 	bl	8008a6c <_ZNK7desenet5Frame6bufferEv>
 801297e:	4606      	mov	r6, r0
 8012980:	6838      	ldr	r0, [r7, #0]
 8012982:	f7f6 f9b7 	bl	8008cf4 <_ZNK7desenet5Frame6lengthEv>
 8012986:	4603      	mov	r3, r0
 8012988:	9300      	str	r3, [sp, #0]
 801298a:	4633      	mov	r3, r6
 801298c:	68fa      	ldr	r2, [r7, #12]
 801298e:	4629      	mov	r1, r5
 8012990:	4620      	mov	r0, r4
 8012992:	f000 f865 	bl	8012a60 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEclES2_mS4_j>
}
 8012996:	bf00      	nop
 8012998:	3714      	adds	r7, #20
 801299a:	46bd      	mov	sp, r7
 801299c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801299e:	bf00      	nop
 80129a0:	0801ab58 	.word	0x0801ab58
 80129a4:	0801ab70 	.word	0x0801ab70
 80129a8:	0801aab8 	.word	0x0801aab8

080129ac <_ZThn8_N7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE>:

	// IPhyObserver interface implementation
protected:
	virtual void onReceive(const Frame & frame);
 80129ac:	f1a0 0008 	sub.w	r0, r0, #8
 80129b0:	f7ff bfc8 	b.w	8012944 <_ZN7desenet20NrfTransceiverDriver9onReceiveERKNS_5FrameE>

080129b4 <_ZN7desenet20NrfTransceiverDriver12onSendStatusEN12IPhyObserver10SendStatusE>:

void NrfTransceiverDriver::onSendStatus(IPhyObserver::SendStatus status)
{
 80129b4:	b480      	push	{r7}
 80129b6:	b083      	sub	sp, #12
 80129b8:	af00      	add	r7, sp, #0
 80129ba:	6078      	str	r0, [r7, #4]
 80129bc:	460b      	mov	r3, r1
 80129be:	70fb      	strb	r3, [r7, #3]
	UNUSED(status);
}
 80129c0:	bf00      	nop
 80129c2:	370c      	adds	r7, #12
 80129c4:	46bd      	mov	sp, r7
 80129c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80129ca:	4770      	bx	lr

080129cc <_ZThn8_N7desenet20NrfTransceiverDriver12onSendStatusEN12IPhyObserver10SendStatusE>:
	virtual void onSendStatus(SendStatus status);
 80129cc:	f1a0 0008 	sub.w	r0, r0, #8
 80129d0:	f7ff bff0 	b.w	80129b4 <_ZN7desenet20NrfTransceiverDriver12onSendStatusEN12IPhyObserver10SendStatusE>

080129d4 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1EDn>:
      function(nullptr_t) noexcept
 80129d4:	b580      	push	{r7, lr}
 80129d6:	b082      	sub	sp, #8
 80129d8:	af00      	add	r7, sp, #0
 80129da:	6078      	str	r0, [r7, #4]
 80129dc:	6039      	str	r1, [r7, #0]
      : _Function_base() { }
 80129de:	687b      	ldr	r3, [r7, #4]
 80129e0:	4618      	mov	r0, r3
 80129e2:	f7f8 fb19 	bl	800b018 <_ZNSt14_Function_baseC1Ev>
 80129e6:	687b      	ldr	r3, [r7, #4]
 80129e8:	4618      	mov	r0, r3
 80129ea:	3708      	adds	r7, #8
 80129ec:	46bd      	mov	sp, r7
 80129ee:	bd80      	pop	{r7, pc}

080129f0 <_ZNSt5arrayIhLj4EE4dataEv>:
	return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
 	           : _AT_Type::_S_ref(_M_elems, 0);
      }

      _GLIBCXX17_CONSTEXPR pointer
      data() noexcept
 80129f0:	b580      	push	{r7, lr}
 80129f2:	b082      	sub	sp, #8
 80129f4:	af00      	add	r7, sp, #0
 80129f6:	6078      	str	r0, [r7, #4]
      { return _AT_Type::_S_ptr(_M_elems); }
 80129f8:	687b      	ldr	r3, [r7, #4]
 80129fa:	4618      	mov	r0, r3
 80129fc:	f000 f862 	bl	8012ac4 <_ZNSt14__array_traitsIhLj4EE6_S_ptrERA4_Kh>
 8012a00:	4603      	mov	r3, r0
 8012a02:	4618      	mov	r0, r3
 8012a04:	3708      	adds	r7, #8
 8012a06:	46bd      	mov	sp, r7
 8012a08:	bd80      	pop	{r7, pc}

08012a0a <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEaSERKS6_>:
      operator=(const function& __x)
 8012a0a:	b580      	push	{r7, lr}
 8012a0c:	b086      	sub	sp, #24
 8012a0e:	af00      	add	r7, sp, #0
 8012a10:	6078      	str	r0, [r7, #4]
 8012a12:	6039      	str	r1, [r7, #0]
	function(__x).swap(*this);
 8012a14:	f107 0308 	add.w	r3, r7, #8
 8012a18:	6839      	ldr	r1, [r7, #0]
 8012a1a:	4618      	mov	r0, r3
 8012a1c:	f000 f85d 	bl	8012ada <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ERKS6_>
 8012a20:	f107 0308 	add.w	r3, r7, #8
 8012a24:	6879      	ldr	r1, [r7, #4]
 8012a26:	4618      	mov	r0, r3
 8012a28:	f000 f879 	bl	8012b1e <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEE4swapERS6_>
 8012a2c:	f107 0308 	add.w	r3, r7, #8
 8012a30:	4618      	mov	r0, r3
 8012a32:	f7f8 fcac 	bl	800b38e <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEED1Ev>
	return *this;
 8012a36:	687b      	ldr	r3, [r7, #4]
      }
 8012a38:	4618      	mov	r0, r3
 8012a3a:	3718      	adds	r7, #24
 8012a3c:	46bd      	mov	sp, r7
 8012a3e:	bd80      	pop	{r7, pc}

08012a40 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEcvbEv>:
      explicit operator bool() const noexcept
 8012a40:	b580      	push	{r7, lr}
 8012a42:	b082      	sub	sp, #8
 8012a44:	af00      	add	r7, sp, #0
 8012a46:	6078      	str	r0, [r7, #4]
      { return !_M_empty(); }
 8012a48:	687b      	ldr	r3, [r7, #4]
 8012a4a:	4618      	mov	r0, r3
 8012a4c:	f7ff fdce 	bl	80125ec <_ZNKSt14_Function_base8_M_emptyEv>
 8012a50:	4603      	mov	r3, r0
 8012a52:	f083 0301 	eor.w	r3, r3, #1
 8012a56:	b2db      	uxtb	r3, r3
 8012a58:	4618      	mov	r0, r3
 8012a5a:	3708      	adds	r7, #8
 8012a5c:	46bd      	mov	sp, r7
 8012a5e:	bd80      	pop	{r7, pc}

08012a60 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEclES2_mS4_j>:

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 8012a60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012a64:	b087      	sub	sp, #28
 8012a66:	af02      	add	r7, sp, #8
 8012a68:	60f8      	str	r0, [r7, #12]
 8012a6a:	60b9      	str	r1, [r7, #8]
 8012a6c:	607a      	str	r2, [r7, #4]
 8012a6e:	603b      	str	r3, [r7, #0]
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 8012a70:	68fb      	ldr	r3, [r7, #12]
 8012a72:	4618      	mov	r0, r3
 8012a74:	f7ff fdba 	bl	80125ec <_ZNKSt14_Function_base8_M_emptyEv>
 8012a78:	4603      	mov	r3, r0
 8012a7a:	2b00      	cmp	r3, #0
 8012a7c:	d001      	beq.n	8012a82 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEclES2_mS4_j+0x22>
	__throw_bad_function_call();
 8012a7e:	f003 fbd5 	bl	801622c <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 8012a82:	68fb      	ldr	r3, [r7, #12]
 8012a84:	68dc      	ldr	r4, [r3, #12]
 8012a86:	68fd      	ldr	r5, [r7, #12]
 8012a88:	68b8      	ldr	r0, [r7, #8]
 8012a8a:	f7f9 fdb5 	bl	800c5f8 <_ZSt7forwardIRN7desenet22NetworkInterfaceDriverEEOT_RNSt16remove_referenceIS3_E4typeE>
 8012a8e:	4606      	mov	r6, r0
 8012a90:	1d3b      	adds	r3, r7, #4
 8012a92:	4618      	mov	r0, r3
 8012a94:	f7f9 fdbb 	bl	800c60e <_ZSt7forwardImEOT_RNSt16remove_referenceIS0_E4typeE>
 8012a98:	4680      	mov	r8, r0
 8012a9a:	463b      	mov	r3, r7
 8012a9c:	4618      	mov	r0, r3
 8012a9e:	f7f9 fdc1 	bl	800c624 <_ZSt7forwardIPKhEOT_RNSt16remove_referenceIS2_E4typeE>
 8012aa2:	4681      	mov	r9, r0
 8012aa4:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8012aa8:	f7f9 fdc7 	bl	800c63a <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 8012aac:	4603      	mov	r3, r0
 8012aae:	9300      	str	r3, [sp, #0]
 8012ab0:	464b      	mov	r3, r9
 8012ab2:	4642      	mov	r2, r8
 8012ab4:	4631      	mov	r1, r6
 8012ab6:	4628      	mov	r0, r5
 8012ab8:	47a0      	blx	r4
 8012aba:	bf00      	nop
    }
 8012abc:	3714      	adds	r7, #20
 8012abe:	46bd      	mov	sp, r7
 8012ac0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08012ac4 <_ZNSt14__array_traitsIhLj4EE6_S_ptrERA4_Kh>:
      _S_ptr(const _Type& __t) noexcept
 8012ac4:	b480      	push	{r7}
 8012ac6:	b083      	sub	sp, #12
 8012ac8:	af00      	add	r7, sp, #0
 8012aca:	6078      	str	r0, [r7, #4]
      { return const_cast<_Tp*>(__t); }
 8012acc:	687b      	ldr	r3, [r7, #4]
 8012ace:	4618      	mov	r0, r3
 8012ad0:	370c      	adds	r7, #12
 8012ad2:	46bd      	mov	sp, r7
 8012ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ad8:	4770      	bx	lr

08012ada <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ERKS6_>:
    function<_Res(_ArgTypes...)>::
 8012ada:	b580      	push	{r7, lr}
 8012adc:	b082      	sub	sp, #8
 8012ade:	af00      	add	r7, sp, #0
 8012ae0:	6078      	str	r0, [r7, #4]
 8012ae2:	6039      	str	r1, [r7, #0]
    : _Function_base()
 8012ae4:	687b      	ldr	r3, [r7, #4]
 8012ae6:	4618      	mov	r0, r3
 8012ae8:	f7f8 fa96 	bl	800b018 <_ZNSt14_Function_baseC1Ev>
      if (static_cast<bool>(__x))
 8012aec:	6838      	ldr	r0, [r7, #0]
 8012aee:	f7ff ffa7 	bl	8012a40 <_ZNKSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEcvbEv>
 8012af2:	4603      	mov	r3, r0
 8012af4:	2b00      	cmp	r3, #0
 8012af6:	d00d      	beq.n	8012b14 <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEEC1ERKS6_+0x3a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 8012af8:	683b      	ldr	r3, [r7, #0]
 8012afa:	689b      	ldr	r3, [r3, #8]
 8012afc:	6878      	ldr	r0, [r7, #4]
 8012afe:	6839      	ldr	r1, [r7, #0]
 8012b00:	2202      	movs	r2, #2
 8012b02:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 8012b04:	683b      	ldr	r3, [r7, #0]
 8012b06:	68da      	ldr	r2, [r3, #12]
 8012b08:	687b      	ldr	r3, [r7, #4]
 8012b0a:	60da      	str	r2, [r3, #12]
	  _M_manager = __x._M_manager;
 8012b0c:	683b      	ldr	r3, [r7, #0]
 8012b0e:	689a      	ldr	r2, [r3, #8]
 8012b10:	687b      	ldr	r3, [r7, #4]
 8012b12:	609a      	str	r2, [r3, #8]
    }
 8012b14:	687b      	ldr	r3, [r7, #4]
 8012b16:	4618      	mov	r0, r3
 8012b18:	3708      	adds	r7, #8
 8012b1a:	46bd      	mov	sp, r7
 8012b1c:	bd80      	pop	{r7, pc}

08012b1e <_ZNSt8functionIFvRN7desenet22NetworkInterfaceDriverEmPKhjEE4swapERS6_>:
      void swap(function& __x) noexcept
 8012b1e:	b580      	push	{r7, lr}
 8012b20:	b082      	sub	sp, #8
 8012b22:	af00      	add	r7, sp, #0
 8012b24:	6078      	str	r0, [r7, #4]
 8012b26:	6039      	str	r1, [r7, #0]
	std::swap(_M_functor, __x._M_functor);
 8012b28:	687b      	ldr	r3, [r7, #4]
 8012b2a:	683a      	ldr	r2, [r7, #0]
 8012b2c:	4611      	mov	r1, r2
 8012b2e:	4618      	mov	r0, r3
 8012b30:	f000 f821 	bl	8012b76 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
	std::swap(_M_manager, __x._M_manager);
 8012b34:	687b      	ldr	r3, [r7, #4]
 8012b36:	f103 0208 	add.w	r2, r3, #8
 8012b3a:	683b      	ldr	r3, [r7, #0]
 8012b3c:	3308      	adds	r3, #8
 8012b3e:	4619      	mov	r1, r3
 8012b40:	4610      	mov	r0, r2
 8012b42:	f000 f84a 	bl	8012bda <_ZSt4swapIPFbRSt9_Any_dataRKS0_St18_Manager_operationEENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleISB_ESt18is_move_assignableISB_EEE5valueEvE4typeERSB_SL_>
	std::swap(_M_invoker, __x._M_invoker);
 8012b46:	687b      	ldr	r3, [r7, #4]
 8012b48:	f103 020c 	add.w	r2, r3, #12
 8012b4c:	683b      	ldr	r3, [r7, #0]
 8012b4e:	330c      	adds	r3, #12
 8012b50:	4619      	mov	r1, r3
 8012b52:	4610      	mov	r0, r2
 8012b54:	f000 f86b 	bl	8012c2e <_ZSt4swapIPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleISH_ESt18is_move_assignableISH_EEE5valueEvE4typeERSH_SR_>
      }
 8012b58:	bf00      	nop
 8012b5a:	3708      	adds	r7, #8
 8012b5c:	46bd      	mov	sp, r7
 8012b5e:	bd80      	pop	{r7, pc}

08012b60 <_ZSt4moveIRSt9_Any_dataEONSt16remove_referenceIT_E4typeEOS3_>:
    move(_Tp&& __t) noexcept
 8012b60:	b480      	push	{r7}
 8012b62:	b083      	sub	sp, #12
 8012b64:	af00      	add	r7, sp, #0
 8012b66:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8012b68:	687b      	ldr	r3, [r7, #4]
 8012b6a:	4618      	mov	r0, r3
 8012b6c:	370c      	adds	r7, #12
 8012b6e:	46bd      	mov	sp, r7
 8012b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b74:	4770      	bx	lr

08012b76 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
    swap(_Tp& __a, _Tp& __b)
 8012b76:	b580      	push	{r7, lr}
 8012b78:	b084      	sub	sp, #16
 8012b7a:	af00      	add	r7, sp, #0
 8012b7c:	6078      	str	r0, [r7, #4]
 8012b7e:	6039      	str	r1, [r7, #0]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 8012b80:	6878      	ldr	r0, [r7, #4]
 8012b82:	f7ff ffed 	bl	8012b60 <_ZSt4moveIRSt9_Any_dataEONSt16remove_referenceIT_E4typeEOS3_>
 8012b86:	4602      	mov	r2, r0
 8012b88:	f107 0308 	add.w	r3, r7, #8
 8012b8c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012b90:	e883 0003 	stmia.w	r3, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 8012b94:	6838      	ldr	r0, [r7, #0]
 8012b96:	f7ff ffe3 	bl	8012b60 <_ZSt4moveIRSt9_Any_dataEONSt16remove_referenceIT_E4typeEOS3_>
 8012b9a:	4602      	mov	r2, r0
 8012b9c:	687b      	ldr	r3, [r7, #4]
 8012b9e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012ba2:	e883 0003 	stmia.w	r3, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 8012ba6:	f107 0308 	add.w	r3, r7, #8
 8012baa:	4618      	mov	r0, r3
 8012bac:	f7ff ffd8 	bl	8012b60 <_ZSt4moveIRSt9_Any_dataEONSt16remove_referenceIT_E4typeEOS3_>
 8012bb0:	4602      	mov	r2, r0
 8012bb2:	683b      	ldr	r3, [r7, #0]
 8012bb4:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012bb8:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 8012bbc:	bf00      	nop
 8012bbe:	3710      	adds	r7, #16
 8012bc0:	46bd      	mov	sp, r7
 8012bc2:	bd80      	pop	{r7, pc}

08012bc4 <_ZSt4moveIRPFbRSt9_Any_dataRKS0_St18_Manager_operationEEONSt16remove_referenceIT_E4typeEOS9_>:
    move(_Tp&& __t) noexcept
 8012bc4:	b480      	push	{r7}
 8012bc6:	b083      	sub	sp, #12
 8012bc8:	af00      	add	r7, sp, #0
 8012bca:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8012bcc:	687b      	ldr	r3, [r7, #4]
 8012bce:	4618      	mov	r0, r3
 8012bd0:	370c      	adds	r7, #12
 8012bd2:	46bd      	mov	sp, r7
 8012bd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012bd8:	4770      	bx	lr

08012bda <_ZSt4swapIPFbRSt9_Any_dataRKS0_St18_Manager_operationEENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleISB_ESt18is_move_assignableISB_EEE5valueEvE4typeERSB_SL_>:
    swap(_Tp& __a, _Tp& __b)
 8012bda:	b580      	push	{r7, lr}
 8012bdc:	b084      	sub	sp, #16
 8012bde:	af00      	add	r7, sp, #0
 8012be0:	6078      	str	r0, [r7, #4]
 8012be2:	6039      	str	r1, [r7, #0]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 8012be4:	6878      	ldr	r0, [r7, #4]
 8012be6:	f7ff ffed 	bl	8012bc4 <_ZSt4moveIRPFbRSt9_Any_dataRKS0_St18_Manager_operationEEONSt16remove_referenceIT_E4typeEOS9_>
 8012bea:	4603      	mov	r3, r0
 8012bec:	681b      	ldr	r3, [r3, #0]
 8012bee:	60fb      	str	r3, [r7, #12]
      __a = _GLIBCXX_MOVE(__b);
 8012bf0:	6838      	ldr	r0, [r7, #0]
 8012bf2:	f7ff ffe7 	bl	8012bc4 <_ZSt4moveIRPFbRSt9_Any_dataRKS0_St18_Manager_operationEEONSt16remove_referenceIT_E4typeEOS9_>
 8012bf6:	4603      	mov	r3, r0
 8012bf8:	681a      	ldr	r2, [r3, #0]
 8012bfa:	687b      	ldr	r3, [r7, #4]
 8012bfc:	601a      	str	r2, [r3, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 8012bfe:	f107 030c 	add.w	r3, r7, #12
 8012c02:	4618      	mov	r0, r3
 8012c04:	f7ff ffde 	bl	8012bc4 <_ZSt4moveIRPFbRSt9_Any_dataRKS0_St18_Manager_operationEEONSt16remove_referenceIT_E4typeEOS9_>
 8012c08:	4603      	mov	r3, r0
 8012c0a:	681a      	ldr	r2, [r3, #0]
 8012c0c:	683b      	ldr	r3, [r7, #0]
 8012c0e:	601a      	str	r2, [r3, #0]
    }
 8012c10:	bf00      	nop
 8012c12:	3710      	adds	r7, #16
 8012c14:	46bd      	mov	sp, r7
 8012c16:	bd80      	pop	{r7, pc}

08012c18 <_ZSt4moveIRPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt16remove_referenceIT_E4typeEOSF_>:
    move(_Tp&& __t) noexcept
 8012c18:	b480      	push	{r7}
 8012c1a:	b083      	sub	sp, #12
 8012c1c:	af00      	add	r7, sp, #0
 8012c1e:	6078      	str	r0, [r7, #4]
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 8012c20:	687b      	ldr	r3, [r7, #4]
 8012c22:	4618      	mov	r0, r3
 8012c24:	370c      	adds	r7, #12
 8012c26:	46bd      	mov	sp, r7
 8012c28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012c2c:	4770      	bx	lr

08012c2e <_ZSt4swapIPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleISH_ESt18is_move_assignableISH_EEE5valueEvE4typeERSH_SR_>:
    swap(_Tp& __a, _Tp& __b)
 8012c2e:	b580      	push	{r7, lr}
 8012c30:	b084      	sub	sp, #16
 8012c32:	af00      	add	r7, sp, #0
 8012c34:	6078      	str	r0, [r7, #4]
 8012c36:	6039      	str	r1, [r7, #0]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 8012c38:	6878      	ldr	r0, [r7, #4]
 8012c3a:	f7ff ffed 	bl	8012c18 <_ZSt4moveIRPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt16remove_referenceIT_E4typeEOSF_>
 8012c3e:	4603      	mov	r3, r0
 8012c40:	681b      	ldr	r3, [r3, #0]
 8012c42:	60fb      	str	r3, [r7, #12]
      __a = _GLIBCXX_MOVE(__b);
 8012c44:	6838      	ldr	r0, [r7, #0]
 8012c46:	f7ff ffe7 	bl	8012c18 <_ZSt4moveIRPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt16remove_referenceIT_E4typeEOSF_>
 8012c4a:	4603      	mov	r3, r0
 8012c4c:	681a      	ldr	r2, [r3, #0]
 8012c4e:	687b      	ldr	r3, [r7, #4]
 8012c50:	601a      	str	r2, [r3, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 8012c52:	f107 030c 	add.w	r3, r7, #12
 8012c56:	4618      	mov	r0, r3
 8012c58:	f7ff ffde 	bl	8012c18 <_ZSt4moveIRPFvRKSt9_Any_dataRN7desenet22NetworkInterfaceDriverEOmOPKhOjEEONSt16remove_referenceIT_E4typeEOSF_>
 8012c5c:	4603      	mov	r3, r0
 8012c5e:	681a      	ldr	r2, [r3, #0]
 8012c60:	683b      	ldr	r3, [r7, #0]
 8012c62:	601a      	str	r2, [r3, #0]
    }
 8012c64:	bf00      	nop
 8012c66:	3710      	adds	r7, #16
 8012c68:	46bd      	mov	sp, r7
 8012c6a:	bd80      	pop	{r7, pc}

08012c6c <_Z41__static_initialization_and_destruction_0ii>:
 8012c6c:	b580      	push	{r7, lr}
 8012c6e:	b088      	sub	sp, #32
 8012c70:	af00      	add	r7, sp, #0
 8012c72:	6078      	str	r0, [r7, #4]
 8012c74:	6039      	str	r1, [r7, #0]
 8012c76:	687b      	ldr	r3, [r7, #4]
 8012c78:	2b01      	cmp	r3, #1
 8012c7a:	d122      	bne.n	8012cc2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8012c7c:	683b      	ldr	r3, [r7, #0]
 8012c7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8012c82:	4293      	cmp	r3, r2
 8012c84:	d11d      	bne.n	8012cc2 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8012c86:	4b18      	ldr	r3, [pc, #96]	; (8012ce8 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8012c88:	681b      	ldr	r3, [r3, #0]
 8012c8a:	613b      	str	r3, [r7, #16]
 8012c8c:	f107 0310 	add.w	r3, r7, #16
 8012c90:	60bb      	str	r3, [r7, #8]
 8012c92:	2304      	movs	r3, #4
 8012c94:	60fb      	str	r3, [r7, #12]
 8012c96:	f107 0308 	add.w	r3, r7, #8
 8012c9a:	e893 0006 	ldmia.w	r3, {r1, r2}
 8012c9e:	4813      	ldr	r0, [pc, #76]	; (8012cec <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8012ca0:	f7f4 f848 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8012ca4:	4b12      	ldr	r3, [pc, #72]	; (8012cf0 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8012ca6:	681b      	ldr	r3, [r3, #0]
 8012ca8:	61fb      	str	r3, [r7, #28]
 8012caa:	f107 031c 	add.w	r3, r7, #28
 8012cae:	617b      	str	r3, [r7, #20]
 8012cb0:	2304      	movs	r3, #4
 8012cb2:	61bb      	str	r3, [r7, #24]
 8012cb4:	f107 0314 	add.w	r3, r7, #20
 8012cb8:	e893 0006 	ldmia.w	r3, {r1, r2}
 8012cbc:	480d      	ldr	r0, [pc, #52]	; (8012cf4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8012cbe:	f7f4 f839 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8012cc2:	687b      	ldr	r3, [r7, #4]
 8012cc4:	2b00      	cmp	r3, #0
 8012cc6:	d10a      	bne.n	8012cde <_Z41__static_initialization_and_destruction_0ii+0x72>
 8012cc8:	683b      	ldr	r3, [r7, #0]
 8012cca:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8012cce:	4293      	cmp	r3, r2
 8012cd0:	d105      	bne.n	8012cde <_Z41__static_initialization_and_destruction_0ii+0x72>
 8012cd2:	4808      	ldr	r0, [pc, #32]	; (8012cf4 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8012cd4:	f7f4 f978 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8012cd8:	4804      	ldr	r0, [pc, #16]	; (8012cec <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8012cda:	f7f4 f975 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8012cde:	bf00      	nop
 8012ce0:	3720      	adds	r7, #32
 8012ce2:	46bd      	mov	sp, r7
 8012ce4:	bd80      	pop	{r7, pc}
 8012ce6:	bf00      	nop
 8012ce8:	0801ad14 	.word	0x0801ad14
 8012cec:	20001d30 	.word	0x20001d30
 8012cf0:	0801ad18 	.word	0x0801ad18
 8012cf4:	20001d38 	.word	0x20001d38

08012cf8 <_GLOBAL__sub_I__Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>:
 8012cf8:	b580      	push	{r7, lr}
 8012cfa:	af00      	add	r7, sp, #0
 8012cfc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8012d00:	2001      	movs	r0, #1
 8012d02:	f7ff ffb3 	bl	8012c6c <_Z41__static_initialization_and_destruction_0ii>
 8012d06:	bd80      	pop	{r7, pc}

08012d08 <_GLOBAL__sub_D__Z14instanciateNicmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>:
 8012d08:	b580      	push	{r7, lr}
 8012d0a:	af00      	add	r7, sp, #0
 8012d0c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8012d10:	2000      	movs	r0, #0
 8012d12:	f7ff ffab 	bl	8012c6c <_Z41__static_initialization_and_destruction_0ii>
 8012d16:	bd80      	pop	{r7, pc}

08012d18 <_ZN16ITimeSlotManagerC1Ev>:

	virtual void onBeaconReceived(const desenet::SlotDuration & slotDuration) = 0;	///< Should be called whenever receiving a beacon frame from the gateway (master).

protected:
	// It is just an interface, so constructor and destructor should be not public.
	explicit ITimeSlotManager() {}
 8012d18:	b480      	push	{r7}
 8012d1a:	b083      	sub	sp, #12
 8012d1c:	af00      	add	r7, sp, #0
 8012d1e:	6078      	str	r0, [r7, #4]
 8012d20:	4a04      	ldr	r2, [pc, #16]	; (8012d34 <_ZN16ITimeSlotManagerC1Ev+0x1c>)
 8012d22:	687b      	ldr	r3, [r7, #4]
 8012d24:	601a      	str	r2, [r3, #0]
 8012d26:	687b      	ldr	r3, [r7, #4]
 8012d28:	4618      	mov	r0, r3
 8012d2a:	370c      	adds	r7, #12
 8012d2c:	46bd      	mov	sp, r7
 8012d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d32:	4770      	bx	lr
 8012d34:	0801dbe0 	.word	0x0801dbe0

08012d38 <_ZN16ITimeSlotManagerD1Ev>:
	virtual ~ITimeSlotManager() {}
 8012d38:	b480      	push	{r7}
 8012d3a:	b083      	sub	sp, #12
 8012d3c:	af00      	add	r7, sp, #0
 8012d3e:	6078      	str	r0, [r7, #4]
 8012d40:	4a04      	ldr	r2, [pc, #16]	; (8012d54 <_ZN16ITimeSlotManagerD1Ev+0x1c>)
 8012d42:	687b      	ldr	r3, [r7, #4]
 8012d44:	601a      	str	r2, [r3, #0]
 8012d46:	687b      	ldr	r3, [r7, #4]
 8012d48:	4618      	mov	r0, r3
 8012d4a:	370c      	adds	r7, #12
 8012d4c:	46bd      	mov	sp, r7
 8012d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d52:	4770      	bx	lr
 8012d54:	0801dbe0 	.word	0x0801dbe0

08012d58 <_ZN16ITimeSlotManagerD0Ev>:
 8012d58:	b580      	push	{r7, lr}
 8012d5a:	b082      	sub	sp, #8
 8012d5c:	af00      	add	r7, sp, #0
 8012d5e:	6078      	str	r0, [r7, #4]
 8012d60:	6878      	ldr	r0, [r7, #4]
 8012d62:	f7ff ffe9 	bl	8012d38 <_ZN16ITimeSlotManagerD1Ev>
 8012d66:	2104      	movs	r1, #4
 8012d68:	6878      	ldr	r0, [r7, #4]
 8012d6a:	f003 fa1f 	bl	80161ac <_ZdlPvj>
 8012d6e:	687b      	ldr	r3, [r7, #4]
 8012d70:	4618      	mov	r0, r3
 8012d72:	3708      	adds	r7, #8
 8012d74:	46bd      	mov	sp, r7
 8012d76:	bd80      	pop	{r7, pc}

08012d78 <_ZN7desenet15TimeSlotManager8instanceEv>:

public:
	TimeSlotManager();
	~TimeSlotManager();

	static TimeSlotManager & instance() { assert(_pInstance); return *_pInstance; }			///< General access to the instance.
 8012d78:	b580      	push	{r7, lr}
 8012d7a:	af00      	add	r7, sp, #0
 8012d7c:	4b06      	ldr	r3, [pc, #24]	; (8012d98 <_ZN7desenet15TimeSlotManager8instanceEv+0x20>)
 8012d7e:	681b      	ldr	r3, [r3, #0]
 8012d80:	2b00      	cmp	r3, #0
 8012d82:	d105      	bne.n	8012d90 <_ZN7desenet15TimeSlotManager8instanceEv+0x18>
 8012d84:	4b05      	ldr	r3, [pc, #20]	; (8012d9c <_ZN7desenet15TimeSlotManager8instanceEv+0x24>)
 8012d86:	4a06      	ldr	r2, [pc, #24]	; (8012da0 <_ZN7desenet15TimeSlotManager8instanceEv+0x28>)
 8012d88:	211c      	movs	r1, #28
 8012d8a:	4806      	ldr	r0, [pc, #24]	; (8012da4 <_ZN7desenet15TimeSlotManager8instanceEv+0x2c>)
 8012d8c:	f003 fb02 	bl	8016394 <__assert_func>
 8012d90:	4b01      	ldr	r3, [pc, #4]	; (8012d98 <_ZN7desenet15TimeSlotManager8instanceEv+0x20>)
 8012d92:	681b      	ldr	r3, [r3, #0]
 8012d94:	4618      	mov	r0, r3
 8012d96:	bd80      	pop	{r7, pc}
 8012d98:	20001dd0 	.word	0x20001dd0
 8012d9c:	0801ad1c 	.word	0x0801ad1c
 8012da0:	0801ad28 	.word	0x0801ad28
 8012da4:	0801ad70 	.word	0x0801ad70

08012da8 <_ZN7desenet15TimeSlotManagerC1Ev>:

namespace desenet {

TimeSlotManager * TimeSlotManager::_pInstance(nullptr);

TimeSlotManager::TimeSlotManager()
 8012da8:	b580      	push	{r7, lr}
 8012daa:	b082      	sub	sp, #8
 8012dac:	af00      	add	r7, sp, #0
 8012dae:	6078      	str	r0, [r7, #4]
 : _pObserver(nullptr),
   _pHardwareTimer(&TIME_SLOT_MANAGER_HARDWARE_TIMER_HANDLE),
   _currentState(STATE_UNKOWN),
   _slotCounter(0),
   _slotNumber(desenet::MAX_SLOT_NUMBER + 1),	// Set to something not valid
   _slotDuration(0)
 8012db0:	687b      	ldr	r3, [r7, #4]
 8012db2:	4618      	mov	r0, r3
 8012db4:	f7ff ffb0 	bl	8012d18 <_ZN16ITimeSlotManagerC1Ev>
 8012db8:	687b      	ldr	r3, [r7, #4]
 8012dba:	3304      	adds	r3, #4
 8012dbc:	2100      	movs	r1, #0
 8012dbe:	4618      	mov	r0, r3
 8012dc0:	f001 f9b0 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 8012dc4:	4a19      	ldr	r2, [pc, #100]	; (8012e2c <_ZN7desenet15TimeSlotManagerC1Ev+0x84>)
 8012dc6:	687b      	ldr	r3, [r7, #4]
 8012dc8:	601a      	str	r2, [r3, #0]
 8012dca:	4a19      	ldr	r2, [pc, #100]	; (8012e30 <_ZN7desenet15TimeSlotManagerC1Ev+0x88>)
 8012dcc:	687b      	ldr	r3, [r7, #4]
 8012dce:	605a      	str	r2, [r3, #4]
 8012dd0:	687b      	ldr	r3, [r7, #4]
 8012dd2:	2200      	movs	r2, #0
 8012dd4:	611a      	str	r2, [r3, #16]
 8012dd6:	687b      	ldr	r3, [r7, #4]
 8012dd8:	4a16      	ldr	r2, [pc, #88]	; (8012e34 <_ZN7desenet15TimeSlotManagerC1Ev+0x8c>)
 8012dda:	615a      	str	r2, [r3, #20]
 8012ddc:	687b      	ldr	r3, [r7, #4]
 8012dde:	2200      	movs	r2, #0
 8012de0:	761a      	strb	r2, [r3, #24]
 8012de2:	687b      	ldr	r3, [r7, #4]
 8012de4:	2200      	movs	r2, #0
 8012de6:	765a      	strb	r2, [r3, #25]
 8012de8:	687b      	ldr	r3, [r7, #4]
 8012dea:	2220      	movs	r2, #32
 8012dec:	769a      	strb	r2, [r3, #26]
 8012dee:	687b      	ldr	r3, [r7, #4]
 8012df0:	2200      	movs	r2, #0
 8012df2:	839a      	strh	r2, [r3, #28]
{
	assert(!_pInstance);	// Only one instance allowed
 8012df4:	4b10      	ldr	r3, [pc, #64]	; (8012e38 <_ZN7desenet15TimeSlotManagerC1Ev+0x90>)
 8012df6:	681b      	ldr	r3, [r3, #0]
 8012df8:	2b00      	cmp	r3, #0
 8012dfa:	d005      	beq.n	8012e08 <_ZN7desenet15TimeSlotManagerC1Ev+0x60>
 8012dfc:	4b0f      	ldr	r3, [pc, #60]	; (8012e3c <_ZN7desenet15TimeSlotManagerC1Ev+0x94>)
 8012dfe:	4a10      	ldr	r2, [pc, #64]	; (8012e40 <_ZN7desenet15TimeSlotManagerC1Ev+0x98>)
 8012e00:	211e      	movs	r1, #30
 8012e02:	4810      	ldr	r0, [pc, #64]	; (8012e44 <_ZN7desenet15TimeSlotManagerC1Ev+0x9c>)
 8012e04:	f003 fac6 	bl	8016394 <__assert_func>
	_pInstance = this;
 8012e08:	4a0b      	ldr	r2, [pc, #44]	; (8012e38 <_ZN7desenet15TimeSlotManagerC1Ev+0x90>)
 8012e0a:	687b      	ldr	r3, [r7, #4]
 8012e0c:	6013      	str	r3, [r2, #0]

	assert(_pHardwareTimer);    // Must not be nullptr
 8012e0e:	687b      	ldr	r3, [r7, #4]
 8012e10:	695b      	ldr	r3, [r3, #20]
 8012e12:	2b00      	cmp	r3, #0
 8012e14:	d105      	bne.n	8012e22 <_ZN7desenet15TimeSlotManagerC1Ev+0x7a>
 8012e16:	4b0c      	ldr	r3, [pc, #48]	; (8012e48 <_ZN7desenet15TimeSlotManagerC1Ev+0xa0>)
 8012e18:	4a09      	ldr	r2, [pc, #36]	; (8012e40 <_ZN7desenet15TimeSlotManagerC1Ev+0x98>)
 8012e1a:	2121      	movs	r1, #33	; 0x21
 8012e1c:	4809      	ldr	r0, [pc, #36]	; (8012e44 <_ZN7desenet15TimeSlotManagerC1Ev+0x9c>)
 8012e1e:	f003 fab9 	bl	8016394 <__assert_func>
}
 8012e22:	687b      	ldr	r3, [r7, #4]
 8012e24:	4618      	mov	r0, r3
 8012e26:	3708      	adds	r7, #8
 8012e28:	46bd      	mov	sp, r7
 8012e2a:	bd80      	pop	{r7, pc}
 8012e2c:	0801db90 	.word	0x0801db90
 8012e30:	0801dbbc 	.word	0x0801dbbc
 8012e34:	200001b0 	.word	0x200001b0
 8012e38:	20001dd0 	.word	0x20001dd0
 8012e3c:	0801ae00 	.word	0x0801ae00
 8012e40:	0801ae0c 	.word	0x0801ae0c
 8012e44:	0801ae38 	.word	0x0801ae38
 8012e48:	0801aecc 	.word	0x0801aecc

08012e4c <_ZN7desenet15TimeSlotManagerD1Ev>:

TimeSlotManager::~TimeSlotManager()
 8012e4c:	b580      	push	{r7, lr}
 8012e4e:	b082      	sub	sp, #8
 8012e50:	af00      	add	r7, sp, #0
 8012e52:	6078      	str	r0, [r7, #4]
 8012e54:	4a09      	ldr	r2, [pc, #36]	; (8012e7c <_ZN7desenet15TimeSlotManagerD1Ev+0x30>)
 8012e56:	687b      	ldr	r3, [r7, #4]
 8012e58:	601a      	str	r2, [r3, #0]
 8012e5a:	4a09      	ldr	r2, [pc, #36]	; (8012e80 <_ZN7desenet15TimeSlotManagerD1Ev+0x34>)
 8012e5c:	687b      	ldr	r3, [r7, #4]
 8012e5e:	605a      	str	r2, [r3, #4]
 8012e60:	687b      	ldr	r3, [r7, #4]
 8012e62:	3304      	adds	r3, #4
 8012e64:	4618      	mov	r0, r3
 8012e66:	f001 f97f 	bl	8014168 <_ZN10XFReactiveD1Ev>
 8012e6a:	687b      	ldr	r3, [r7, #4]
 8012e6c:	4618      	mov	r0, r3
 8012e6e:	f7ff ff63 	bl	8012d38 <_ZN16ITimeSlotManagerD1Ev>
{

}
 8012e72:	687b      	ldr	r3, [r7, #4]
 8012e74:	4618      	mov	r0, r3
 8012e76:	3708      	adds	r7, #8
 8012e78:	46bd      	mov	sp, r7
 8012e7a:	bd80      	pop	{r7, pc}
 8012e7c:	0801db90 	.word	0x0801db90
 8012e80:	0801dbbc 	.word	0x0801dbbc

08012e84 <_ZThn4_N7desenet15TimeSlotManagerD1Ev>:
	~TimeSlotManager();
 8012e84:	f1a0 0004 	sub.w	r0, r0, #4
 8012e88:	f7ff bfe0 	b.w	8012e4c <_ZN7desenet15TimeSlotManagerD1Ev>

08012e8c <_ZN7desenet15TimeSlotManagerD0Ev>:
TimeSlotManager::~TimeSlotManager()
 8012e8c:	b580      	push	{r7, lr}
 8012e8e:	b082      	sub	sp, #8
 8012e90:	af00      	add	r7, sp, #0
 8012e92:	6078      	str	r0, [r7, #4]
}
 8012e94:	6878      	ldr	r0, [r7, #4]
 8012e96:	f7ff ffd9 	bl	8012e4c <_ZN7desenet15TimeSlotManagerD1Ev>
 8012e9a:	2120      	movs	r1, #32
 8012e9c:	6878      	ldr	r0, [r7, #4]
 8012e9e:	f003 f985 	bl	80161ac <_ZdlPvj>
 8012ea2:	687b      	ldr	r3, [r7, #4]
 8012ea4:	4618      	mov	r0, r3
 8012ea6:	3708      	adds	r7, #8
 8012ea8:	46bd      	mov	sp, r7
 8012eaa:	bd80      	pop	{r7, pc}

08012eac <_ZThn4_N7desenet15TimeSlotManagerD0Ev>:
 8012eac:	f1a0 0004 	sub.w	r0, r0, #4
 8012eb0:	f7ff bfec 	b.w	8012e8c <_ZN7desenet15TimeSlotManagerD0Ev>

08012eb4 <_ZN7desenet15TimeSlotManager10initializeERKh>:

void TimeSlotManager::initialize(const desenet::SlotNumber & slotNumber)
{
 8012eb4:	b580      	push	{r7, lr}
 8012eb6:	b082      	sub	sp, #8
 8012eb8:	af00      	add	r7, sp, #0
 8012eba:	6078      	str	r0, [r7, #4]
 8012ebc:	6039      	str	r1, [r7, #0]
	assert(slotNumber <= desenet::MAX_SLOT_NUMBER);		// Slot 0 to 31
 8012ebe:	683b      	ldr	r3, [r7, #0]
 8012ec0:	781b      	ldrb	r3, [r3, #0]
 8012ec2:	2b1f      	cmp	r3, #31
 8012ec4:	d905      	bls.n	8012ed2 <_ZN7desenet15TimeSlotManager10initializeERKh+0x1e>
 8012ec6:	4b09      	ldr	r3, [pc, #36]	; (8012eec <_ZN7desenet15TimeSlotManager10initializeERKh+0x38>)
 8012ec8:	4a09      	ldr	r2, [pc, #36]	; (8012ef0 <_ZN7desenet15TimeSlotManager10initializeERKh+0x3c>)
 8012eca:	212b      	movs	r1, #43	; 0x2b
 8012ecc:	4809      	ldr	r0, [pc, #36]	; (8012ef4 <_ZN7desenet15TimeSlotManager10initializeERKh+0x40>)
 8012ece:	f003 fa61 	bl	8016394 <__assert_func>

	HAL_TIM_Base_DeInit(_pHardwareTimer);
 8012ed2:	687b      	ldr	r3, [r7, #4]
 8012ed4:	695b      	ldr	r3, [r3, #20]
 8012ed6:	4618      	mov	r0, r3
 8012ed8:	f7f1 fccb 	bl	8004872 <HAL_TIM_Base_DeInit>

	_slotNumber = slotNumber;
 8012edc:	683b      	ldr	r3, [r7, #0]
 8012ede:	781a      	ldrb	r2, [r3, #0]
 8012ee0:	687b      	ldr	r3, [r7, #4]
 8012ee2:	769a      	strb	r2, [r3, #26]
	// Set pins to zero.
	GPIO_WriteBit(GPIOB, GPIO_Pin_12, Bit_RESET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_13, Bit_RESET);

#endif // USE_GPIOS_TO_SIGNAL_TIME_SLOTS
}
 8012ee4:	bf00      	nop
 8012ee6:	3708      	adds	r7, #8
 8012ee8:	46bd      	mov	sp, r7
 8012eea:	bd80      	pop	{r7, pc}
 8012eec:	0801aedc 	.word	0x0801aedc
 8012ef0:	0801af04 	.word	0x0801af04
 8012ef4:	0801ae38 	.word	0x0801ae38

08012ef8 <_ZN7desenet15TimeSlotManager19initializeRelationsERKN16ITimeSlotManager8ObserverE>:

void TimeSlotManager::initializeRelations(const Observer & observer)
{
 8012ef8:	b580      	push	{r7, lr}
 8012efa:	b082      	sub	sp, #8
 8012efc:	af00      	add	r7, sp, #0
 8012efe:	6078      	str	r0, [r7, #4]
 8012f00:	6039      	str	r1, [r7, #0]
	setObserver(observer);
 8012f02:	687b      	ldr	r3, [r7, #4]
 8012f04:	681b      	ldr	r3, [r3, #0]
 8012f06:	3308      	adds	r3, #8
 8012f08:	681b      	ldr	r3, [r3, #0]
 8012f0a:	6839      	ldr	r1, [r7, #0]
 8012f0c:	6878      	ldr	r0, [r7, #4]
 8012f0e:	4798      	blx	r3
}
 8012f10:	bf00      	nop
 8012f12:	3708      	adds	r7, #8
 8012f14:	46bd      	mov	sp, r7
 8012f16:	bd80      	pop	{r7, pc}

08012f18 <_ZN7desenet15TimeSlotManager11setObserverERKN16ITimeSlotManager8ObserverE>:

bool TimeSlotManager::setObserver(const TimeSlotManager::Observer & observer)
{
 8012f18:	b480      	push	{r7}
 8012f1a:	b083      	sub	sp, #12
 8012f1c:	af00      	add	r7, sp, #0
 8012f1e:	6078      	str	r0, [r7, #4]
 8012f20:	6039      	str	r1, [r7, #0]
	if (_pObserver == nullptr)
 8012f22:	687b      	ldr	r3, [r7, #4]
 8012f24:	691b      	ldr	r3, [r3, #16]
 8012f26:	2b00      	cmp	r3, #0
 8012f28:	d104      	bne.n	8012f34 <_ZN7desenet15TimeSlotManager11setObserverERKN16ITimeSlotManager8ObserverE+0x1c>
	{
		_pObserver = const_cast<Observer*>(&observer);
 8012f2a:	687b      	ldr	r3, [r7, #4]
 8012f2c:	683a      	ldr	r2, [r7, #0]
 8012f2e:	611a      	str	r2, [r3, #16]
		return true;
 8012f30:	2301      	movs	r3, #1
 8012f32:	e000      	b.n	8012f36 <_ZN7desenet15TimeSlotManager11setObserverERKN16ITimeSlotManager8ObserverE+0x1e>
	}
	return false;
 8012f34:	2300      	movs	r3, #0
}
 8012f36:	4618      	mov	r0, r3
 8012f38:	370c      	adds	r7, #12
 8012f3a:	46bd      	mov	sp, r7
 8012f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f40:	4770      	bx	lr

08012f42 <_ZN7desenet15TimeSlotManager5startEv>:

void TimeSlotManager::start()
{
 8012f42:	b580      	push	{r7, lr}
 8012f44:	b082      	sub	sp, #8
 8012f46:	af00      	add	r7, sp, #0
 8012f48:	6078      	str	r0, [r7, #4]
	startBehavior();
 8012f4a:	687b      	ldr	r3, [r7, #4]
 8012f4c:	1d1a      	adds	r2, r3, #4
 8012f4e:	687b      	ldr	r3, [r7, #4]
 8012f50:	685b      	ldr	r3, [r3, #4]
 8012f52:	3308      	adds	r3, #8
 8012f54:	681b      	ldr	r3, [r3, #0]
 8012f56:	4610      	mov	r0, r2
 8012f58:	4798      	blx	r3
}
 8012f5a:	bf00      	nop
 8012f5c:	3708      	adds	r7, #8
 8012f5e:	46bd      	mov	sp, r7
 8012f60:	bd80      	pop	{r7, pc}

08012f62 <_ZNK7desenet15TimeSlotManager10slotNumberEv>:

desenet::SlotNumber TimeSlotManager::slotNumber() const
{
 8012f62:	b480      	push	{r7}
 8012f64:	b083      	sub	sp, #12
 8012f66:	af00      	add	r7, sp, #0
 8012f68:	6078      	str	r0, [r7, #4]
    return _slotNumber;
 8012f6a:	687b      	ldr	r3, [r7, #4]
 8012f6c:	7e9b      	ldrb	r3, [r3, #26]
}
 8012f6e:	4618      	mov	r0, r3
 8012f70:	370c      	adds	r7, #12
 8012f72:	46bd      	mov	sp, r7
 8012f74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f78:	4770      	bx	lr
	...

08012f7c <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt>:
 * GPIO_Pin_12:  0    ---+-----+-----+     +-----+     +-----+     +...
 * _slotCounter:         0     0     1     2     3     4     5     6
 */

void TimeSlotManager::onBeaconReceived(const desenet::SlotDuration & slotDuration)
{
 8012f7c:	b580      	push	{r7, lr}
 8012f7e:	b084      	sub	sp, #16
 8012f80:	af00      	add	r7, sp, #0
 8012f82:	6078      	str	r0, [r7, #4]
 8012f84:	6039      	str	r1, [r7, #0]
	assert(_slotNumber <= desenet::MAX_SLOT_NUMBER);		// Slot 0 to 31
 8012f86:	687b      	ldr	r3, [r7, #4]
 8012f88:	7e9b      	ldrb	r3, [r3, #26]
 8012f8a:	2b1f      	cmp	r3, #31
 8012f8c:	d905      	bls.n	8012f9a <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt+0x1e>
 8012f8e:	4b12      	ldr	r3, [pc, #72]	; (8012fd8 <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt+0x5c>)
 8012f90:	4a12      	ldr	r2, [pc, #72]	; (8012fdc <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt+0x60>)
 8012f92:	2169      	movs	r1, #105	; 0x69
 8012f94:	4812      	ldr	r0, [pc, #72]	; (8012fe0 <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt+0x64>)
 8012f96:	f003 f9fd 	bl	8016394 <__assert_func>

	notify(SIG::CYCLE_START);
 8012f9a:	2300      	movs	r3, #0
 8012f9c:	73fb      	strb	r3, [r7, #15]
 8012f9e:	f107 030f 	add.w	r3, r7, #15
 8012fa2:	4619      	mov	r1, r3
 8012fa4:	6878      	ldr	r0, [r7, #4]
 8012fa6:	f000 f827 	bl	8012ff8 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE>

	_stopTimer();
 8012faa:	6878      	ldr	r0, [r7, #4]
 8012fac:	f000 f972 	bl	8013294 <_ZN7desenet15TimeSlotManager10_stopTimerEv>

	_slotCounter = 0;	// Restart counting of slots
 8012fb0:	687b      	ldr	r3, [r7, #4]
 8012fb2:	2200      	movs	r2, #0
 8012fb4:	765a      	strb	r2, [r3, #25]
#if (USE_GPIOS_TO_SIGNAL_TIME_SLOTS != 0)
	GPIO_WriteBit(GPIOB, GPIO_Pin_12, (BitAction)(_slotCounter % 2));	// Indicate start of beacon
#endif

	if (_slotDuration != slotDuration)
 8012fb6:	687b      	ldr	r3, [r7, #4]
 8012fb8:	8b9a      	ldrh	r2, [r3, #28]
 8012fba:	683b      	ldr	r3, [r7, #0]
 8012fbc:	881b      	ldrh	r3, [r3, #0]
 8012fbe:	429a      	cmp	r2, r3
 8012fc0:	d003      	beq.n	8012fca <_ZN7desenet15TimeSlotManager16onBeaconReceivedERKt+0x4e>
	{	// Slot duration has changed
		_setSlotDuration(slotDuration);
 8012fc2:	6839      	ldr	r1, [r7, #0]
 8012fc4:	6878      	ldr	r0, [r7, #4]
 8012fc6:	f000 f867 	bl	8013098 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt>
	}

	_startTimer();
 8012fca:	6878      	ldr	r0, [r7, #4]
 8012fcc:	f000 f83a 	bl	8013044 <_ZN7desenet15TimeSlotManager11_startTimerEv>
}
 8012fd0:	bf00      	nop
 8012fd2:	3710      	adds	r7, #16
 8012fd4:	46bd      	mov	sp, r7
 8012fd6:	bd80      	pop	{r7, pc}
 8012fd8:	0801af4c 	.word	0x0801af4c
 8012fdc:	0801af74 	.word	0x0801af74
 8012fe0:	0801ae38 	.word	0x0801ae38

08012fe4 <_ZN7desenet15TimeSlotManager5onIrqEv>:

//static
void TimeSlotManager::onIrq()
{	// Called within IRQ!
 8012fe4:	b580      	push	{r7, lr}
 8012fe6:	af00      	add	r7, sp, #0
	instance()._processIrq();
 8012fe8:	f7ff fec6 	bl	8012d78 <_ZN7desenet15TimeSlotManager8instanceEv>
 8012fec:	4603      	mov	r3, r0
 8012fee:	4618      	mov	r0, r3
 8012ff0:	f000 f95e 	bl	80132b0 <_ZN7desenet15TimeSlotManager11_processIrqEv>
}
 8012ff4:	bf00      	nop
 8012ff6:	bd80      	pop	{r7, pc}

08012ff8 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE>:

void TimeSlotManager::notify(const SIG & signal)
{
 8012ff8:	b580      	push	{r7, lr}
 8012ffa:	b082      	sub	sp, #8
 8012ffc:	af00      	add	r7, sp, #0
 8012ffe:	6078      	str	r0, [r7, #4]
 8013000:	6039      	str	r1, [r7, #0]
	assert(_pObserver);
 8013002:	687b      	ldr	r3, [r7, #4]
 8013004:	691b      	ldr	r3, [r3, #16]
 8013006:	2b00      	cmp	r3, #0
 8013008:	d105      	bne.n	8013016 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE+0x1e>
 801300a:	4b0b      	ldr	r3, [pc, #44]	; (8013038 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE+0x40>)
 801300c:	4a0b      	ldr	r2, [pc, #44]	; (801303c <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE+0x44>)
 801300e:	2184      	movs	r1, #132	; 0x84
 8013010:	480b      	ldr	r0, [pc, #44]	; (8013040 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE+0x48>)
 8013012:	f003 f9bf 	bl	8016394 <__assert_func>
	if (_pObserver)
 8013016:	687b      	ldr	r3, [r7, #4]
 8013018:	691b      	ldr	r3, [r3, #16]
 801301a:	2b00      	cmp	r3, #0
 801301c:	d008      	beq.n	8013030 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE+0x38>
	{
		_pObserver->onTimeSlotSignal(*this, signal);
 801301e:	687b      	ldr	r3, [r7, #4]
 8013020:	6918      	ldr	r0, [r3, #16]
 8013022:	687b      	ldr	r3, [r7, #4]
 8013024:	691b      	ldr	r3, [r3, #16]
 8013026:	681b      	ldr	r3, [r3, #0]
 8013028:	681b      	ldr	r3, [r3, #0]
 801302a:	6879      	ldr	r1, [r7, #4]
 801302c:	683a      	ldr	r2, [r7, #0]
 801302e:	4798      	blx	r3
	}
}
 8013030:	bf00      	nop
 8013032:	3708      	adds	r7, #8
 8013034:	46bd      	mov	sp, r7
 8013036:	bd80      	pop	{r7, pc}
 8013038:	0801afc4 	.word	0x0801afc4
 801303c:	0801afd0 	.word	0x0801afd0
 8013040:	0801ae38 	.word	0x0801ae38

08013044 <_ZN7desenet15TimeSlotManager11_startTimerEv>:

void TimeSlotManager::_startTimer()
{
 8013044:	b580      	push	{r7, lr}
 8013046:	b082      	sub	sp, #8
 8013048:	af00      	add	r7, sp, #0
 801304a:	6078      	str	r0, [r7, #4]
    assert(_slotCounter == 0);                              // Slot counter must be 0
 801304c:	687b      	ldr	r3, [r7, #4]
 801304e:	7e5b      	ldrb	r3, [r3, #25]
 8013050:	2b00      	cmp	r3, #0
 8013052:	d005      	beq.n	8013060 <_ZN7desenet15TimeSlotManager11_startTimerEv+0x1c>
 8013054:	4b0d      	ldr	r3, [pc, #52]	; (801308c <_ZN7desenet15TimeSlotManager11_startTimerEv+0x48>)
 8013056:	4a0e      	ldr	r2, [pc, #56]	; (8013090 <_ZN7desenet15TimeSlotManager11_startTimerEv+0x4c>)
 8013058:	218d      	movs	r1, #141	; 0x8d
 801305a:	480e      	ldr	r0, [pc, #56]	; (8013094 <_ZN7desenet15TimeSlotManager11_startTimerEv+0x50>)
 801305c:	f003 f99a 	bl	8016394 <__assert_func>

    __HAL_TIM_SET_COUNTER(_pHardwareTimer, 0);              // Reset hardware counter to 0
 8013060:	687b      	ldr	r3, [r7, #4]
 8013062:	695b      	ldr	r3, [r3, #20]
 8013064:	681b      	ldr	r3, [r3, #0]
 8013066:	2200      	movs	r2, #0
 8013068:	625a      	str	r2, [r3, #36]	; 0x24
    __HAL_TIM_CLEAR_IT(_pHardwareTimer, TIM_IT_CC1);        // Clear output compare interrupt
 801306a:	687b      	ldr	r3, [r7, #4]
 801306c:	695b      	ldr	r3, [r3, #20]
 801306e:	681b      	ldr	r3, [r3, #0]
 8013070:	f06f 0202 	mvn.w	r2, #2
 8013074:	611a      	str	r2, [r3, #16]

    HAL_TIM_OC_Start_IT(_pHardwareTimer, TIM_CHANNEL_1);    // Start timer and enable interrupts
 8013076:	687b      	ldr	r3, [r7, #4]
 8013078:	695b      	ldr	r3, [r3, #20]
 801307a:	2100      	movs	r1, #0
 801307c:	4618      	mov	r0, r3
 801307e:	f7f1 fcb5 	bl	80049ec <HAL_TIM_OC_Start_IT>
}
 8013082:	bf00      	nop
 8013084:	3708      	adds	r7, #8
 8013086:	46bd      	mov	sp, r7
 8013088:	bd80      	pop	{r7, pc}
 801308a:	bf00      	nop
 801308c:	0801b014 	.word	0x0801b014
 8013090:	0801b028 	.word	0x0801b028
 8013094:	0801ae38 	.word	0x0801ae38

08013098 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt>:

void TimeSlotManager::_setSlotDuration(const desenet::SlotDuration & slotDuration)
{
 8013098:	b580      	push	{r7, lr}
 801309a:	b090      	sub	sp, #64	; 0x40
 801309c:	af00      	add	r7, sp, #0
 801309e:	6078      	str	r0, [r7, #4]
 80130a0:	6039      	str	r1, [r7, #0]
	uint32_t timClk;
	uint32_t period = 0;
 80130a2:	2300      	movs	r3, #0
 80130a4:	63fb      	str	r3, [r7, #60]	; 0x3c
	uint32_t prescaler = 0;
 80130a6:	2300      	movs	r3, #0
 80130a8:	63bb      	str	r3, [r7, #56]	; 0x38
	HAL_StatusTypeDef status;

	assert(slotDuration > 0);
 80130aa:	683b      	ldr	r3, [r7, #0]
 80130ac:	881b      	ldrh	r3, [r3, #0]
 80130ae:	2b00      	cmp	r3, #0
 80130b0:	d105      	bne.n	80130be <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x26>
 80130b2:	4b71      	ldr	r3, [pc, #452]	; (8013278 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e0>)
 80130b4:	4a71      	ldr	r2, [pc, #452]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 80130b6:	219c      	movs	r1, #156	; 0x9c
 80130b8:	4871      	ldr	r0, [pc, #452]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 80130ba:	f003 f96b 	bl	8016394 <__assert_func>

	_slotDuration = slotDuration;
 80130be:	683b      	ldr	r3, [r7, #0]
 80130c0:	881a      	ldrh	r2, [r3, #0]
 80130c2:	687b      	ldr	r3, [r7, #4]
 80130c4:	839a      	strh	r2, [r3, #28]

	HAL_TIM_Base_DeInit(_pHardwareTimer);
 80130c6:	687b      	ldr	r3, [r7, #4]
 80130c8:	695b      	ldr	r3, [r3, #20]
 80130ca:	4618      	mov	r0, r3
 80130cc:	f7f1 fbd1 	bl	8004872 <HAL_TIM_Base_DeInit>
	timClk = HAL_RCC_GetPCLK1Freq();
 80130d0:	f7f0 f89c 	bl	800320c <HAL_RCC_GetPCLK1Freq>
 80130d4:	6378      	str	r0, [r7, #52]	; 0x34
	// The prescaler slows down the clock frequency
	// The period defines how many ticks the timer should count
	// to reach the desired interval (slotDuration).

	// Calculate the prescaler
	period = 0xFFFF;	// Set temporary the period to the highest value
 80130d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80130da:	63fb      	str	r3, [r7, #60]	; 0x3c
	prescaler = (timClk / 1000 * slotDuration / period) - 1;
 80130dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80130de:	4a69      	ldr	r2, [pc, #420]	; (8013284 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1ec>)
 80130e0:	fba2 2303 	umull	r2, r3, r2, r3
 80130e4:	099b      	lsrs	r3, r3, #6
 80130e6:	683a      	ldr	r2, [r7, #0]
 80130e8:	8812      	ldrh	r2, [r2, #0]
 80130ea:	fb03 f202 	mul.w	r2, r3, r2
 80130ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80130f0:	fbb2 f3f3 	udiv	r3, r2, r3
 80130f4:	3b01      	subs	r3, #1
 80130f6:	63bb      	str	r3, [r7, #56]	; 0x38

	if (prescaler <= 0xFFFF)
 80130f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80130fa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80130fe:	d223      	bcs.n	8013148 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0xb0>
	{
		period = timClk / 1000 * slotDuration / (prescaler + 1);
 8013100:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013102:	4a60      	ldr	r2, [pc, #384]	; (8013284 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1ec>)
 8013104:	fba2 2303 	umull	r2, r3, r2, r3
 8013108:	099b      	lsrs	r3, r3, #6
 801310a:	683a      	ldr	r2, [r7, #0]
 801310c:	8812      	ldrh	r2, [r2, #0]
 801310e:	fb03 f202 	mul.w	r2, r3, r2
 8013112:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013114:	3301      	adds	r3, #1
 8013116:	fbb2 f3f3 	udiv	r3, r2, r3
 801311a:	63fb      	str	r3, [r7, #60]	; 0x3c

		if (period > 0xFFFF)	// Check if calculated period is too high
 801311c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801311e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8013122:	d317      	bcc.n	8013154 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0xbc>
		{
			prescaler++;	// Push prescaler to the next value.
 8013124:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013126:	3301      	adds	r3, #1
 8013128:	63bb      	str	r3, [r7, #56]	; 0x38
			period = timClk / 1000 * slotDuration / (prescaler + 1);
 801312a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801312c:	4a55      	ldr	r2, [pc, #340]	; (8013284 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1ec>)
 801312e:	fba2 2303 	umull	r2, r3, r2, r3
 8013132:	099b      	lsrs	r3, r3, #6
 8013134:	683a      	ldr	r2, [r7, #0]
 8013136:	8812      	ldrh	r2, [r2, #0]
 8013138:	fb03 f202 	mul.w	r2, r3, r2
 801313c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801313e:	3301      	adds	r3, #1
 8013140:	fbb2 f3f3 	udiv	r3, r2, r3
 8013144:	63fb      	str	r3, [r7, #60]	; 0x3c
 8013146:	e005      	b.n	8013154 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0xbc>
			// Now the period must to be in the right range
		}
	}
	else
	{
		assert(false); // Slot duration is too high.
 8013148:	4b4f      	ldr	r3, [pc, #316]	; (8013288 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f0>)
 801314a:	4a4c      	ldr	r2, [pc, #304]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 801314c:	21bb      	movs	r1, #187	; 0xbb
 801314e:	484c      	ldr	r0, [pc, #304]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 8013150:	f003 f920 	bl	8016394 <__assert_func>
	}

	assert(period <= 0xFFFFUL);	// Error: Not able to provide the time slot duration needed
 8013154:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013156:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801315a:	d305      	bcc.n	8013168 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0xd0>
 801315c:	4b4b      	ldr	r3, [pc, #300]	; (801328c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f4>)
 801315e:	4a47      	ldr	r2, [pc, #284]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 8013160:	21be      	movs	r1, #190	; 0xbe
 8013162:	4847      	ldr	r0, [pc, #284]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 8013164:	f003 f916 	bl	8016394 <__assert_func>

    TIM_MasterConfigTypeDef sMasterConfig = {0};
 8013168:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801316c:	2200      	movs	r2, #0
 801316e:	601a      	str	r2, [r3, #0]
 8013170:	605a      	str	r2, [r3, #4]
 8013172:	609a      	str	r2, [r3, #8]
    TIM_OC_InitTypeDef sConfigOC = {0};
 8013174:	f107 0308 	add.w	r3, r7, #8
 8013178:	2200      	movs	r2, #0
 801317a:	601a      	str	r2, [r3, #0]
 801317c:	605a      	str	r2, [r3, #4]
 801317e:	609a      	str	r2, [r3, #8]
 8013180:	60da      	str	r2, [r3, #12]
 8013182:	611a      	str	r2, [r3, #16]
 8013184:	615a      	str	r2, [r3, #20]
 8013186:	619a      	str	r2, [r3, #24]

	// Configure hardware timer
    _pHardwareTimer->Instance = TIM2;
 8013188:	687b      	ldr	r3, [r7, #4]
 801318a:	695b      	ldr	r3, [r3, #20]
 801318c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8013190:	601a      	str	r2, [r3, #0]
    _pHardwareTimer->Init.Prescaler = prescaler;
 8013192:	687b      	ldr	r3, [r7, #4]
 8013194:	695b      	ldr	r3, [r3, #20]
 8013196:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013198:	605a      	str	r2, [r3, #4]
    _pHardwareTimer->Init.CounterMode = TIM_COUNTERMODE_UP;
 801319a:	687b      	ldr	r3, [r7, #4]
 801319c:	695b      	ldr	r3, [r3, #20]
 801319e:	2200      	movs	r2, #0
 80131a0:	609a      	str	r2, [r3, #8]
    _pHardwareTimer->Init.Period = period;
 80131a2:	687b      	ldr	r3, [r7, #4]
 80131a4:	695b      	ldr	r3, [r3, #20]
 80131a6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80131a8:	60da      	str	r2, [r3, #12]
    _pHardwareTimer->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80131aa:	687b      	ldr	r3, [r7, #4]
 80131ac:	695b      	ldr	r3, [r3, #20]
 80131ae:	2200      	movs	r2, #0
 80131b0:	611a      	str	r2, [r3, #16]
    _pHardwareTimer->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80131b2:	687b      	ldr	r3, [r7, #4]
 80131b4:	695b      	ldr	r3, [r3, #20]
 80131b6:	2200      	movs	r2, #0
 80131b8:	619a      	str	r2, [r3, #24]
    status = HAL_TIM_Base_Init(_pHardwareTimer);
 80131ba:	687b      	ldr	r3, [r7, #4]
 80131bc:	695b      	ldr	r3, [r3, #20]
 80131be:	4618      	mov	r0, r3
 80131c0:	f7f1 fb00 	bl	80047c4 <HAL_TIM_Base_Init>
 80131c4:	4603      	mov	r3, r0
 80131c6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    assert(status == HAL_OK);
 80131ca:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80131ce:	2b00      	cmp	r3, #0
 80131d0:	d005      	beq.n	80131de <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x146>
 80131d2:	4b2f      	ldr	r3, [pc, #188]	; (8013290 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f8>)
 80131d4:	4a29      	ldr	r2, [pc, #164]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 80131d6:	21cb      	movs	r1, #203	; 0xcb
 80131d8:	4829      	ldr	r0, [pc, #164]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 80131da:	f003 f8db 	bl	8016394 <__assert_func>

    status = HAL_TIM_OC_Init(_pHardwareTimer);
 80131de:	687b      	ldr	r3, [r7, #4]
 80131e0:	695b      	ldr	r3, [r3, #20]
 80131e2:	4618      	mov	r0, r3
 80131e4:	f7f1 fba1 	bl	800492a <HAL_TIM_OC_Init>
 80131e8:	4603      	mov	r3, r0
 80131ea:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    assert(status == HAL_OK);
 80131ee:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80131f2:	2b00      	cmp	r3, #0
 80131f4:	d005      	beq.n	8013202 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x16a>
 80131f6:	4b26      	ldr	r3, [pc, #152]	; (8013290 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f8>)
 80131f8:	4a20      	ldr	r2, [pc, #128]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 80131fa:	21ce      	movs	r1, #206	; 0xce
 80131fc:	4820      	ldr	r0, [pc, #128]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 80131fe:	f003 f8c9 	bl	8016394 <__assert_func>

    // Enable 'output compare 1' interrupt event
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC1REF;
 8013202:	2340      	movs	r3, #64	; 0x40
 8013204:	627b      	str	r3, [r7, #36]	; 0x24
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8013206:	2300      	movs	r3, #0
 8013208:	62fb      	str	r3, [r7, #44]	; 0x2c
    status = HAL_TIMEx_MasterConfigSynchronization(_pHardwareTimer, &sMasterConfig);
 801320a:	687b      	ldr	r3, [r7, #4]
 801320c:	695b      	ldr	r3, [r3, #20]
 801320e:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8013212:	4611      	mov	r1, r2
 8013214:	4618      	mov	r0, r3
 8013216:	f7f2 fcc5 	bl	8005ba4 <HAL_TIMEx_MasterConfigSynchronization>
 801321a:	4603      	mov	r3, r0
 801321c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    assert(status == HAL_OK);
 8013220:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8013224:	2b00      	cmp	r3, #0
 8013226:	d005      	beq.n	8013234 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x19c>
 8013228:	4b19      	ldr	r3, [pc, #100]	; (8013290 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f8>)
 801322a:	4a14      	ldr	r2, [pc, #80]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 801322c:	21d4      	movs	r1, #212	; 0xd4
 801322e:	4814      	ldr	r0, [pc, #80]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 8013230:	f003 f8b0 	bl	8016394 <__assert_func>

    sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8013234:	2300      	movs	r3, #0
 8013236:	60bb      	str	r3, [r7, #8]
    sConfigOC.Pulse = 0;
 8013238:	2300      	movs	r3, #0
 801323a:	60fb      	str	r3, [r7, #12]
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801323c:	2300      	movs	r3, #0
 801323e:	613b      	str	r3, [r7, #16]
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8013240:	2300      	movs	r3, #0
 8013242:	61bb      	str	r3, [r7, #24]
    status = HAL_TIM_OC_ConfigChannel(_pHardwareTimer, &sConfigOC, TIM_CHANNEL_1);
 8013244:	687b      	ldr	r3, [r7, #4]
 8013246:	695b      	ldr	r3, [r3, #20]
 8013248:	f107 0108 	add.w	r1, r7, #8
 801324c:	2200      	movs	r2, #0
 801324e:	4618      	mov	r0, r3
 8013250:	f7f1 ff14 	bl	800507c <HAL_TIM_OC_ConfigChannel>
 8013254:	4603      	mov	r3, r0
 8013256:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    assert(status == HAL_OK);
 801325a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801325e:	2b00      	cmp	r3, #0
 8013260:	d005      	beq.n	801326e <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1d6>
 8013262:	4b0b      	ldr	r3, [pc, #44]	; (8013290 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1f8>)
 8013264:	4a05      	ldr	r2, [pc, #20]	; (801327c <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e4>)
 8013266:	21db      	movs	r1, #219	; 0xdb
 8013268:	4805      	ldr	r0, [pc, #20]	; (8013280 <_ZN7desenet15TimeSlotManager16_setSlotDurationERKt+0x1e8>)
 801326a:	f003 f893 	bl	8016394 <__assert_func>
}
 801326e:	bf00      	nop
 8013270:	3740      	adds	r7, #64	; 0x40
 8013272:	46bd      	mov	sp, r7
 8013274:	bd80      	pop	{r7, pc}
 8013276:	bf00      	nop
 8013278:	0801b058 	.word	0x0801b058
 801327c:	0801b06c 	.word	0x0801b06c
 8013280:	0801ae38 	.word	0x0801ae38
 8013284:	10624dd3 	.word	0x10624dd3
 8013288:	0801b0b4 	.word	0x0801b0b4
 801328c:	0801b0bc 	.word	0x0801b0bc
 8013290:	0801b0d0 	.word	0x0801b0d0

08013294 <_ZN7desenet15TimeSlotManager10_stopTimerEv>:

void TimeSlotManager::_stopTimer()
{
 8013294:	b580      	push	{r7, lr}
 8013296:	b082      	sub	sp, #8
 8013298:	af00      	add	r7, sp, #0
 801329a:	6078      	str	r0, [r7, #4]
    HAL_TIM_OC_Stop_IT(_pHardwareTimer, TIM_CHANNEL_1);
 801329c:	687b      	ldr	r3, [r7, #4]
 801329e:	695b      	ldr	r3, [r3, #20]
 80132a0:	2100      	movs	r1, #0
 80132a2:	4618      	mov	r0, r3
 80132a4:	f7f1 fcee 	bl	8004c84 <HAL_TIM_OC_Stop_IT>
}
 80132a8:	bf00      	nop
 80132aa:	3708      	adds	r7, #8
 80132ac:	46bd      	mov	sp, r7
 80132ae:	bd80      	pop	{r7, pc}

080132b0 <_ZN7desenet15TimeSlotManager11_processIrqEv>:

void TimeSlotManager::_processIrq()
{
 80132b0:	b580      	push	{r7, lr}
 80132b2:	b084      	sub	sp, #16
 80132b4:	af00      	add	r7, sp, #0
 80132b6:	6078      	str	r0, [r7, #4]
#if (USE_GPIOS_TO_SIGNAL_TIME_SLOTS != 0)
	GPIO_WriteBit(GPIOB, GPIO_Pin_12, (BitAction)(_slotCounter % 2));	// Toggle pin each time
#endif

	if (_slotCounter == _slotNumber)				// Start of your slot
 80132b8:	687b      	ldr	r3, [r7, #4]
 80132ba:	7e5a      	ldrb	r2, [r3, #25]
 80132bc:	687b      	ldr	r3, [r7, #4]
 80132be:	7e9b      	ldrb	r3, [r3, #26]
 80132c0:	429a      	cmp	r2, r3
 80132c2:	d108      	bne.n	80132d6 <_ZN7desenet15TimeSlotManager11_processIrqEv+0x26>
	{
#if (USE_GPIOS_TO_SIGNAL_TIME_SLOTS != 0)
	GPIO_WriteBit(GPIOB, GPIO_Pin_13, Bit_SET);
#endif
		notify(SIG::OWN_SLOT_START);
 80132c4:	2302      	movs	r3, #2
 80132c6:	737b      	strb	r3, [r7, #13]
 80132c8:	f107 030d 	add.w	r3, r7, #13
 80132cc:	4619      	mov	r1, r3
 80132ce:	6878      	ldr	r0, [r7, #4]
 80132d0:	f7ff fe92 	bl	8012ff8 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE>
 80132d4:	e00f      	b.n	80132f6 <_ZN7desenet15TimeSlotManager11_processIrqEv+0x46>
	}
	else if (_slotCounter == (_slotNumber + 1))		// End of our slot
 80132d6:	687b      	ldr	r3, [r7, #4]
 80132d8:	7e5b      	ldrb	r3, [r3, #25]
 80132da:	461a      	mov	r2, r3
 80132dc:	687b      	ldr	r3, [r7, #4]
 80132de:	7e9b      	ldrb	r3, [r3, #26]
 80132e0:	3301      	adds	r3, #1
 80132e2:	429a      	cmp	r2, r3
 80132e4:	d107      	bne.n	80132f6 <_ZN7desenet15TimeSlotManager11_processIrqEv+0x46>
	{
#if (USE_GPIOS_TO_SIGNAL_TIME_SLOTS != 0)
	GPIO_WriteBit(GPIOB, GPIO_Pin_13, Bit_RESET);
#endif
		notify(SIG::OWN_SLOT_FINISH);
 80132e6:	2303      	movs	r3, #3
 80132e8:	73bb      	strb	r3, [r7, #14]
 80132ea:	f107 030e 	add.w	r3, r7, #14
 80132ee:	4619      	mov	r1, r3
 80132f0:	6878      	ldr	r0, [r7, #4]
 80132f2:	f7ff fe81 	bl	8012ff8 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE>
	}

	// Stop hardware timer after counting all time slots
	if (_slotCounter >= (desenet::MAX_SLOT_NUMBER + 1))
 80132f6:	687b      	ldr	r3, [r7, #4]
 80132f8:	7e5b      	ldrb	r3, [r3, #25]
 80132fa:	2b1f      	cmp	r3, #31
 80132fc:	d90a      	bls.n	8013314 <_ZN7desenet15TimeSlotManager11_processIrqEv+0x64>
	{
		notify(SIG::CYCLE_FINISH);
 80132fe:	2301      	movs	r3, #1
 8013300:	73fb      	strb	r3, [r7, #15]
 8013302:	f107 030f 	add.w	r3, r7, #15
 8013306:	4619      	mov	r1, r3
 8013308:	6878      	ldr	r0, [r7, #4]
 801330a:	f7ff fe75 	bl	8012ff8 <_ZN7desenet15TimeSlotManager6notifyERKN16ITimeSlotManager3SIGE>

		_stopTimer();
 801330e:	6878      	ldr	r0, [r7, #4]
 8013310:	f7ff ffc0 	bl	8013294 <_ZN7desenet15TimeSlotManager10_stopTimerEv>
	}

	_slotCounter++;	// Increment slotCounter for the next slot
 8013314:	687b      	ldr	r3, [r7, #4]
 8013316:	7e5b      	ldrb	r3, [r3, #25]
 8013318:	3301      	adds	r3, #1
 801331a:	b2da      	uxtb	r2, r3
 801331c:	687b      	ldr	r3, [r7, #4]
 801331e:	765a      	strb	r2, [r3, #25]
}
 8013320:	bf00      	nop
 8013322:	3710      	adds	r7, #16
 8013324:	46bd      	mov	sp, r7
 8013326:	bd80      	pop	{r7, pc}

08013328 <_ZN7desenet15TimeSlotManager12processEventEv>:

EventStatus TimeSlotManager::processEvent()
{
 8013328:	b580      	push	{r7, lr}
 801332a:	b084      	sub	sp, #16
 801332c:	af00      	add	r7, sp, #0
 801332e:	6078      	str	r0, [r7, #4]
	eMainState newState = _currentState;
 8013330:	687b      	ldr	r3, [r7, #4]
 8013332:	7e1b      	ldrb	r3, [r3, #24]
 8013334:	73fb      	strb	r3, [r7, #15]

	switch (_currentState)
 8013336:	687b      	ldr	r3, [r7, #4]
 8013338:	7e1b      	ldrb	r3, [r3, #24]
 801333a:	2b01      	cmp	r3, #1
 801333c:	dc02      	bgt.n	8013344 <_ZN7desenet15TimeSlotManager12processEventEv+0x1c>
 801333e:	2b00      	cmp	r3, #0
 8013340:	da03      	bge.n	801334a <_ZN7desenet15TimeSlotManager12processEventEv+0x22>
 8013342:	e048      	b.n	80133d6 <_ZN7desenet15TimeSlotManager12processEventEv+0xae>
 8013344:	2b02      	cmp	r3, #2
 8013346:	d023      	beq.n	8013390 <_ZN7desenet15TimeSlotManager12processEventEv+0x68>
 8013348:	e045      	b.n	80133d6 <_ZN7desenet15TimeSlotManager12processEventEv+0xae>
	{
	case STATE_UNKOWN:
	case STATE_INITIAL:
		if (getCurrentEvent()->getEventType() == IXFEvent::Initial)
 801334a:	687b      	ldr	r3, [r7, #4]
 801334c:	3304      	adds	r3, #4
 801334e:	4618      	mov	r0, r3
 8013350:	f000 ffc6 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8013354:	4603      	mov	r3, r0
 8013356:	4618      	mov	r0, r3
 8013358:	f7f3 fb23 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 801335c:	4603      	mov	r3, r0
 801335e:	2b01      	cmp	r3, #1
 8013360:	bf0c      	ite	eq
 8013362:	2301      	moveq	r3, #1
 8013364:	2300      	movne	r3, #0
 8013366:	b2db      	uxtb	r3, r3
 8013368:	2b00      	cmp	r3, #0
 801336a:	d031      	beq.n	80133d0 <_ZN7desenet15TimeSlotManager12processEventEv+0xa8>
		{
			newState = STATE_ROOT;	// Move to state ROOT
 801336c:	2302      	movs	r3, #2
 801336e:	73fb      	strb	r3, [r7, #15]

			// Start timeout
			getThread()->scheduleTimeout(Timeout_SIM_BEACON_RECEIVED_id, SIM_BEACON_INTERVAL_IN_MS, this);
 8013370:	687b      	ldr	r3, [r7, #4]
 8013372:	1d1a      	adds	r2, r3, #4
 8013374:	687b      	ldr	r3, [r7, #4]
 8013376:	685b      	ldr	r3, [r3, #4]
 8013378:	3318      	adds	r3, #24
 801337a:	681b      	ldr	r3, [r3, #0]
 801337c:	4610      	mov	r0, r2
 801337e:	4798      	blx	r3
 8013380:	687b      	ldr	r3, [r7, #4]
 8013382:	3304      	adds	r3, #4
 8013384:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8013388:	2101      	movs	r1, #1
 801338a:	f001 f964 	bl	8014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>
		}
		break;
 801338e:	e01f      	b.n	80133d0 <_ZN7desenet15TimeSlotManager12processEventEv+0xa8>
	case STATE_ROOT:
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 8013390:	687b      	ldr	r3, [r7, #4]
 8013392:	3304      	adds	r3, #4
 8013394:	4618      	mov	r0, r3
 8013396:	f000 ffa3 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 801339a:	4603      	mov	r3, r0
 801339c:	4618      	mov	r0, r3
 801339e:	f7f3 fb00 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 80133a2:	4603      	mov	r3, r0
 80133a4:	2b04      	cmp	r3, #4
 80133a6:	d10d      	bne.n	80133c4 <_ZN7desenet15TimeSlotManager12processEventEv+0x9c>
			getCurrentTimeout()->getId() == Timeout_SIM_BEACON_RECEIVED_id)
 80133a8:	687b      	ldr	r3, [r7, #4]
 80133aa:	3304      	adds	r3, #4
 80133ac:	4618      	mov	r0, r3
 80133ae:	f000 ffb1 	bl	8014314 <_ZN10XFReactive17getCurrentTimeoutEv>
 80133b2:	4603      	mov	r3, r0
 80133b4:	4618      	mov	r0, r3
 80133b6:	f7f3 fb01 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 80133ba:	4603      	mov	r3, r0
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 80133bc:	2b01      	cmp	r3, #1
 80133be:	d101      	bne.n	80133c4 <_ZN7desenet15TimeSlotManager12processEventEv+0x9c>
 80133c0:	2301      	movs	r3, #1
 80133c2:	e000      	b.n	80133c6 <_ZN7desenet15TimeSlotManager12processEventEv+0x9e>
 80133c4:	2300      	movs	r3, #0
 80133c6:	2b00      	cmp	r3, #0
 80133c8:	d004      	beq.n	80133d4 <_ZN7desenet15TimeSlotManager12processEventEv+0xac>
		{
			newState = STATE_ROOT;	// Stay in state
 80133ca:	2302      	movs	r3, #2
 80133cc:	73fb      	strb	r3, [r7, #15]

			// Simulate we got a beacon
			onBeaconReceived(2000 /*ms*/);
#endif // TIMESLOTMANAGER_SIMULATE_BEACON
		}
		break;
 80133ce:	e001      	b.n	80133d4 <_ZN7desenet15TimeSlotManager12processEventEv+0xac>
		break;
 80133d0:	bf00      	nop
 80133d2:	e000      	b.n	80133d6 <_ZN7desenet15TimeSlotManager12processEventEv+0xae>
		break;
 80133d4:	bf00      	nop
	}

	_currentState = newState;		// Save new state to actual
 80133d6:	687b      	ldr	r3, [r7, #4]
 80133d8:	7bfa      	ldrb	r2, [r7, #15]
 80133da:	761a      	strb	r2, [r3, #24]

	return EventStatus::Consumed;	// We consume all given events/timeouts
 80133dc:	f107 030c 	add.w	r3, r7, #12
 80133e0:	2101      	movs	r1, #1
 80133e2:	4618      	mov	r0, r3
 80133e4:	f7f3 faf6 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 80133e8:	7b3b      	ldrb	r3, [r7, #12]
}
 80133ea:	4618      	mov	r0, r3
 80133ec:	3710      	adds	r7, #16
 80133ee:	46bd      	mov	sp, r7
 80133f0:	bd80      	pop	{r7, pc}

080133f2 <_ZThn4_N7desenet15TimeSlotManager12processEventEv>:

	virtual void onBeaconReceived(const desenet::SlotDuration & slotDuration);

protected:
	// Interface from XFReactive
	virtual EventStatus processEvent();		///< Implements the state machine.
 80133f2:	f1a0 0004 	sub.w	r0, r0, #4
 80133f6:	f7ff bf97 	b.w	8013328 <_ZN7desenet15TimeSlotManager12processEventEv>
	...

080133fc <_Z41__static_initialization_and_destruction_0ii>:

} // namespace desenet
 80133fc:	b580      	push	{r7, lr}
 80133fe:	b088      	sub	sp, #32
 8013400:	af00      	add	r7, sp, #0
 8013402:	6078      	str	r0, [r7, #4]
 8013404:	6039      	str	r1, [r7, #0]
 8013406:	687b      	ldr	r3, [r7, #4]
 8013408:	2b01      	cmp	r3, #1
 801340a:	d122      	bne.n	8013452 <_Z41__static_initialization_and_destruction_0ii+0x56>
 801340c:	683b      	ldr	r3, [r7, #0]
 801340e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013412:	4293      	cmp	r3, r2
 8013414:	d11d      	bne.n	8013452 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8013416:	4b18      	ldr	r3, [pc, #96]	; (8013478 <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8013418:	681b      	ldr	r3, [r3, #0]
 801341a:	613b      	str	r3, [r7, #16]
 801341c:	f107 0310 	add.w	r3, r7, #16
 8013420:	60bb      	str	r3, [r7, #8]
 8013422:	2304      	movs	r3, #4
 8013424:	60fb      	str	r3, [r7, #12]
 8013426:	f107 0308 	add.w	r3, r7, #8
 801342a:	e893 0006 	ldmia.w	r3, {r1, r2}
 801342e:	4813      	ldr	r0, [pc, #76]	; (801347c <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8013430:	f7f3 fc80 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8013434:	4b12      	ldr	r3, [pc, #72]	; (8013480 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8013436:	681b      	ldr	r3, [r3, #0]
 8013438:	61fb      	str	r3, [r7, #28]
 801343a:	f107 031c 	add.w	r3, r7, #28
 801343e:	617b      	str	r3, [r7, #20]
 8013440:	2304      	movs	r3, #4
 8013442:	61bb      	str	r3, [r7, #24]
 8013444:	f107 0314 	add.w	r3, r7, #20
 8013448:	e893 0006 	ldmia.w	r3, {r1, r2}
 801344c:	480d      	ldr	r0, [pc, #52]	; (8013484 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 801344e:	f7f3 fc71 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8013452:	687b      	ldr	r3, [r7, #4]
 8013454:	2b00      	cmp	r3, #0
 8013456:	d10a      	bne.n	801346e <_Z41__static_initialization_and_destruction_0ii+0x72>
 8013458:	683b      	ldr	r3, [r7, #0]
 801345a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801345e:	4293      	cmp	r3, r2
 8013460:	d105      	bne.n	801346e <_Z41__static_initialization_and_destruction_0ii+0x72>
 8013462:	4808      	ldr	r0, [pc, #32]	; (8013484 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8013464:	f7f3 fdb0 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8013468:	4804      	ldr	r0, [pc, #16]	; (801347c <_Z41__static_initialization_and_destruction_0ii+0x80>)
 801346a:	f7f3 fdad 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 801346e:	bf00      	nop
 8013470:	3720      	adds	r7, #32
 8013472:	46bd      	mov	sp, r7
 8013474:	bd80      	pop	{r7, pc}
 8013476:	bf00      	nop
 8013478:	0801b1cc 	.word	0x0801b1cc
 801347c:	20001dc0 	.word	0x20001dc0
 8013480:	0801b1d0 	.word	0x0801b1d0
 8013484:	20001dc8 	.word	0x20001dc8

08013488 <_GLOBAL__sub_I__ZN7desenet15TimeSlotManager10_pInstanceE>:
 8013488:	b580      	push	{r7, lr}
 801348a:	af00      	add	r7, sp, #0
 801348c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013490:	2001      	movs	r0, #1
 8013492:	f7ff ffb3 	bl	80133fc <_Z41__static_initialization_and_destruction_0ii>
 8013496:	bd80      	pop	{r7, pc}

08013498 <_GLOBAL__sub_D__ZN7desenet15TimeSlotManager10_pInstanceE>:
 8013498:	b580      	push	{r7, lr}
 801349a:	af00      	add	r7, sp, #0
 801349c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80134a0:	2000      	movs	r0, #0
 80134a2:	f7ff ffab 	bl	80133fc <_Z41__static_initialization_and_destruction_0ii>
 80134a6:	bd80      	pop	{r7, pc}

080134a8 <enterCritical>:
volatile unsigned char bInISR = 0;
volatile unsigned char bEnterCriticalRegionNested = 0;


void enterCritical()
{
 80134a8:	b480      	push	{r7}
 80134aa:	af00      	add	r7, sp, #0
	// Only disable interrupts when not calling from an ISR
	if (!inISR())
 80134ac:	4b0b      	ldr	r3, [pc, #44]	; (80134dc <enterCritical+0x34>)
 80134ae:	781b      	ldrb	r3, [r3, #0]
 80134b0:	b2db      	uxtb	r3, r3
 80134b2:	2b00      	cmp	r3, #0
 80134b4:	d10c      	bne.n	80134d0 <enterCritical+0x28>
	{
		if (!bEnterCriticalRegionNested)
 80134b6:	4b0a      	ldr	r3, [pc, #40]	; (80134e0 <enterCritical+0x38>)
 80134b8:	781b      	ldrb	r3, [r3, #0]
 80134ba:	b2db      	uxtb	r3, r3
 80134bc:	2b00      	cmp	r3, #0
 80134be:	d100      	bne.n	80134c2 <enterCritical+0x1a>
		{
			// Turn off the priority configurable interrupts
			asm volatile ("cpsid i");
 80134c0:	b672      	cpsid	i
		}
		bEnterCriticalRegionNested++;
 80134c2:	4b07      	ldr	r3, [pc, #28]	; (80134e0 <enterCritical+0x38>)
 80134c4:	781b      	ldrb	r3, [r3, #0]
 80134c6:	b2db      	uxtb	r3, r3
 80134c8:	3301      	adds	r3, #1
 80134ca:	b2da      	uxtb	r2, r3
 80134cc:	4b04      	ldr	r3, [pc, #16]	; (80134e0 <enterCritical+0x38>)
 80134ce:	701a      	strb	r2, [r3, #0]
	}

}
 80134d0:	bf00      	nop
 80134d2:	46bd      	mov	sp, r7
 80134d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80134d8:	4770      	bx	lr
 80134da:	bf00      	nop
 80134dc:	20001dd4 	.word	0x20001dd4
 80134e0:	20001dd5 	.word	0x20001dd5

080134e4 <exitCritical>:

void exitCritical()
{
 80134e4:	b480      	push	{r7}
 80134e6:	af00      	add	r7, sp, #0
	// Only enable interrupts when not calling from an ISR
	if (!inISR())
 80134e8:	4b0b      	ldr	r3, [pc, #44]	; (8013518 <exitCritical+0x34>)
 80134ea:	781b      	ldrb	r3, [r3, #0]
 80134ec:	b2db      	uxtb	r3, r3
 80134ee:	2b00      	cmp	r3, #0
 80134f0:	d10c      	bne.n	801350c <exitCritical+0x28>
	{
		bEnterCriticalRegionNested--;
 80134f2:	4b0a      	ldr	r3, [pc, #40]	; (801351c <exitCritical+0x38>)
 80134f4:	781b      	ldrb	r3, [r3, #0]
 80134f6:	b2db      	uxtb	r3, r3
 80134f8:	3b01      	subs	r3, #1
 80134fa:	b2da      	uxtb	r2, r3
 80134fc:	4b07      	ldr	r3, [pc, #28]	; (801351c <exitCritical+0x38>)
 80134fe:	701a      	strb	r2, [r3, #0]

		if (!bEnterCriticalRegionNested)
 8013500:	4b06      	ldr	r3, [pc, #24]	; (801351c <exitCritical+0x38>)
 8013502:	781b      	ldrb	r3, [r3, #0]
 8013504:	b2db      	uxtb	r3, r3
 8013506:	2b00      	cmp	r3, #0
 8013508:	d100      	bne.n	801350c <exitCritical+0x28>
		{
			// Turn on the interrupts with configurable priority
			asm volatile("cpsie i");
 801350a:	b662      	cpsie	i
		}
	}
}
 801350c:	bf00      	nop
 801350e:	46bd      	mov	sp, r7
 8013510:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013514:	4770      	bx	lr
 8013516:	bf00      	nop
 8013518:	20001dd4 	.word	0x20001dd4
 801351c:	20001dd5 	.word	0x20001dd5

08013520 <_ZN3SpiC1Ei>:
#include "spi.h"

extern "C" SPI_HandleTypeDef hspi2;     // All defined in main.c
extern "C" SPI_HandleTypeDef hspi3;

Spi::Spi(int spiNbr)
 8013520:	b580      	push	{r7, lr}
 8013522:	b082      	sub	sp, #8
 8013524:	af00      	add	r7, sp, #0
 8013526:	6078      	str	r0, [r7, #4]
 8013528:	6039      	str	r1, [r7, #0]
 : _bInitialized(false),
   _pSPI(NULL)
 801352a:	4a11      	ldr	r2, [pc, #68]	; (8013570 <_ZN3SpiC1Ei+0x50>)
 801352c:	687b      	ldr	r3, [r7, #4]
 801352e:	601a      	str	r2, [r3, #0]
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	2200      	movs	r2, #0
 8013534:	711a      	strb	r2, [r3, #4]
 8013536:	687b      	ldr	r3, [r7, #4]
 8013538:	2200      	movs	r2, #0
 801353a:	609a      	str	r2, [r3, #8]
{
	switch (spiNbr)
 801353c:	683b      	ldr	r3, [r7, #0]
 801353e:	2b01      	cmp	r3, #1
 8013540:	d003      	beq.n	801354a <_ZN3SpiC1Ei+0x2a>
 8013542:	683b      	ldr	r3, [r7, #0]
 8013544:	2b02      	cmp	r3, #2
 8013546:	d004      	beq.n	8013552 <_ZN3SpiC1Ei+0x32>
 8013548:	e007      	b.n	801355a <_ZN3SpiC1Ei+0x3a>
	{
	case 1:
		_pSPI = &hspi2;
 801354a:	687b      	ldr	r3, [r7, #4]
 801354c:	4a09      	ldr	r2, [pc, #36]	; (8013574 <_ZN3SpiC1Ei+0x54>)
 801354e:	609a      	str	r2, [r3, #8]
		break;
 8013550:	e009      	b.n	8013566 <_ZN3SpiC1Ei+0x46>
	case 2:
		_pSPI = &hspi3;
 8013552:	687b      	ldr	r3, [r7, #4]
 8013554:	4a08      	ldr	r2, [pc, #32]	; (8013578 <_ZN3SpiC1Ei+0x58>)
 8013556:	609a      	str	r2, [r3, #8]
		break;
 8013558:	e005      	b.n	8013566 <_ZN3SpiC1Ei+0x46>
	default:
		assert(false);	// Passed wrong parameter
 801355a:	4b08      	ldr	r3, [pc, #32]	; (801357c <_ZN3SpiC1Ei+0x5c>)
 801355c:	4a08      	ldr	r2, [pc, #32]	; (8013580 <_ZN3SpiC1Ei+0x60>)
 801355e:	2116      	movs	r1, #22
 8013560:	4808      	ldr	r0, [pc, #32]	; (8013584 <_ZN3SpiC1Ei+0x64>)
 8013562:	f002 ff17 	bl	8016394 <__assert_func>
	}
}
 8013566:	687b      	ldr	r3, [r7, #4]
 8013568:	4618      	mov	r0, r3
 801356a:	3708      	adds	r7, #8
 801356c:	46bd      	mov	sp, r7
 801356e:	bd80      	pop	{r7, pc}
 8013570:	0801dc08 	.word	0x0801dc08
 8013574:	200000e8 	.word	0x200000e8
 8013578:	2000014c 	.word	0x2000014c
 801357c:	0801b1d4 	.word	0x0801b1d4
 8013580:	0801b1dc 	.word	0x0801b1dc
 8013584:	0801b1ec 	.word	0x0801b1ec

08013588 <_ZN3SpiD1Ev>:

Spi::~Spi()
 8013588:	b480      	push	{r7}
 801358a:	b083      	sub	sp, #12
 801358c:	af00      	add	r7, sp, #0
 801358e:	6078      	str	r0, [r7, #4]
 8013590:	4a04      	ldr	r2, [pc, #16]	; (80135a4 <_ZN3SpiD1Ev+0x1c>)
 8013592:	687b      	ldr	r3, [r7, #4]
 8013594:	601a      	str	r2, [r3, #0]
{

}
 8013596:	687b      	ldr	r3, [r7, #4]
 8013598:	4618      	mov	r0, r3
 801359a:	370c      	adds	r7, #12
 801359c:	46bd      	mov	sp, r7
 801359e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135a2:	4770      	bx	lr
 80135a4:	0801dc08 	.word	0x0801dc08

080135a8 <_ZN3SpiD0Ev>:
Spi::~Spi()
 80135a8:	b580      	push	{r7, lr}
 80135aa:	b082      	sub	sp, #8
 80135ac:	af00      	add	r7, sp, #0
 80135ae:	6078      	str	r0, [r7, #4]
}
 80135b0:	6878      	ldr	r0, [r7, #4]
 80135b2:	f7ff ffe9 	bl	8013588 <_ZN3SpiD1Ev>
 80135b6:	210c      	movs	r1, #12
 80135b8:	6878      	ldr	r0, [r7, #4]
 80135ba:	f002 fdf7 	bl	80161ac <_ZdlPvj>
 80135be:	687b      	ldr	r3, [r7, #4]
 80135c0:	4618      	mov	r0, r3
 80135c2:	3708      	adds	r7, #8
 80135c4:	46bd      	mov	sp, r7
 80135c6:	bd80      	pop	{r7, pc}

080135c8 <__tcf_0>:

	switch (spiIndex)
	{
	case 0:
		{
			static Spi spi1(0);
 80135c8:	b580      	push	{r7, lr}
 80135ca:	af00      	add	r7, sp, #0
 80135cc:	4801      	ldr	r0, [pc, #4]	; (80135d4 <__tcf_0+0xc>)
 80135ce:	f7ff ffdb 	bl	8013588 <_ZN3SpiD1Ev>
 80135d2:	bd80      	pop	{r7, pc}
 80135d4:	20001dd8 	.word	0x20001dd8

080135d8 <__tcf_1>:
			pSpi = &spi1;
		}
		break;
	case 1:
		{
			static Spi spi2(1);
 80135d8:	b580      	push	{r7, lr}
 80135da:	af00      	add	r7, sp, #0
 80135dc:	4801      	ldr	r0, [pc, #4]	; (80135e4 <__tcf_1+0xc>)
 80135de:	f7ff ffd3 	bl	8013588 <_ZN3SpiD1Ev>
 80135e2:	bd80      	pop	{r7, pc}
 80135e4:	20001de8 	.word	0x20001de8

080135e8 <__tcf_2>:
			pSpi = &spi2;
		}
		break;
	case 2:
		{
			static Spi spi3(2);
 80135e8:	b580      	push	{r7, lr}
 80135ea:	af00      	add	r7, sp, #0
 80135ec:	4801      	ldr	r0, [pc, #4]	; (80135f4 <__tcf_2+0xc>)
 80135ee:	f7ff ffcb 	bl	8013588 <_ZN3SpiD1Ev>
 80135f2:	bd80      	pop	{r7, pc}
 80135f4:	20001df8 	.word	0x20001df8

080135f8 <_ZN3Spi8instanceEh>:
{
 80135f8:	b580      	push	{r7, lr}
 80135fa:	b084      	sub	sp, #16
 80135fc:	af00      	add	r7, sp, #0
 80135fe:	4603      	mov	r3, r0
 8013600:	71fb      	strb	r3, [r7, #7]
	Spi * pSpi = NULL;
 8013602:	2300      	movs	r3, #0
 8013604:	60fb      	str	r3, [r7, #12]
	switch (spiIndex)
 8013606:	79fb      	ldrb	r3, [r7, #7]
 8013608:	2b02      	cmp	r3, #2
 801360a:	d052      	beq.n	80136b2 <_ZN3Spi8instanceEh+0xba>
 801360c:	2b02      	cmp	r3, #2
 801360e:	dc76      	bgt.n	80136fe <_ZN3Spi8instanceEh+0x106>
 8013610:	2b00      	cmp	r3, #0
 8013612:	d002      	beq.n	801361a <_ZN3Spi8instanceEh+0x22>
 8013614:	2b01      	cmp	r3, #1
 8013616:	d026      	beq.n	8013666 <_ZN3Spi8instanceEh+0x6e>

			pSpi = &spi3;
		}
		break;
	default:
		break;
 8013618:	e071      	b.n	80136fe <_ZN3Spi8instanceEh+0x106>
			static Spi spi1(0);
 801361a:	4b40      	ldr	r3, [pc, #256]	; (801371c <_ZN3Spi8instanceEh+0x124>)
 801361c:	781b      	ldrb	r3, [r3, #0]
 801361e:	f3bf 8f5b 	dmb	ish
 8013622:	b2db      	uxtb	r3, r3
 8013624:	f003 0301 	and.w	r3, r3, #1
 8013628:	2b00      	cmp	r3, #0
 801362a:	bf0c      	ite	eq
 801362c:	2301      	moveq	r3, #1
 801362e:	2300      	movne	r3, #0
 8013630:	b2db      	uxtb	r3, r3
 8013632:	2b00      	cmp	r3, #0
 8013634:	d014      	beq.n	8013660 <_ZN3Spi8instanceEh+0x68>
 8013636:	4839      	ldr	r0, [pc, #228]	; (801371c <_ZN3Spi8instanceEh+0x124>)
 8013638:	f002 fdbc 	bl	80161b4 <__cxa_guard_acquire>
 801363c:	4603      	mov	r3, r0
 801363e:	2b00      	cmp	r3, #0
 8013640:	bf14      	ite	ne
 8013642:	2301      	movne	r3, #1
 8013644:	2300      	moveq	r3, #0
 8013646:	b2db      	uxtb	r3, r3
 8013648:	2b00      	cmp	r3, #0
 801364a:	d009      	beq.n	8013660 <_ZN3Spi8instanceEh+0x68>
 801364c:	2100      	movs	r1, #0
 801364e:	4834      	ldr	r0, [pc, #208]	; (8013720 <_ZN3Spi8instanceEh+0x128>)
 8013650:	f7ff ff66 	bl	8013520 <_ZN3SpiC1Ei>
 8013654:	4833      	ldr	r0, [pc, #204]	; (8013724 <_ZN3Spi8instanceEh+0x12c>)
 8013656:	f002 febb 	bl	80163d0 <atexit>
 801365a:	4830      	ldr	r0, [pc, #192]	; (801371c <_ZN3Spi8instanceEh+0x124>)
 801365c:	f002 fdb6 	bl	80161cc <__cxa_guard_release>
			pSpi = &spi1;
 8013660:	4b2f      	ldr	r3, [pc, #188]	; (8013720 <_ZN3Spi8instanceEh+0x128>)
 8013662:	60fb      	str	r3, [r7, #12]
		break;
 8013664:	e04c      	b.n	8013700 <_ZN3Spi8instanceEh+0x108>
			static Spi spi2(1);
 8013666:	4b30      	ldr	r3, [pc, #192]	; (8013728 <_ZN3Spi8instanceEh+0x130>)
 8013668:	781b      	ldrb	r3, [r3, #0]
 801366a:	f3bf 8f5b 	dmb	ish
 801366e:	b2db      	uxtb	r3, r3
 8013670:	f003 0301 	and.w	r3, r3, #1
 8013674:	2b00      	cmp	r3, #0
 8013676:	bf0c      	ite	eq
 8013678:	2301      	moveq	r3, #1
 801367a:	2300      	movne	r3, #0
 801367c:	b2db      	uxtb	r3, r3
 801367e:	2b00      	cmp	r3, #0
 8013680:	d014      	beq.n	80136ac <_ZN3Spi8instanceEh+0xb4>
 8013682:	4829      	ldr	r0, [pc, #164]	; (8013728 <_ZN3Spi8instanceEh+0x130>)
 8013684:	f002 fd96 	bl	80161b4 <__cxa_guard_acquire>
 8013688:	4603      	mov	r3, r0
 801368a:	2b00      	cmp	r3, #0
 801368c:	bf14      	ite	ne
 801368e:	2301      	movne	r3, #1
 8013690:	2300      	moveq	r3, #0
 8013692:	b2db      	uxtb	r3, r3
 8013694:	2b00      	cmp	r3, #0
 8013696:	d009      	beq.n	80136ac <_ZN3Spi8instanceEh+0xb4>
 8013698:	2101      	movs	r1, #1
 801369a:	4824      	ldr	r0, [pc, #144]	; (801372c <_ZN3Spi8instanceEh+0x134>)
 801369c:	f7ff ff40 	bl	8013520 <_ZN3SpiC1Ei>
 80136a0:	4823      	ldr	r0, [pc, #140]	; (8013730 <_ZN3Spi8instanceEh+0x138>)
 80136a2:	f002 fe95 	bl	80163d0 <atexit>
 80136a6:	4820      	ldr	r0, [pc, #128]	; (8013728 <_ZN3Spi8instanceEh+0x130>)
 80136a8:	f002 fd90 	bl	80161cc <__cxa_guard_release>
			pSpi = &spi2;
 80136ac:	4b1f      	ldr	r3, [pc, #124]	; (801372c <_ZN3Spi8instanceEh+0x134>)
 80136ae:	60fb      	str	r3, [r7, #12]
		break;
 80136b0:	e026      	b.n	8013700 <_ZN3Spi8instanceEh+0x108>
			static Spi spi3(2);
 80136b2:	4b20      	ldr	r3, [pc, #128]	; (8013734 <_ZN3Spi8instanceEh+0x13c>)
 80136b4:	781b      	ldrb	r3, [r3, #0]
 80136b6:	f3bf 8f5b 	dmb	ish
 80136ba:	b2db      	uxtb	r3, r3
 80136bc:	f003 0301 	and.w	r3, r3, #1
 80136c0:	2b00      	cmp	r3, #0
 80136c2:	bf0c      	ite	eq
 80136c4:	2301      	moveq	r3, #1
 80136c6:	2300      	movne	r3, #0
 80136c8:	b2db      	uxtb	r3, r3
 80136ca:	2b00      	cmp	r3, #0
 80136cc:	d014      	beq.n	80136f8 <_ZN3Spi8instanceEh+0x100>
 80136ce:	4819      	ldr	r0, [pc, #100]	; (8013734 <_ZN3Spi8instanceEh+0x13c>)
 80136d0:	f002 fd70 	bl	80161b4 <__cxa_guard_acquire>
 80136d4:	4603      	mov	r3, r0
 80136d6:	2b00      	cmp	r3, #0
 80136d8:	bf14      	ite	ne
 80136da:	2301      	movne	r3, #1
 80136dc:	2300      	moveq	r3, #0
 80136de:	b2db      	uxtb	r3, r3
 80136e0:	2b00      	cmp	r3, #0
 80136e2:	d009      	beq.n	80136f8 <_ZN3Spi8instanceEh+0x100>
 80136e4:	2102      	movs	r1, #2
 80136e6:	4814      	ldr	r0, [pc, #80]	; (8013738 <_ZN3Spi8instanceEh+0x140>)
 80136e8:	f7ff ff1a 	bl	8013520 <_ZN3SpiC1Ei>
 80136ec:	4813      	ldr	r0, [pc, #76]	; (801373c <_ZN3Spi8instanceEh+0x144>)
 80136ee:	f002 fe6f 	bl	80163d0 <atexit>
 80136f2:	4810      	ldr	r0, [pc, #64]	; (8013734 <_ZN3Spi8instanceEh+0x13c>)
 80136f4:	f002 fd6a 	bl	80161cc <__cxa_guard_release>
			pSpi = &spi3;
 80136f8:	4b0f      	ldr	r3, [pc, #60]	; (8013738 <_ZN3Spi8instanceEh+0x140>)
 80136fa:	60fb      	str	r3, [r7, #12]
		break;
 80136fc:	e000      	b.n	8013700 <_ZN3Spi8instanceEh+0x108>
		break;
 80136fe:	bf00      	nop
	}

	if (!pSpi)
 8013700:	68fb      	ldr	r3, [r7, #12]
 8013702:	2b00      	cmp	r3, #0
 8013704:	d105      	bne.n	8013712 <_ZN3Spi8instanceEh+0x11a>
	{
		assert(false);
 8013706:	4b0e      	ldr	r3, [pc, #56]	; (8013740 <_ZN3Spi8instanceEh+0x148>)
 8013708:	4a0e      	ldr	r2, [pc, #56]	; (8013744 <_ZN3Spi8instanceEh+0x14c>)
 801370a:	2145      	movs	r1, #69	; 0x45
 801370c:	480e      	ldr	r0, [pc, #56]	; (8013748 <_ZN3Spi8instanceEh+0x150>)
 801370e:	f002 fe41 	bl	8016394 <__assert_func>
	}

	return *pSpi;
 8013712:	68fb      	ldr	r3, [r7, #12]
}
 8013714:	4618      	mov	r0, r3
 8013716:	3710      	adds	r7, #16
 8013718:	46bd      	mov	sp, r7
 801371a:	bd80      	pop	{r7, pc}
 801371c:	20001de4 	.word	0x20001de4
 8013720:	20001dd8 	.word	0x20001dd8
 8013724:	080135c9 	.word	0x080135c9
 8013728:	20001df4 	.word	0x20001df4
 801372c:	20001de8 	.word	0x20001de8
 8013730:	080135d9 	.word	0x080135d9
 8013734:	20001e04 	.word	0x20001e04
 8013738:	20001df8 	.word	0x20001df8
 801373c:	080135e9 	.word	0x080135e9
 8013740:	0801b1d4 	.word	0x0801b1d4
 8013744:	0801b274 	.word	0x0801b274
 8013748:	0801b1ec 	.word	0x0801b1ec

0801374c <_ZN3Spi10initializeEv>:
 * needs to be made in an other place (see in board configuration).
 *
 * After complete initialization the SPI can be enabled using the #enable method.
 */
bool Spi::initialize()
{
 801374c:	b480      	push	{r7}
 801374e:	b083      	sub	sp, #12
 8013750:	af00      	add	r7, sp, #0
 8013752:	6078      	str	r0, [r7, #4]
	if (!_bInitialized)
 8013754:	687b      	ldr	r3, [r7, #4]
 8013756:	791b      	ldrb	r3, [r3, #4]
 8013758:	f083 0301 	eor.w	r3, r3, #1
 801375c:	b2db      	uxtb	r3, r3
 801375e:	2b00      	cmp	r3, #0
 8013760:	d004      	beq.n	801376c <_ZN3Spi10initializeEv+0x20>
	{
		_bInitialized = true;
 8013762:	687b      	ldr	r3, [r7, #4]
 8013764:	2201      	movs	r2, #1
 8013766:	711a      	strb	r2, [r3, #4]

#ifdef IDE_STM32CUBEIDE
		// HAL initialization is done in the main.c file
		return true;
 8013768:	2301      	movs	r3, #1
 801376a:	e000      	b.n	801376e <_ZN3Spi10initializeEv+0x22>
#endif // IDE_STM32CUBEIDE

		return true;
	}

	return false;
 801376c:	2300      	movs	r3, #0
}
 801376e:	4618      	mov	r0, r3
 8013770:	370c      	adds	r7, #12
 8013772:	46bd      	mov	sp, r7
 8013774:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013778:	4770      	bx	lr
	...

0801377c <_ZN3Spi8sendByteEh>:
//	assert(_pSPI);
//	return SPI_I2S_GetFlagStatus(_pSPI, flagMask);
//}

Spi::tStatus Spi::sendByte(unsigned char data)
{
 801377c:	b580      	push	{r7, lr}
 801377e:	b086      	sub	sp, #24
 8013780:	af02      	add	r7, sp, #8
 8013782:	6078      	str	r0, [r7, #4]
 8013784:	460b      	mov	r3, r1
 8013786:	70fb      	strb	r3, [r7, #3]
	HAL_StatusTypeDef status = HAL_ERROR;
 8013788:	2301      	movs	r3, #1
 801378a:	73fb      	strb	r3, [r7, #15]
	uint8_t rxData[1];

	status = HAL_SPI_TransmitReceive(_pSPI, &data, rxData, 1, 50);
 801378c:	687b      	ldr	r3, [r7, #4]
 801378e:	6898      	ldr	r0, [r3, #8]
 8013790:	f107 020c 	add.w	r2, r7, #12
 8013794:	1cf9      	adds	r1, r7, #3
 8013796:	2332      	movs	r3, #50	; 0x32
 8013798:	9300      	str	r3, [sp, #0]
 801379a:	2301      	movs	r3, #1
 801379c:	f7f0 fc9f 	bl	80040de <HAL_SPI_TransmitReceive>
 80137a0:	4603      	mov	r3, r0
 80137a2:	73fb      	strb	r3, [r7, #15]
	assert(status == HAL_OK);
 80137a4:	7bfb      	ldrb	r3, [r7, #15]
 80137a6:	2b00      	cmp	r3, #0
 80137a8:	d005      	beq.n	80137b6 <_ZN3Spi8sendByteEh+0x3a>
 80137aa:	4b05      	ldr	r3, [pc, #20]	; (80137c0 <_ZN3Spi8sendByteEh+0x44>)
 80137ac:	4a05      	ldr	r2, [pc, #20]	; (80137c4 <_ZN3Spi8sendByteEh+0x48>)
 80137ae:	2182      	movs	r1, #130	; 0x82
 80137b0:	4805      	ldr	r0, [pc, #20]	; (80137c8 <_ZN3Spi8sendByteEh+0x4c>)
 80137b2:	f002 fdef 	bl	8016394 <__assert_func>

	// Return the byte read from the SPI bus
	return rxData[0];
 80137b6:	7b3b      	ldrb	r3, [r7, #12]
}
 80137b8:	4618      	mov	r0, r3
 80137ba:	3710      	adds	r7, #16
 80137bc:	46bd      	mov	sp, r7
 80137be:	bd80      	pop	{r7, pc}
 80137c0:	0801b298 	.word	0x0801b298
 80137c4:	0801b2ac 	.word	0x0801b2ac
 80137c8:	0801b1ec 	.word	0x0801b1ec

080137cc <_ZN4UartC1EhP20__UART_HandleTypeDefb>:
#endif

Uart * Uart::_sUart[Uart::UART_COUNT];				// Comment: Startup script should initialize pointers to zero (.bss section)
bool Uart::_sInitialized[Uart::UART_COUNT];			// Same for other arrays

Uart::Uart(const unsigned char uartNbr, UART_HandleTypeDef * uartHandle, bool bTxDMA /* = false */)
 80137cc:	b580      	push	{r7, lr}
 80137ce:	b084      	sub	sp, #16
 80137d0:	af00      	add	r7, sp, #0
 80137d2:	60f8      	str	r0, [r7, #12]
 80137d4:	607a      	str	r2, [r7, #4]
 80137d6:	461a      	mov	r2, r3
 80137d8:	460b      	mov	r3, r1
 80137da:	72fb      	strb	r3, [r7, #11]
 80137dc:	4613      	mov	r3, r2
 80137de:	72bb      	strb	r3, [r7, #10]
 : _uartNbr(-1),
   _pUartHandle(NULL),
   _bTxDMA(bTxDMA)
 80137e0:	4a1a      	ldr	r2, [pc, #104]	; (801384c <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x80>)
 80137e2:	68fb      	ldr	r3, [r7, #12]
 80137e4:	601a      	str	r2, [r3, #0]
 80137e6:	68fb      	ldr	r3, [r7, #12]
 80137e8:	22ff      	movs	r2, #255	; 0xff
 80137ea:	711a      	strb	r2, [r3, #4]
 80137ec:	68fb      	ldr	r3, [r7, #12]
 80137ee:	2200      	movs	r2, #0
 80137f0:	609a      	str	r2, [r3, #8]
 80137f2:	68fb      	ldr	r3, [r7, #12]
 80137f4:	7aba      	ldrb	r2, [r7, #10]
 80137f6:	731a      	strb	r2, [r3, #12]
{
	assert(uartNbr < UART_COUNT);
 80137f8:	7afb      	ldrb	r3, [r7, #11]
 80137fa:	2b02      	cmp	r3, #2
 80137fc:	d905      	bls.n	801380a <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x3e>
 80137fe:	4b14      	ldr	r3, [pc, #80]	; (8013850 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x84>)
 8013800:	4a14      	ldr	r2, [pc, #80]	; (8013854 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x88>)
 8013802:	2111      	movs	r1, #17
 8013804:	4814      	ldr	r0, [pc, #80]	; (8013858 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x8c>)
 8013806:	f002 fdc5 	bl	8016394 <__assert_func>

	if (uartNbr < UART_COUNT)
 801380a:	7afb      	ldrb	r3, [r7, #11]
 801380c:	2b02      	cmp	r3, #2
 801380e:	d817      	bhi.n	8013840 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x74>
    {
        if (!_sUart[uartNbr])
 8013810:	7afb      	ldrb	r3, [r7, #11]
 8013812:	4a12      	ldr	r2, [pc, #72]	; (801385c <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x90>)
 8013814:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013818:	2b00      	cmp	r3, #0
 801381a:	d10b      	bne.n	8013834 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x68>
        {
            // Register instance
            _sUart[uartNbr] = this;
 801381c:	7afb      	ldrb	r3, [r7, #11]
 801381e:	490f      	ldr	r1, [pc, #60]	; (801385c <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x90>)
 8013820:	68fa      	ldr	r2, [r7, #12]
 8013822:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            _uartNbr = uartNbr;
 8013826:	68fb      	ldr	r3, [r7, #12]
 8013828:	7afa      	ldrb	r2, [r7, #11]
 801382a:	711a      	strb	r2, [r3, #4]

            _pUartHandle = uartHandle;
 801382c:	68fb      	ldr	r3, [r7, #12]
 801382e:	687a      	ldr	r2, [r7, #4]
 8013830:	609a      	str	r2, [r3, #8]
 8013832:	e005      	b.n	8013840 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x74>
        }
        else
        {
            assert(false);  // Error: Instance for specified UART already exists.
 8013834:	4b0a      	ldr	r3, [pc, #40]	; (8013860 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x94>)
 8013836:	4a07      	ldr	r2, [pc, #28]	; (8013854 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x88>)
 8013838:	211f      	movs	r1, #31
 801383a:	4807      	ldr	r0, [pc, #28]	; (8013858 <_ZN4UartC1EhP20__UART_HandleTypeDefb+0x8c>)
 801383c:	f002 fdaa 	bl	8016394 <__assert_func>
        }
    }
}
 8013840:	68fb      	ldr	r3, [r7, #12]
 8013842:	4618      	mov	r0, r3
 8013844:	3710      	adds	r7, #16
 8013846:	46bd      	mov	sp, r7
 8013848:	bd80      	pop	{r7, pc}
 801384a:	bf00      	nop
 801384c:	0801dc18 	.word	0x0801dc18
 8013850:	0801b2d8 	.word	0x0801b2d8
 8013854:	0801b2f0 	.word	0x0801b2f0
 8013858:	0801b328 	.word	0x0801b328
 801385c:	20001e08 	.word	0x20001e08
 8013860:	0801b3b0 	.word	0x0801b3b0

08013864 <_ZN4UartD1Ev>:

Uart::~Uart()
 8013864:	b480      	push	{r7}
 8013866:	b083      	sub	sp, #12
 8013868:	af00      	add	r7, sp, #0
 801386a:	6078      	str	r0, [r7, #4]
 801386c:	4a04      	ldr	r2, [pc, #16]	; (8013880 <_ZN4UartD1Ev+0x1c>)
 801386e:	687b      	ldr	r3, [r7, #4]
 8013870:	601a      	str	r2, [r3, #0]
{

}
 8013872:	687b      	ldr	r3, [r7, #4]
 8013874:	4618      	mov	r0, r3
 8013876:	370c      	adds	r7, #12
 8013878:	46bd      	mov	sp, r7
 801387a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801387e:	4770      	bx	lr
 8013880:	0801dc18 	.word	0x0801dc18

08013884 <_ZN4UartD0Ev>:
Uart::~Uart()
 8013884:	b580      	push	{r7, lr}
 8013886:	b082      	sub	sp, #8
 8013888:	af00      	add	r7, sp, #0
 801388a:	6078      	str	r0, [r7, #4]
}
 801388c:	6878      	ldr	r0, [r7, #4]
 801388e:	f7ff ffe9 	bl	8013864 <_ZN4UartD1Ev>
 8013892:	2190      	movs	r1, #144	; 0x90
 8013894:	6878      	ldr	r0, [r7, #4]
 8013896:	f002 fc89 	bl	80161ac <_ZdlPvj>
 801389a:	687b      	ldr	r3, [r7, #4]
 801389c:	4618      	mov	r0, r3
 801389e:	3708      	adds	r7, #8
 80138a0:	46bd      	mov	sp, r7
 80138a2:	bd80      	pop	{r7, pc}

080138a4 <_ZN4Uart10initializeEv>:

bool Uart::initialize()
{
 80138a4:	b480      	push	{r7}
 80138a6:	b083      	sub	sp, #12
 80138a8:	af00      	add	r7, sp, #0
 80138aa:	6078      	str	r0, [r7, #4]
	return true;
 80138ac:	2301      	movs	r3, #1
}
 80138ae:	4618      	mov	r0, r3
 80138b0:	370c      	adds	r7, #12
 80138b2:	46bd      	mov	sp, r7
 80138b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80138b8:	4770      	bx	lr

080138ba <_ZN4Uart5writeEPKcj>:
    __HAL_UART_DISABLE(_pUartHandle);
    return true;
}

void Uart::write(const char * str, unsigned int length /* = 0 */)
{
 80138ba:	b580      	push	{r7, lr}
 80138bc:	b084      	sub	sp, #16
 80138be:	af00      	add	r7, sp, #0
 80138c0:	60f8      	str	r0, [r7, #12]
 80138c2:	60b9      	str	r1, [r7, #8]
 80138c4:	607a      	str	r2, [r7, #4]
	if (!length)
 80138c6:	687b      	ldr	r3, [r7, #4]
 80138c8:	2b00      	cmp	r3, #0
 80138ca:	d103      	bne.n	80138d4 <_ZN4Uart5writeEPKcj+0x1a>
	{
		length = strlen(str);
 80138cc:	68b8      	ldr	r0, [r7, #8]
 80138ce:	f7ec fccf 	bl	8000270 <strlen>
 80138d2:	6078      	str	r0, [r7, #4]
	}

    if (!_bTxDMA)
 80138d4:	68fb      	ldr	r3, [r7, #12]
 80138d6:	7b1b      	ldrb	r3, [r3, #12]
 80138d8:	f083 0301 	eor.w	r3, r3, #1
 80138dc:	b2db      	uxtb	r3, r3
 80138de:	2b00      	cmp	r3, #0
 80138e0:	d008      	beq.n	80138f4 <_ZN4Uart5writeEPKcj+0x3a>
    {   // Transmit without DMA
        // Send next character
        HAL_UART_Transmit(_pUartHandle, (uint8_t *)str, length, 50);
 80138e2:	68fb      	ldr	r3, [r7, #12]
 80138e4:	6898      	ldr	r0, [r3, #8]
 80138e6:	687b      	ldr	r3, [r7, #4]
 80138e8:	b29a      	uxth	r2, r3
 80138ea:	2332      	movs	r3, #50	; 0x32
 80138ec:	68b9      	ldr	r1, [r7, #8]
 80138ee:	f7f2 fa4d 	bl	8005d8c <HAL_UART_Transmit>
    }
    else
    {   // TX DMA enabled
        writeUsingDMA((const uint8_t *)str, length);
    }
}
 80138f2:	e004      	b.n	80138fe <_ZN4Uart5writeEPKcj+0x44>
        writeUsingDMA((const uint8_t *)str, length);
 80138f4:	687a      	ldr	r2, [r7, #4]
 80138f6:	68b9      	ldr	r1, [r7, #8]
 80138f8:	68f8      	ldr	r0, [r7, #12]
 80138fa:	f000 f805 	bl	8013908 <_ZN4Uart13writeUsingDMAEPKhm>
}
 80138fe:	bf00      	nop
 8013900:	3710      	adds	r7, #16
 8013902:	46bd      	mov	sp, r7
 8013904:	bd80      	pop	{r7, pc}
	...

08013908 <_ZN4Uart13writeUsingDMAEPKhm>:

void Uart::writeUsingDMA(const uint8_t * str, uint32_t length)
{
 8013908:	b580      	push	{r7, lr}
 801390a:	b084      	sub	sp, #16
 801390c:	af00      	add	r7, sp, #0
 801390e:	60f8      	str	r0, [r7, #12]
 8013910:	60b9      	str	r1, [r7, #8]
 8013912:	607a      	str	r2, [r7, #4]
    assert(length <= sizeof(_pTxDmaBuffer));
 8013914:	687b      	ldr	r3, [r7, #4]
 8013916:	2b80      	cmp	r3, #128	; 0x80
 8013918:	d905      	bls.n	8013926 <_ZN4Uart13writeUsingDMAEPKhm+0x1e>
 801391a:	4b13      	ldr	r3, [pc, #76]	; (8013968 <_ZN4Uart13writeUsingDMAEPKhm+0x60>)
 801391c:	4a13      	ldr	r2, [pc, #76]	; (801396c <_ZN4Uart13writeUsingDMAEPKhm+0x64>)
 801391e:	2150      	movs	r1, #80	; 0x50
 8013920:	4813      	ldr	r0, [pc, #76]	; (8013970 <_ZN4Uart13writeUsingDMAEPKhm+0x68>)
 8013922:	f002 fd37 	bl	8016394 <__assert_func>

    // Copy data to TX DMA buffer
    ::memcpy(_pTxDmaBuffer, str, length);
 8013926:	68fb      	ldr	r3, [r7, #12]
 8013928:	330d      	adds	r3, #13
 801392a:	687a      	ldr	r2, [r7, #4]
 801392c:	68b9      	ldr	r1, [r7, #8]
 801392e:	4618      	mov	r0, r3
 8013930:	f002 fda0 	bl	8016474 <memcpy>

    // Check that a Tx process is not already ongoing
    // (should never happen, but who knows!)
    while (_pUartHandle->gState != HAL_UART_STATE_READY)
 8013934:	68fb      	ldr	r3, [r7, #12]
 8013936:	689b      	ldr	r3, [r3, #8]
 8013938:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801393a:	2b20      	cmp	r3, #32
 801393c:	bf14      	ite	ne
 801393e:	2301      	movne	r3, #1
 8013940:	2300      	moveq	r3, #0
 8013942:	b2db      	uxtb	r3, r3
 8013944:	2b00      	cmp	r3, #0
 8013946:	d001      	beq.n	801394c <_ZN4Uart13writeUsingDMAEPKhm+0x44>
    { continue; }
 8013948:	bf00      	nop
    while (_pUartHandle->gState != HAL_UART_STATE_READY)
 801394a:	e7f3      	b.n	8013934 <_ZN4Uart13writeUsingDMAEPKhm+0x2c>

    // Give data to TX DMA
    HAL_UART_Transmit_DMA(_pUartHandle, _pTxDmaBuffer, length);
 801394c:	68fb      	ldr	r3, [r7, #12]
 801394e:	6898      	ldr	r0, [r3, #8]
 8013950:	68fb      	ldr	r3, [r7, #12]
 8013952:	330d      	adds	r3, #13
 8013954:	687a      	ldr	r2, [r7, #4]
 8013956:	b292      	uxth	r2, r2
 8013958:	4619      	mov	r1, r3
 801395a:	f7f2 faab 	bl	8005eb4 <HAL_UART_Transmit_DMA>
}
 801395e:	bf00      	nop
 8013960:	3710      	adds	r7, #16
 8013962:	46bd      	mov	sp, r7
 8013964:	bd80      	pop	{r7, pc}
 8013966:	bf00      	nop
 8013968:	0801b3b8 	.word	0x0801b3b8
 801396c:	0801b3d8 	.word	0x0801b3d8
 8013970:	0801b328 	.word	0x0801b328

08013974 <_ZN10LedFlasher13ledControllerEv>:
	} eMainState;

	eMainState _newState;		///< Attribute indicating currently active state

protected:
    board::LedController & ledController() { return _ledController; }
 8013974:	b480      	push	{r7}
 8013976:	b083      	sub	sp, #12
 8013978:	af00      	add	r7, sp, #0
 801397a:	6078      	str	r0, [r7, #4]
 801397c:	687b      	ldr	r3, [r7, #4]
 801397e:	691b      	ldr	r3, [r3, #16]
 8013980:	4618      	mov	r0, r3
 8013982:	370c      	adds	r7, #12
 8013984:	46bd      	mov	sp, r7
 8013986:	f85d 7b04 	ldr.w	r7, [sp], #4
 801398a:	4770      	bx	lr

0801398c <_ZN10LedFlasherC1EtRN5board13LedControllerE>:
#include "xf/xfevent.h"
#include "board/ledcontroller.h"
#include "ledflasher.h"

LedFlasher::LedFlasher(uint16_t ledIndex, board::LedController & ledController)
 801398c:	b580      	push	{r7, lr}
 801398e:	b084      	sub	sp, #16
 8013990:	af00      	add	r7, sp, #0
 8013992:	60f8      	str	r0, [r7, #12]
 8013994:	460b      	mov	r3, r1
 8013996:	607a      	str	r2, [r7, #4]
 8013998:	817b      	strh	r3, [r7, #10]
 : _newState(STATE_UNKOWN),
   _ledIndex(ledIndex),
   _ledController(ledController),
   _flashTimeInMilliseconds(100)
 801399a:	68fb      	ldr	r3, [r7, #12]
 801399c:	2100      	movs	r1, #0
 801399e:	4618      	mov	r0, r3
 80139a0:	f000 fbc0 	bl	8014124 <_ZN10XFReactiveC1EP8XFThread>
 80139a4:	4a09      	ldr	r2, [pc, #36]	; (80139cc <_ZN10LedFlasherC1EtRN5board13LedControllerE+0x40>)
 80139a6:	68fb      	ldr	r3, [r7, #12]
 80139a8:	601a      	str	r2, [r3, #0]
 80139aa:	68fb      	ldr	r3, [r7, #12]
 80139ac:	2200      	movs	r2, #0
 80139ae:	731a      	strb	r2, [r3, #12]
 80139b0:	68fb      	ldr	r3, [r7, #12]
 80139b2:	897a      	ldrh	r2, [r7, #10]
 80139b4:	81da      	strh	r2, [r3, #14]
 80139b6:	68fb      	ldr	r3, [r7, #12]
 80139b8:	687a      	ldr	r2, [r7, #4]
 80139ba:	611a      	str	r2, [r3, #16]
 80139bc:	68fb      	ldr	r3, [r7, #12]
 80139be:	2264      	movs	r2, #100	; 0x64
 80139c0:	615a      	str	r2, [r3, #20]
{
}
 80139c2:	68fb      	ldr	r3, [r7, #12]
 80139c4:	4618      	mov	r0, r3
 80139c6:	3710      	adds	r7, #16
 80139c8:	46bd      	mov	sp, r7
 80139ca:	bd80      	pop	{r7, pc}
 80139cc:	0801dc28 	.word	0x0801dc28

080139d0 <_ZN10LedFlasher5startEv>:
{
	_flashTimeInMilliseconds = flashTimeInMilliseconds;
}

void LedFlasher::start()
{
 80139d0:	b580      	push	{r7, lr}
 80139d2:	b082      	sub	sp, #8
 80139d4:	af00      	add	r7, sp, #0
 80139d6:	6078      	str	r0, [r7, #4]
	XFReactive::startBehavior();
 80139d8:	687b      	ldr	r3, [r7, #4]
 80139da:	4618      	mov	r0, r3
 80139dc:	f000 fbe6 	bl	80141ac <_ZN10XFReactive13startBehaviorEv>
}
 80139e0:	bf00      	nop
 80139e2:	3708      	adds	r7, #8
 80139e4:	46bd      	mov	sp, r7
 80139e6:	bd80      	pop	{r7, pc}

080139e8 <_ZN10LedFlasher8flashLedEv>:

void LedFlasher::flashLed()
{
 80139e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80139ea:	b083      	sub	sp, #12
 80139ec:	af00      	add	r7, sp, #0
 80139ee:	6078      	str	r0, [r7, #4]
	GEN(XFEvent(EV_LED_FLASH_id));
 80139f0:	687d      	ldr	r5, [r7, #4]
 80139f2:	687b      	ldr	r3, [r7, #4]
 80139f4:	681b      	ldr	r3, [r3, #0]
 80139f6:	330c      	adds	r3, #12
 80139f8:	681c      	ldr	r4, [r3, #0]
 80139fa:	2014      	movs	r0, #20
 80139fc:	f002 fbe9 	bl	80161d2 <_Znwj>
 8013a00:	4603      	mov	r3, r0
 8013a02:	461e      	mov	r6, r3
 8013a04:	2200      	movs	r2, #0
 8013a06:	2101      	movs	r1, #1
 8013a08:	4630      	mov	r0, r6
 8013a0a:	f000 fadb 	bl	8013fc4 <_ZN7XFEventC1EiP11IXFReactive>
 8013a0e:	4631      	mov	r1, r6
 8013a10:	4628      	mov	r0, r5
 8013a12:	47a0      	blx	r4
}
 8013a14:	bf00      	nop
 8013a16:	370c      	adds	r7, #12
 8013a18:	46bd      	mov	sp, r7
 8013a1a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08013a1c <_ZN10LedFlasher12processEventEv>:

EventStatus LedFlasher::processEvent()
{
 8013a1c:	b580      	push	{r7, lr}
 8013a1e:	b084      	sub	sp, #16
 8013a20:	af00      	add	r7, sp, #0
 8013a22:	6078      	str	r0, [r7, #4]
	const eMainState lastState = _newState;
 8013a24:	687b      	ldr	r3, [r7, #4]
 8013a26:	7b1b      	ldrb	r3, [r3, #12]
 8013a28:	73fb      	strb	r3, [r7, #15]

	// Action on transition switch
	switch (lastState)
 8013a2a:	7bfb      	ldrb	r3, [r7, #15]
 8013a2c:	2b03      	cmp	r3, #3
 8013a2e:	d03c      	beq.n	8013aaa <_ZN10LedFlasher12processEventEv+0x8e>
 8013a30:	2b03      	cmp	r3, #3
 8013a32:	dc5e      	bgt.n	8013af2 <_ZN10LedFlasher12processEventEv+0xd6>
 8013a34:	2b01      	cmp	r3, #1
 8013a36:	dc02      	bgt.n	8013a3e <_ZN10LedFlasher12processEventEv+0x22>
 8013a38:	2b00      	cmp	r3, #0
 8013a3a:	da03      	bge.n	8013a44 <_ZN10LedFlasher12processEventEv+0x28>
 8013a3c:	e059      	b.n	8013af2 <_ZN10LedFlasher12processEventEv+0xd6>
 8013a3e:	2b02      	cmp	r3, #2
 8013a40:	d014      	beq.n	8013a6c <_ZN10LedFlasher12processEventEv+0x50>
 8013a42:	e056      	b.n	8013af2 <_ZN10LedFlasher12processEventEv+0xd6>
	{
	case STATE_UNKOWN:
	case STATE_INITIAL:
		if (getCurrentEvent()->getEventType() == IXFEvent::Initial)
 8013a44:	687b      	ldr	r3, [r7, #4]
 8013a46:	4618      	mov	r0, r3
 8013a48:	f000 fc4a 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8013a4c:	4603      	mov	r3, r0
 8013a4e:	4618      	mov	r0, r3
 8013a50:	f7f2 ffa7 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 8013a54:	4603      	mov	r3, r0
 8013a56:	2b01      	cmp	r3, #1
 8013a58:	bf0c      	ite	eq
 8013a5a:	2301      	moveq	r3, #1
 8013a5c:	2300      	movne	r3, #0
 8013a5e:	b2db      	uxtb	r3, r3
 8013a60:	2b00      	cmp	r3, #0
 8013a62:	d041      	beq.n	8013ae8 <_ZN10LedFlasher12processEventEv+0xcc>
		{
			_newState = STATE_WAIT_FLASH;
 8013a64:	687b      	ldr	r3, [r7, #4]
 8013a66:	2202      	movs	r2, #2
 8013a68:	731a      	strb	r2, [r3, #12]
		}
		break;
 8013a6a:	e03d      	b.n	8013ae8 <_ZN10LedFlasher12processEventEv+0xcc>
	case STATE_WAIT_FLASH:
		if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 8013a6c:	687b      	ldr	r3, [r7, #4]
 8013a6e:	4618      	mov	r0, r3
 8013a70:	f000 fc36 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8013a74:	4603      	mov	r3, r0
 8013a76:	4618      	mov	r0, r3
 8013a78:	f7f2 ff93 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 8013a7c:	4603      	mov	r3, r0
 8013a7e:	2b03      	cmp	r3, #3
 8013a80:	d10c      	bne.n	8013a9c <_ZN10LedFlasher12processEventEv+0x80>
			getCurrentEvent()->getId() == EV_LED_FLASH_id)
 8013a82:	687b      	ldr	r3, [r7, #4]
 8013a84:	4618      	mov	r0, r3
 8013a86:	f000 fc2b 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8013a8a:	4603      	mov	r3, r0
 8013a8c:	4618      	mov	r0, r3
 8013a8e:	f7f2 ff95 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 8013a92:	4603      	mov	r3, r0
		if (getCurrentEvent()->getEventType() == IXFEvent::Event &&
 8013a94:	2b01      	cmp	r3, #1
 8013a96:	d101      	bne.n	8013a9c <_ZN10LedFlasher12processEventEv+0x80>
 8013a98:	2301      	movs	r3, #1
 8013a9a:	e000      	b.n	8013a9e <_ZN10LedFlasher12processEventEv+0x82>
 8013a9c:	2300      	movs	r3, #0
 8013a9e:	2b00      	cmp	r3, #0
 8013aa0:	d024      	beq.n	8013aec <_ZN10LedFlasher12processEventEv+0xd0>
		{
			_newState = STATE_LED_FLASH;
 8013aa2:	687b      	ldr	r3, [r7, #4]
 8013aa4:	2203      	movs	r2, #3
 8013aa6:	731a      	strb	r2, [r3, #12]
		}
		break;
 8013aa8:	e020      	b.n	8013aec <_ZN10LedFlasher12processEventEv+0xd0>
	case STATE_LED_FLASH:
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 8013aaa:	687b      	ldr	r3, [r7, #4]
 8013aac:	4618      	mov	r0, r3
 8013aae:	f000 fc17 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8013ab2:	4603      	mov	r3, r0
 8013ab4:	4618      	mov	r0, r3
 8013ab6:	f7f2 ff74 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 8013aba:	4603      	mov	r3, r0
 8013abc:	2b04      	cmp	r3, #4
 8013abe:	d10c      	bne.n	8013ada <_ZN10LedFlasher12processEventEv+0xbe>
			getCurrentTimeout()->getId() == TM_LED_FLASH_id)
 8013ac0:	687b      	ldr	r3, [r7, #4]
 8013ac2:	4618      	mov	r0, r3
 8013ac4:	f000 fc26 	bl	8014314 <_ZN10XFReactive17getCurrentTimeoutEv>
 8013ac8:	4603      	mov	r3, r0
 8013aca:	4618      	mov	r0, r3
 8013acc:	f7f2 ff76 	bl	80069bc <_ZNK8IXFEvent5getIdEv>
 8013ad0:	4603      	mov	r3, r0
		if (getCurrentEvent()->getEventType() == IXFEvent::Timeout &&
 8013ad2:	2b01      	cmp	r3, #1
 8013ad4:	d101      	bne.n	8013ada <_ZN10LedFlasher12processEventEv+0xbe>
 8013ad6:	2301      	movs	r3, #1
 8013ad8:	e000      	b.n	8013adc <_ZN10LedFlasher12processEventEv+0xc0>
 8013ada:	2300      	movs	r3, #0
 8013adc:	2b00      	cmp	r3, #0
 8013ade:	d007      	beq.n	8013af0 <_ZN10LedFlasher12processEventEv+0xd4>
		{
			_newState = STATE_WAIT_FLASH;
 8013ae0:	687b      	ldr	r3, [r7, #4]
 8013ae2:	2202      	movs	r2, #2
 8013ae4:	731a      	strb	r2, [r3, #12]
		}
		break;
 8013ae6:	e003      	b.n	8013af0 <_ZN10LedFlasher12processEventEv+0xd4>
		break;
 8013ae8:	bf00      	nop
 8013aea:	e002      	b.n	8013af2 <_ZN10LedFlasher12processEventEv+0xd6>
		break;
 8013aec:	bf00      	nop
 8013aee:	e000      	b.n	8013af2 <_ZN10LedFlasher12processEventEv+0xd6>
		break;
 8013af0:	bf00      	nop
	}

	if (lastState != _newState)
 8013af2:	687b      	ldr	r3, [r7, #4]
 8013af4:	7b1b      	ldrb	r3, [r3, #12]
 8013af6:	7bfa      	ldrb	r2, [r7, #15]
 8013af8:	429a      	cmp	r2, r3
 8013afa:	d028      	beq.n	8013b4e <_ZN10LedFlasher12processEventEv+0x132>
	{
		// Action on entry switch
		switch (_newState)
 8013afc:	687b      	ldr	r3, [r7, #4]
 8013afe:	7b1b      	ldrb	r3, [r3, #12]
 8013b00:	2b02      	cmp	r3, #2
 8013b02:	d002      	beq.n	8013b0a <_ZN10LedFlasher12processEventEv+0xee>
 8013b04:	2b03      	cmp	r3, #3
 8013b06:	d00a      	beq.n	8013b1e <_ZN10LedFlasher12processEventEv+0x102>

				ledController().setLed(_ledIndex, true);
			}
			break;
		default:
			break;
 8013b08:	e021      	b.n	8013b4e <_ZN10LedFlasher12processEventEv+0x132>
				ledController().setLed(_ledIndex, false);
 8013b0a:	6878      	ldr	r0, [r7, #4]
 8013b0c:	f7ff ff32 	bl	8013974 <_ZN10LedFlasher13ledControllerEv>
 8013b10:	687b      	ldr	r3, [r7, #4]
 8013b12:	89db      	ldrh	r3, [r3, #14]
 8013b14:	2200      	movs	r2, #0
 8013b16:	4619      	mov	r1, r3
 8013b18:	f7fb fcb6 	bl	800f488 <_ZN5board13LedController6setLedEib>
			break;
 8013b1c:	e017      	b.n	8013b4e <_ZN10LedFlasher12processEventEv+0x132>
				getThread()->scheduleTimeout(TM_LED_FLASH_id, _flashTimeInMilliseconds, this);
 8013b1e:	687a      	ldr	r2, [r7, #4]
 8013b20:	687b      	ldr	r3, [r7, #4]
 8013b22:	681b      	ldr	r3, [r3, #0]
 8013b24:	3318      	adds	r3, #24
 8013b26:	681b      	ldr	r3, [r3, #0]
 8013b28:	4610      	mov	r0, r2
 8013b2a:	4798      	blx	r3
 8013b2c:	687b      	ldr	r3, [r7, #4]
 8013b2e:	695b      	ldr	r3, [r3, #20]
 8013b30:	461a      	mov	r2, r3
 8013b32:	687b      	ldr	r3, [r7, #4]
 8013b34:	2101      	movs	r1, #1
 8013b36:	f000 fd8e 	bl	8014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>
				ledController().setLed(_ledIndex, true);
 8013b3a:	6878      	ldr	r0, [r7, #4]
 8013b3c:	f7ff ff1a 	bl	8013974 <_ZN10LedFlasher13ledControllerEv>
 8013b40:	687b      	ldr	r3, [r7, #4]
 8013b42:	89db      	ldrh	r3, [r3, #14]
 8013b44:	2201      	movs	r2, #1
 8013b46:	4619      	mov	r1, r3
 8013b48:	f7fb fc9e 	bl	800f488 <_ZN5board13LedController6setLedEib>
			break;
 8013b4c:	bf00      	nop
		}
	}

	return EventStatus::Consumed;	// We consume all given events/timeouts
 8013b4e:	f107 030c 	add.w	r3, r7, #12
 8013b52:	2101      	movs	r1, #1
 8013b54:	4618      	mov	r0, r3
 8013b56:	f7f2 ff3d 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 8013b5a:	7b3b      	ldrb	r3, [r7, #12]
}
 8013b5c:	4618      	mov	r0, r3
 8013b5e:	3710      	adds	r7, #16
 8013b60:	46bd      	mov	sp, r7
 8013b62:	bd80      	pop	{r7, pc}

08013b64 <_ZN5board14NrfTransceiver8instanceEv>:

	static void traceOut(const char * const format, ...);

	inline static NrfTransceiver & instance() { assert(_pInstance); return *_pInstance; }
 8013b64:	b580      	push	{r7, lr}
 8013b66:	af00      	add	r7, sp, #0
 8013b68:	4b06      	ldr	r3, [pc, #24]	; (8013b84 <_ZN5board14NrfTransceiver8instanceEv+0x20>)
 8013b6a:	681b      	ldr	r3, [r3, #0]
 8013b6c:	2b00      	cmp	r3, #0
 8013b6e:	d105      	bne.n	8013b7c <_ZN5board14NrfTransceiver8instanceEv+0x18>
 8013b70:	4b05      	ldr	r3, [pc, #20]	; (8013b88 <_ZN5board14NrfTransceiver8instanceEv+0x24>)
 8013b72:	4a06      	ldr	r2, [pc, #24]	; (8013b8c <_ZN5board14NrfTransceiver8instanceEv+0x28>)
 8013b74:	2157      	movs	r1, #87	; 0x57
 8013b76:	4806      	ldr	r0, [pc, #24]	; (8013b90 <_ZN5board14NrfTransceiver8instanceEv+0x2c>)
 8013b78:	f002 fc0c 	bl	8016394 <__assert_func>
 8013b7c:	4b01      	ldr	r3, [pc, #4]	; (8013b84 <_ZN5board14NrfTransceiver8instanceEv+0x20>)
 8013b7e:	681b      	ldr	r3, [r3, #0]
 8013b80:	4618      	mov	r0, r3
 8013b82:	bd80      	pop	{r7, pc}
 8013b84:	20001c14 	.word	0x20001c14
 8013b88:	0801b40c 	.word	0x0801b40c
 8013b8c:	0801b418 	.word	0x0801b418
 8013b90:	0801b458 	.word	0x0801b458

08013b94 <HAL_GPIO_EXTI_Callback>:
#include "board/joystick.h"
#include "board/accel/accelerometer.h"
#include "desenet/timeslotmanager.h"

extern "C" void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8013b94:	b580      	push	{r7, lr}
 8013b96:	b082      	sub	sp, #8
 8013b98:	af00      	add	r7, sp, #0
 8013b9a:	4603      	mov	r3, r0
 8013b9c:	80fb      	strh	r3, [r7, #6]
    switch (GPIO_Pin)
 8013b9e:	88fb      	ldrh	r3, [r7, #6]
 8013ba0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013ba4:	d061      	beq.n	8013c6a <HAL_GPIO_EXTI_Callback+0xd6>
 8013ba6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013baa:	dc6c      	bgt.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
 8013bac:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013bb0:	d05b      	beq.n	8013c6a <HAL_GPIO_EXTI_Callback+0xd6>
 8013bb2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013bb6:	dc66      	bgt.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
 8013bb8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8013bbc:	d055      	beq.n	8013c6a <HAL_GPIO_EXTI_Callback+0xd6>
 8013bbe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8013bc2:	dc60      	bgt.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
 8013bc4:	2b20      	cmp	r3, #32
 8013bc6:	dc47      	bgt.n	8013c58 <HAL_GPIO_EXTI_Callback+0xc4>
 8013bc8:	2b00      	cmp	r3, #0
 8013bca:	dd5c      	ble.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
 8013bcc:	3b01      	subs	r3, #1
 8013bce:	2b1f      	cmp	r3, #31
 8013bd0:	d859      	bhi.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
 8013bd2:	a201      	add	r2, pc, #4	; (adr r2, 8013bd8 <HAL_GPIO_EXTI_Callback+0x44>)
 8013bd4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013bd8:	08013c7d 	.word	0x08013c7d
 8013bdc:	08013c87 	.word	0x08013c87
 8013be0:	08013c87 	.word	0x08013c87
 8013be4:	08013c87 	.word	0x08013c87
 8013be8:	08013c87 	.word	0x08013c87
 8013bec:	08013c87 	.word	0x08013c87
 8013bf0:	08013c87 	.word	0x08013c87
 8013bf4:	08013c7d 	.word	0x08013c7d
 8013bf8:	08013c87 	.word	0x08013c87
 8013bfc:	08013c87 	.word	0x08013c87
 8013c00:	08013c87 	.word	0x08013c87
 8013c04:	08013c87 	.word	0x08013c87
 8013c08:	08013c87 	.word	0x08013c87
 8013c0c:	08013c87 	.word	0x08013c87
 8013c10:	08013c87 	.word	0x08013c87
 8013c14:	08013c6b 	.word	0x08013c6b
 8013c18:	08013c87 	.word	0x08013c87
 8013c1c:	08013c87 	.word	0x08013c87
 8013c20:	08013c87 	.word	0x08013c87
 8013c24:	08013c87 	.word	0x08013c87
 8013c28:	08013c87 	.word	0x08013c87
 8013c2c:	08013c87 	.word	0x08013c87
 8013c30:	08013c87 	.word	0x08013c87
 8013c34:	08013c87 	.word	0x08013c87
 8013c38:	08013c87 	.word	0x08013c87
 8013c3c:	08013c87 	.word	0x08013c87
 8013c40:	08013c87 	.word	0x08013c87
 8013c44:	08013c87 	.word	0x08013c87
 8013c48:	08013c87 	.word	0x08013c87
 8013c4c:	08013c87 	.word	0x08013c87
 8013c50:	08013c87 	.word	0x08013c87
 8013c54:	08013c6b 	.word	0x08013c6b
 8013c58:	2b80      	cmp	r3, #128	; 0x80
 8013c5a:	d114      	bne.n	8013c86 <HAL_GPIO_EXTI_Callback+0xf2>
    {
    case NRF_IRQ_Pin:   // nRF24L01 IRQ
#if (EXCLUDE_BOARD_NRFTRANSCEIVER == 0)
        // Call transceivers interrupt reception method
        board::NrfTransceiver::instance().onIrq();
 8013c5c:	f7ff ff82 	bl	8013b64 <_ZN5board14NrfTransceiver8instanceEv>
 8013c60:	4603      	mov	r3, r0
 8013c62:	4618      	mov	r0, r3
 8013c64:	f7fd ffba 	bl	8011bdc <_ZN5board14NrfTransceiver5onIrqEv>
#endif
        break;
 8013c68:	e00e      	b.n	8013c88 <HAL_GPIO_EXTI_Callback+0xf4>
    case NAVS_LEFT_Pin:
        //no break;
    case NAVS_RIGHT_Pin:
        //no break;
    case NAVS_CENTER_Pin:
        board::Joystick::instance().onIrq(GPIO_Pin);
 8013c6a:	f7fb f867 	bl	800ed3c <_ZN5board8Joystick8instanceEv>
 8013c6e:	4602      	mov	r2, r0
 8013c70:	88fb      	ldrh	r3, [r7, #6]
 8013c72:	4619      	mov	r1, r3
 8013c74:	4610      	mov	r0, r2
 8013c76:	f7fb fa81 	bl	800f17c <_ZN5board8Joystick5onIrqEt>
        break;
 8013c7a:	e005      	b.n	8013c88 <HAL_GPIO_EXTI_Callback+0xf4>
    case ACCEL_IRQ1_Pin:
        //no break;
    case ACCEL_IRQ2_Pin:
        board::Accelerometer::onIrq(GPIO_Pin);
 8013c7c:	88fb      	ldrh	r3, [r7, #6]
 8013c7e:	4618      	mov	r0, r3
 8013c80:	f7fa fe57 	bl	800e932 <_ZN5board13Accelerometer5onIrqEt>
        break;
 8013c84:	e000      	b.n	8013c88 <HAL_GPIO_EXTI_Callback+0xf4>
    default:
        break;
 8013c86:	bf00      	nop
    }
}
 8013c88:	bf00      	nop
 8013c8a:	3708      	adds	r7, #8
 8013c8c:	46bd      	mov	sp, r7
 8013c8e:	bd80      	pop	{r7, pc}

08013c90 <HAL_TIM_OC_DelayElapsedCallback>:

extern "C" void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef * htim)
{
 8013c90:	b580      	push	{r7, lr}
 8013c92:	b082      	sub	sp, #8
 8013c94:	af00      	add	r7, sp, #0
 8013c96:	6078      	str	r0, [r7, #4]
    if (htim->Instance == TIM2)
 8013c98:	687b      	ldr	r3, [r7, #4]
 8013c9a:	681b      	ldr	r3, [r3, #0]
 8013c9c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8013ca0:	d101      	bne.n	8013ca6 <HAL_TIM_OC_DelayElapsedCallback+0x16>
    {
        TimeSlotManager::onIrq();
 8013ca2:	f7ff f99f 	bl	8012fe4 <_ZN7desenet15TimeSlotManager5onIrqEv>
    }
}
 8013ca6:	bf00      	nop
 8013ca8:	3708      	adds	r7, #8
 8013caa:	46bd      	mov	sp, r7
 8013cac:	bd80      	pop	{r7, pc}
	...

08013cb0 <_Z41__static_initialization_and_destruction_0ii>:
 8013cb0:	b580      	push	{r7, lr}
 8013cb2:	b088      	sub	sp, #32
 8013cb4:	af00      	add	r7, sp, #0
 8013cb6:	6078      	str	r0, [r7, #4]
 8013cb8:	6039      	str	r1, [r7, #0]
 8013cba:	687b      	ldr	r3, [r7, #4]
 8013cbc:	2b01      	cmp	r3, #1
 8013cbe:	d122      	bne.n	8013d06 <_Z41__static_initialization_and_destruction_0ii+0x56>
 8013cc0:	683b      	ldr	r3, [r7, #0]
 8013cc2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013cc6:	4293      	cmp	r3, r2
 8013cc8:	d11d      	bne.n	8013d06 <_Z41__static_initialization_and_destruction_0ii+0x56>
#define NRFTRANSCEIVER_TRACE_VERBOSE 	1

#define DESNET_NODE_NAME				"SENSOR"

#ifdef __cplusplus
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8013cca:	4b18      	ldr	r3, [pc, #96]	; (8013d2c <_Z41__static_initialization_and_destruction_0ii+0x7c>)
 8013ccc:	681b      	ldr	r3, [r3, #0]
 8013cce:	613b      	str	r3, [r7, #16]
 8013cd0:	f107 0310 	add.w	r3, r7, #16
 8013cd4:	60bb      	str	r3, [r7, #8]
 8013cd6:	2304      	movs	r3, #4
 8013cd8:	60fb      	str	r3, [r7, #12]
 8013cda:	f107 0308 	add.w	r3, r7, #8
 8013cde:	e893 0006 	ldmia.w	r3, {r1, r2}
 8013ce2:	4813      	ldr	r0, [pc, #76]	; (8013d30 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8013ce4:	f7f3 f826 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
  static const desenet::Address SENSOR_ADDRESS({0xC7, 0xC7, 0xC7, 0xC7});	///< @brief Sensor's reception address.
 8013ce8:	4b12      	ldr	r3, [pc, #72]	; (8013d34 <_Z41__static_initialization_and_destruction_0ii+0x84>)
 8013cea:	681b      	ldr	r3, [r3, #0]
 8013cec:	61fb      	str	r3, [r7, #28]
 8013cee:	f107 031c 	add.w	r3, r7, #28
 8013cf2:	617b      	str	r3, [r7, #20]
 8013cf4:	2304      	movs	r3, #4
 8013cf6:	61bb      	str	r3, [r7, #24]
 8013cf8:	f107 0314 	add.w	r3, r7, #20
 8013cfc:	e893 0006 	ldmia.w	r3, {r1, r2}
 8013d00:	480d      	ldr	r0, [pc, #52]	; (8013d38 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8013d02:	f7f3 f817 	bl	8006d34 <_ZN3phy7AddressILj4EEC1ESt16initializer_listIhE>
 8013d06:	687b      	ldr	r3, [r7, #4]
 8013d08:	2b00      	cmp	r3, #0
 8013d0a:	d10a      	bne.n	8013d22 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8013d0c:	683b      	ldr	r3, [r7, #0]
 8013d0e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013d12:	4293      	cmp	r3, r2
 8013d14:	d105      	bne.n	8013d22 <_Z41__static_initialization_and_destruction_0ii+0x72>
 8013d16:	4808      	ldr	r0, [pc, #32]	; (8013d38 <_Z41__static_initialization_and_destruction_0ii+0x88>)
 8013d18:	f7f3 f956 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
  static const desenet::Address GATEWAY_ADDRESS({0xE2, 0xE2, 0xE2, 0xE2});	///< @brief Gateway's reception address.
 8013d1c:	4804      	ldr	r0, [pc, #16]	; (8013d30 <_Z41__static_initialization_and_destruction_0ii+0x80>)
 8013d1e:	f7f3 f953 	bl	8006fc8 <_ZN3phy7AddressILj4EED1Ev>
 8013d22:	bf00      	nop
 8013d24:	3720      	adds	r7, #32
 8013d26:	46bd      	mov	sp, r7
 8013d28:	bd80      	pop	{r7, pc}
 8013d2a:	bf00      	nop
 8013d2c:	0801b5dc 	.word	0x0801b5dc
 8013d30:	20001e14 	.word	0x20001e14
 8013d34:	0801b5e0 	.word	0x0801b5e0
 8013d38:	20001e1c 	.word	0x20001e1c

08013d3c <_GLOBAL__sub_I_HAL_GPIO_EXTI_Callback>:
 8013d3c:	b580      	push	{r7, lr}
 8013d3e:	af00      	add	r7, sp, #0
 8013d40:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013d44:	2001      	movs	r0, #1
 8013d46:	f7ff ffb3 	bl	8013cb0 <_Z41__static_initialization_and_destruction_0ii>
 8013d4a:	bd80      	pop	{r7, pc}

08013d4c <_GLOBAL__sub_D_HAL_GPIO_EXTI_Callback>:
 8013d4c:	b580      	push	{r7, lr}
 8013d4e:	af00      	add	r7, sp, #0
 8013d50:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013d54:	2000      	movs	r0, #0
 8013d56:	f7ff ffab 	bl	8013cb0 <_Z41__static_initialization_and_destruction_0ii>
 8013d5a:	bd80      	pop	{r7, pc}

08013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>:
    IXFEvent(eEventType eventType, int id, IXFReactive * pBehavior) : _eventType(eventType), _id(id), _pBehavior(pBehavior) { _eventStatus.shouldDelete = true; }
 8013d5c:	b580      	push	{r7, lr}
 8013d5e:	b084      	sub	sp, #16
 8013d60:	af00      	add	r7, sp, #0
 8013d62:	60f8      	str	r0, [r7, #12]
 8013d64:	607a      	str	r2, [r7, #4]
 8013d66:	603b      	str	r3, [r7, #0]
 8013d68:	460b      	mov	r3, r1
 8013d6a:	72fb      	strb	r3, [r7, #11]
 8013d6c:	4a0d      	ldr	r2, [pc, #52]	; (8013da4 <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive+0x48>)
 8013d6e:	68fb      	ldr	r3, [r7, #12]
 8013d70:	601a      	str	r2, [r3, #0]
 8013d72:	68fb      	ldr	r3, [r7, #12]
 8013d74:	7afa      	ldrb	r2, [r7, #11]
 8013d76:	711a      	strb	r2, [r3, #4]
 8013d78:	68fb      	ldr	r3, [r7, #12]
 8013d7a:	687a      	ldr	r2, [r7, #4]
 8013d7c:	609a      	str	r2, [r3, #8]
 8013d7e:	68fb      	ldr	r3, [r7, #12]
 8013d80:	330c      	adds	r3, #12
 8013d82:	4618      	mov	r0, r3
 8013d84:	f000 f830 	bl	8013de8 <_ZN8IXFEvent13_tEventStatusC1Ev>
 8013d88:	68fb      	ldr	r3, [r7, #12]
 8013d8a:	683a      	ldr	r2, [r7, #0]
 8013d8c:	611a      	str	r2, [r3, #16]
 8013d8e:	68fa      	ldr	r2, [r7, #12]
 8013d90:	7b13      	ldrb	r3, [r2, #12]
 8013d92:	f043 0301 	orr.w	r3, r3, #1
 8013d96:	7313      	strb	r3, [r2, #12]
 8013d98:	68fb      	ldr	r3, [r7, #12]
 8013d9a:	4618      	mov	r0, r3
 8013d9c:	3710      	adds	r7, #16
 8013d9e:	46bd      	mov	sp, r7
 8013da0:	bd80      	pop	{r7, pc}
 8013da2:	bf00      	nop
 8013da4:	0801dc5c 	.word	0x0801dc5c

08013da8 <_ZN8IXFEventD1Ev>:
    virtual ~IXFEvent() {}		///< Class destructor
 8013da8:	b480      	push	{r7}
 8013daa:	b083      	sub	sp, #12
 8013dac:	af00      	add	r7, sp, #0
 8013dae:	6078      	str	r0, [r7, #4]
 8013db0:	4a04      	ldr	r2, [pc, #16]	; (8013dc4 <_ZN8IXFEventD1Ev+0x1c>)
 8013db2:	687b      	ldr	r3, [r7, #4]
 8013db4:	601a      	str	r2, [r3, #0]
 8013db6:	687b      	ldr	r3, [r7, #4]
 8013db8:	4618      	mov	r0, r3
 8013dba:	370c      	adds	r7, #12
 8013dbc:	46bd      	mov	sp, r7
 8013dbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013dc2:	4770      	bx	lr
 8013dc4:	0801dc5c 	.word	0x0801dc5c

08013dc8 <_ZN8IXFEventD0Ev>:
 8013dc8:	b580      	push	{r7, lr}
 8013dca:	b082      	sub	sp, #8
 8013dcc:	af00      	add	r7, sp, #0
 8013dce:	6078      	str	r0, [r7, #4]
 8013dd0:	6878      	ldr	r0, [r7, #4]
 8013dd2:	f7ff ffe9 	bl	8013da8 <_ZN8IXFEventD1Ev>
 8013dd6:	2114      	movs	r1, #20
 8013dd8:	6878      	ldr	r0, [r7, #4]
 8013dda:	f002 f9e7 	bl	80161ac <_ZdlPvj>
 8013dde:	687b      	ldr	r3, [r7, #4]
 8013de0:	4618      	mov	r0, r3
 8013de2:	3708      	adds	r7, #8
 8013de4:	46bd      	mov	sp, r7
 8013de6:	bd80      	pop	{r7, pc}

08013de8 <_ZN8IXFEvent13_tEventStatusC1Ev>:
protected:
    typedef struct _tEventStatus
    {
        unsigned char shouldDelete : 1;	///< True in case the event should be deleted after consume.

        _tEventStatus()
 8013de8:	b480      	push	{r7}
 8013dea:	b083      	sub	sp, #12
 8013dec:	af00      	add	r7, sp, #0
 8013dee:	6078      	str	r0, [r7, #4]
        {
            shouldDelete = true;
 8013df0:	687a      	ldr	r2, [r7, #4]
 8013df2:	7813      	ldrb	r3, [r2, #0]
 8013df4:	f043 0301 	orr.w	r3, r3, #1
 8013df8:	7013      	strb	r3, [r2, #0]
        }
 8013dfa:	687b      	ldr	r3, [r7, #4]
 8013dfc:	4618      	mov	r0, r3
 8013dfe:	370c      	adds	r7, #12
 8013e00:	46bd      	mov	sp, r7
 8013e02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e06:	4770      	bx	lr

08013e08 <_ZN12InitialEventC1Ev>:
#include "xf.h"
#include "initialevent.h"

InitialEvent::InitialEvent()
 8013e08:	b580      	push	{r7, lr}
 8013e0a:	b082      	sub	sp, #8
 8013e0c:	af00      	add	r7, sp, #0
 8013e0e:	6078      	str	r0, [r7, #4]
    : IXFEvent(IXFEvent::Initial, 0, NULL)
 8013e10:	6878      	ldr	r0, [r7, #4]
 8013e12:	2300      	movs	r3, #0
 8013e14:	2200      	movs	r2, #0
 8013e16:	2101      	movs	r1, #1
 8013e18:	f7ff ffa0 	bl	8013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>
 8013e1c:	4a03      	ldr	r2, [pc, #12]	; (8013e2c <_ZN12InitialEventC1Ev+0x24>)
 8013e1e:	687b      	ldr	r3, [r7, #4]
 8013e20:	601a      	str	r2, [r3, #0]
{
}
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	4618      	mov	r0, r3
 8013e26:	3708      	adds	r7, #8
 8013e28:	46bd      	mov	sp, r7
 8013e2a:	bd80      	pop	{r7, pc}
 8013e2c:	0801dc4c 	.word	0x0801dc4c

08013e30 <_ZN12InitialEventD1Ev>:

InitialEvent::~InitialEvent()
 8013e30:	b580      	push	{r7, lr}
 8013e32:	b082      	sub	sp, #8
 8013e34:	af00      	add	r7, sp, #0
 8013e36:	6078      	str	r0, [r7, #4]
 8013e38:	4a05      	ldr	r2, [pc, #20]	; (8013e50 <_ZN12InitialEventD1Ev+0x20>)
 8013e3a:	687b      	ldr	r3, [r7, #4]
 8013e3c:	601a      	str	r2, [r3, #0]
 8013e3e:	687b      	ldr	r3, [r7, #4]
 8013e40:	4618      	mov	r0, r3
 8013e42:	f7ff ffb1 	bl	8013da8 <_ZN8IXFEventD1Ev>
{

}
 8013e46:	687b      	ldr	r3, [r7, #4]
 8013e48:	4618      	mov	r0, r3
 8013e4a:	3708      	adds	r7, #8
 8013e4c:	46bd      	mov	sp, r7
 8013e4e:	bd80      	pop	{r7, pc}
 8013e50:	0801dc4c 	.word	0x0801dc4c

08013e54 <_ZN12InitialEventD0Ev>:
InitialEvent::~InitialEvent()
 8013e54:	b580      	push	{r7, lr}
 8013e56:	b082      	sub	sp, #8
 8013e58:	af00      	add	r7, sp, #0
 8013e5a:	6078      	str	r0, [r7, #4]
}
 8013e5c:	6878      	ldr	r0, [r7, #4]
 8013e5e:	f7ff ffe7 	bl	8013e30 <_ZN12InitialEventD1Ev>
 8013e62:	2114      	movs	r1, #20
 8013e64:	6878      	ldr	r0, [r7, #4]
 8013e66:	f002 f9a1 	bl	80161ac <_ZdlPvj>
 8013e6a:	687b      	ldr	r3, [r7, #4]
 8013e6c:	4618      	mov	r0, r3
 8013e6e:	3708      	adds	r7, #8
 8013e70:	46bd      	mov	sp, r7
 8013e72:	bd80      	pop	{r7, pc}

08013e74 <_ZN2XF4initEi>:
/**
 * Initializes the eXecution Framework (XF). Call
 * this method prior to initialize the other objects of the system.
 */
void XF::init(int timeInterval)
{
 8013e74:	b580      	push	{r7, lr}
 8013e76:	b082      	sub	sp, #8
 8013e78:	af00      	add	r7, sp, #0
 8013e7a:	6078      	str	r0, [r7, #4]
    // Create and initialize XFTimeoutManager
    XFTimeoutManager::getInstance()->setTickInterval(timeInterval);
 8013e7c:	f001 fc0a 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 8013e80:	4603      	mov	r3, r0
 8013e82:	6879      	ldr	r1, [r7, #4]
 8013e84:	4618      	mov	r0, r3
 8013e86:	f001 fc1b 	bl	80156c0 <_ZN16XFTimeoutManager15setTickIntervalEi>
    // Start it
    XFTimeoutManager::getInstance()->start();
 8013e8a:	f001 fc03 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 8013e8e:	4603      	mov	r3, r0
 8013e90:	4618      	mov	r0, r3
 8013e92:	f001 fc23 	bl	80156dc <_ZN16XFTimeoutManager5startEv>
}
 8013e96:	bf00      	nop
 8013e98:	3708      	adds	r7, #8
 8013e9a:	46bd      	mov	sp, r7
 8013e9c:	bd80      	pop	{r7, pc}
	...

08013ea0 <_ZN2XF5startEv>:


#if defined(TC_STM32) || defined(TC_STM32CUBEIDE) /*******************************************************************/

void XF::start()
{
 8013ea0:	b580      	push	{r7, lr}
 8013ea2:	af00      	add	r7, sp, #0
    _isRunning = true;     // From here the XF is running
 8013ea4:	4b03      	ldr	r3, [pc, #12]	; (8013eb4 <_ZN2XF5startEv+0x14>)
 8013ea6:	2201      	movs	r2, #1
 8013ea8:	701a      	strb	r2, [r3, #0]

    _mainThread.start();
 8013eaa:	4803      	ldr	r0, [pc, #12]	; (8013eb8 <_ZN2XF5startEv+0x18>)
 8013eac:	f000 fb7a 	bl	80145a4 <_ZN8XFThread5startEv>
}
 8013eb0:	bf00      	nop
 8013eb2:	bd80      	pop	{r7, pc}
 8013eb4:	20001e24 	.word	0x20001e24
 8013eb8:	20001e28 	.word	0x20001e28

08013ebc <_ZN2XF13getMainThreadEv>:

#endif /**************************************************************************************************************/


XFThread * XF::getMainThread()
{
 8013ebc:	b480      	push	{r7}
 8013ebe:	af00      	add	r7, sp, #0
    return &_mainThread;
 8013ec0:	4b02      	ldr	r3, [pc, #8]	; (8013ecc <_ZN2XF13getMainThreadEv+0x10>)
}
 8013ec2:	4618      	mov	r0, r3
 8013ec4:	46bd      	mov	sp, r7
 8013ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013eca:	4770      	bx	lr
 8013ecc:	20001e28 	.word	0x20001e28

08013ed0 <_ZN2XF9isRunningEv>:

bool XF::isRunning()
{
 8013ed0:	b480      	push	{r7}
 8013ed2:	af00      	add	r7, sp, #0
    return _isRunning;
 8013ed4:	4b03      	ldr	r3, [pc, #12]	; (8013ee4 <_ZN2XF9isRunningEv+0x14>)
 8013ed6:	781b      	ldrb	r3, [r3, #0]
}
 8013ed8:	4618      	mov	r0, r3
 8013eda:	46bd      	mov	sp, r7
 8013edc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ee0:	4770      	bx	lr
 8013ee2:	bf00      	nop
 8013ee4:	20001e24 	.word	0x20001e24

08013ee8 <XF_init>:

void XF_init(int timeInterval)
{
 8013ee8:	b580      	push	{r7, lr}
 8013eea:	b082      	sub	sp, #8
 8013eec:	af00      	add	r7, sp, #0
 8013eee:	6078      	str	r0, [r7, #4]
    XF::init(timeInterval);
 8013ef0:	6878      	ldr	r0, [r7, #4]
 8013ef2:	f7ff ffbf 	bl	8013e74 <_ZN2XF4initEi>
}
 8013ef6:	bf00      	nop
 8013ef8:	3708      	adds	r7, #8
 8013efa:	46bd      	mov	sp, r7
 8013efc:	bd80      	pop	{r7, pc}

08013efe <XF_start>:

void XF_start()
{
 8013efe:	b580      	push	{r7, lr}
 8013f00:	af00      	add	r7, sp, #0
    XF::start();
 8013f02:	f7ff ffcd 	bl	8013ea0 <_ZN2XF5startEv>
}
 8013f06:	bf00      	nop
 8013f08:	bd80      	pop	{r7, pc}

08013f0a <XF_isRunning>:

bool XF_isRunning()
{
 8013f0a:	b580      	push	{r7, lr}
 8013f0c:	af00      	add	r7, sp, #0
    return XF::isRunning();
 8013f0e:	f7ff ffdf 	bl	8013ed0 <_ZN2XF9isRunningEv>
 8013f12:	4603      	mov	r3, r0
}
 8013f14:	4618      	mov	r0, r3
 8013f16:	bd80      	pop	{r7, pc}

08013f18 <XF_tick>:

void XF_tick()
{
 8013f18:	b580      	push	{r7, lr}
 8013f1a:	af00      	add	r7, sp, #0
    enterISR();                                     // Tell critical section we are in an ISR
 8013f1c:	4b09      	ldr	r3, [pc, #36]	; (8013f44 <XF_tick+0x2c>)
 8013f1e:	2201      	movs	r2, #1
 8013f20:	701a      	strb	r2, [r3, #0]
    if (XF::isRunning())                            // Call tick only if XF is running
 8013f22:	f7ff ffd5 	bl	8013ed0 <_ZN2XF9isRunningEv>
 8013f26:	4603      	mov	r3, r0
 8013f28:	2b00      	cmp	r3, #0
 8013f2a:	d005      	beq.n	8013f38 <XF_tick+0x20>
    {
        XFTimeoutManager::getInstance()->tick();    // Call framework hook tick function
 8013f2c:	f001 fbb2 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 8013f30:	4603      	mov	r3, r0
 8013f32:	4618      	mov	r0, r3
 8013f34:	f001 fc05 	bl	8015742 <_ZN16XFTimeoutManager4tickEv>
    }
    exitISR();
 8013f38:	4b02      	ldr	r3, [pc, #8]	; (8013f44 <XF_tick+0x2c>)
 8013f3a:	2200      	movs	r2, #0
 8013f3c:	701a      	strb	r2, [r3, #0]
}
 8013f3e:	bf00      	nop
 8013f40:	bd80      	pop	{r7, pc}
 8013f42:	bf00      	nop
 8013f44:	20001dd4 	.word	0x20001dd4

08013f48 <XF_tickIntervalInMilliseconds>:

int32_t XF_tickIntervalInMilliseconds()
{
 8013f48:	b580      	push	{r7, lr}
 8013f4a:	af00      	add	r7, sp, #0
    return XFTimeoutManager::getInstance()->tickInterval();
 8013f4c:	f001 fba2 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 8013f50:	4603      	mov	r3, r0
 8013f52:	4618      	mov	r0, r3
 8013f54:	f7f4 f95f 	bl	8008216 <_ZNK16XFTimeoutManager12tickIntervalEv>
 8013f58:	4603      	mov	r3, r0
}
 8013f5a:	4618      	mov	r0, r3
 8013f5c:	bd80      	pop	{r7, pc}
	...

08013f60 <_Z41__static_initialization_and_destruction_0ii>:
 8013f60:	b580      	push	{r7, lr}
 8013f62:	b082      	sub	sp, #8
 8013f64:	af00      	add	r7, sp, #0
 8013f66:	6078      	str	r0, [r7, #4]
 8013f68:	6039      	str	r1, [r7, #0]
 8013f6a:	687b      	ldr	r3, [r7, #4]
 8013f6c:	2b01      	cmp	r3, #1
 8013f6e:	d107      	bne.n	8013f80 <_Z41__static_initialization_and_destruction_0ii+0x20>
 8013f70:	683b      	ldr	r3, [r7, #0]
 8013f72:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013f76:	4293      	cmp	r3, r2
 8013f78:	d102      	bne.n	8013f80 <_Z41__static_initialization_and_destruction_0ii+0x20>
XFThread XF::_mainThread;
 8013f7a:	4809      	ldr	r0, [pc, #36]	; (8013fa0 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 8013f7c:	f000 fad8 	bl	8014530 <_ZN8XFThreadC1Ev>
 8013f80:	687b      	ldr	r3, [r7, #4]
 8013f82:	2b00      	cmp	r3, #0
 8013f84:	d107      	bne.n	8013f96 <_Z41__static_initialization_and_destruction_0ii+0x36>
 8013f86:	683b      	ldr	r3, [r7, #0]
 8013f88:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013f8c:	4293      	cmp	r3, r2
 8013f8e:	d102      	bne.n	8013f96 <_Z41__static_initialization_and_destruction_0ii+0x36>
 8013f90:	4803      	ldr	r0, [pc, #12]	; (8013fa0 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 8013f92:	f000 fae3 	bl	801455c <_ZN8XFThreadD1Ev>
}
 8013f96:	bf00      	nop
 8013f98:	3708      	adds	r7, #8
 8013f9a:	46bd      	mov	sp, r7
 8013f9c:	bd80      	pop	{r7, pc}
 8013f9e:	bf00      	nop
 8013fa0:	20001e28 	.word	0x20001e28

08013fa4 <_GLOBAL__sub_I__ZN2XF13_bInitializedE>:
 8013fa4:	b580      	push	{r7, lr}
 8013fa6:	af00      	add	r7, sp, #0
 8013fa8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013fac:	2001      	movs	r0, #1
 8013fae:	f7ff ffd7 	bl	8013f60 <_Z41__static_initialization_and_destruction_0ii>
 8013fb2:	bd80      	pop	{r7, pc}

08013fb4 <_GLOBAL__sub_D__ZN2XF13_bInitializedE>:
 8013fb4:	b580      	push	{r7, lr}
 8013fb6:	af00      	add	r7, sp, #0
 8013fb8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013fbc:	2000      	movs	r0, #0
 8013fbe:	f7ff ffcf 	bl	8013f60 <_Z41__static_initialization_and_destruction_0ii>
 8013fc2:	bd80      	pop	{r7, pc}

08013fc4 <_ZN7XFEventC1EiP11IXFReactive>:
 * Constructor for the class
 *
 * \param id Identifier uniquely identifying the event in the context of the behavior
 * \param pBehavior The Behavior for which the event was constructed (will consume the event)
 **/
XFEvent::XFEvent(int id, IXFReactive * pBehavior)
 8013fc4:	b580      	push	{r7, lr}
 8013fc6:	b084      	sub	sp, #16
 8013fc8:	af00      	add	r7, sp, #0
 8013fca:	60f8      	str	r0, [r7, #12]
 8013fcc:	60b9      	str	r1, [r7, #8]
 8013fce:	607a      	str	r2, [r7, #4]
    : IXFEvent(IXFEvent::Event, id, pBehavior)
 8013fd0:	68f8      	ldr	r0, [r7, #12]
 8013fd2:	687b      	ldr	r3, [r7, #4]
 8013fd4:	68ba      	ldr	r2, [r7, #8]
 8013fd6:	2103      	movs	r1, #3
 8013fd8:	f7ff fec0 	bl	8013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>
 8013fdc:	4a03      	ldr	r2, [pc, #12]	; (8013fec <_ZN7XFEventC1EiP11IXFReactive+0x28>)
 8013fde:	68fb      	ldr	r3, [r7, #12]
 8013fe0:	601a      	str	r2, [r3, #0]
{

}
 8013fe2:	68fb      	ldr	r3, [r7, #12]
 8013fe4:	4618      	mov	r0, r3
 8013fe6:	3710      	adds	r7, #16
 8013fe8:	46bd      	mov	sp, r7
 8013fea:	bd80      	pop	{r7, pc}
 8013fec:	0801dc6c 	.word	0x0801dc6c

08013ff0 <_ZN7XFEventD1Ev>:

XFEvent::~XFEvent()
 8013ff0:	b580      	push	{r7, lr}
 8013ff2:	b082      	sub	sp, #8
 8013ff4:	af00      	add	r7, sp, #0
 8013ff6:	6078      	str	r0, [r7, #4]
 8013ff8:	4a05      	ldr	r2, [pc, #20]	; (8014010 <_ZN7XFEventD1Ev+0x20>)
 8013ffa:	687b      	ldr	r3, [r7, #4]
 8013ffc:	601a      	str	r2, [r3, #0]
 8013ffe:	687b      	ldr	r3, [r7, #4]
 8014000:	4618      	mov	r0, r3
 8014002:	f7ff fed1 	bl	8013da8 <_ZN8IXFEventD1Ev>
{

}
 8014006:	687b      	ldr	r3, [r7, #4]
 8014008:	4618      	mov	r0, r3
 801400a:	3708      	adds	r7, #8
 801400c:	46bd      	mov	sp, r7
 801400e:	bd80      	pop	{r7, pc}
 8014010:	0801dc6c 	.word	0x0801dc6c

08014014 <_ZN7XFEventD0Ev>:
XFEvent::~XFEvent()
 8014014:	b580      	push	{r7, lr}
 8014016:	b082      	sub	sp, #8
 8014018:	af00      	add	r7, sp, #0
 801401a:	6078      	str	r0, [r7, #4]
}
 801401c:	6878      	ldr	r0, [r7, #4]
 801401e:	f7ff ffe7 	bl	8013ff0 <_ZN7XFEventD1Ev>
 8014022:	2114      	movs	r1, #20
 8014024:	6878      	ldr	r0, [r7, #4]
 8014026:	f002 f8c1 	bl	80161ac <_ZdlPvj>
 801402a:	687b      	ldr	r3, [r7, #4]
 801402c:	4618      	mov	r0, r3
 801402e:	3708      	adds	r7, #8
 8014030:	46bd      	mov	sp, r7
 8014032:	bd80      	pop	{r7, pc}

08014034 <_ZN16XFNullTransitionC1EiP11IXFReactive>:
 * Constuctor
 *
 * @param id		ID of the null transition.
 * \param pBehavior Behavior in which the null transition will be executed.
 */
XFNullTransition::XFNullTransition( int id , IXFReactive * pBehavior)
 8014034:	b580      	push	{r7, lr}
 8014036:	b084      	sub	sp, #16
 8014038:	af00      	add	r7, sp, #0
 801403a:	60f8      	str	r0, [r7, #12]
 801403c:	60b9      	str	r1, [r7, #8]
 801403e:	607a      	str	r2, [r7, #4]
 : IXFEvent(IXFEvent::NullTransition, id , pBehavior)
 8014040:	68f8      	ldr	r0, [r7, #12]
 8014042:	687b      	ldr	r3, [r7, #4]
 8014044:	68ba      	ldr	r2, [r7, #8]
 8014046:	2102      	movs	r1, #2
 8014048:	f7ff fe88 	bl	8013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>
 801404c:	4a03      	ldr	r2, [pc, #12]	; (801405c <_ZN16XFNullTransitionC1EiP11IXFReactive+0x28>)
 801404e:	68fb      	ldr	r3, [r7, #12]
 8014050:	601a      	str	r2, [r3, #0]
{
}
 8014052:	68fb      	ldr	r3, [r7, #12]
 8014054:	4618      	mov	r0, r3
 8014056:	3710      	adds	r7, #16
 8014058:	46bd      	mov	sp, r7
 801405a:	bd80      	pop	{r7, pc}
 801405c:	0801dc7c 	.word	0x0801dc7c

08014060 <_ZN16XFNullTransitionD1Ev>:

XFNullTransition::~XFNullTransition()
 8014060:	b580      	push	{r7, lr}
 8014062:	b082      	sub	sp, #8
 8014064:	af00      	add	r7, sp, #0
 8014066:	6078      	str	r0, [r7, #4]
 8014068:	4a05      	ldr	r2, [pc, #20]	; (8014080 <_ZN16XFNullTransitionD1Ev+0x20>)
 801406a:	687b      	ldr	r3, [r7, #4]
 801406c:	601a      	str	r2, [r3, #0]
 801406e:	687b      	ldr	r3, [r7, #4]
 8014070:	4618      	mov	r0, r3
 8014072:	f7ff fe99 	bl	8013da8 <_ZN8IXFEventD1Ev>
{

}
 8014076:	687b      	ldr	r3, [r7, #4]
 8014078:	4618      	mov	r0, r3
 801407a:	3708      	adds	r7, #8
 801407c:	46bd      	mov	sp, r7
 801407e:	bd80      	pop	{r7, pc}
 8014080:	0801dc7c 	.word	0x0801dc7c

08014084 <_ZN16XFNullTransitionD0Ev>:
XFNullTransition::~XFNullTransition()
 8014084:	b580      	push	{r7, lr}
 8014086:	b082      	sub	sp, #8
 8014088:	af00      	add	r7, sp, #0
 801408a:	6078      	str	r0, [r7, #4]
}
 801408c:	6878      	ldr	r0, [r7, #4]
 801408e:	f7ff ffe7 	bl	8014060 <_ZN16XFNullTransitionD1Ev>
 8014092:	2114      	movs	r1, #20
 8014094:	6878      	ldr	r0, [r7, #4]
 8014096:	f002 f889 	bl	80161ac <_ZdlPvj>
 801409a:	687b      	ldr	r3, [r7, #4]
 801409c:	4618      	mov	r0, r3
 801409e:	3708      	adds	r7, #8
 80140a0:	46bd      	mov	sp, r7
 80140a2:	bd80      	pop	{r7, pc}

080140a4 <_ZN8IXFEvent11setBehaviorEP11IXFReactive>:
    inline void setBehavior(IXFReactive * pBehavior) { _pBehavior = pBehavior; }
 80140a4:	b480      	push	{r7}
 80140a6:	b083      	sub	sp, #12
 80140a8:	af00      	add	r7, sp, #0
 80140aa:	6078      	str	r0, [r7, #4]
 80140ac:	6039      	str	r1, [r7, #0]
 80140ae:	687b      	ldr	r3, [r7, #4]
 80140b0:	683a      	ldr	r2, [r7, #0]
 80140b2:	611a      	str	r2, [r3, #16]
 80140b4:	bf00      	nop
 80140b6:	370c      	adds	r7, #12
 80140b8:	46bd      	mov	sp, r7
 80140ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140be:	4770      	bx	lr

080140c0 <_ZN11IXFReactiveC1EP9IXFThread>:
    /**
     * Constructor
     *
     * \param pThread Reference to thread executing the behavior of this class.
     */
    IXFReactive(IXFThread * pThread = NULL) { (void)pThread; }
 80140c0:	b480      	push	{r7}
 80140c2:	b083      	sub	sp, #12
 80140c4:	af00      	add	r7, sp, #0
 80140c6:	6078      	str	r0, [r7, #4]
 80140c8:	6039      	str	r1, [r7, #0]
 80140ca:	4a05      	ldr	r2, [pc, #20]	; (80140e0 <_ZN11IXFReactiveC1EP9IXFThread+0x20>)
 80140cc:	687b      	ldr	r3, [r7, #4]
 80140ce:	601a      	str	r2, [r3, #0]
 80140d0:	687b      	ldr	r3, [r7, #4]
 80140d2:	4618      	mov	r0, r3
 80140d4:	370c      	adds	r7, #12
 80140d6:	46bd      	mov	sp, r7
 80140d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140dc:	4770      	bx	lr
 80140de:	bf00      	nop
 80140e0:	0801dcb0 	.word	0x0801dcb0

080140e4 <_ZN11IXFReactiveD1Ev>:
    virtual ~IXFReactive() {}
 80140e4:	b480      	push	{r7}
 80140e6:	b083      	sub	sp, #12
 80140e8:	af00      	add	r7, sp, #0
 80140ea:	6078      	str	r0, [r7, #4]
 80140ec:	4a04      	ldr	r2, [pc, #16]	; (8014100 <_ZN11IXFReactiveD1Ev+0x1c>)
 80140ee:	687b      	ldr	r3, [r7, #4]
 80140f0:	601a      	str	r2, [r3, #0]
 80140f2:	687b      	ldr	r3, [r7, #4]
 80140f4:	4618      	mov	r0, r3
 80140f6:	370c      	adds	r7, #12
 80140f8:	46bd      	mov	sp, r7
 80140fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140fe:	4770      	bx	lr
 8014100:	0801dcb0 	.word	0x0801dcb0

08014104 <_ZN11IXFReactiveD0Ev>:
 8014104:	b580      	push	{r7, lr}
 8014106:	b082      	sub	sp, #8
 8014108:	af00      	add	r7, sp, #0
 801410a:	6078      	str	r0, [r7, #4]
 801410c:	6878      	ldr	r0, [r7, #4]
 801410e:	f7ff ffe9 	bl	80140e4 <_ZN11IXFReactiveD1Ev>
 8014112:	2104      	movs	r1, #4
 8014114:	6878      	ldr	r0, [r7, #4]
 8014116:	f002 f849 	bl	80161ac <_ZdlPvj>
 801411a:	687b      	ldr	r3, [r7, #4]
 801411c:	4618      	mov	r0, r3
 801411e:	3708      	adds	r7, #8
 8014120:	46bd      	mov	sp, r7
 8014122:	bd80      	pop	{r7, pc}

08014124 <_ZN10XFReactiveC1EP8XFThread>:
/**
 * Constructor
 *
 * \param pThread Reference to thread who will process the behavioral part of this reactive class.
 */
XFReactive::XFReactive(XFThread * pThread)
 8014124:	b580      	push	{r7, lr}
 8014126:	b082      	sub	sp, #8
 8014128:	af00      	add	r7, sp, #0
 801412a:	6078      	str	r0, [r7, #4]
 801412c:	6039      	str	r1, [r7, #0]
 : _pThread((pThread) ? pThread : XF::getMainThread()),
   _pCurrentEvent(nullptr)
 801412e:	687b      	ldr	r3, [r7, #4]
 8014130:	2100      	movs	r1, #0
 8014132:	4618      	mov	r0, r3
 8014134:	f7ff ffc4 	bl	80140c0 <_ZN11IXFReactiveC1EP9IXFThread>
 8014138:	4a0a      	ldr	r2, [pc, #40]	; (8014164 <_ZN10XFReactiveC1EP8XFThread+0x40>)
 801413a:	687b      	ldr	r3, [r7, #4]
 801413c:	601a      	str	r2, [r3, #0]
 : _pThread((pThread) ? pThread : XF::getMainThread()),
 801413e:	683b      	ldr	r3, [r7, #0]
 8014140:	2b00      	cmp	r3, #0
 8014142:	d103      	bne.n	801414c <_ZN10XFReactiveC1EP8XFThread+0x28>
 8014144:	f7ff feba 	bl	8013ebc <_ZN2XF13getMainThreadEv>
 8014148:	4603      	mov	r3, r0
 801414a:	e000      	b.n	801414e <_ZN10XFReactiveC1EP8XFThread+0x2a>
 801414c:	683b      	ldr	r3, [r7, #0]
   _pCurrentEvent(nullptr)
 801414e:	687a      	ldr	r2, [r7, #4]
 8014150:	6053      	str	r3, [r2, #4]
 8014152:	687b      	ldr	r3, [r7, #4]
 8014154:	2200      	movs	r2, #0
 8014156:	609a      	str	r2, [r3, #8]
{
}
 8014158:	687b      	ldr	r3, [r7, #4]
 801415a:	4618      	mov	r0, r3
 801415c:	3708      	adds	r7, #8
 801415e:	46bd      	mov	sp, r7
 8014160:	bd80      	pop	{r7, pc}
 8014162:	bf00      	nop
 8014164:	0801dc8c 	.word	0x0801dc8c

08014168 <_ZN10XFReactiveD1Ev>:

XFReactive::~XFReactive()
 8014168:	b580      	push	{r7, lr}
 801416a:	b082      	sub	sp, #8
 801416c:	af00      	add	r7, sp, #0
 801416e:	6078      	str	r0, [r7, #4]
 8014170:	4a05      	ldr	r2, [pc, #20]	; (8014188 <_ZN10XFReactiveD1Ev+0x20>)
 8014172:	687b      	ldr	r3, [r7, #4]
 8014174:	601a      	str	r2, [r3, #0]
 8014176:	687b      	ldr	r3, [r7, #4]
 8014178:	4618      	mov	r0, r3
 801417a:	f7ff ffb3 	bl	80140e4 <_ZN11IXFReactiveD1Ev>
{

}
 801417e:	687b      	ldr	r3, [r7, #4]
 8014180:	4618      	mov	r0, r3
 8014182:	3708      	adds	r7, #8
 8014184:	46bd      	mov	sp, r7
 8014186:	bd80      	pop	{r7, pc}
 8014188:	0801dc8c 	.word	0x0801dc8c

0801418c <_ZN10XFReactiveD0Ev>:
XFReactive::~XFReactive()
 801418c:	b580      	push	{r7, lr}
 801418e:	b082      	sub	sp, #8
 8014190:	af00      	add	r7, sp, #0
 8014192:	6078      	str	r0, [r7, #4]
}
 8014194:	6878      	ldr	r0, [r7, #4]
 8014196:	f7ff ffe7 	bl	8014168 <_ZN10XFReactiveD1Ev>
 801419a:	210c      	movs	r1, #12
 801419c:	6878      	ldr	r0, [r7, #4]
 801419e:	f002 f805 	bl	80161ac <_ZdlPvj>
 80141a2:	687b      	ldr	r3, [r7, #4]
 80141a4:	4618      	mov	r0, r3
 80141a6:	3708      	adds	r7, #8
 80141a8:	46bd      	mov	sp, r7
 80141aa:	bd80      	pop	{r7, pc}

080141ac <_ZN10XFReactive13startBehaviorEv>:

void XFReactive::startBehavior()
{
 80141ac:	b5b0      	push	{r4, r5, r7, lr}
 80141ae:	b082      	sub	sp, #8
 80141b0:	af00      	add	r7, sp, #0
 80141b2:	6078      	str	r0, [r7, #4]
    GEN(InitialEvent());
 80141b4:	687b      	ldr	r3, [r7, #4]
 80141b6:	681b      	ldr	r3, [r3, #0]
 80141b8:	330c      	adds	r3, #12
 80141ba:	681c      	ldr	r4, [r3, #0]
 80141bc:	2014      	movs	r0, #20
 80141be:	f002 f808 	bl	80161d2 <_Znwj>
 80141c2:	4603      	mov	r3, r0
 80141c4:	461d      	mov	r5, r3
 80141c6:	4628      	mov	r0, r5
 80141c8:	f7ff fe1e 	bl	8013e08 <_ZN12InitialEventC1Ev>
 80141cc:	4629      	mov	r1, r5
 80141ce:	6878      	ldr	r0, [r7, #4]
 80141d0:	47a0      	blx	r4
}
 80141d2:	bf00      	nop
 80141d4:	3708      	adds	r7, #8
 80141d6:	46bd      	mov	sp, r7
 80141d8:	bdb0      	pop	{r4, r5, r7, pc}
	...

080141dc <_ZN10XFReactive9pushEventEP8IXFEvent>:


void XFReactive::pushEvent(IXFEvent * pEvent)
{
 80141dc:	b580      	push	{r7, lr}
 80141de:	b082      	sub	sp, #8
 80141e0:	af00      	add	r7, sp, #0
 80141e2:	6078      	str	r0, [r7, #4]
 80141e4:	6039      	str	r1, [r7, #0]
    assert(pEvent);
 80141e6:	683b      	ldr	r3, [r7, #0]
 80141e8:	2b00      	cmp	r3, #0
 80141ea:	d105      	bne.n	80141f8 <_ZN10XFReactive9pushEventEP8IXFEvent+0x1c>
 80141ec:	4b0c      	ldr	r3, [pc, #48]	; (8014220 <_ZN10XFReactive9pushEventEP8IXFEvent+0x44>)
 80141ee:	4a0d      	ldr	r2, [pc, #52]	; (8014224 <_ZN10XFReactive9pushEventEP8IXFEvent+0x48>)
 80141f0:	2120      	movs	r1, #32
 80141f2:	480d      	ldr	r0, [pc, #52]	; (8014228 <_ZN10XFReactive9pushEventEP8IXFEvent+0x4c>)
 80141f4:	f002 f8ce 	bl	8016394 <__assert_func>

    // Set owner
    pEvent->setBehavior(this);
 80141f8:	687b      	ldr	r3, [r7, #4]
 80141fa:	4619      	mov	r1, r3
 80141fc:	6838      	ldr	r0, [r7, #0]
 80141fe:	f7ff ff51 	bl	80140a4 <_ZN8IXFEvent11setBehaviorEP11IXFReactive>
    // Push to threads event queue
    getThread()->pushEvent(pEvent);
 8014202:	687b      	ldr	r3, [r7, #4]
 8014204:	681b      	ldr	r3, [r3, #0]
 8014206:	3318      	adds	r3, #24
 8014208:	681b      	ldr	r3, [r3, #0]
 801420a:	6878      	ldr	r0, [r7, #4]
 801420c:	4798      	blx	r3
 801420e:	4603      	mov	r3, r0
 8014210:	6839      	ldr	r1, [r7, #0]
 8014212:	4618      	mov	r0, r3
 8014214:	f000 fa0f 	bl	8014636 <_ZN8XFThread9pushEventEP8IXFEvent>
}
 8014218:	bf00      	nop
 801421a:	3708      	adds	r7, #8
 801421c:	46bd      	mov	sp, r7
 801421e:	bd80      	pop	{r7, pc}
 8014220:	0801b5e4 	.word	0x0801b5e4
 8014224:	0801b5ec 	.word	0x0801b5ec
 8014228:	0801b61c 	.word	0x0801b61c

0801422c <_ZN10XFReactive7processEP8IXFEvent>:
 * Must only be called by the associated thread (see #_pThread).
 *
 * \param pEvent The event to process.
 */
EventStatus XFReactive::process(IXFEvent * pEvent)
{
 801422c:	b580      	push	{r7, lr}
 801422e:	b084      	sub	sp, #16
 8014230:	af00      	add	r7, sp, #0
 8014232:	6078      	str	r0, [r7, #4]
 8014234:	6039      	str	r1, [r7, #0]
    EventStatus eventStatus;
 8014236:	f107 030c 	add.w	r3, r7, #12
 801423a:	2100      	movs	r1, #0
 801423c:	4618      	mov	r0, r3
 801423e:	f7f2 fbc9 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>

    assert(pEvent);
 8014242:	683b      	ldr	r3, [r7, #0]
 8014244:	2b00      	cmp	r3, #0
 8014246:	d105      	bne.n	8014254 <_ZN10XFReactive7processEP8IXFEvent+0x28>
 8014248:	4b0d      	ldr	r3, [pc, #52]	; (8014280 <_ZN10XFReactive7processEP8IXFEvent+0x54>)
 801424a:	4a0e      	ldr	r2, [pc, #56]	; (8014284 <_ZN10XFReactive7processEP8IXFEvent+0x58>)
 801424c:	2136      	movs	r1, #54	; 0x36
 801424e:	480e      	ldr	r0, [pc, #56]	; (8014288 <_ZN10XFReactive7processEP8IXFEvent+0x5c>)
 8014250:	f002 f8a0 	bl	8016394 <__assert_func>

    setCurrentEvent(pEvent);
 8014254:	6839      	ldr	r1, [r7, #0]
 8014256:	6878      	ldr	r0, [r7, #4]
 8014258:	f000 f833 	bl	80142c2 <_ZN10XFReactive15setCurrentEventEP8IXFEvent>

    eventStatus = processEvent();
 801425c:	687b      	ldr	r3, [r7, #4]
 801425e:	681b      	ldr	r3, [r3, #0]
 8014260:	3314      	adds	r3, #20
 8014262:	681b      	ldr	r3, [r3, #0]
 8014264:	6878      	ldr	r0, [r7, #4]
 8014266:	4798      	blx	r3
 8014268:	4603      	mov	r3, r0
 801426a:	733b      	strb	r3, [r7, #12]

    setCurrentEvent(NULL);
 801426c:	2100      	movs	r1, #0
 801426e:	6878      	ldr	r0, [r7, #4]
 8014270:	f000 f827 	bl	80142c2 <_ZN10XFReactive15setCurrentEventEP8IXFEvent>

    return eventStatus;
 8014274:	7b3b      	ldrb	r3, [r7, #12]
}
 8014276:	4618      	mov	r0, r3
 8014278:	3710      	adds	r7, #16
 801427a:	46bd      	mov	sp, r7
 801427c:	bd80      	pop	{r7, pc}
 801427e:	bf00      	nop
 8014280:	0801b5e4 	.word	0x0801b5e4
 8014284:	0801b684 	.word	0x0801b684
 8014288:	0801b61c 	.word	0x0801b61c

0801428c <_ZN10XFReactive12processEventEv>:
/**
 * Executes the current event in its implemented behavior.
 * This method needs to be overridden to implement the behavior needed.
 */
EventStatus XFReactive::processEvent()
{
 801428c:	b580      	push	{r7, lr}
 801428e:	b084      	sub	sp, #16
 8014290:	af00      	add	r7, sp, #0
 8014292:	6078      	str	r0, [r7, #4]
    // You should really implement this function in
    // the derived class!

    return EventStatus::Unknown;
 8014294:	f107 030c 	add.w	r3, r7, #12
 8014298:	2100      	movs	r1, #0
 801429a:	4618      	mov	r0, r3
 801429c:	f7f2 fb9a 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>
 80142a0:	7b3b      	ldrb	r3, [r7, #12]
}
 80142a2:	4618      	mov	r0, r3
 80142a4:	3710      	adds	r7, #16
 80142a6:	46bd      	mov	sp, r7
 80142a8:	bd80      	pop	{r7, pc}

080142aa <_ZN10XFReactive9getThreadEv>:


XFThread * XFReactive::getThread()
{
 80142aa:	b480      	push	{r7}
 80142ac:	b083      	sub	sp, #12
 80142ae:	af00      	add	r7, sp, #0
 80142b0:	6078      	str	r0, [r7, #4]
    return _pThread;
 80142b2:	687b      	ldr	r3, [r7, #4]
 80142b4:	685b      	ldr	r3, [r3, #4]
}
 80142b6:	4618      	mov	r0, r3
 80142b8:	370c      	adds	r7, #12
 80142ba:	46bd      	mov	sp, r7
 80142bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142c0:	4770      	bx	lr

080142c2 <_ZN10XFReactive15setCurrentEventEP8IXFEvent>:

void XFReactive::setCurrentEvent(IXFEvent * pEvent)
{
 80142c2:	b480      	push	{r7}
 80142c4:	b083      	sub	sp, #12
 80142c6:	af00      	add	r7, sp, #0
 80142c8:	6078      	str	r0, [r7, #4]
 80142ca:	6039      	str	r1, [r7, #0]
    _pCurrentEvent = pEvent;
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	683a      	ldr	r2, [r7, #0]
 80142d0:	609a      	str	r2, [r3, #8]
}
 80142d2:	bf00      	nop
 80142d4:	370c      	adds	r7, #12
 80142d6:	46bd      	mov	sp, r7
 80142d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142dc:	4770      	bx	lr
	...

080142e0 <_ZNK10XFReactive15getCurrentEventEv>:

IXFEvent * XFReactive::getCurrentEvent() const
{
 80142e0:	b580      	push	{r7, lr}
 80142e2:	b082      	sub	sp, #8
 80142e4:	af00      	add	r7, sp, #0
 80142e6:	6078      	str	r0, [r7, #4]
    assert(_pCurrentEvent);
 80142e8:	687b      	ldr	r3, [r7, #4]
 80142ea:	689b      	ldr	r3, [r3, #8]
 80142ec:	2b00      	cmp	r3, #0
 80142ee:	d105      	bne.n	80142fc <_ZNK10XFReactive15getCurrentEventEv+0x1c>
 80142f0:	4b05      	ldr	r3, [pc, #20]	; (8014308 <_ZNK10XFReactive15getCurrentEventEv+0x28>)
 80142f2:	4a06      	ldr	r2, [pc, #24]	; (801430c <_ZNK10XFReactive15getCurrentEventEv+0x2c>)
 80142f4:	215a      	movs	r1, #90	; 0x5a
 80142f6:	4806      	ldr	r0, [pc, #24]	; (8014310 <_ZNK10XFReactive15getCurrentEventEv+0x30>)
 80142f8:	f002 f84c 	bl	8016394 <__assert_func>
    return _pCurrentEvent;
 80142fc:	687b      	ldr	r3, [r7, #4]
 80142fe:	689b      	ldr	r3, [r3, #8]
}
 8014300:	4618      	mov	r0, r3
 8014302:	3708      	adds	r7, #8
 8014304:	46bd      	mov	sp, r7
 8014306:	bd80      	pop	{r7, pc}
 8014308:	0801b6b8 	.word	0x0801b6b8
 801430c:	0801b6c8 	.word	0x0801b6c8
 8014310:	0801b61c 	.word	0x0801b61c

08014314 <_ZN10XFReactive17getCurrentTimeoutEv>:
/** \brief Returns a reference to the actually processed timeout.
 *
 * Will work only if the current event is of type IXFEvent::Timeout.
 */
XFTimeout * XFReactive::getCurrentTimeout()
{
 8014314:	b580      	push	{r7, lr}
 8014316:	b082      	sub	sp, #8
 8014318:	af00      	add	r7, sp, #0
 801431a:	6078      	str	r0, [r7, #4]
    assert(getCurrentEvent()->getEventType() == IXFEvent::Timeout);
 801431c:	6878      	ldr	r0, [r7, #4]
 801431e:	f7ff ffdf 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8014322:	4603      	mov	r3, r0
 8014324:	4618      	mov	r0, r3
 8014326:	f7f2 fb3c 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 801432a:	4603      	mov	r3, r0
 801432c:	2b04      	cmp	r3, #4
 801432e:	d005      	beq.n	801433c <_ZN10XFReactive17getCurrentTimeoutEv+0x28>
 8014330:	4b06      	ldr	r3, [pc, #24]	; (801434c <_ZN10XFReactive17getCurrentTimeoutEv+0x38>)
 8014332:	4a07      	ldr	r2, [pc, #28]	; (8014350 <_ZN10XFReactive17getCurrentTimeoutEv+0x3c>)
 8014334:	2164      	movs	r1, #100	; 0x64
 8014336:	4807      	ldr	r0, [pc, #28]	; (8014354 <_ZN10XFReactive17getCurrentTimeoutEv+0x40>)
 8014338:	f002 f82c 	bl	8016394 <__assert_func>

    return (XFTimeout *)getCurrentEvent();
 801433c:	6878      	ldr	r0, [r7, #4]
 801433e:	f7ff ffcf 	bl	80142e0 <_ZNK10XFReactive15getCurrentEventEv>
 8014342:	4603      	mov	r3, r0
}
 8014344:	4618      	mov	r0, r3
 8014346:	3708      	adds	r7, #8
 8014348:	46bd      	mov	sp, r7
 801434a:	bd80      	pop	{r7, pc}
 801434c:	0801b6f8 	.word	0x0801b6f8
 8014350:	0801b730 	.word	0x0801b730
 8014354:	0801b61c 	.word	0x0801b61c

08014358 <_ZN8IXFEvent15setShouldDeleteEb>:
    inline void setShouldDelete(bool bShouldDelete = true) { _eventStatus.shouldDelete = bShouldDelete; }
 8014358:	b480      	push	{r7}
 801435a:	b083      	sub	sp, #12
 801435c:	af00      	add	r7, sp, #0
 801435e:	6078      	str	r0, [r7, #4]
 8014360:	460b      	mov	r3, r1
 8014362:	70fb      	strb	r3, [r7, #3]
 8014364:	687a      	ldr	r2, [r7, #4]
 8014366:	7b13      	ldrb	r3, [r2, #12]
 8014368:	78f9      	ldrb	r1, [r7, #3]
 801436a:	f361 0300 	bfi	r3, r1, #0, #1
 801436e:	7313      	strb	r3, [r2, #12]
 8014370:	bf00      	nop
 8014372:	370c      	adds	r7, #12
 8014374:	46bd      	mov	sp, r7
 8014376:	f85d 7b04 	ldr.w	r7, [sp], #4
 801437a:	4770      	bx	lr

0801437c <_ZN13XFStaticEventC1EiP11IXFReactive>:
#include "xfstaticevent.h"


XFStaticEvent::XFStaticEvent(int id, IXFReactive * pBehavior)
 801437c:	b580      	push	{r7, lr}
 801437e:	b084      	sub	sp, #16
 8014380:	af00      	add	r7, sp, #0
 8014382:	60f8      	str	r0, [r7, #12]
 8014384:	60b9      	str	r1, [r7, #8]
 8014386:	607a      	str	r2, [r7, #4]
: IXFEvent(IXFEvent::Event, id, pBehavior)
 8014388:	68f8      	ldr	r0, [r7, #12]
 801438a:	687b      	ldr	r3, [r7, #4]
 801438c:	68ba      	ldr	r2, [r7, #8]
 801438e:	2103      	movs	r1, #3
 8014390:	f7ff fce4 	bl	8013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>
 8014394:	4a06      	ldr	r2, [pc, #24]	; (80143b0 <_ZN13XFStaticEventC1EiP11IXFReactive+0x34>)
 8014396:	68fb      	ldr	r3, [r7, #12]
 8014398:	601a      	str	r2, [r3, #0]
{
	// Clear the shouldDelete flag in the _eventStatus attribute.
	setShouldDelete(false);
 801439a:	68fb      	ldr	r3, [r7, #12]
 801439c:	2100      	movs	r1, #0
 801439e:	4618      	mov	r0, r3
 80143a0:	f7ff ffda 	bl	8014358 <_ZN8IXFEvent15setShouldDeleteEb>
}
 80143a4:	68fb      	ldr	r3, [r7, #12]
 80143a6:	4618      	mov	r0, r3
 80143a8:	3710      	adds	r7, #16
 80143aa:	46bd      	mov	sp, r7
 80143ac:	bd80      	pop	{r7, pc}
 80143ae:	bf00      	nop
 80143b0:	0801dccc 	.word	0x0801dccc

080143b4 <_ZN13XFStaticEventD1Ev>:

XFStaticEvent::~XFStaticEvent()
 80143b4:	b580      	push	{r7, lr}
 80143b6:	b082      	sub	sp, #8
 80143b8:	af00      	add	r7, sp, #0
 80143ba:	6078      	str	r0, [r7, #4]
 80143bc:	4a05      	ldr	r2, [pc, #20]	; (80143d4 <_ZN13XFStaticEventD1Ev+0x20>)
 80143be:	687b      	ldr	r3, [r7, #4]
 80143c0:	601a      	str	r2, [r3, #0]
 80143c2:	687b      	ldr	r3, [r7, #4]
 80143c4:	4618      	mov	r0, r3
 80143c6:	f7ff fcef 	bl	8013da8 <_ZN8IXFEventD1Ev>
{

}
 80143ca:	687b      	ldr	r3, [r7, #4]
 80143cc:	4618      	mov	r0, r3
 80143ce:	3708      	adds	r7, #8
 80143d0:	46bd      	mov	sp, r7
 80143d2:	bd80      	pop	{r7, pc}
 80143d4:	0801dccc 	.word	0x0801dccc

080143d8 <_ZN13XFStaticEventD0Ev>:
XFStaticEvent::~XFStaticEvent()
 80143d8:	b580      	push	{r7, lr}
 80143da:	b082      	sub	sp, #8
 80143dc:	af00      	add	r7, sp, #0
 80143de:	6078      	str	r0, [r7, #4]
}
 80143e0:	6878      	ldr	r0, [r7, #4]
 80143e2:	f7ff ffe7 	bl	80143b4 <_ZN13XFStaticEventD1Ev>
 80143e6:	2114      	movs	r1, #20
 80143e8:	6878      	ldr	r0, [r7, #4]
 80143ea:	f001 fedf 	bl	80161ac <_ZdlPvj>
 80143ee:	687b      	ldr	r3, [r7, #4]
 80143f0:	4618      	mov	r0, r3
 80143f2:	3708      	adds	r7, #8
 80143f4:	46bd      	mov	sp, r7
 80143f6:	bd80      	pop	{r7, pc}

080143f8 <_ZNK8IXFEvent11getBehaviorEv>:
    inline IXFReactive * getBehavior() const { return _pBehavior; }
 80143f8:	b480      	push	{r7}
 80143fa:	b083      	sub	sp, #12
 80143fc:	af00      	add	r7, sp, #0
 80143fe:	6078      	str	r0, [r7, #4]
 8014400:	687b      	ldr	r3, [r7, #4]
 8014402:	691b      	ldr	r3, [r3, #16]
 8014404:	4618      	mov	r0, r3
 8014406:	370c      	adds	r7, #12
 8014408:	46bd      	mov	sp, r7
 801440a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801440e:	4770      	bx	lr

08014410 <_ZNK8IXFEvent12shouldDeleteEv>:
    inline bool shouldDelete() const { return _eventStatus.shouldDelete; }
 8014410:	b480      	push	{r7}
 8014412:	b083      	sub	sp, #12
 8014414:	af00      	add	r7, sp, #0
 8014416:	6078      	str	r0, [r7, #4]
 8014418:	687b      	ldr	r3, [r7, #4]
 801441a:	7b1b      	ldrb	r3, [r3, #12]
 801441c:	f003 0301 	and.w	r3, r3, #1
 8014420:	b2db      	uxtb	r3, r3
 8014422:	2b00      	cmp	r3, #0
 8014424:	bf14      	ite	ne
 8014426:	2301      	movne	r3, #1
 8014428:	2300      	moveq	r3, #0
 801442a:	b2db      	uxtb	r3, r3
 801442c:	4618      	mov	r0, r3
 801442e:	370c      	adds	r7, #12
 8014430:	46bd      	mov	sp, r7
 8014432:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014436:	4770      	bx	lr

08014438 <_ZSt16__deque_buf_sizej>:
#define _GLIBCXX_DEQUE_BUF_SIZE 512
#endif

  _GLIBCXX_CONSTEXPR inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
 8014438:	b480      	push	{r7}
 801443a:	b083      	sub	sp, #12
 801443c:	af00      	add	r7, sp, #0
 801443e:	6078      	str	r0, [r7, #4]
	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
 8014440:	687b      	ldr	r3, [r7, #4]
 8014442:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8014446:	d205      	bcs.n	8014454 <_ZSt16__deque_buf_sizej+0x1c>
 8014448:	f44f 7200 	mov.w	r2, #512	; 0x200
 801444c:	687b      	ldr	r3, [r7, #4]
 801444e:	fbb2 f3f3 	udiv	r3, r2, r3
 8014452:	e000      	b.n	8014456 <_ZSt16__deque_buf_sizej+0x1e>
 8014454:	2301      	movs	r3, #1
 8014456:	4618      	mov	r0, r3
 8014458:	370c      	adds	r7, #12
 801445a:	46bd      	mov	sp, r7
 801445c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014460:	4770      	bx	lr

08014462 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEED1Ev>:
   *  Members not found in @a normal containers are @c container_type,
   *  which is a typedef for the second Sequence parameter, and @c push and
   *  @c pop, which are standard %queue/FIFO operations.
  */
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
 8014462:	b580      	push	{r7, lr}
 8014464:	b082      	sub	sp, #8
 8014466:	af00      	add	r7, sp, #0
 8014468:	6078      	str	r0, [r7, #4]
 801446a:	687b      	ldr	r3, [r7, #4]
 801446c:	4618      	mov	r0, r3
 801446e:	f000 f96e 	bl	801474e <_ZNSt5dequeIP8IXFEventSaIS1_EED1Ev>
 8014472:	687b      	ldr	r3, [r7, #4]
 8014474:	4618      	mov	r0, r3
 8014476:	3708      	adds	r7, #8
 8014478:	46bd      	mov	sp, r7
 801447a:	bd80      	pop	{r7, pc}

0801447c <_ZN12XFEventQueueC1Ev>:
 * Queue for pending events.
 */
class XFEventQueue : public std::queue<IXFEvent *>
{
public:
	XFEventQueue() {}
 801447c:	b580      	push	{r7, lr}
 801447e:	b082      	sub	sp, #8
 8014480:	af00      	add	r7, sp, #0
 8014482:	6078      	str	r0, [r7, #4]
 8014484:	687b      	ldr	r3, [r7, #4]
 8014486:	3304      	adds	r3, #4
 8014488:	4618      	mov	r0, r3
 801448a:	f000 f94c 	bl	8014726 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEEC1IS4_vEEv>
 801448e:	4a04      	ldr	r2, [pc, #16]	; (80144a0 <_ZN12XFEventQueueC1Ev+0x24>)
 8014490:	687b      	ldr	r3, [r7, #4]
 8014492:	601a      	str	r2, [r3, #0]
 8014494:	687b      	ldr	r3, [r7, #4]
 8014496:	4618      	mov	r0, r3
 8014498:	3708      	adds	r7, #8
 801449a:	46bd      	mov	sp, r7
 801449c:	bd80      	pop	{r7, pc}
 801449e:	bf00      	nop
 80144a0:	0801dcec 	.word	0x0801dcec

080144a4 <_ZN12XFEventQueueD1Ev>:
	virtual ~XFEventQueue() {}
 80144a4:	b580      	push	{r7, lr}
 80144a6:	b082      	sub	sp, #8
 80144a8:	af00      	add	r7, sp, #0
 80144aa:	6078      	str	r0, [r7, #4]
 80144ac:	4a06      	ldr	r2, [pc, #24]	; (80144c8 <_ZN12XFEventQueueD1Ev+0x24>)
 80144ae:	687b      	ldr	r3, [r7, #4]
 80144b0:	601a      	str	r2, [r3, #0]
 80144b2:	687b      	ldr	r3, [r7, #4]
 80144b4:	3304      	adds	r3, #4
 80144b6:	4618      	mov	r0, r3
 80144b8:	f7ff ffd3 	bl	8014462 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEED1Ev>
 80144bc:	687b      	ldr	r3, [r7, #4]
 80144be:	4618      	mov	r0, r3
 80144c0:	3708      	adds	r7, #8
 80144c2:	46bd      	mov	sp, r7
 80144c4:	bd80      	pop	{r7, pc}
 80144c6:	bf00      	nop
 80144c8:	0801dcec 	.word	0x0801dcec

080144cc <_ZN12XFEventQueueD0Ev>:
 80144cc:	b580      	push	{r7, lr}
 80144ce:	b082      	sub	sp, #8
 80144d0:	af00      	add	r7, sp, #0
 80144d2:	6078      	str	r0, [r7, #4]
 80144d4:	6878      	ldr	r0, [r7, #4]
 80144d6:	f7ff ffe5 	bl	80144a4 <_ZN12XFEventQueueD1Ev>
 80144da:	212c      	movs	r1, #44	; 0x2c
 80144dc:	6878      	ldr	r0, [r7, #4]
 80144de:	f001 fe65 	bl	80161ac <_ZdlPvj>
 80144e2:	687b      	ldr	r3, [r7, #4]
 80144e4:	4618      	mov	r0, r3
 80144e6:	3708      	adds	r7, #8
 80144e8:	46bd      	mov	sp, r7
 80144ea:	bd80      	pop	{r7, pc}

080144ec <_ZN12XFEventQueue5emptyEv>:

	typedef std::queue<IXFEvent *> BaseClass;

	bool empty() __attribute__ ((noinline)) { return BaseClass::empty(); }	// Prevent gcc from optimizing this operation
 80144ec:	b580      	push	{r7, lr}
 80144ee:	b082      	sub	sp, #8
 80144f0:	af00      	add	r7, sp, #0
 80144f2:	6078      	str	r0, [r7, #4]
 80144f4:	687b      	ldr	r3, [r7, #4]
 80144f6:	3304      	adds	r3, #4
 80144f8:	4618      	mov	r0, r3
 80144fa:	f000 f94d 	bl	8014798 <_ZNKSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE5emptyEv>
 80144fe:	4603      	mov	r3, r0
 8014500:	4618      	mov	r0, r3
 8014502:	3708      	adds	r7, #8
 8014504:	46bd      	mov	sp, r7
 8014506:	bd80      	pop	{r7, pc}

08014508 <_ZNK11EventStatuseqERKNS_12eEventStatusE>:

    /**
     * Check if both variables contain the same event status
     */
    bool operator == (const EventStatus::eEventStatus & eventStatus) const
 8014508:	b480      	push	{r7}
 801450a:	b083      	sub	sp, #12
 801450c:	af00      	add	r7, sp, #0
 801450e:	6078      	str	r0, [r7, #4]
 8014510:	6039      	str	r1, [r7, #0]
    {
        return (this->_status == eventStatus);
 8014512:	687b      	ldr	r3, [r7, #4]
 8014514:	781a      	ldrb	r2, [r3, #0]
 8014516:	683b      	ldr	r3, [r7, #0]
 8014518:	781b      	ldrb	r3, [r3, #0]
 801451a:	429a      	cmp	r2, r3
 801451c:	bf0c      	ite	eq
 801451e:	2301      	moveq	r3, #1
 8014520:	2300      	movne	r3, #0
 8014522:	b2db      	uxtb	r3, r3
    }
 8014524:	4618      	mov	r0, r3
 8014526:	370c      	adds	r7, #12
 8014528:	46bd      	mov	sp, r7
 801452a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801452e:	4770      	bx	lr

08014530 <_ZN8XFThreadC1Ev>:
#ifdef TC_STM32
  #include "mcu/mcu.h"
#endif


XFThread::XFThread()
 8014530:	b580      	push	{r7, lr}
 8014532:	b082      	sub	sp, #8
 8014534:	af00      	add	r7, sp, #0
 8014536:	6078      	str	r0, [r7, #4]
 : _bExecuting(true)
 8014538:	4a07      	ldr	r2, [pc, #28]	; (8014558 <_ZN8XFThreadC1Ev+0x28>)
 801453a:	687b      	ldr	r3, [r7, #4]
 801453c:	601a      	str	r2, [r3, #0]
 801453e:	687b      	ldr	r3, [r7, #4]
 8014540:	2201      	movs	r2, #1
 8014542:	711a      	strb	r2, [r3, #4]
 8014544:	687b      	ldr	r3, [r7, #4]
 8014546:	3308      	adds	r3, #8
 8014548:	4618      	mov	r0, r3
 801454a:	f7ff ff97 	bl	801447c <_ZN12XFEventQueueC1Ev>

#endif /**************************************************************************************************************/


{
}
 801454e:	687b      	ldr	r3, [r7, #4]
 8014550:	4618      	mov	r0, r3
 8014552:	3708      	adds	r7, #8
 8014554:	46bd      	mov	sp, r7
 8014556:	bd80      	pop	{r7, pc}
 8014558:	0801dcdc 	.word	0x0801dcdc

0801455c <_ZN8XFThreadD1Ev>:

XFThread::~XFThread()
 801455c:	b580      	push	{r7, lr}
 801455e:	b082      	sub	sp, #8
 8014560:	af00      	add	r7, sp, #0
 8014562:	6078      	str	r0, [r7, #4]
 8014564:	4a06      	ldr	r2, [pc, #24]	; (8014580 <_ZN8XFThreadD1Ev+0x24>)
 8014566:	687b      	ldr	r3, [r7, #4]
 8014568:	601a      	str	r2, [r3, #0]
 801456a:	687b      	ldr	r3, [r7, #4]
 801456c:	3308      	adds	r3, #8
 801456e:	4618      	mov	r0, r3
 8014570:	f7ff ff98 	bl	80144a4 <_ZN12XFEventQueueD1Ev>
{
}
 8014574:	687b      	ldr	r3, [r7, #4]
 8014576:	4618      	mov	r0, r3
 8014578:	3708      	adds	r7, #8
 801457a:	46bd      	mov	sp, r7
 801457c:	bd80      	pop	{r7, pc}
 801457e:	bf00      	nop
 8014580:	0801dcdc 	.word	0x0801dcdc

08014584 <_ZN8XFThreadD0Ev>:
XFThread::~XFThread()
 8014584:	b580      	push	{r7, lr}
 8014586:	b082      	sub	sp, #8
 8014588:	af00      	add	r7, sp, #0
 801458a:	6078      	str	r0, [r7, #4]
}
 801458c:	6878      	ldr	r0, [r7, #4]
 801458e:	f7ff ffe5 	bl	801455c <_ZN8XFThreadD1Ev>
 8014592:	2134      	movs	r1, #52	; 0x34
 8014594:	6878      	ldr	r0, [r7, #4]
 8014596:	f001 fe09 	bl	80161ac <_ZdlPvj>
 801459a:	687b      	ldr	r3, [r7, #4]
 801459c:	4618      	mov	r0, r3
 801459e:	3708      	adds	r7, #8
 80145a0:	46bd      	mov	sp, r7
 80145a2:	bd80      	pop	{r7, pc}

080145a4 <_ZN8XFThread5startEv>:

void XFThread::start()
{
 80145a4:	b580      	push	{r7, lr}
 80145a6:	b082      	sub	sp, #8
 80145a8:	af00      	add	r7, sp, #0
 80145aa:	6078      	str	r0, [r7, #4]
    execute();
 80145ac:	6878      	ldr	r0, [r7, #4]
 80145ae:	f000 f865 	bl	801467c <_ZN8XFThread7executeEv>
}
 80145b2:	bf00      	nop
 80145b4:	3708      	adds	r7, #8
 80145b6:	46bd      	mov	sp, r7
 80145b8:	bd80      	pop	{r7, pc}

080145ba <_ZNK8XFThread17getTimeoutManagerEv>:

XFTimeoutManager * XFThread::getTimeoutManager() const
{
 80145ba:	b580      	push	{r7, lr}
 80145bc:	b082      	sub	sp, #8
 80145be:	af00      	add	r7, sp, #0
 80145c0:	6078      	str	r0, [r7, #4]
    return XFTimeoutManager::getInstance();
 80145c2:	f001 f867 	bl	8015694 <_ZN16XFTimeoutManager11getInstanceEv>
 80145c6:	4603      	mov	r3, r0
}
 80145c8:	4618      	mov	r0, r3
 80145ca:	3708      	adds	r7, #8
 80145cc:	46bd      	mov	sp, r7
 80145ce:	bd80      	pop	{r7, pc}

080145d0 <_ZNK8XFThread13dispatchEventEP8IXFEvent>:
 * Dispatchs the event to the corresponding behavioral part. For example
 * the state machine which sould process the event.
 * \param pEvent The event to dispatch
 */
void XFThread::dispatchEvent(IXFEvent * pEvent) const
{
 80145d0:	b580      	push	{r7, lr}
 80145d2:	b084      	sub	sp, #16
 80145d4:	af00      	add	r7, sp, #0
 80145d6:	6078      	str	r0, [r7, #4]
 80145d8:	6039      	str	r1, [r7, #0]
    EventStatus eventStatus;
 80145da:	f107 030c 	add.w	r3, r7, #12
 80145de:	2100      	movs	r1, #0
 80145e0:	4618      	mov	r0, r3
 80145e2:	f7f2 f9f7 	bl	80069d4 <_ZN11EventStatusC1ENS_12eEventStatusE>

    eventStatus = pEvent->getBehavior()->process(pEvent);
 80145e6:	6838      	ldr	r0, [r7, #0]
 80145e8:	f7ff ff06 	bl	80143f8 <_ZNK8IXFEvent11getBehaviorEv>
 80145ec:	4603      	mov	r3, r0
 80145ee:	681a      	ldr	r2, [r3, #0]
 80145f0:	3210      	adds	r2, #16
 80145f2:	6812      	ldr	r2, [r2, #0]
 80145f4:	6839      	ldr	r1, [r7, #0]
 80145f6:	4618      	mov	r0, r3
 80145f8:	4790      	blx	r2
 80145fa:	4603      	mov	r3, r0
 80145fc:	733b      	strb	r3, [r7, #12]

    // Check if behavior should be deleted
    if (eventStatus == EventStatus::Terminate)
 80145fe:	2304      	movs	r3, #4
 8014600:	73fb      	strb	r3, [r7, #15]
 8014602:	f107 020f 	add.w	r2, r7, #15
 8014606:	f107 030c 	add.w	r3, r7, #12
 801460a:	4611      	mov	r1, r2
 801460c:	4618      	mov	r0, r3
 801460e:	f7ff ff7b 	bl	8014508 <_ZNK11EventStatuseqERKNS_12eEventStatusE>
 8014612:	4603      	mov	r3, r0
 8014614:	2b00      	cmp	r3, #0
 8014616:	d00a      	beq.n	801462e <_ZNK8XFThread13dispatchEventEP8IXFEvent+0x5e>
    {
        delete pEvent->getBehavior();
 8014618:	6838      	ldr	r0, [r7, #0]
 801461a:	f7ff feed 	bl	80143f8 <_ZNK8IXFEvent11getBehaviorEv>
 801461e:	4603      	mov	r3, r0
 8014620:	2b00      	cmp	r3, #0
 8014622:	d004      	beq.n	801462e <_ZNK8XFThread13dispatchEventEP8IXFEvent+0x5e>
 8014624:	681a      	ldr	r2, [r3, #0]
 8014626:	3204      	adds	r2, #4
 8014628:	6812      	ldr	r2, [r2, #0]
 801462a:	4618      	mov	r0, r3
 801462c:	4790      	blx	r2
    }
}
 801462e:	bf00      	nop
 8014630:	3710      	adds	r7, #16
 8014632:	46bd      	mov	sp, r7
 8014634:	bd80      	pop	{r7, pc}

08014636 <_ZN8XFThread9pushEventEP8IXFEvent>:

void XFThread::pushEvent(IXFEvent * pEvent)
{
 8014636:	b580      	push	{r7, lr}
 8014638:	b082      	sub	sp, #8
 801463a:	af00      	add	r7, sp, #0
 801463c:	6078      	str	r0, [r7, #4]
 801463e:	6039      	str	r1, [r7, #0]
    _events.push(pEvent);
 8014640:	687b      	ldr	r3, [r7, #4]
 8014642:	330c      	adds	r3, #12
 8014644:	463a      	mov	r2, r7
 8014646:	4611      	mov	r1, r2
 8014648:	4618      	mov	r0, r3
 801464a:	f000 f8b2 	bl	80147b2 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE4pushERKS1_>
    }

#endif /**************************************************************************************************************/


}
 801464e:	bf00      	nop
 8014650:	3708      	adds	r7, #8
 8014652:	46bd      	mov	sp, r7
 8014654:	bd80      	pop	{r7, pc}

08014656 <_ZN8XFThread15scheduleTimeoutEiiP11IXFReactive>:
/**
 * Adds a new timeout to be handled. The XFThread will forward the timeout
 * information to the timeout manager which is responsible to handle all timeouts.
 */
void XFThread::scheduleTimeout(int timeoutId, int interval, IXFReactive * pReactive)
{
 8014656:	b580      	push	{r7, lr}
 8014658:	b084      	sub	sp, #16
 801465a:	af00      	add	r7, sp, #0
 801465c:	60f8      	str	r0, [r7, #12]
 801465e:	60b9      	str	r1, [r7, #8]
 8014660:	607a      	str	r2, [r7, #4]
 8014662:	603b      	str	r3, [r7, #0]
    // Forward timeout to the timeout manager
    getTimeoutManager()->scheduleTimeout(timeoutId, interval, pReactive);
 8014664:	68f8      	ldr	r0, [r7, #12]
 8014666:	f7ff ffa8 	bl	80145ba <_ZNK8XFThread17getTimeoutManagerEv>
 801466a:	683b      	ldr	r3, [r7, #0]
 801466c:	687a      	ldr	r2, [r7, #4]
 801466e:	68b9      	ldr	r1, [r7, #8]
 8014670:	f001 f849 	bl	8015706 <_ZN16XFTimeoutManager15scheduleTimeoutEiiP11IXFReactive>
}
 8014674:	bf00      	nop
 8014676:	3710      	adds	r7, #16
 8014678:	46bd      	mov	sp, r7
 801467a:	bd80      	pop	{r7, pc}

0801467c <_ZN8XFThread7executeEv>:

/**
 * Main loop of the thread. Implements event loop processing.
 */
void XFThread::execute()
{
 801467c:	b580      	push	{r7, lr}
 801467e:	b084      	sub	sp, #16
 8014680:	af00      	add	r7, sp, #0
 8014682:	6078      	str	r0, [r7, #4]
    while(_bExecuting)
 8014684:	687b      	ldr	r3, [r7, #4]
 8014686:	791b      	ldrb	r3, [r3, #4]
 8014688:	2b00      	cmp	r3, #0
 801468a:	d03b      	beq.n	8014704 <_ZN8XFThread7executeEv+0x88>
    {
        IXFEvent * pEvent;

        while (_events.empty())
 801468c:	687b      	ldr	r3, [r7, #4]
 801468e:	3308      	adds	r3, #8
 8014690:	4618      	mov	r0, r3
 8014692:	f7ff ff2b 	bl	80144ec <_ZN12XFEventQueue5emptyEv>
 8014696:	4603      	mov	r3, r0
 8014698:	2b00      	cmp	r3, #0
 801469a:	d001      	beq.n	80146a0 <_ZN8XFThread7executeEv+0x24>
            killTimer( _tid );
            _tid = -1;
            return;

#endif /**************************************************************************************************************/
            __asm__("NOP");    // Prevent compiler from optimising this loop away
 801469c:	bf00      	nop
        while (_events.empty())
 801469e:	e7f5      	b.n	801468c <_ZN8XFThread7executeEv+0x10>
        }

        // Deque next event from queue
        pEvent = _events.front(); _events.pop();
 80146a0:	687b      	ldr	r3, [r7, #4]
 80146a2:	330c      	adds	r3, #12
 80146a4:	4618      	mov	r0, r3
 80146a6:	f000 f892 	bl	80147ce <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE5frontEv>
 80146aa:	4603      	mov	r3, r0
 80146ac:	681b      	ldr	r3, [r3, #0]
 80146ae:	60fb      	str	r3, [r7, #12]
 80146b0:	687b      	ldr	r3, [r7, #4]
 80146b2:	330c      	adds	r3, #12
 80146b4:	4618      	mov	r0, r3
 80146b6:	f000 f897 	bl	80147e8 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE3popEv>

        if (pEvent)
 80146ba:	68fb      	ldr	r3, [r7, #12]
 80146bc:	2b00      	cmp	r3, #0
 80146be:	d003      	beq.n	80146c8 <_ZN8XFThread7executeEv+0x4c>
        {
            // Forward the event to the behavioral class
            dispatchEvent(pEvent);
 80146c0:	68f9      	ldr	r1, [r7, #12]
 80146c2:	6878      	ldr	r0, [r7, #4]
 80146c4:	f7ff ff84 	bl	80145d0 <_ZNK8XFThread13dispatchEventEP8IXFEvent>
        }

        if (pEvent->getEventType() == IXFEvent::Terminate)
 80146c8:	68f8      	ldr	r0, [r7, #12]
 80146ca:	f7f2 f96a 	bl	80069a2 <_ZNK8IXFEvent12getEventTypeEv>
 80146ce:	4603      	mov	r3, r0
 80146d0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80146d4:	bf0c      	ite	eq
 80146d6:	2301      	moveq	r3, #1
 80146d8:	2300      	movne	r3, #0
 80146da:	b2db      	uxtb	r3, r3
 80146dc:	2b00      	cmp	r3, #0
 80146de:	d002      	beq.n	80146e6 <_ZN8XFThread7executeEv+0x6a>
        {
            // Exit the event loop
            _bExecuting = false;
 80146e0:	687b      	ldr	r3, [r7, #4]
 80146e2:	2200      	movs	r2, #0
 80146e4:	711a      	strb	r2, [r3, #4]
        }

        if (pEvent->shouldDelete())
 80146e6:	68f8      	ldr	r0, [r7, #12]
 80146e8:	f7ff fe92 	bl	8014410 <_ZNK8IXFEvent12shouldDeleteEv>
 80146ec:	4603      	mov	r3, r0
 80146ee:	2b00      	cmp	r3, #0
 80146f0:	d0c8      	beq.n	8014684 <_ZN8XFThread7executeEv+0x8>
        {
            // Delete consumed event
            delete pEvent;
 80146f2:	68fb      	ldr	r3, [r7, #12]
 80146f4:	2b00      	cmp	r3, #0
 80146f6:	d0c5      	beq.n	8014684 <_ZN8XFThread7executeEv+0x8>
 80146f8:	681a      	ldr	r2, [r3, #0]
 80146fa:	3204      	adds	r2, #4
 80146fc:	6812      	ldr	r2, [r2, #0]
 80146fe:	4618      	mov	r0, r3
 8014700:	4790      	blx	r2
    while(_bExecuting)
 8014702:	e7bf      	b.n	8014684 <_ZN8XFThread7executeEv+0x8>
        }
    }
}
 8014704:	bf00      	nop
 8014706:	3710      	adds	r7, #16
 8014708:	46bd      	mov	sp, r7
 801470a:	bd80      	pop	{r7, pc}

0801470c <_ZNSt5dequeIP8IXFEventSaIS1_EEC1Ev>:

      /**
       *  @brief  Creates a %deque with no elements.
       */
#if __cplusplus >= 201103L
      deque() = default;
 801470c:	b580      	push	{r7, lr}
 801470e:	b082      	sub	sp, #8
 8014710:	af00      	add	r7, sp, #0
 8014712:	6078      	str	r0, [r7, #4]
 8014714:	687b      	ldr	r3, [r7, #4]
 8014716:	4618      	mov	r0, r3
 8014718:	f000 f87e 	bl	8014818 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EEC1Ev>
 801471c:	687b      	ldr	r3, [r7, #4]
 801471e:	4618      	mov	r0, r3
 8014720:	3708      	adds	r7, #8
 8014722:	46bd      	mov	sp, r7
 8014724:	bd80      	pop	{r7, pc}

08014726 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEEC1IS4_vEEv>:
      queue(const _Sequence& __c = _Sequence())
      : c(__c) { }
#else
      template<typename _Seq = _Sequence, typename _Requires = typename
	       enable_if<is_default_constructible<_Seq>::value>::type>
	queue()
 8014726:	b580      	push	{r7, lr}
 8014728:	b082      	sub	sp, #8
 801472a:	af00      	add	r7, sp, #0
 801472c:	6078      	str	r0, [r7, #4]
	: c() { }
 801472e:	687b      	ldr	r3, [r7, #4]
 8014730:	4618      	mov	r0, r3
 8014732:	2328      	movs	r3, #40	; 0x28
 8014734:	461a      	mov	r2, r3
 8014736:	2100      	movs	r1, #0
 8014738:	f001 fec4 	bl	80164c4 <memset>
 801473c:	687b      	ldr	r3, [r7, #4]
 801473e:	4618      	mov	r0, r3
 8014740:	f7ff ffe4 	bl	801470c <_ZNSt5dequeIP8IXFEventSaIS1_EEC1Ev>
 8014744:	687b      	ldr	r3, [r7, #4]
 8014746:	4618      	mov	r0, r3
 8014748:	3708      	adds	r7, #8
 801474a:	46bd      	mov	sp, r7
 801474c:	bd80      	pop	{r7, pc}

0801474e <_ZNSt5dequeIP8IXFEventSaIS1_EED1Ev>:
      /**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */
      ~deque()
 801474e:	b580      	push	{r7, lr}
 8014750:	b08a      	sub	sp, #40	; 0x28
 8014752:	af00      	add	r7, sp, #0
 8014754:	6078      	str	r0, [r7, #4]
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
 8014756:	f107 0308 	add.w	r3, r7, #8
 801475a:	6879      	ldr	r1, [r7, #4]
 801475c:	4618      	mov	r0, r3
 801475e:	f000 f88e 	bl	801487e <_ZNSt5dequeIP8IXFEventSaIS1_EE5beginEv>
 8014762:	f107 0318 	add.w	r3, r7, #24
 8014766:	6879      	ldr	r1, [r7, #4]
 8014768:	4618      	mov	r0, r3
 801476a:	f000 f897 	bl	801489c <_ZNSt5dequeIP8IXFEventSaIS1_EE3endEv>
 801476e:	687b      	ldr	r3, [r7, #4]
 8014770:	4618      	mov	r0, r3
 8014772:	f000 f8a2 	bl	80148ba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>
 8014776:	4603      	mov	r3, r0
 8014778:	f107 0218 	add.w	r2, r7, #24
 801477c:	f107 0108 	add.w	r1, r7, #8
 8014780:	6878      	ldr	r0, [r7, #4]
 8014782:	f000 f8c1 	bl	8014908 <_ZNSt5dequeIP8IXFEventSaIS1_EE15_M_destroy_dataESt15_Deque_iteratorIS1_RS1_PS1_ES7_RKS2_>
 8014786:	687b      	ldr	r3, [r7, #4]
 8014788:	4618      	mov	r0, r3
 801478a:	f000 f856 	bl	801483a <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EED1Ev>
 801478e:	687b      	ldr	r3, [r7, #4]
 8014790:	4618      	mov	r0, r3
 8014792:	3728      	adds	r7, #40	; 0x28
 8014794:	46bd      	mov	sp, r7
 8014796:	bd80      	pop	{r7, pc}

08014798 <_ZNKSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE5emptyEv>:

      /**
       *  Returns true if the %queue is empty.
       */
      _GLIBCXX_NODISCARD bool
      empty() const
 8014798:	b580      	push	{r7, lr}
 801479a:	b082      	sub	sp, #8
 801479c:	af00      	add	r7, sp, #0
 801479e:	6078      	str	r0, [r7, #4]
      { return c.empty(); }
 80147a0:	687b      	ldr	r3, [r7, #4]
 80147a2:	4618      	mov	r0, r3
 80147a4:	f000 f8bd 	bl	8014922 <_ZNKSt5dequeIP8IXFEventSaIS1_EE5emptyEv>
 80147a8:	4603      	mov	r3, r0
 80147aa:	4618      	mov	r0, r3
 80147ac:	3708      	adds	r7, #8
 80147ae:	46bd      	mov	sp, r7
 80147b0:	bd80      	pop	{r7, pc}

080147b2 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE4pushERKS1_>:
       *  element at the end of the %queue and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */
      void
      push(const value_type& __x)
 80147b2:	b580      	push	{r7, lr}
 80147b4:	b082      	sub	sp, #8
 80147b6:	af00      	add	r7, sp, #0
 80147b8:	6078      	str	r0, [r7, #4]
 80147ba:	6039      	str	r1, [r7, #0]
      { c.push_back(__x); }
 80147bc:	687b      	ldr	r3, [r7, #4]
 80147be:	6839      	ldr	r1, [r7, #0]
 80147c0:	4618      	mov	r0, r3
 80147c2:	f000 f8c0 	bl	8014946 <_ZNSt5dequeIP8IXFEventSaIS1_EE9push_backERKS1_>
 80147c6:	bf00      	nop
 80147c8:	3708      	adds	r7, #8
 80147ca:	46bd      	mov	sp, r7
 80147cc:	bd80      	pop	{r7, pc}

080147ce <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE5frontEv>:
      front()
 80147ce:	b580      	push	{r7, lr}
 80147d0:	b082      	sub	sp, #8
 80147d2:	af00      	add	r7, sp, #0
 80147d4:	6078      	str	r0, [r7, #4]
	return c.front();
 80147d6:	687b      	ldr	r3, [r7, #4]
 80147d8:	4618      	mov	r0, r3
 80147da:	f000 f8d5 	bl	8014988 <_ZNSt5dequeIP8IXFEventSaIS1_EE5frontEv>
 80147de:	4603      	mov	r3, r0
      }
 80147e0:	4618      	mov	r0, r3
 80147e2:	3708      	adds	r7, #8
 80147e4:	46bd      	mov	sp, r7
 80147e6:	bd80      	pop	{r7, pc}

080147e8 <_ZNSt5queueIP8IXFEventSt5dequeIS1_SaIS1_EEE3popEv>:
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */
      void
      pop()
 80147e8:	b580      	push	{r7, lr}
 80147ea:	b082      	sub	sp, #8
 80147ec:	af00      	add	r7, sp, #0
 80147ee:	6078      	str	r0, [r7, #4]
      {
	__glibcxx_requires_nonempty();
	c.pop_front();
 80147f0:	687b      	ldr	r3, [r7, #4]
 80147f2:	4618      	mov	r0, r3
 80147f4:	f000 f8dc 	bl	80149b0 <_ZNSt5dequeIP8IXFEventSaIS1_EE9pop_frontEv>
      }
 80147f8:	bf00      	nop
 80147fa:	3708      	adds	r7, #8
 80147fc:	46bd      	mov	sp, r7
 80147fe:	bd80      	pop	{r7, pc}

08014800 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE11_Deque_implD1Ev>:
      struct _Deque_impl
 8014800:	b580      	push	{r7, lr}
 8014802:	b082      	sub	sp, #8
 8014804:	af00      	add	r7, sp, #0
 8014806:	6078      	str	r0, [r7, #4]
 8014808:	6878      	ldr	r0, [r7, #4]
 801480a:	f000 f904 	bl	8014a16 <_ZNSaIP8IXFEventED1Ev>
 801480e:	687b      	ldr	r3, [r7, #4]
 8014810:	4618      	mov	r0, r3
 8014812:	3708      	adds	r7, #8
 8014814:	46bd      	mov	sp, r7
 8014816:	bd80      	pop	{r7, pc}

08014818 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EEC1Ev>:
      _Deque_base()
 8014818:	b580      	push	{r7, lr}
 801481a:	b082      	sub	sp, #8
 801481c:	af00      	add	r7, sp, #0
 801481e:	6078      	str	r0, [r7, #4]
      : _M_impl()
 8014820:	687b      	ldr	r3, [r7, #4]
 8014822:	4618      	mov	r0, r3
 8014824:	f000 f8e7 	bl	80149f6 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE11_Deque_implC1Ev>
      { _M_initialize_map(0); }
 8014828:	2100      	movs	r1, #0
 801482a:	6878      	ldr	r0, [r7, #4]
 801482c:	f000 f8ff 	bl	8014a2e <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE17_M_initialize_mapEj>
 8014830:	687b      	ldr	r3, [r7, #4]
 8014832:	4618      	mov	r0, r3
 8014834:	3708      	adds	r7, #8
 8014836:	46bd      	mov	sp, r7
 8014838:	bd80      	pop	{r7, pc}

0801483a <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EED1Ev>:
    _Deque_base<_Tp, _Alloc>::
 801483a:	b580      	push	{r7, lr}
 801483c:	b082      	sub	sp, #8
 801483e:	af00      	add	r7, sp, #0
 8014840:	6078      	str	r0, [r7, #4]
      if (this->_M_impl._M_map)
 8014842:	687b      	ldr	r3, [r7, #4]
 8014844:	681b      	ldr	r3, [r3, #0]
 8014846:	2b00      	cmp	r3, #0
 8014848:	d010      	beq.n	801486c <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EED1Ev+0x32>
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
 801484a:	687b      	ldr	r3, [r7, #4]
 801484c:	6959      	ldr	r1, [r3, #20]
			   this->_M_impl._M_finish._M_node + 1);
 801484e:	687b      	ldr	r3, [r7, #4]
 8014850:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
 8014852:	3304      	adds	r3, #4
 8014854:	461a      	mov	r2, r3
 8014856:	6878      	ldr	r0, [r7, #4]
 8014858:	f000 f94c 	bl	8014af4 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_destroy_nodesEPPS1_S5_>
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 801485c:	687b      	ldr	r3, [r7, #4]
 801485e:	6819      	ldr	r1, [r3, #0]
 8014860:	687b      	ldr	r3, [r7, #4]
 8014862:	685b      	ldr	r3, [r3, #4]
 8014864:	461a      	mov	r2, r3
 8014866:	6878      	ldr	r0, [r7, #4]
 8014868:	f000 f95e 	bl	8014b28 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE17_M_deallocate_mapEPPS1_j>
    }
 801486c:	687b      	ldr	r3, [r7, #4]
 801486e:	4618      	mov	r0, r3
 8014870:	f7ff ffc6 	bl	8014800 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE11_Deque_implD1Ev>
 8014874:	687b      	ldr	r3, [r7, #4]
 8014876:	4618      	mov	r0, r3
 8014878:	3708      	adds	r7, #8
 801487a:	46bd      	mov	sp, r7
 801487c:	bd80      	pop	{r7, pc}

0801487e <_ZNSt5dequeIP8IXFEventSaIS1_EE5beginEv>:
      /**
       *  Returns a read/write iterator that points to the first element in the
       *  %deque.  Iteration is done in ordinary element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
 801487e:	b580      	push	{r7, lr}
 8014880:	b082      	sub	sp, #8
 8014882:	af00      	add	r7, sp, #0
 8014884:	6078      	str	r0, [r7, #4]
 8014886:	6039      	str	r1, [r7, #0]
      { return this->_M_impl._M_start; }
 8014888:	683b      	ldr	r3, [r7, #0]
 801488a:	3308      	adds	r3, #8
 801488c:	4619      	mov	r1, r3
 801488e:	6878      	ldr	r0, [r7, #4]
 8014890:	f000 f81e 	bl	80148d0 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1ERKS4_>
 8014894:	6878      	ldr	r0, [r7, #4]
 8014896:	3708      	adds	r7, #8
 8014898:	46bd      	mov	sp, r7
 801489a:	bd80      	pop	{r7, pc}

0801489c <_ZNSt5dequeIP8IXFEventSaIS1_EE3endEv>:
       *  Returns a read/write iterator that points one past the last
       *  element in the %deque.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
 801489c:	b580      	push	{r7, lr}
 801489e:	b082      	sub	sp, #8
 80148a0:	af00      	add	r7, sp, #0
 80148a2:	6078      	str	r0, [r7, #4]
 80148a4:	6039      	str	r1, [r7, #0]
      { return this->_M_impl._M_finish; }
 80148a6:	683b      	ldr	r3, [r7, #0]
 80148a8:	3318      	adds	r3, #24
 80148aa:	4619      	mov	r1, r3
 80148ac:	6878      	ldr	r0, [r7, #4]
 80148ae:	f000 f80f 	bl	80148d0 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1ERKS4_>
 80148b2:	6878      	ldr	r0, [r7, #4]
 80148b4:	3708      	adds	r7, #8
 80148b6:	46bd      	mov	sp, r7
 80148b8:	bd80      	pop	{r7, pc}

080148ba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>:
      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
 80148ba:	b480      	push	{r7}
 80148bc:	b083      	sub	sp, #12
 80148be:	af00      	add	r7, sp, #0
 80148c0:	6078      	str	r0, [r7, #4]
      { return this->_M_impl; }
 80148c2:	687b      	ldr	r3, [r7, #4]
 80148c4:	4618      	mov	r0, r3
 80148c6:	370c      	adds	r7, #12
 80148c8:	46bd      	mov	sp, r7
 80148ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148ce:	4770      	bx	lr

080148d0 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1ERKS4_>:
      _Deque_iterator(const _Deque_iterator& __x) noexcept
 80148d0:	b480      	push	{r7}
 80148d2:	b083      	sub	sp, #12
 80148d4:	af00      	add	r7, sp, #0
 80148d6:	6078      	str	r0, [r7, #4]
 80148d8:	6039      	str	r1, [r7, #0]
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
 80148da:	683b      	ldr	r3, [r7, #0]
 80148dc:	681a      	ldr	r2, [r3, #0]
	 _M_last(__x._M_last), _M_node(__x._M_node) { }
 80148de:	687b      	ldr	r3, [r7, #4]
 80148e0:	601a      	str	r2, [r3, #0]
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
 80148e2:	683b      	ldr	r3, [r7, #0]
 80148e4:	685a      	ldr	r2, [r3, #4]
	 _M_last(__x._M_last), _M_node(__x._M_node) { }
 80148e6:	687b      	ldr	r3, [r7, #4]
 80148e8:	605a      	str	r2, [r3, #4]
 80148ea:	683b      	ldr	r3, [r7, #0]
 80148ec:	689a      	ldr	r2, [r3, #8]
 80148ee:	687b      	ldr	r3, [r7, #4]
 80148f0:	609a      	str	r2, [r3, #8]
 80148f2:	683b      	ldr	r3, [r7, #0]
 80148f4:	68da      	ldr	r2, [r3, #12]
 80148f6:	687b      	ldr	r3, [r7, #4]
 80148f8:	60da      	str	r2, [r3, #12]
 80148fa:	687b      	ldr	r3, [r7, #4]
 80148fc:	4618      	mov	r0, r3
 80148fe:	370c      	adds	r7, #12
 8014900:	46bd      	mov	sp, r7
 8014902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014906:	4770      	bx	lr

08014908 <_ZNSt5dequeIP8IXFEventSaIS1_EE15_M_destroy_dataESt15_Deque_iteratorIS1_RS1_PS1_ES7_RKS2_>:
	void
	_M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
	{ _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
 8014908:	b480      	push	{r7}
 801490a:	b08d      	sub	sp, #52	; 0x34
 801490c:	af00      	add	r7, sp, #0
 801490e:	60f8      	str	r0, [r7, #12]
 8014910:	60b9      	str	r1, [r7, #8]
 8014912:	607a      	str	r2, [r7, #4]
 8014914:	603b      	str	r3, [r7, #0]
		      const std::allocator<_Tp>&)
      {
	if (!__has_trivial_destructor(value_type))
	  _M_destroy_data_aux(__first, __last);
      }
 8014916:	bf00      	nop
 8014918:	3734      	adds	r7, #52	; 0x34
 801491a:	46bd      	mov	sp, r7
 801491c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014920:	4770      	bx	lr

08014922 <_ZNKSt5dequeIP8IXFEventSaIS1_EE5emptyEv>:
      empty() const _GLIBCXX_NOEXCEPT
 8014922:	b580      	push	{r7, lr}
 8014924:	b082      	sub	sp, #8
 8014926:	af00      	add	r7, sp, #0
 8014928:	6078      	str	r0, [r7, #4]
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
 801492a:	687b      	ldr	r3, [r7, #4]
 801492c:	f103 0218 	add.w	r2, r3, #24
 8014930:	687b      	ldr	r3, [r7, #4]
 8014932:	3308      	adds	r3, #8
 8014934:	4619      	mov	r1, r3
 8014936:	4610      	mov	r0, r2
 8014938:	f000 f912 	bl	8014b60 <_ZSteqRKSt15_Deque_iteratorIP8IXFEventRS1_PS1_ES6_>
 801493c:	4603      	mov	r3, r0
 801493e:	4618      	mov	r0, r3
 8014940:	3708      	adds	r7, #8
 8014942:	46bd      	mov	sp, r7
 8014944:	bd80      	pop	{r7, pc}

08014946 <_ZNSt5dequeIP8IXFEventSaIS1_EE9push_backERKS1_>:
      push_back(const value_type& __x)
 8014946:	b580      	push	{r7, lr}
 8014948:	b082      	sub	sp, #8
 801494a:	af00      	add	r7, sp, #0
 801494c:	6078      	str	r0, [r7, #4]
 801494e:	6039      	str	r1, [r7, #0]
	if (this->_M_impl._M_finish._M_cur
 8014950:	687b      	ldr	r3, [r7, #4]
 8014952:	699a      	ldr	r2, [r3, #24]
	    != this->_M_impl._M_finish._M_last - 1)
 8014954:	687b      	ldr	r3, [r7, #4]
 8014956:	6a1b      	ldr	r3, [r3, #32]
 8014958:	3b04      	subs	r3, #4
	if (this->_M_impl._M_finish._M_cur
 801495a:	429a      	cmp	r2, r3
 801495c:	d00c      	beq.n	8014978 <_ZNSt5dequeIP8IXFEventSaIS1_EE9push_backERKS1_+0x32>
	    _Alloc_traits::construct(this->_M_impl,
 801495e:	6878      	ldr	r0, [r7, #4]
 8014960:	687b      	ldr	r3, [r7, #4]
 8014962:	699b      	ldr	r3, [r3, #24]
 8014964:	683a      	ldr	r2, [r7, #0]
 8014966:	4619      	mov	r1, r3
 8014968:	f000 f90e 	bl	8014b88 <_ZNSt16allocator_traitsISaIP8IXFEventEE9constructIS1_JRKS1_EEEvRS2_PT_DpOT0_>
	    ++this->_M_impl._M_finish._M_cur;
 801496c:	687b      	ldr	r3, [r7, #4]
 801496e:	699b      	ldr	r3, [r3, #24]
 8014970:	1d1a      	adds	r2, r3, #4
 8014972:	687b      	ldr	r3, [r7, #4]
 8014974:	619a      	str	r2, [r3, #24]
      }
 8014976:	e003      	b.n	8014980 <_ZNSt5dequeIP8IXFEventSaIS1_EE9push_backERKS1_+0x3a>
	  _M_push_back_aux(__x);
 8014978:	6839      	ldr	r1, [r7, #0]
 801497a:	6878      	ldr	r0, [r7, #4]
 801497c:	f000 f918 	bl	8014bb0 <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_push_back_auxIJRKS1_EEEvDpOT_>
      }
 8014980:	bf00      	nop
 8014982:	3708      	adds	r7, #8
 8014984:	46bd      	mov	sp, r7
 8014986:	bd80      	pop	{r7, pc}

08014988 <_ZNSt5dequeIP8IXFEventSaIS1_EE5frontEv>:
      front() _GLIBCXX_NOEXCEPT
 8014988:	b580      	push	{r7, lr}
 801498a:	b086      	sub	sp, #24
 801498c:	af00      	add	r7, sp, #0
 801498e:	6078      	str	r0, [r7, #4]
	return *begin();
 8014990:	f107 0308 	add.w	r3, r7, #8
 8014994:	6879      	ldr	r1, [r7, #4]
 8014996:	4618      	mov	r0, r3
 8014998:	f7ff ff71 	bl	801487e <_ZNSt5dequeIP8IXFEventSaIS1_EE5beginEv>
 801499c:	f107 0308 	add.w	r3, r7, #8
 80149a0:	4618      	mov	r0, r3
 80149a2:	f000 f949 	bl	8014c38 <_ZNKSt15_Deque_iteratorIP8IXFEventRS1_PS1_EdeEv>
 80149a6:	4603      	mov	r3, r0
      }
 80149a8:	4618      	mov	r0, r3
 80149aa:	3718      	adds	r7, #24
 80149ac:	46bd      	mov	sp, r7
 80149ae:	bd80      	pop	{r7, pc}

080149b0 <_ZNSt5dequeIP8IXFEventSaIS1_EE9pop_frontEv>:
      pop_front() _GLIBCXX_NOEXCEPT
 80149b0:	b580      	push	{r7, lr}
 80149b2:	b082      	sub	sp, #8
 80149b4:	af00      	add	r7, sp, #0
 80149b6:	6078      	str	r0, [r7, #4]
	if (this->_M_impl._M_start._M_cur
 80149b8:	687b      	ldr	r3, [r7, #4]
 80149ba:	689a      	ldr	r2, [r3, #8]
	    != this->_M_impl._M_start._M_last - 1)
 80149bc:	687b      	ldr	r3, [r7, #4]
 80149be:	691b      	ldr	r3, [r3, #16]
 80149c0:	3b04      	subs	r3, #4
	if (this->_M_impl._M_start._M_cur
 80149c2:	429a      	cmp	r2, r3
 80149c4:	d010      	beq.n	80149e8 <_ZNSt5dequeIP8IXFEventSaIS1_EE9pop_frontEv+0x38>
	    _Alloc_traits::destroy(_M_get_Tp_allocator(),
 80149c6:	687b      	ldr	r3, [r7, #4]
 80149c8:	4618      	mov	r0, r3
 80149ca:	f7ff ff76 	bl	80148ba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>
 80149ce:	4602      	mov	r2, r0
 80149d0:	687b      	ldr	r3, [r7, #4]
 80149d2:	689b      	ldr	r3, [r3, #8]
 80149d4:	4619      	mov	r1, r3
 80149d6:	4610      	mov	r0, r2
 80149d8:	f000 f93a 	bl	8014c50 <_ZNSt16allocator_traitsISaIP8IXFEventEE7destroyIS1_EEvRS2_PT_>
	    ++this->_M_impl._M_start._M_cur;
 80149dc:	687b      	ldr	r3, [r7, #4]
 80149de:	689b      	ldr	r3, [r3, #8]
 80149e0:	1d1a      	adds	r2, r3, #4
 80149e2:	687b      	ldr	r3, [r7, #4]
 80149e4:	609a      	str	r2, [r3, #8]
      }
 80149e6:	e002      	b.n	80149ee <_ZNSt5dequeIP8IXFEventSaIS1_EE9pop_frontEv+0x3e>
	  _M_pop_front_aux();
 80149e8:	6878      	ldr	r0, [r7, #4]
 80149ea:	f000 f93e 	bl	8014c6a <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_pop_front_auxEv>
      }
 80149ee:	bf00      	nop
 80149f0:	3708      	adds	r7, #8
 80149f2:	46bd      	mov	sp, r7
 80149f4:	bd80      	pop	{r7, pc}

080149f6 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE11_Deque_implC1Ev>:
	_Deque_impl() _GLIBCXX_NOEXCEPT_IF(
 80149f6:	b580      	push	{r7, lr}
 80149f8:	b082      	sub	sp, #8
 80149fa:	af00      	add	r7, sp, #0
 80149fc:	6078      	str	r0, [r7, #4]
	: _Tp_alloc_type()
 80149fe:	6878      	ldr	r0, [r7, #4]
 8014a00:	f000 f95b 	bl	8014cba <_ZNSaIP8IXFEventEC1Ev>
 8014a04:	687b      	ldr	r3, [r7, #4]
 8014a06:	4618      	mov	r0, r3
 8014a08:	f000 f963 	bl	8014cd2 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_Deque_impl_dataC1Ev>
	{ }
 8014a0c:	687b      	ldr	r3, [r7, #4]
 8014a0e:	4618      	mov	r0, r3
 8014a10:	3708      	adds	r7, #8
 8014a12:	46bd      	mov	sp, r7
 8014a14:	bd80      	pop	{r7, pc}

08014a16 <_ZNSaIP8IXFEventED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 8014a16:	b580      	push	{r7, lr}
 8014a18:	b082      	sub	sp, #8
 8014a1a:	af00      	add	r7, sp, #0
 8014a1c:	6078      	str	r0, [r7, #4]
 8014a1e:	6878      	ldr	r0, [r7, #4]
 8014a20:	f000 f970 	bl	8014d04 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventED1Ev>
 8014a24:	687b      	ldr	r3, [r7, #4]
 8014a26:	4618      	mov	r0, r3
 8014a28:	3708      	adds	r7, #8
 8014a2a:	46bd      	mov	sp, r7
 8014a2c:	bd80      	pop	{r7, pc}

08014a2e <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE17_M_initialize_mapEj>:
    _Deque_base<_Tp, _Alloc>::
 8014a2e:	b590      	push	{r4, r7, lr}
 8014a30:	b089      	sub	sp, #36	; 0x24
 8014a32:	af00      	add	r7, sp, #0
 8014a34:	6078      	str	r0, [r7, #4]
 8014a36:	6039      	str	r1, [r7, #0]
      const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
 8014a38:	2004      	movs	r0, #4
 8014a3a:	f7ff fcfd 	bl	8014438 <_ZSt16__deque_buf_sizej>
 8014a3e:	4602      	mov	r2, r0
 8014a40:	683b      	ldr	r3, [r7, #0]
 8014a42:	fbb3 f3f2 	udiv	r3, r3, r2
 8014a46:	3301      	adds	r3, #1
 8014a48:	61fb      	str	r3, [r7, #28]
      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
 8014a4a:	2308      	movs	r3, #8
 8014a4c:	60fb      	str	r3, [r7, #12]
					   size_t(__num_nodes + 2));
 8014a4e:	69fb      	ldr	r3, [r7, #28]
 8014a50:	3302      	adds	r3, #2
 8014a52:	613b      	str	r3, [r7, #16]
 8014a54:	f107 0210 	add.w	r2, r7, #16
 8014a58:	f107 030c 	add.w	r3, r7, #12
 8014a5c:	4611      	mov	r1, r2
 8014a5e:	4618      	mov	r0, r3
 8014a60:	f7f5 feb3 	bl	800a7ca <_ZSt3maxIjERKT_S2_S2_>
 8014a64:	4603      	mov	r3, r0
      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
 8014a66:	681a      	ldr	r2, [r3, #0]
 8014a68:	687b      	ldr	r3, [r7, #4]
 8014a6a:	605a      	str	r2, [r3, #4]
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
 8014a6c:	687b      	ldr	r3, [r7, #4]
 8014a6e:	685b      	ldr	r3, [r3, #4]
 8014a70:	4619      	mov	r1, r3
 8014a72:	6878      	ldr	r0, [r7, #4]
 8014a74:	f000 f951 	bl	8014d1a <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_allocate_mapEj>
 8014a78:	4602      	mov	r2, r0
 8014a7a:	687b      	ldr	r3, [r7, #4]
 8014a7c:	601a      	str	r2, [r3, #0]
      _Map_pointer __nstart = (this->_M_impl._M_map
 8014a7e:	687b      	ldr	r3, [r7, #4]
 8014a80:	681a      	ldr	r2, [r3, #0]
			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
 8014a82:	687b      	ldr	r3, [r7, #4]
 8014a84:	6859      	ldr	r1, [r3, #4]
 8014a86:	69fb      	ldr	r3, [r7, #28]
 8014a88:	1acb      	subs	r3, r1, r3
 8014a8a:	085b      	lsrs	r3, r3, #1
 8014a8c:	009b      	lsls	r3, r3, #2
      _Map_pointer __nstart = (this->_M_impl._M_map
 8014a8e:	4413      	add	r3, r2
 8014a90:	61bb      	str	r3, [r7, #24]
      _Map_pointer __nfinish = __nstart + __num_nodes;
 8014a92:	69fb      	ldr	r3, [r7, #28]
 8014a94:	009b      	lsls	r3, r3, #2
 8014a96:	69ba      	ldr	r2, [r7, #24]
 8014a98:	4413      	add	r3, r2
 8014a9a:	617b      	str	r3, [r7, #20]
	{ _M_create_nodes(__nstart, __nfinish); }
 8014a9c:	697a      	ldr	r2, [r7, #20]
 8014a9e:	69b9      	ldr	r1, [r7, #24]
 8014aa0:	6878      	ldr	r0, [r7, #4]
 8014aa2:	f000 f957 	bl	8014d54 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_create_nodesEPPS1_S5_>
      this->_M_impl._M_start._M_set_node(__nstart);
 8014aa6:	687b      	ldr	r3, [r7, #4]
 8014aa8:	3308      	adds	r3, #8
 8014aaa:	69b9      	ldr	r1, [r7, #24]
 8014aac:	4618      	mov	r0, r3
 8014aae:	f000 f96b 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
 8014ab2:	687b      	ldr	r3, [r7, #4]
 8014ab4:	f103 0218 	add.w	r2, r3, #24
 8014ab8:	697b      	ldr	r3, [r7, #20]
 8014aba:	3b04      	subs	r3, #4
 8014abc:	4619      	mov	r1, r3
 8014abe:	4610      	mov	r0, r2
 8014ac0:	f000 f962 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
 8014ac4:	687b      	ldr	r3, [r7, #4]
 8014ac6:	68da      	ldr	r2, [r3, #12]
 8014ac8:	687b      	ldr	r3, [r7, #4]
 8014aca:	609a      	str	r2, [r3, #8]
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
 8014acc:	687b      	ldr	r3, [r7, #4]
 8014ace:	69dc      	ldr	r4, [r3, #28]
					% __deque_buf_size(sizeof(_Tp)));
 8014ad0:	2004      	movs	r0, #4
 8014ad2:	f7ff fcb1 	bl	8014438 <_ZSt16__deque_buf_sizej>
 8014ad6:	4602      	mov	r2, r0
 8014ad8:	683b      	ldr	r3, [r7, #0]
 8014ada:	fbb3 f1f2 	udiv	r1, r3, r2
 8014ade:	fb01 f202 	mul.w	r2, r1, r2
 8014ae2:	1a9b      	subs	r3, r3, r2
					+ __num_elements
 8014ae4:	009b      	lsls	r3, r3, #2
 8014ae6:	18e2      	adds	r2, r4, r3
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
 8014ae8:	687b      	ldr	r3, [r7, #4]
 8014aea:	619a      	str	r2, [r3, #24]
    }
 8014aec:	bf00      	nop
 8014aee:	3724      	adds	r7, #36	; 0x24
 8014af0:	46bd      	mov	sp, r7
 8014af2:	bd90      	pop	{r4, r7, pc}

08014af4 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_destroy_nodesEPPS1_S5_>:
    _Deque_base<_Tp, _Alloc>::
 8014af4:	b580      	push	{r7, lr}
 8014af6:	b086      	sub	sp, #24
 8014af8:	af00      	add	r7, sp, #0
 8014afa:	60f8      	str	r0, [r7, #12]
 8014afc:	60b9      	str	r1, [r7, #8]
 8014afe:	607a      	str	r2, [r7, #4]
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 8014b00:	68bb      	ldr	r3, [r7, #8]
 8014b02:	617b      	str	r3, [r7, #20]
 8014b04:	697a      	ldr	r2, [r7, #20]
 8014b06:	687b      	ldr	r3, [r7, #4]
 8014b08:	429a      	cmp	r2, r3
 8014b0a:	d209      	bcs.n	8014b20 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_destroy_nodesEPPS1_S5_+0x2c>
	_M_deallocate_node(*__n);
 8014b0c:	697b      	ldr	r3, [r7, #20]
 8014b0e:	681b      	ldr	r3, [r3, #0]
 8014b10:	4619      	mov	r1, r3
 8014b12:	68f8      	ldr	r0, [r7, #12]
 8014b14:	f000 f951 	bl	8014dba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE18_M_deallocate_nodeEPS1_>
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 8014b18:	697b      	ldr	r3, [r7, #20]
 8014b1a:	3304      	adds	r3, #4
 8014b1c:	617b      	str	r3, [r7, #20]
 8014b1e:	e7f1      	b.n	8014b04 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_destroy_nodesEPPS1_S5_+0x10>
    }
 8014b20:	bf00      	nop
 8014b22:	3718      	adds	r7, #24
 8014b24:	46bd      	mov	sp, r7
 8014b26:	bd80      	pop	{r7, pc}

08014b28 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE17_M_deallocate_mapEPPS1_j>:
      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
 8014b28:	b580      	push	{r7, lr}
 8014b2a:	b086      	sub	sp, #24
 8014b2c:	af00      	add	r7, sp, #0
 8014b2e:	60f8      	str	r0, [r7, #12]
 8014b30:	60b9      	str	r1, [r7, #8]
 8014b32:	607a      	str	r2, [r7, #4]
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
 8014b34:	f107 0314 	add.w	r3, r7, #20
 8014b38:	68f9      	ldr	r1, [r7, #12]
 8014b3a:	4618      	mov	r0, r3
 8014b3c:	f000 f950 	bl	8014de0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE20_M_get_map_allocatorEv>
	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
 8014b40:	f107 0314 	add.w	r3, r7, #20
 8014b44:	687a      	ldr	r2, [r7, #4]
 8014b46:	68b9      	ldr	r1, [r7, #8]
 8014b48:	4618      	mov	r0, r3
 8014b4a:	f000 f966 	bl	8014e1a <_ZNSt16allocator_traitsISaIPP8IXFEventEE10deallocateERS3_PS2_j>
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
 8014b4e:	f107 0314 	add.w	r3, r7, #20
 8014b52:	4618      	mov	r0, r3
 8014b54:	f000 f955 	bl	8014e02 <_ZNSaIPP8IXFEventED1Ev>
      }
 8014b58:	bf00      	nop
 8014b5a:	3718      	adds	r7, #24
 8014b5c:	46bd      	mov	sp, r7
 8014b5e:	bd80      	pop	{r7, pc}

08014b60 <_ZSteqRKSt15_Deque_iteratorIP8IXFEventRS1_PS1_ES6_>:
      operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 8014b60:	b480      	push	{r7}
 8014b62:	b083      	sub	sp, #12
 8014b64:	af00      	add	r7, sp, #0
 8014b66:	6078      	str	r0, [r7, #4]
 8014b68:	6039      	str	r1, [r7, #0]
      { return __x._M_cur == __y._M_cur; }
 8014b6a:	687b      	ldr	r3, [r7, #4]
 8014b6c:	681a      	ldr	r2, [r3, #0]
 8014b6e:	683b      	ldr	r3, [r7, #0]
 8014b70:	681b      	ldr	r3, [r3, #0]
 8014b72:	429a      	cmp	r2, r3
 8014b74:	bf0c      	ite	eq
 8014b76:	2301      	moveq	r3, #1
 8014b78:	2300      	movne	r3, #0
 8014b7a:	b2db      	uxtb	r3, r3
 8014b7c:	4618      	mov	r0, r3
 8014b7e:	370c      	adds	r7, #12
 8014b80:	46bd      	mov	sp, r7
 8014b82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014b86:	4770      	bx	lr

08014b88 <_ZNSt16allocator_traitsISaIP8IXFEventEE9constructIS1_JRKS1_EEEvRS2_PT_DpOT0_>:
	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
 8014b88:	b580      	push	{r7, lr}
 8014b8a:	b084      	sub	sp, #16
 8014b8c:	af00      	add	r7, sp, #0
 8014b8e:	60f8      	str	r0, [r7, #12]
 8014b90:	60b9      	str	r1, [r7, #8]
 8014b92:	607a      	str	r2, [r7, #4]
	  __a.construct(__p, std::forward<_Args>(__args)...);
 8014b94:	6878      	ldr	r0, [r7, #4]
 8014b96:	f000 f94f 	bl	8014e38 <_ZSt7forwardIRKP8IXFEventEOT_RNSt16remove_referenceIS4_E4typeE>
 8014b9a:	4603      	mov	r3, r0
 8014b9c:	461a      	mov	r2, r3
 8014b9e:	68b9      	ldr	r1, [r7, #8]
 8014ba0:	68f8      	ldr	r0, [r7, #12]
 8014ba2:	f000 f954 	bl	8014e4e <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE9constructIS2_JRKS2_EEEvPT_DpOT0_>
	}
 8014ba6:	bf00      	nop
 8014ba8:	3710      	adds	r7, #16
 8014baa:	46bd      	mov	sp, r7
 8014bac:	bd80      	pop	{r7, pc}
	...

08014bb0 <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_push_back_auxIJRKS1_EEEvDpOT_>:
  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
 8014bb0:	b5b0      	push	{r4, r5, r7, lr}
 8014bb2:	b082      	sub	sp, #8
 8014bb4:	af00      	add	r7, sp, #0
 8014bb6:	6078      	str	r0, [r7, #4]
 8014bb8:	6039      	str	r1, [r7, #0]
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)
#endif
      {
	if (size() == max_size())
 8014bba:	6878      	ldr	r0, [r7, #4]
 8014bbc:	f000 f95d 	bl	8014e7a <_ZNKSt5dequeIP8IXFEventSaIS1_EE4sizeEv>
 8014bc0:	4604      	mov	r4, r0
 8014bc2:	6878      	ldr	r0, [r7, #4]
 8014bc4:	f000 f96b 	bl	8014e9e <_ZNKSt5dequeIP8IXFEventSaIS1_EE8max_sizeEv>
 8014bc8:	4603      	mov	r3, r0
 8014bca:	429c      	cmp	r4, r3
 8014bcc:	bf0c      	ite	eq
 8014bce:	2301      	moveq	r3, #1
 8014bd0:	2300      	movne	r3, #0
 8014bd2:	b2db      	uxtb	r3, r3
 8014bd4:	2b00      	cmp	r3, #0
 8014bd6:	d002      	beq.n	8014bde <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_push_back_auxIJRKS1_EEEvDpOT_+0x2e>
	  __throw_length_error(
 8014bd8:	4816      	ldr	r0, [pc, #88]	; (8014c34 <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_push_back_auxIJRKS1_EEEvDpOT_+0x84>)
 8014bda:	f001 fb24 	bl	8016226 <_ZSt20__throw_length_errorPKc>
	      __N("cannot create std::deque larger than max_size()"));

	_M_reserve_map_at_back();
 8014bde:	2101      	movs	r1, #1
 8014be0:	6878      	ldr	r0, [r7, #4]
 8014be2:	f000 f96d 	bl	8014ec0 <_ZNSt5dequeIP8IXFEventSaIS1_EE22_M_reserve_map_at_backEj>
	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 8014be6:	687a      	ldr	r2, [r7, #4]
 8014be8:	687b      	ldr	r3, [r7, #4]
 8014bea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014bec:	1d1c      	adds	r4, r3, #4
 8014bee:	4610      	mov	r0, r2
 8014bf0:	f000 f981 	bl	8014ef6 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_allocate_nodeEv>
 8014bf4:	4603      	mov	r3, r0
 8014bf6:	6023      	str	r3, [r4, #0]
	__try
	  {
#if __cplusplus >= 201103L
	    _Alloc_traits::construct(this->_M_impl,
 8014bf8:	687c      	ldr	r4, [r7, #4]
 8014bfa:	687b      	ldr	r3, [r7, #4]
 8014bfc:	699d      	ldr	r5, [r3, #24]
 8014bfe:	6838      	ldr	r0, [r7, #0]
 8014c00:	f000 f91a 	bl	8014e38 <_ZSt7forwardIRKP8IXFEventEOT_RNSt16remove_referenceIS4_E4typeE>
 8014c04:	4603      	mov	r3, r0
 8014c06:	461a      	mov	r2, r3
 8014c08:	4629      	mov	r1, r5
 8014c0a:	4620      	mov	r0, r4
 8014c0c:	f7ff ffbc 	bl	8014b88 <_ZNSt16allocator_traitsISaIP8IXFEventEE9constructIS1_JRKS1_EEEvRS2_PT_DpOT0_>
				     this->_M_impl._M_finish._M_cur,
				     std::forward<_Args>(__args)...);
#else
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
#endif
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
 8014c10:	687b      	ldr	r3, [r7, #4]
 8014c12:	f103 0218 	add.w	r2, r3, #24
 8014c16:	687b      	ldr	r3, [r7, #4]
 8014c18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014c1a:	3304      	adds	r3, #4
 8014c1c:	4619      	mov	r1, r3
 8014c1e:	4610      	mov	r0, r2
 8014c20:	f000 f8b2 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
 8014c24:	687b      	ldr	r3, [r7, #4]
 8014c26:	69da      	ldr	r2, [r3, #28]
 8014c28:	687b      	ldr	r3, [r7, #4]
 8014c2a:	619a      	str	r2, [r3, #24]
	__catch(...)
	  {
	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
	    __throw_exception_again;
	  }
      }
 8014c2c:	bf00      	nop
 8014c2e:	3708      	adds	r7, #8
 8014c30:	46bd      	mov	sp, r7
 8014c32:	bdb0      	pop	{r4, r5, r7, pc}
 8014c34:	0801b75c 	.word	0x0801b75c

08014c38 <_ZNKSt15_Deque_iteratorIP8IXFEventRS1_PS1_EdeEv>:
      operator*() const _GLIBCXX_NOEXCEPT
 8014c38:	b480      	push	{r7}
 8014c3a:	b083      	sub	sp, #12
 8014c3c:	af00      	add	r7, sp, #0
 8014c3e:	6078      	str	r0, [r7, #4]
      { return *_M_cur; }
 8014c40:	687b      	ldr	r3, [r7, #4]
 8014c42:	681b      	ldr	r3, [r3, #0]
 8014c44:	4618      	mov	r0, r3
 8014c46:	370c      	adds	r7, #12
 8014c48:	46bd      	mov	sp, r7
 8014c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014c4e:	4770      	bx	lr

08014c50 <_ZNSt16allocator_traitsISaIP8IXFEventEE7destroyIS1_EEvRS2_PT_>:
	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 8014c50:	b580      	push	{r7, lr}
 8014c52:	b082      	sub	sp, #8
 8014c54:	af00      	add	r7, sp, #0
 8014c56:	6078      	str	r0, [r7, #4]
 8014c58:	6039      	str	r1, [r7, #0]
	  __a.destroy(__p);
 8014c5a:	6839      	ldr	r1, [r7, #0]
 8014c5c:	6878      	ldr	r0, [r7, #4]
 8014c5e:	f000 f95c 	bl	8014f1a <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE7destroyIS2_EEvPT_>
	}
 8014c62:	bf00      	nop
 8014c64:	3708      	adds	r7, #8
 8014c66:	46bd      	mov	sp, r7
 8014c68:	bd80      	pop	{r7, pc}

08014c6a <_ZNSt5dequeIP8IXFEventSaIS1_EE16_M_pop_front_auxEv>:
  // Note that if the deque has at least one element (a precondition for this
  // member function), and if
  //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
  // then the deque must have at least two nodes.
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
 8014c6a:	b580      	push	{r7, lr}
 8014c6c:	b082      	sub	sp, #8
 8014c6e:	af00      	add	r7, sp, #0
 8014c70:	6078      	str	r0, [r7, #4]
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
 8014c72:	687b      	ldr	r3, [r7, #4]
 8014c74:	4618      	mov	r0, r3
 8014c76:	f7ff fe20 	bl	80148ba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>
 8014c7a:	4602      	mov	r2, r0
 8014c7c:	687b      	ldr	r3, [r7, #4]
 8014c7e:	689b      	ldr	r3, [r3, #8]
 8014c80:	4619      	mov	r1, r3
 8014c82:	4610      	mov	r0, r2
 8014c84:	f7ff ffe4 	bl	8014c50 <_ZNSt16allocator_traitsISaIP8IXFEventEE7destroyIS1_EEvRS2_PT_>
			     this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
 8014c88:	687a      	ldr	r2, [r7, #4]
 8014c8a:	687b      	ldr	r3, [r7, #4]
 8014c8c:	68db      	ldr	r3, [r3, #12]
 8014c8e:	4619      	mov	r1, r3
 8014c90:	4610      	mov	r0, r2
 8014c92:	f000 f892 	bl	8014dba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE18_M_deallocate_nodeEPS1_>
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
 8014c96:	687b      	ldr	r3, [r7, #4]
 8014c98:	f103 0208 	add.w	r2, r3, #8
 8014c9c:	687b      	ldr	r3, [r7, #4]
 8014c9e:	695b      	ldr	r3, [r3, #20]
 8014ca0:	3304      	adds	r3, #4
 8014ca2:	4619      	mov	r1, r3
 8014ca4:	4610      	mov	r0, r2
 8014ca6:	f000 f86f 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
 8014caa:	687b      	ldr	r3, [r7, #4]
 8014cac:	68da      	ldr	r2, [r3, #12]
 8014cae:	687b      	ldr	r3, [r7, #4]
 8014cb0:	609a      	str	r2, [r3, #8]
    }
 8014cb2:	bf00      	nop
 8014cb4:	3708      	adds	r7, #8
 8014cb6:	46bd      	mov	sp, r7
 8014cb8:	bd80      	pop	{r7, pc}

08014cba <_ZNSaIP8IXFEventEC1Ev>:
      allocator() _GLIBCXX_NOTHROW { }
 8014cba:	b580      	push	{r7, lr}
 8014cbc:	b082      	sub	sp, #8
 8014cbe:	af00      	add	r7, sp, #0
 8014cc0:	6078      	str	r0, [r7, #4]
 8014cc2:	6878      	ldr	r0, [r7, #4]
 8014cc4:	f000 f934 	bl	8014f30 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventEC1Ev>
 8014cc8:	687b      	ldr	r3, [r7, #4]
 8014cca:	4618      	mov	r0, r3
 8014ccc:	3708      	adds	r7, #8
 8014cce:	46bd      	mov	sp, r7
 8014cd0:	bd80      	pop	{r7, pc}

08014cd2 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_Deque_impl_dataC1Ev>:
	_Deque_impl_data() _GLIBCXX_NOEXCEPT
 8014cd2:	b580      	push	{r7, lr}
 8014cd4:	b082      	sub	sp, #8
 8014cd6:	af00      	add	r7, sp, #0
 8014cd8:	6078      	str	r0, [r7, #4]
	: _M_map(), _M_map_size(), _M_start(), _M_finish()
 8014cda:	687b      	ldr	r3, [r7, #4]
 8014cdc:	2200      	movs	r2, #0
 8014cde:	601a      	str	r2, [r3, #0]
 8014ce0:	687b      	ldr	r3, [r7, #4]
 8014ce2:	2200      	movs	r2, #0
 8014ce4:	605a      	str	r2, [r3, #4]
 8014ce6:	687b      	ldr	r3, [r7, #4]
 8014ce8:	3308      	adds	r3, #8
 8014cea:	4618      	mov	r0, r3
 8014cec:	f000 f92b 	bl	8014f46 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1Ev>
 8014cf0:	687b      	ldr	r3, [r7, #4]
 8014cf2:	3318      	adds	r3, #24
 8014cf4:	4618      	mov	r0, r3
 8014cf6:	f000 f926 	bl	8014f46 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1Ev>
	{ }
 8014cfa:	687b      	ldr	r3, [r7, #4]
 8014cfc:	4618      	mov	r0, r3
 8014cfe:	3708      	adds	r7, #8
 8014d00:	46bd      	mov	sp, r7
 8014d02:	bd80      	pop	{r7, pc}

08014d04 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8014d04:	b480      	push	{r7}
 8014d06:	b083      	sub	sp, #12
 8014d08:	af00      	add	r7, sp, #0
 8014d0a:	6078      	str	r0, [r7, #4]
 8014d0c:	687b      	ldr	r3, [r7, #4]
 8014d0e:	4618      	mov	r0, r3
 8014d10:	370c      	adds	r7, #12
 8014d12:	46bd      	mov	sp, r7
 8014d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d18:	4770      	bx	lr

08014d1a <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_allocate_mapEj>:
      _M_allocate_map(size_t __n)
 8014d1a:	b590      	push	{r4, r7, lr}
 8014d1c:	b085      	sub	sp, #20
 8014d1e:	af00      	add	r7, sp, #0
 8014d20:	6078      	str	r0, [r7, #4]
 8014d22:	6039      	str	r1, [r7, #0]
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
 8014d24:	f107 030c 	add.w	r3, r7, #12
 8014d28:	6879      	ldr	r1, [r7, #4]
 8014d2a:	4618      	mov	r0, r3
 8014d2c:	f000 f858 	bl	8014de0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE20_M_get_map_allocatorEv>
	return _Map_alloc_traits::allocate(__map_alloc, __n);
 8014d30:	f107 030c 	add.w	r3, r7, #12
 8014d34:	6839      	ldr	r1, [r7, #0]
 8014d36:	4618      	mov	r0, r3
 8014d38:	f000 f91c 	bl	8014f74 <_ZNSt16allocator_traitsISaIPP8IXFEventEE8allocateERS3_j>
 8014d3c:	4604      	mov	r4, r0
 8014d3e:	bf00      	nop
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
 8014d40:	f107 030c 	add.w	r3, r7, #12
 8014d44:	4618      	mov	r0, r3
 8014d46:	f000 f85c 	bl	8014e02 <_ZNSaIPP8IXFEventED1Ev>
	return _Map_alloc_traits::allocate(__map_alloc, __n);
 8014d4a:	4623      	mov	r3, r4
      }
 8014d4c:	4618      	mov	r0, r3
 8014d4e:	3714      	adds	r7, #20
 8014d50:	46bd      	mov	sp, r7
 8014d52:	bd90      	pop	{r4, r7, pc}

08014d54 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_create_nodesEPPS1_S5_>:
    _Deque_base<_Tp, _Alloc>::
 8014d54:	b580      	push	{r7, lr}
 8014d56:	b086      	sub	sp, #24
 8014d58:	af00      	add	r7, sp, #0
 8014d5a:	60f8      	str	r0, [r7, #12]
 8014d5c:	60b9      	str	r1, [r7, #8]
 8014d5e:	607a      	str	r2, [r7, #4]
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
 8014d60:	68bb      	ldr	r3, [r7, #8]
 8014d62:	617b      	str	r3, [r7, #20]
 8014d64:	697a      	ldr	r2, [r7, #20]
 8014d66:	687b      	ldr	r3, [r7, #4]
 8014d68:	429a      	cmp	r2, r3
 8014d6a:	d209      	bcs.n	8014d80 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_create_nodesEPPS1_S5_+0x2c>
	    *__cur = this->_M_allocate_node();
 8014d6c:	68f8      	ldr	r0, [r7, #12]
 8014d6e:	f000 f8c2 	bl	8014ef6 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_allocate_nodeEv>
 8014d72:	4602      	mov	r2, r0
 8014d74:	697b      	ldr	r3, [r7, #20]
 8014d76:	601a      	str	r2, [r3, #0]
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
 8014d78:	697b      	ldr	r3, [r7, #20]
 8014d7a:	3304      	adds	r3, #4
 8014d7c:	617b      	str	r3, [r7, #20]
 8014d7e:	e7f1      	b.n	8014d64 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_create_nodesEPPS1_S5_+0x10>
    }
 8014d80:	bf00      	nop
 8014d82:	3718      	adds	r7, #24
 8014d84:	46bd      	mov	sp, r7
 8014d86:	bd80      	pop	{r7, pc}

08014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>:
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
 8014d88:	b590      	push	{r4, r7, lr}
 8014d8a:	b083      	sub	sp, #12
 8014d8c:	af00      	add	r7, sp, #0
 8014d8e:	6078      	str	r0, [r7, #4]
 8014d90:	6039      	str	r1, [r7, #0]
	_M_node = __new_node;
 8014d92:	687b      	ldr	r3, [r7, #4]
 8014d94:	683a      	ldr	r2, [r7, #0]
 8014d96:	60da      	str	r2, [r3, #12]
	_M_first = *__new_node;
 8014d98:	683b      	ldr	r3, [r7, #0]
 8014d9a:	681a      	ldr	r2, [r3, #0]
 8014d9c:	687b      	ldr	r3, [r7, #4]
 8014d9e:	605a      	str	r2, [r3, #4]
	_M_last = _M_first + difference_type(_S_buffer_size());
 8014da0:	687b      	ldr	r3, [r7, #4]
 8014da2:	685c      	ldr	r4, [r3, #4]
 8014da4:	f000 f8f5 	bl	8014f92 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E14_S_buffer_sizeEv>
 8014da8:	4603      	mov	r3, r0
 8014daa:	009b      	lsls	r3, r3, #2
 8014dac:	18e2      	adds	r2, r4, r3
 8014dae:	687b      	ldr	r3, [r7, #4]
 8014db0:	609a      	str	r2, [r3, #8]
      }
 8014db2:	bf00      	nop
 8014db4:	370c      	adds	r7, #12
 8014db6:	46bd      	mov	sp, r7
 8014db8:	bd90      	pop	{r4, r7, pc}

08014dba <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE18_M_deallocate_nodeEPS1_>:
      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
 8014dba:	b590      	push	{r4, r7, lr}
 8014dbc:	b083      	sub	sp, #12
 8014dbe:	af00      	add	r7, sp, #0
 8014dc0:	6078      	str	r0, [r7, #4]
 8014dc2:	6039      	str	r1, [r7, #0]
	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
 8014dc4:	687c      	ldr	r4, [r7, #4]
 8014dc6:	2004      	movs	r0, #4
 8014dc8:	f7ff fb36 	bl	8014438 <_ZSt16__deque_buf_sizej>
 8014dcc:	4603      	mov	r3, r0
 8014dce:	461a      	mov	r2, r3
 8014dd0:	6839      	ldr	r1, [r7, #0]
 8014dd2:	4620      	mov	r0, r4
 8014dd4:	f000 f8e5 	bl	8014fa2 <_ZNSt16allocator_traitsISaIP8IXFEventEE10deallocateERS2_PS1_j>
      }
 8014dd8:	bf00      	nop
 8014dda:	370c      	adds	r7, #12
 8014ddc:	46bd      	mov	sp, r7
 8014dde:	bd90      	pop	{r4, r7, pc}

08014de0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE20_M_get_map_allocatorEv>:
      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
 8014de0:	b580      	push	{r7, lr}
 8014de2:	b082      	sub	sp, #8
 8014de4:	af00      	add	r7, sp, #0
 8014de6:	6078      	str	r0, [r7, #4]
 8014de8:	6039      	str	r1, [r7, #0]
      { return _Map_alloc_type(_M_get_Tp_allocator()); }
 8014dea:	6838      	ldr	r0, [r7, #0]
 8014dec:	f000 f8e8 	bl	8014fc0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>
 8014df0:	4603      	mov	r3, r0
 8014df2:	4619      	mov	r1, r3
 8014df4:	6878      	ldr	r0, [r7, #4]
 8014df6:	f000 f8ee 	bl	8014fd6 <_ZNSaIPP8IXFEventEC1IS0_EERKSaIT_E>
 8014dfa:	6878      	ldr	r0, [r7, #4]
 8014dfc:	3708      	adds	r7, #8
 8014dfe:	46bd      	mov	sp, r7
 8014e00:	bd80      	pop	{r7, pc}

08014e02 <_ZNSaIPP8IXFEventED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 8014e02:	b580      	push	{r7, lr}
 8014e04:	b082      	sub	sp, #8
 8014e06:	af00      	add	r7, sp, #0
 8014e08:	6078      	str	r0, [r7, #4]
 8014e0a:	6878      	ldr	r0, [r7, #4]
 8014e0c:	f000 f8f0 	bl	8014ff0 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventED1Ev>
 8014e10:	687b      	ldr	r3, [r7, #4]
 8014e12:	4618      	mov	r0, r3
 8014e14:	3708      	adds	r7, #8
 8014e16:	46bd      	mov	sp, r7
 8014e18:	bd80      	pop	{r7, pc}

08014e1a <_ZNSt16allocator_traitsISaIPP8IXFEventEE10deallocateERS3_PS2_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8014e1a:	b580      	push	{r7, lr}
 8014e1c:	b084      	sub	sp, #16
 8014e1e:	af00      	add	r7, sp, #0
 8014e20:	60f8      	str	r0, [r7, #12]
 8014e22:	60b9      	str	r1, [r7, #8]
 8014e24:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 8014e26:	687a      	ldr	r2, [r7, #4]
 8014e28:	68b9      	ldr	r1, [r7, #8]
 8014e2a:	68f8      	ldr	r0, [r7, #12]
 8014e2c:	f000 f8eb 	bl	8015006 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventE10deallocateEPS3_j>
 8014e30:	bf00      	nop
 8014e32:	3710      	adds	r7, #16
 8014e34:	46bd      	mov	sp, r7
 8014e36:	bd80      	pop	{r7, pc}

08014e38 <_ZSt7forwardIRKP8IXFEventEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 8014e38:	b480      	push	{r7}
 8014e3a:	b083      	sub	sp, #12
 8014e3c:	af00      	add	r7, sp, #0
 8014e3e:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 8014e40:	687b      	ldr	r3, [r7, #4]
 8014e42:	4618      	mov	r0, r3
 8014e44:	370c      	adds	r7, #12
 8014e46:	46bd      	mov	sp, r7
 8014e48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e4c:	4770      	bx	lr

08014e4e <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE9constructIS2_JRKS2_EEEvPT_DpOT0_>:
	construct(_Up* __p, _Args&&... __args)
 8014e4e:	b590      	push	{r4, r7, lr}
 8014e50:	b085      	sub	sp, #20
 8014e52:	af00      	add	r7, sp, #0
 8014e54:	60f8      	str	r0, [r7, #12]
 8014e56:	60b9      	str	r1, [r7, #8]
 8014e58:	607a      	str	r2, [r7, #4]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 8014e5a:	6878      	ldr	r0, [r7, #4]
 8014e5c:	f7ff ffec 	bl	8014e38 <_ZSt7forwardIRKP8IXFEventEOT_RNSt16remove_referenceIS4_E4typeE>
 8014e60:	4603      	mov	r3, r0
 8014e62:	681c      	ldr	r4, [r3, #0]
 8014e64:	68bb      	ldr	r3, [r7, #8]
 8014e66:	4619      	mov	r1, r3
 8014e68:	2004      	movs	r0, #4
 8014e6a:	f7f2 fc4d 	bl	8007708 <_ZnwjPv>
 8014e6e:	4603      	mov	r3, r0
 8014e70:	601c      	str	r4, [r3, #0]
 8014e72:	bf00      	nop
 8014e74:	3714      	adds	r7, #20
 8014e76:	46bd      	mov	sp, r7
 8014e78:	bd90      	pop	{r4, r7, pc}

08014e7a <_ZNKSt5dequeIP8IXFEventSaIS1_EE4sizeEv>:
      size() const _GLIBCXX_NOEXCEPT
 8014e7a:	b580      	push	{r7, lr}
 8014e7c:	b082      	sub	sp, #8
 8014e7e:	af00      	add	r7, sp, #0
 8014e80:	6078      	str	r0, [r7, #4]
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
 8014e82:	687b      	ldr	r3, [r7, #4]
 8014e84:	f103 0218 	add.w	r2, r3, #24
 8014e88:	687b      	ldr	r3, [r7, #4]
 8014e8a:	3308      	adds	r3, #8
 8014e8c:	4619      	mov	r1, r3
 8014e8e:	4610      	mov	r0, r2
 8014e90:	f000 f8c9 	bl	8015026 <_ZStmiRKSt15_Deque_iteratorIP8IXFEventRS1_PS1_ES6_>
 8014e94:	4603      	mov	r3, r0
 8014e96:	4618      	mov	r0, r3
 8014e98:	3708      	adds	r7, #8
 8014e9a:	46bd      	mov	sp, r7
 8014e9c:	bd80      	pop	{r7, pc}

08014e9e <_ZNKSt5dequeIP8IXFEventSaIS1_EE8max_sizeEv>:
      max_size() const _GLIBCXX_NOEXCEPT
 8014e9e:	b580      	push	{r7, lr}
 8014ea0:	b082      	sub	sp, #8
 8014ea2:	af00      	add	r7, sp, #0
 8014ea4:	6078      	str	r0, [r7, #4]
      { return _S_max_size(_M_get_Tp_allocator()); }
 8014ea6:	687b      	ldr	r3, [r7, #4]
 8014ea8:	4618      	mov	r0, r3
 8014eaa:	f000 f889 	bl	8014fc0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>
 8014eae:	4603      	mov	r3, r0
 8014eb0:	4618      	mov	r0, r3
 8014eb2:	f000 f8dc 	bl	801506e <_ZNSt5dequeIP8IXFEventSaIS1_EE11_S_max_sizeERKS2_>
 8014eb6:	4603      	mov	r3, r0
 8014eb8:	4618      	mov	r0, r3
 8014eba:	3708      	adds	r7, #8
 8014ebc:	46bd      	mov	sp, r7
 8014ebe:	bd80      	pop	{r7, pc}

08014ec0 <_ZNSt5dequeIP8IXFEventSaIS1_EE22_M_reserve_map_at_backEj>:
       *  Makes sure the _M_map has space for new nodes.  Does not
       *  actually add the nodes.  Can invalidate _M_map pointers.
       *  (And consequently, %deque iterators.)
       */
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
 8014ec0:	b580      	push	{r7, lr}
 8014ec2:	b082      	sub	sp, #8
 8014ec4:	af00      	add	r7, sp, #0
 8014ec6:	6078      	str	r0, [r7, #4]
 8014ec8:	6039      	str	r1, [r7, #0]
      {
	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
 8014eca:	683b      	ldr	r3, [r7, #0]
 8014ecc:	1c5a      	adds	r2, r3, #1
 8014ece:	687b      	ldr	r3, [r7, #4]
 8014ed0:	685b      	ldr	r3, [r3, #4]
	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
 8014ed2:	6879      	ldr	r1, [r7, #4]
 8014ed4:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8014ed6:	6879      	ldr	r1, [r7, #4]
 8014ed8:	6809      	ldr	r1, [r1, #0]
 8014eda:	1a41      	subs	r1, r0, r1
 8014edc:	1089      	asrs	r1, r1, #2
 8014ede:	1a5b      	subs	r3, r3, r1
	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
 8014ee0:	429a      	cmp	r2, r3
 8014ee2:	d904      	bls.n	8014eee <_ZNSt5dequeIP8IXFEventSaIS1_EE22_M_reserve_map_at_backEj+0x2e>
	  _M_reallocate_map(__nodes_to_add, false);
 8014ee4:	2200      	movs	r2, #0
 8014ee6:	6839      	ldr	r1, [r7, #0]
 8014ee8:	6878      	ldr	r0, [r7, #4]
 8014eea:	f000 f8da 	bl	80150a2 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb>
      }
 8014eee:	bf00      	nop
 8014ef0:	3708      	adds	r7, #8
 8014ef2:	46bd      	mov	sp, r7
 8014ef4:	bd80      	pop	{r7, pc}

08014ef6 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE16_M_allocate_nodeEv>:
      _M_allocate_node()
 8014ef6:	b590      	push	{r4, r7, lr}
 8014ef8:	b083      	sub	sp, #12
 8014efa:	af00      	add	r7, sp, #0
 8014efc:	6078      	str	r0, [r7, #4]
	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
 8014efe:	687c      	ldr	r4, [r7, #4]
 8014f00:	2004      	movs	r0, #4
 8014f02:	f7ff fa99 	bl	8014438 <_ZSt16__deque_buf_sizej>
 8014f06:	4603      	mov	r3, r0
 8014f08:	4619      	mov	r1, r3
 8014f0a:	4620      	mov	r0, r4
 8014f0c:	f000 f963 	bl	80151d6 <_ZNSt16allocator_traitsISaIP8IXFEventEE8allocateERS2_j>
 8014f10:	4603      	mov	r3, r0
      }
 8014f12:	4618      	mov	r0, r3
 8014f14:	370c      	adds	r7, #12
 8014f16:	46bd      	mov	sp, r7
 8014f18:	bd90      	pop	{r4, r7, pc}

08014f1a <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE7destroyIS2_EEvPT_>:
	destroy(_Up* __p)
 8014f1a:	b480      	push	{r7}
 8014f1c:	b083      	sub	sp, #12
 8014f1e:	af00      	add	r7, sp, #0
 8014f20:	6078      	str	r0, [r7, #4]
 8014f22:	6039      	str	r1, [r7, #0]
	{ __p->~_Up(); }
 8014f24:	bf00      	nop
 8014f26:	370c      	adds	r7, #12
 8014f28:	46bd      	mov	sp, r7
 8014f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f2e:	4770      	bx	lr

08014f30 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8014f30:	b480      	push	{r7}
 8014f32:	b083      	sub	sp, #12
 8014f34:	af00      	add	r7, sp, #0
 8014f36:	6078      	str	r0, [r7, #4]
 8014f38:	687b      	ldr	r3, [r7, #4]
 8014f3a:	4618      	mov	r0, r3
 8014f3c:	370c      	adds	r7, #12
 8014f3e:	46bd      	mov	sp, r7
 8014f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f44:	4770      	bx	lr

08014f46 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_EC1Ev>:
      _Deque_iterator() _GLIBCXX_NOEXCEPT
 8014f46:	b480      	push	{r7}
 8014f48:	b083      	sub	sp, #12
 8014f4a:	af00      	add	r7, sp, #0
 8014f4c:	6078      	str	r0, [r7, #4]
      : _M_cur(), _M_first(), _M_last(), _M_node() { }
 8014f4e:	687b      	ldr	r3, [r7, #4]
 8014f50:	2200      	movs	r2, #0
 8014f52:	601a      	str	r2, [r3, #0]
 8014f54:	687b      	ldr	r3, [r7, #4]
 8014f56:	2200      	movs	r2, #0
 8014f58:	605a      	str	r2, [r3, #4]
 8014f5a:	687b      	ldr	r3, [r7, #4]
 8014f5c:	2200      	movs	r2, #0
 8014f5e:	609a      	str	r2, [r3, #8]
 8014f60:	687b      	ldr	r3, [r7, #4]
 8014f62:	2200      	movs	r2, #0
 8014f64:	60da      	str	r2, [r3, #12]
 8014f66:	687b      	ldr	r3, [r7, #4]
 8014f68:	4618      	mov	r0, r3
 8014f6a:	370c      	adds	r7, #12
 8014f6c:	46bd      	mov	sp, r7
 8014f6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f72:	4770      	bx	lr

08014f74 <_ZNSt16allocator_traitsISaIPP8IXFEventEE8allocateERS3_j>:
      allocate(allocator_type& __a, size_type __n)
 8014f74:	b580      	push	{r7, lr}
 8014f76:	b082      	sub	sp, #8
 8014f78:	af00      	add	r7, sp, #0
 8014f7a:	6078      	str	r0, [r7, #4]
 8014f7c:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 8014f7e:	2200      	movs	r2, #0
 8014f80:	6839      	ldr	r1, [r7, #0]
 8014f82:	6878      	ldr	r0, [r7, #4]
 8014f84:	f000 f936 	bl	80151f4 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventE8allocateEjPKv>
 8014f88:	4603      	mov	r3, r0
 8014f8a:	4618      	mov	r0, r3
 8014f8c:	3708      	adds	r7, #8
 8014f8e:	46bd      	mov	sp, r7
 8014f90:	bd80      	pop	{r7, pc}

08014f92 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E14_S_buffer_sizeEv>:
      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
 8014f92:	b580      	push	{r7, lr}
 8014f94:	af00      	add	r7, sp, #0
      { return __deque_buf_size(sizeof(_Tp)); }
 8014f96:	2004      	movs	r0, #4
 8014f98:	f7ff fa4e 	bl	8014438 <_ZSt16__deque_buf_sizej>
 8014f9c:	4603      	mov	r3, r0
 8014f9e:	4618      	mov	r0, r3
 8014fa0:	bd80      	pop	{r7, pc}

08014fa2 <_ZNSt16allocator_traitsISaIP8IXFEventEE10deallocateERS2_PS1_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8014fa2:	b580      	push	{r7, lr}
 8014fa4:	b084      	sub	sp, #16
 8014fa6:	af00      	add	r7, sp, #0
 8014fa8:	60f8      	str	r0, [r7, #12]
 8014faa:	60b9      	str	r1, [r7, #8]
 8014fac:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 8014fae:	687a      	ldr	r2, [r7, #4]
 8014fb0:	68b9      	ldr	r1, [r7, #8]
 8014fb2:	68f8      	ldr	r0, [r7, #12]
 8014fb4:	f000 f93c 	bl	8015230 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE10deallocateEPS2_j>
 8014fb8:	bf00      	nop
 8014fba:	3710      	adds	r7, #16
 8014fbc:	46bd      	mov	sp, r7
 8014fbe:	bd80      	pop	{r7, pc}

08014fc0 <_ZNKSt11_Deque_baseIP8IXFEventSaIS1_EE19_M_get_Tp_allocatorEv>:
      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
 8014fc0:	b480      	push	{r7}
 8014fc2:	b083      	sub	sp, #12
 8014fc4:	af00      	add	r7, sp, #0
 8014fc6:	6078      	str	r0, [r7, #4]
      { return this->_M_impl; }
 8014fc8:	687b      	ldr	r3, [r7, #4]
 8014fca:	4618      	mov	r0, r3
 8014fcc:	370c      	adds	r7, #12
 8014fce:	46bd      	mov	sp, r7
 8014fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014fd4:	4770      	bx	lr

08014fd6 <_ZNSaIPP8IXFEventEC1IS0_EERKSaIT_E>:
	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
 8014fd6:	b580      	push	{r7, lr}
 8014fd8:	b082      	sub	sp, #8
 8014fda:	af00      	add	r7, sp, #0
 8014fdc:	6078      	str	r0, [r7, #4]
 8014fde:	6039      	str	r1, [r7, #0]
 8014fe0:	6878      	ldr	r0, [r7, #4]
 8014fe2:	f000 f935 	bl	8015250 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventEC1Ev>
 8014fe6:	687b      	ldr	r3, [r7, #4]
 8014fe8:	4618      	mov	r0, r3
 8014fea:	3708      	adds	r7, #8
 8014fec:	46bd      	mov	sp, r7
 8014fee:	bd80      	pop	{r7, pc}

08014ff0 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8014ff0:	b480      	push	{r7}
 8014ff2:	b083      	sub	sp, #12
 8014ff4:	af00      	add	r7, sp, #0
 8014ff6:	6078      	str	r0, [r7, #4]
 8014ff8:	687b      	ldr	r3, [r7, #4]
 8014ffa:	4618      	mov	r0, r3
 8014ffc:	370c      	adds	r7, #12
 8014ffe:	46bd      	mov	sp, r7
 8015000:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015004:	4770      	bx	lr

08015006 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventE10deallocateEPS3_j>:
      deallocate(_Tp* __p, size_type __t)
 8015006:	b580      	push	{r7, lr}
 8015008:	b084      	sub	sp, #16
 801500a:	af00      	add	r7, sp, #0
 801500c:	60f8      	str	r0, [r7, #12]
 801500e:	60b9      	str	r1, [r7, #8]
 8015010:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 8015012:	687b      	ldr	r3, [r7, #4]
 8015014:	009b      	lsls	r3, r3, #2
 8015016:	4619      	mov	r1, r3
 8015018:	68b8      	ldr	r0, [r7, #8]
 801501a:	f001 f8c7 	bl	80161ac <_ZdlPvj>
      }
 801501e:	bf00      	nop
 8015020:	3710      	adds	r7, #16
 8015022:	46bd      	mov	sp, r7
 8015024:	bd80      	pop	{r7, pc}

08015026 <_ZStmiRKSt15_Deque_iteratorIP8IXFEventRS1_PS1_ES6_>:
      operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 8015026:	b580      	push	{r7, lr}
 8015028:	b082      	sub	sp, #8
 801502a:	af00      	add	r7, sp, #0
 801502c:	6078      	str	r0, [r7, #4]
 801502e:	6039      	str	r1, [r7, #0]
	return difference_type(_S_buffer_size())
 8015030:	f7ff ffaf 	bl	8014f92 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E14_S_buffer_sizeEv>
 8015034:	4603      	mov	r3, r0
 8015036:	4619      	mov	r1, r3
	  * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 8015038:	687b      	ldr	r3, [r7, #4]
 801503a:	68da      	ldr	r2, [r3, #12]
 801503c:	683b      	ldr	r3, [r7, #0]
 801503e:	68db      	ldr	r3, [r3, #12]
 8015040:	1ad3      	subs	r3, r2, r3
 8015042:	109b      	asrs	r3, r3, #2
 8015044:	3b01      	subs	r3, #1
 8015046:	fb01 f303 	mul.w	r3, r1, r3
 801504a:	687a      	ldr	r2, [r7, #4]
 801504c:	6811      	ldr	r1, [r2, #0]
 801504e:	687a      	ldr	r2, [r7, #4]
 8015050:	6852      	ldr	r2, [r2, #4]
 8015052:	1a8a      	subs	r2, r1, r2
 8015054:	1092      	asrs	r2, r2, #2
 8015056:	4413      	add	r3, r2
	  + (__y._M_last - __y._M_cur);
 8015058:	683a      	ldr	r2, [r7, #0]
 801505a:	6891      	ldr	r1, [r2, #8]
 801505c:	683a      	ldr	r2, [r7, #0]
 801505e:	6812      	ldr	r2, [r2, #0]
 8015060:	1a8a      	subs	r2, r1, r2
 8015062:	1092      	asrs	r2, r2, #2
 8015064:	4413      	add	r3, r2
      }
 8015066:	4618      	mov	r0, r3
 8015068:	3708      	adds	r7, #8
 801506a:	46bd      	mov	sp, r7
 801506c:	bd80      	pop	{r7, pc}

0801506e <_ZNSt5dequeIP8IXFEventSaIS1_EE11_S_max_sizeERKS2_>:
      _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
 801506e:	b580      	push	{r7, lr}
 8015070:	b084      	sub	sp, #16
 8015072:	af00      	add	r7, sp, #0
 8015074:	6078      	str	r0, [r7, #4]
	const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;
 8015076:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801507a:	60fb      	str	r3, [r7, #12]
	const size_t __allocmax = _Alloc_traits::max_size(__a);
 801507c:	6878      	ldr	r0, [r7, #4]
 801507e:	f000 f8f2 	bl	8015266 <_ZNSt16allocator_traitsISaIP8IXFEventEE8max_sizeERKS2_>
 8015082:	4603      	mov	r3, r0
 8015084:	60bb      	str	r3, [r7, #8]
	return (std::min)(__diffmax, __allocmax);
 8015086:	f107 0208 	add.w	r2, r7, #8
 801508a:	f107 030c 	add.w	r3, r7, #12
 801508e:	4611      	mov	r1, r2
 8015090:	4618      	mov	r0, r3
 8015092:	f7f5 fc74 	bl	800a97e <_ZSt3minIjERKT_S2_S2_>
 8015096:	4603      	mov	r3, r0
 8015098:	681b      	ldr	r3, [r3, #0]
      }
 801509a:	4618      	mov	r0, r3
 801509c:	3710      	adds	r7, #16
 801509e:	46bd      	mov	sp, r7
 80150a0:	bd80      	pop	{r7, pc}

080150a2 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb>:
	}
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
 80150a2:	b590      	push	{r4, r7, lr}
 80150a4:	b08b      	sub	sp, #44	; 0x2c
 80150a6:	af00      	add	r7, sp, #0
 80150a8:	60f8      	str	r0, [r7, #12]
 80150aa:	60b9      	str	r1, [r7, #8]
 80150ac:	4613      	mov	r3, r2
 80150ae:	71fb      	strb	r3, [r7, #7]
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
 80150b0:	68fb      	ldr	r3, [r7, #12]
 80150b2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80150b4:	68fb      	ldr	r3, [r7, #12]
 80150b6:	695b      	ldr	r3, [r3, #20]
 80150b8:	1ad3      	subs	r3, r2, r3
 80150ba:	109b      	asrs	r3, r3, #2
 80150bc:	3301      	adds	r3, #1
      const size_type __old_num_nodes
 80150be:	623b      	str	r3, [r7, #32]
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
 80150c0:	68bb      	ldr	r3, [r7, #8]
 80150c2:	6a3a      	ldr	r2, [r7, #32]
 80150c4:	4413      	add	r3, r2
 80150c6:	61fb      	str	r3, [r7, #28]

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 80150c8:	68fb      	ldr	r3, [r7, #12]
 80150ca:	685a      	ldr	r2, [r3, #4]
 80150cc:	69fb      	ldr	r3, [r7, #28]
 80150ce:	005b      	lsls	r3, r3, #1
 80150d0:	429a      	cmp	r2, r3
 80150d2:	d92d      	bls.n	8015130 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x8e>
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
 80150d4:	68fb      	ldr	r3, [r7, #12]
 80150d6:	681a      	ldr	r2, [r3, #0]
 80150d8:	68fb      	ldr	r3, [r7, #12]
 80150da:	6859      	ldr	r1, [r3, #4]
					 - __new_num_nodes) / 2
 80150dc:	69fb      	ldr	r3, [r7, #28]
 80150de:	1acb      	subs	r3, r1, r3
 80150e0:	085b      	lsrs	r3, r3, #1
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
 80150e2:	0099      	lsls	r1, r3, #2
			 + (__add_at_front ? __nodes_to_add : 0);
 80150e4:	79fb      	ldrb	r3, [r7, #7]
 80150e6:	2b00      	cmp	r3, #0
 80150e8:	d002      	beq.n	80150f0 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x4e>
 80150ea:	68bb      	ldr	r3, [r7, #8]
 80150ec:	009b      	lsls	r3, r3, #2
 80150ee:	e000      	b.n	80150f2 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x50>
 80150f0:	2300      	movs	r3, #0
 80150f2:	440b      	add	r3, r1
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
 80150f4:	4413      	add	r3, r2
 80150f6:	627b      	str	r3, [r7, #36]	; 0x24
	  if (__new_nstart < this->_M_impl._M_start._M_node)
 80150f8:	68fb      	ldr	r3, [r7, #12]
 80150fa:	695b      	ldr	r3, [r3, #20]
 80150fc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80150fe:	429a      	cmp	r2, r3
 8015100:	d209      	bcs.n	8015116 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x74>
	    std::copy(this->_M_impl._M_start._M_node,
 8015102:	68fb      	ldr	r3, [r7, #12]
 8015104:	6958      	ldr	r0, [r3, #20]
		      this->_M_impl._M_finish._M_node + 1,
 8015106:	68fb      	ldr	r3, [r7, #12]
 8015108:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	    std::copy(this->_M_impl._M_start._M_node,
 801510a:	3304      	adds	r3, #4
 801510c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801510e:	4619      	mov	r1, r3
 8015110:	f000 f8b5 	bl	801527e <_ZSt4copyIPPP8IXFEventS3_ET0_T_S5_S4_>
 8015114:	e048      	b.n	80151a8 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x106>
		      __new_nstart);
	  else
	    std::copy_backward(this->_M_impl._M_start._M_node,
 8015116:	68fb      	ldr	r3, [r7, #12]
 8015118:	6958      	ldr	r0, [r3, #20]
			       this->_M_impl._M_finish._M_node + 1,
 801511a:	68fb      	ldr	r3, [r7, #12]
 801511c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	    std::copy_backward(this->_M_impl._M_start._M_node,
 801511e:	1d19      	adds	r1, r3, #4
			       __new_nstart + __old_num_nodes);
 8015120:	6a3b      	ldr	r3, [r7, #32]
 8015122:	009b      	lsls	r3, r3, #2
	    std::copy_backward(this->_M_impl._M_start._M_node,
 8015124:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015126:	4413      	add	r3, r2
 8015128:	461a      	mov	r2, r3
 801512a:	f000 f8c0 	bl	80152ae <_ZSt13copy_backwardIPPP8IXFEventS3_ET0_T_S5_S4_>
 801512e:	e03b      	b.n	80151a8 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0x106>
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
 8015130:	68fb      	ldr	r3, [r7, #12]
 8015132:	685c      	ldr	r4, [r3, #4]
				     + std::max(this->_M_impl._M_map_size,
 8015134:	68fb      	ldr	r3, [r7, #12]
 8015136:	3304      	adds	r3, #4
 8015138:	f107 0208 	add.w	r2, r7, #8
 801513c:	4611      	mov	r1, r2
 801513e:	4618      	mov	r0, r3
 8015140:	f7f5 fb43 	bl	800a7ca <_ZSt3maxIjERKT_S2_S2_>
 8015144:	4603      	mov	r3, r0
 8015146:	681b      	ldr	r3, [r3, #0]
 8015148:	4423      	add	r3, r4
	  size_type __new_map_size = this->_M_impl._M_map_size
 801514a:	3302      	adds	r3, #2
 801514c:	61bb      	str	r3, [r7, #24]
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
 801514e:	68fb      	ldr	r3, [r7, #12]
 8015150:	69b9      	ldr	r1, [r7, #24]
 8015152:	4618      	mov	r0, r3
 8015154:	f7ff fde1 	bl	8014d1a <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE15_M_allocate_mapEj>
 8015158:	6178      	str	r0, [r7, #20]
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
 801515a:	69ba      	ldr	r2, [r7, #24]
 801515c:	69fb      	ldr	r3, [r7, #28]
 801515e:	1ad3      	subs	r3, r2, r3
 8015160:	085b      	lsrs	r3, r3, #1
 8015162:	009a      	lsls	r2, r3, #2
			 + (__add_at_front ? __nodes_to_add : 0);
 8015164:	79fb      	ldrb	r3, [r7, #7]
 8015166:	2b00      	cmp	r3, #0
 8015168:	d002      	beq.n	8015170 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0xce>
 801516a:	68bb      	ldr	r3, [r7, #8]
 801516c:	009b      	lsls	r3, r3, #2
 801516e:	e000      	b.n	8015172 <_ZNSt5dequeIP8IXFEventSaIS1_EE17_M_reallocate_mapEjb+0xd0>
 8015170:	2300      	movs	r3, #0
 8015172:	4413      	add	r3, r2
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
 8015174:	697a      	ldr	r2, [r7, #20]
 8015176:	4413      	add	r3, r2
 8015178:	627b      	str	r3, [r7, #36]	; 0x24
	  std::copy(this->_M_impl._M_start._M_node,
 801517a:	68fb      	ldr	r3, [r7, #12]
 801517c:	6958      	ldr	r0, [r3, #20]
		    this->_M_impl._M_finish._M_node + 1,
 801517e:	68fb      	ldr	r3, [r7, #12]
 8015180:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	  std::copy(this->_M_impl._M_start._M_node,
 8015182:	3304      	adds	r3, #4
 8015184:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015186:	4619      	mov	r1, r3
 8015188:	f000 f879 	bl	801527e <_ZSt4copyIPPP8IXFEventS3_ET0_T_S5_S4_>
		    __new_nstart);
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 801518c:	68f8      	ldr	r0, [r7, #12]
 801518e:	68fb      	ldr	r3, [r7, #12]
 8015190:	6819      	ldr	r1, [r3, #0]
 8015192:	68fb      	ldr	r3, [r7, #12]
 8015194:	685b      	ldr	r3, [r3, #4]
 8015196:	461a      	mov	r2, r3
 8015198:	f7ff fcc6 	bl	8014b28 <_ZNSt11_Deque_baseIP8IXFEventSaIS1_EE17_M_deallocate_mapEPPS1_j>

	  this->_M_impl._M_map = __new_map;
 801519c:	68fb      	ldr	r3, [r7, #12]
 801519e:	697a      	ldr	r2, [r7, #20]
 80151a0:	601a      	str	r2, [r3, #0]
	  this->_M_impl._M_map_size = __new_map_size;
 80151a2:	68fb      	ldr	r3, [r7, #12]
 80151a4:	69ba      	ldr	r2, [r7, #24]
 80151a6:	605a      	str	r2, [r3, #4]
	}

      this->_M_impl._M_start._M_set_node(__new_nstart);
 80151a8:	68fb      	ldr	r3, [r7, #12]
 80151aa:	3308      	adds	r3, #8
 80151ac:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80151ae:	4618      	mov	r0, r3
 80151b0:	f7ff fdea 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
 80151b4:	68fb      	ldr	r3, [r7, #12]
 80151b6:	f103 0018 	add.w	r0, r3, #24
 80151ba:	6a3b      	ldr	r3, [r7, #32]
 80151bc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80151c0:	3b01      	subs	r3, #1
 80151c2:	009b      	lsls	r3, r3, #2
 80151c4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80151c6:	4413      	add	r3, r2
 80151c8:	4619      	mov	r1, r3
 80151ca:	f7ff fddd 	bl	8014d88 <_ZNSt15_Deque_iteratorIP8IXFEventRS1_PS1_E11_M_set_nodeEPS3_>
    }
 80151ce:	bf00      	nop
 80151d0:	372c      	adds	r7, #44	; 0x2c
 80151d2:	46bd      	mov	sp, r7
 80151d4:	bd90      	pop	{r4, r7, pc}

080151d6 <_ZNSt16allocator_traitsISaIP8IXFEventEE8allocateERS2_j>:
      allocate(allocator_type& __a, size_type __n)
 80151d6:	b580      	push	{r7, lr}
 80151d8:	b082      	sub	sp, #8
 80151da:	af00      	add	r7, sp, #0
 80151dc:	6078      	str	r0, [r7, #4]
 80151de:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 80151e0:	2200      	movs	r2, #0
 80151e2:	6839      	ldr	r1, [r7, #0]
 80151e4:	6878      	ldr	r0, [r7, #4]
 80151e6:	f000 f87a 	bl	80152de <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE8allocateEjPKv>
 80151ea:	4603      	mov	r3, r0
 80151ec:	4618      	mov	r0, r3
 80151ee:	3708      	adds	r7, #8
 80151f0:	46bd      	mov	sp, r7
 80151f2:	bd80      	pop	{r7, pc}

080151f4 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 80151f4:	b580      	push	{r7, lr}
 80151f6:	b084      	sub	sp, #16
 80151f8:	af00      	add	r7, sp, #0
 80151fa:	60f8      	str	r0, [r7, #12]
 80151fc:	60b9      	str	r1, [r7, #8]
 80151fe:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 8015200:	68f8      	ldr	r0, [r7, #12]
 8015202:	f000 f88a 	bl	801531a <_ZNK9__gnu_cxx13new_allocatorIPP8IXFEventE11_M_max_sizeEv>
 8015206:	4602      	mov	r2, r0
 8015208:	68bb      	ldr	r3, [r7, #8]
 801520a:	4293      	cmp	r3, r2
 801520c:	bf8c      	ite	hi
 801520e:	2301      	movhi	r3, #1
 8015210:	2300      	movls	r3, #0
 8015212:	b2db      	uxtb	r3, r3
 8015214:	2b00      	cmp	r3, #0
 8015216:	d001      	beq.n	801521c <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 8015218:	f000 ffff 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 801521c:	68bb      	ldr	r3, [r7, #8]
 801521e:	009b      	lsls	r3, r3, #2
 8015220:	4618      	mov	r0, r3
 8015222:	f000 ffd6 	bl	80161d2 <_Znwj>
 8015226:	4603      	mov	r3, r0
      }
 8015228:	4618      	mov	r0, r3
 801522a:	3710      	adds	r7, #16
 801522c:	46bd      	mov	sp, r7
 801522e:	bd80      	pop	{r7, pc}

08015230 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE10deallocateEPS2_j>:
      deallocate(_Tp* __p, size_type __t)
 8015230:	b580      	push	{r7, lr}
 8015232:	b084      	sub	sp, #16
 8015234:	af00      	add	r7, sp, #0
 8015236:	60f8      	str	r0, [r7, #12]
 8015238:	60b9      	str	r1, [r7, #8]
 801523a:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 801523c:	687b      	ldr	r3, [r7, #4]
 801523e:	009b      	lsls	r3, r3, #2
 8015240:	4619      	mov	r1, r3
 8015242:	68b8      	ldr	r0, [r7, #8]
 8015244:	f000 ffb2 	bl	80161ac <_ZdlPvj>
      }
 8015248:	bf00      	nop
 801524a:	3710      	adds	r7, #16
 801524c:	46bd      	mov	sp, r7
 801524e:	bd80      	pop	{r7, pc}

08015250 <_ZN9__gnu_cxx13new_allocatorIPP8IXFEventEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8015250:	b480      	push	{r7}
 8015252:	b083      	sub	sp, #12
 8015254:	af00      	add	r7, sp, #0
 8015256:	6078      	str	r0, [r7, #4]
 8015258:	687b      	ldr	r3, [r7, #4]
 801525a:	4618      	mov	r0, r3
 801525c:	370c      	adds	r7, #12
 801525e:	46bd      	mov	sp, r7
 8015260:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015264:	4770      	bx	lr

08015266 <_ZNSt16allocator_traitsISaIP8IXFEventEE8max_sizeERKS2_>:
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
 8015266:	b580      	push	{r7, lr}
 8015268:	b082      	sub	sp, #8
 801526a:	af00      	add	r7, sp, #0
 801526c:	6078      	str	r0, [r7, #4]
	return __a.max_size();
 801526e:	6878      	ldr	r0, [r7, #4]
 8015270:	f000 f85f 	bl	8015332 <_ZNK9__gnu_cxx13new_allocatorIP8IXFEventE8max_sizeEv>
 8015274:	4603      	mov	r3, r0
      }
 8015276:	4618      	mov	r0, r3
 8015278:	3708      	adds	r7, #8
 801527a:	46bd      	mov	sp, r7
 801527c:	bd80      	pop	{r7, pc}

0801527e <_ZSt4copyIPPP8IXFEventS3_ET0_T_S5_S4_>:
    copy(_II __first, _II __last, _OI __result)
 801527e:	b590      	push	{r4, r7, lr}
 8015280:	b085      	sub	sp, #20
 8015282:	af00      	add	r7, sp, #0
 8015284:	60f8      	str	r0, [r7, #12]
 8015286:	60b9      	str	r1, [r7, #8]
 8015288:	607a      	str	r2, [r7, #4]
	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 801528a:	68f8      	ldr	r0, [r7, #12]
 801528c:	f000 f85d 	bl	801534a <_ZSt12__miter_baseIPPP8IXFEventET_S4_>
 8015290:	4604      	mov	r4, r0
 8015292:	68b8      	ldr	r0, [r7, #8]
 8015294:	f000 f859 	bl	801534a <_ZSt12__miter_baseIPPP8IXFEventET_S4_>
 8015298:	4603      	mov	r3, r0
 801529a:	687a      	ldr	r2, [r7, #4]
 801529c:	4619      	mov	r1, r3
 801529e:	4620      	mov	r0, r4
 80152a0:	f000 f85e 	bl	8015360 <_ZSt13__copy_move_aILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 80152a4:	4603      	mov	r3, r0
    }
 80152a6:	4618      	mov	r0, r3
 80152a8:	3714      	adds	r7, #20
 80152aa:	46bd      	mov	sp, r7
 80152ac:	bd90      	pop	{r4, r7, pc}

080152ae <_ZSt13copy_backwardIPPP8IXFEventS3_ET0_T_S5_S4_>:
   *  that the start of the output range may overlap [first,last).
  */
  template<typename _BI1, typename _BI2>
    _GLIBCXX20_CONSTEXPR
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
 80152ae:	b590      	push	{r4, r7, lr}
 80152b0:	b085      	sub	sp, #20
 80152b2:	af00      	add	r7, sp, #0
 80152b4:	60f8      	str	r0, [r7, #12]
 80152b6:	60b9      	str	r1, [r7, #8]
 80152b8:	607a      	str	r2, [r7, #4]
	    typename iterator_traits<_BI1>::value_type,
	    typename iterator_traits<_BI2>::value_type>)
      __glibcxx_requires_can_decrement_range(__first, __last, __result);

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 80152ba:	68f8      	ldr	r0, [r7, #12]
 80152bc:	f000 f845 	bl	801534a <_ZSt12__miter_baseIPPP8IXFEventET_S4_>
 80152c0:	4604      	mov	r4, r0
 80152c2:	68b8      	ldr	r0, [r7, #8]
 80152c4:	f000 f841 	bl	801534a <_ZSt12__miter_baseIPPP8IXFEventET_S4_>
 80152c8:	4603      	mov	r3, r0
 80152ca:	687a      	ldr	r2, [r7, #4]
 80152cc:	4619      	mov	r1, r3
 80152ce:	4620      	mov	r0, r4
 80152d0:	f000 f869 	bl	80153a6 <_ZSt22__copy_move_backward_aILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 80152d4:	4603      	mov	r3, r0
    }
 80152d6:	4618      	mov	r0, r3
 80152d8:	3714      	adds	r7, #20
 80152da:	46bd      	mov	sp, r7
 80152dc:	bd90      	pop	{r4, r7, pc}

080152de <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 80152de:	b580      	push	{r7, lr}
 80152e0:	b084      	sub	sp, #16
 80152e2:	af00      	add	r7, sp, #0
 80152e4:	60f8      	str	r0, [r7, #12]
 80152e6:	60b9      	str	r1, [r7, #8]
 80152e8:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 80152ea:	68f8      	ldr	r0, [r7, #12]
 80152ec:	f000 f87e 	bl	80153ec <_ZNK9__gnu_cxx13new_allocatorIP8IXFEventE11_M_max_sizeEv>
 80152f0:	4602      	mov	r2, r0
 80152f2:	68bb      	ldr	r3, [r7, #8]
 80152f4:	4293      	cmp	r3, r2
 80152f6:	bf8c      	ite	hi
 80152f8:	2301      	movhi	r3, #1
 80152fa:	2300      	movls	r3, #0
 80152fc:	b2db      	uxtb	r3, r3
 80152fe:	2b00      	cmp	r3, #0
 8015300:	d001      	beq.n	8015306 <_ZN9__gnu_cxx13new_allocatorIP8IXFEventE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 8015302:	f000 ff8a 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 8015306:	68bb      	ldr	r3, [r7, #8]
 8015308:	009b      	lsls	r3, r3, #2
 801530a:	4618      	mov	r0, r3
 801530c:	f000 ff61 	bl	80161d2 <_Znwj>
 8015310:	4603      	mov	r3, r0
      }
 8015312:	4618      	mov	r0, r3
 8015314:	3710      	adds	r7, #16
 8015316:	46bd      	mov	sp, r7
 8015318:	bd80      	pop	{r7, pc}

0801531a <_ZNK9__gnu_cxx13new_allocatorIPP8IXFEventE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 801531a:	b480      	push	{r7}
 801531c:	b083      	sub	sp, #12
 801531e:	af00      	add	r7, sp, #0
 8015320:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 8015322:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
      }
 8015326:	4618      	mov	r0, r3
 8015328:	370c      	adds	r7, #12
 801532a:	46bd      	mov	sp, r7
 801532c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015330:	4770      	bx	lr

08015332 <_ZNK9__gnu_cxx13new_allocatorIP8IXFEventE8max_sizeEv>:
      max_size() const _GLIBCXX_USE_NOEXCEPT
 8015332:	b580      	push	{r7, lr}
 8015334:	b082      	sub	sp, #8
 8015336:	af00      	add	r7, sp, #0
 8015338:	6078      	str	r0, [r7, #4]
      { return _M_max_size(); }
 801533a:	6878      	ldr	r0, [r7, #4]
 801533c:	f000 f856 	bl	80153ec <_ZNK9__gnu_cxx13new_allocatorIP8IXFEventE11_M_max_sizeEv>
 8015340:	4603      	mov	r3, r0
 8015342:	4618      	mov	r0, r3
 8015344:	3708      	adds	r7, #8
 8015346:	46bd      	mov	sp, r7
 8015348:	bd80      	pop	{r7, pc}

0801534a <_ZSt12__miter_baseIPPP8IXFEventET_S4_>:
    __miter_base(_Iterator __it)
 801534a:	b480      	push	{r7}
 801534c:	b083      	sub	sp, #12
 801534e:	af00      	add	r7, sp, #0
 8015350:	6078      	str	r0, [r7, #4]
    { return __it; }
 8015352:	687b      	ldr	r3, [r7, #4]
 8015354:	4618      	mov	r0, r3
 8015356:	370c      	adds	r7, #12
 8015358:	46bd      	mov	sp, r7
 801535a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801535e:	4770      	bx	lr

08015360 <_ZSt13__copy_move_aILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_a(_II __first, _II __last, _OI __result)
 8015360:	b5b0      	push	{r4, r5, r7, lr}
 8015362:	b084      	sub	sp, #16
 8015364:	af00      	add	r7, sp, #0
 8015366:	60f8      	str	r0, [r7, #12]
 8015368:	60b9      	str	r1, [r7, #8]
 801536a:	607a      	str	r2, [r7, #4]
      return std::__niter_wrap(__result,
 801536c:	68f8      	ldr	r0, [r7, #12]
 801536e:	f000 f849 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 8015372:	4604      	mov	r4, r0
 8015374:	68b8      	ldr	r0, [r7, #8]
 8015376:	f000 f845 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 801537a:	4605      	mov	r5, r0
 801537c:	687b      	ldr	r3, [r7, #4]
 801537e:	4618      	mov	r0, r3
 8015380:	f000 f840 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 8015384:	4603      	mov	r3, r0
 8015386:	461a      	mov	r2, r3
 8015388:	4629      	mov	r1, r5
 801538a:	4620      	mov	r0, r4
 801538c:	f000 f845 	bl	801541a <_ZSt14__copy_move_a1ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 8015390:	4602      	mov	r2, r0
 8015392:	1d3b      	adds	r3, r7, #4
 8015394:	4611      	mov	r1, r2
 8015396:	4618      	mov	r0, r3
 8015398:	f000 f84f 	bl	801543a <_ZSt12__niter_wrapIPPP8IXFEventET_RKS4_S4_>
 801539c:	4603      	mov	r3, r0
    }
 801539e:	4618      	mov	r0, r3
 80153a0:	3710      	adds	r7, #16
 80153a2:	46bd      	mov	sp, r7
 80153a4:	bdb0      	pop	{r4, r5, r7, pc}

080153a6 <_ZSt22__copy_move_backward_aILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
 80153a6:	b5b0      	push	{r4, r5, r7, lr}
 80153a8:	b084      	sub	sp, #16
 80153aa:	af00      	add	r7, sp, #0
 80153ac:	60f8      	str	r0, [r7, #12]
 80153ae:	60b9      	str	r1, [r7, #8]
 80153b0:	607a      	str	r2, [r7, #4]
      return std::__niter_wrap(__result,
 80153b2:	68f8      	ldr	r0, [r7, #12]
 80153b4:	f000 f826 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 80153b8:	4604      	mov	r4, r0
 80153ba:	68b8      	ldr	r0, [r7, #8]
 80153bc:	f000 f822 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 80153c0:	4605      	mov	r5, r0
 80153c2:	687b      	ldr	r3, [r7, #4]
 80153c4:	4618      	mov	r0, r3
 80153c6:	f000 f81d 	bl	8015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>
 80153ca:	4603      	mov	r3, r0
 80153cc:	461a      	mov	r2, r3
 80153ce:	4629      	mov	r1, r5
 80153d0:	4620      	mov	r0, r4
 80153d2:	f000 f83e 	bl	8015452 <_ZSt23__copy_move_backward_a1ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 80153d6:	4602      	mov	r2, r0
 80153d8:	1d3b      	adds	r3, r7, #4
 80153da:	4611      	mov	r1, r2
 80153dc:	4618      	mov	r0, r3
 80153de:	f000 f82c 	bl	801543a <_ZSt12__niter_wrapIPPP8IXFEventET_RKS4_S4_>
 80153e2:	4603      	mov	r3, r0
    }
 80153e4:	4618      	mov	r0, r3
 80153e6:	3710      	adds	r7, #16
 80153e8:	46bd      	mov	sp, r7
 80153ea:	bdb0      	pop	{r4, r5, r7, pc}

080153ec <_ZNK9__gnu_cxx13new_allocatorIP8IXFEventE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 80153ec:	b480      	push	{r7}
 80153ee:	b083      	sub	sp, #12
 80153f0:	af00      	add	r7, sp, #0
 80153f2:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 80153f4:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
      }
 80153f8:	4618      	mov	r0, r3
 80153fa:	370c      	adds	r7, #12
 80153fc:	46bd      	mov	sp, r7
 80153fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015402:	4770      	bx	lr

08015404 <_ZSt12__niter_baseIPPP8IXFEventET_S4_>:
    __niter_base(_Iterator __it)
 8015404:	b480      	push	{r7}
 8015406:	b083      	sub	sp, #12
 8015408:	af00      	add	r7, sp, #0
 801540a:	6078      	str	r0, [r7, #4]
    { return __it; }
 801540c:	687b      	ldr	r3, [r7, #4]
 801540e:	4618      	mov	r0, r3
 8015410:	370c      	adds	r7, #12
 8015412:	46bd      	mov	sp, r7
 8015414:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015418:	4770      	bx	lr

0801541a <_ZSt14__copy_move_a1ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_a1(_II __first, _II __last, _OI __result)
 801541a:	b580      	push	{r7, lr}
 801541c:	b084      	sub	sp, #16
 801541e:	af00      	add	r7, sp, #0
 8015420:	60f8      	str	r0, [r7, #12]
 8015422:	60b9      	str	r1, [r7, #8]
 8015424:	607a      	str	r2, [r7, #4]
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
 8015426:	687a      	ldr	r2, [r7, #4]
 8015428:	68b9      	ldr	r1, [r7, #8]
 801542a:	68f8      	ldr	r0, [r7, #12]
 801542c:	f000 f821 	bl	8015472 <_ZSt14__copy_move_a2ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 8015430:	4603      	mov	r3, r0
 8015432:	4618      	mov	r0, r3
 8015434:	3710      	adds	r7, #16
 8015436:	46bd      	mov	sp, r7
 8015438:	bd80      	pop	{r7, pc}

0801543a <_ZSt12__niter_wrapIPPP8IXFEventET_RKS4_S4_>:
    __niter_wrap(const _Iterator&, _Iterator __res)
 801543a:	b480      	push	{r7}
 801543c:	b083      	sub	sp, #12
 801543e:	af00      	add	r7, sp, #0
 8015440:	6078      	str	r0, [r7, #4]
 8015442:	6039      	str	r1, [r7, #0]
    { return __res; }
 8015444:	683b      	ldr	r3, [r7, #0]
 8015446:	4618      	mov	r0, r3
 8015448:	370c      	adds	r7, #12
 801544a:	46bd      	mov	sp, r7
 801544c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015450:	4770      	bx	lr

08015452 <_ZSt23__copy_move_backward_a1ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
 8015452:	b580      	push	{r7, lr}
 8015454:	b084      	sub	sp, #16
 8015456:	af00      	add	r7, sp, #0
 8015458:	60f8      	str	r0, [r7, #12]
 801545a:	60b9      	str	r1, [r7, #8]
 801545c:	607a      	str	r2, [r7, #4]
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }
 801545e:	687a      	ldr	r2, [r7, #4]
 8015460:	68b9      	ldr	r1, [r7, #8]
 8015462:	68f8      	ldr	r0, [r7, #12]
 8015464:	f000 f815 	bl	8015492 <_ZSt23__copy_move_backward_a2ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>
 8015468:	4603      	mov	r3, r0
 801546a:	4618      	mov	r0, r3
 801546c:	3710      	adds	r7, #16
 801546e:	46bd      	mov	sp, r7
 8015470:	bd80      	pop	{r7, pc}

08015472 <_ZSt14__copy_move_a2ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_a2(_II __first, _II __last, _OI __result)
 8015472:	b580      	push	{r7, lr}
 8015474:	b084      	sub	sp, #16
 8015476:	af00      	add	r7, sp, #0
 8015478:	60f8      	str	r0, [r7, #12]
 801547a:	60b9      	str	r1, [r7, #8]
 801547c:	607a      	str	r2, [r7, #4]
			      _Category>::__copy_m(__first, __last, __result);
 801547e:	687a      	ldr	r2, [r7, #4]
 8015480:	68b9      	ldr	r1, [r7, #8]
 8015482:	68f8      	ldr	r0, [r7, #12]
 8015484:	f000 f815 	bl	80154b2 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIPP8IXFEventEEPT_PKS6_S9_S7_>
 8015488:	4603      	mov	r3, r0
    }
 801548a:	4618      	mov	r0, r3
 801548c:	3710      	adds	r7, #16
 801548e:	46bd      	mov	sp, r7
 8015490:	bd80      	pop	{r7, pc}

08015492 <_ZSt23__copy_move_backward_a2ILb0EPPP8IXFEventS3_ET1_T0_S5_S4_>:
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
 8015492:	b580      	push	{r7, lr}
 8015494:	b084      	sub	sp, #16
 8015496:	af00      	add	r7, sp, #0
 8015498:	60f8      	str	r0, [r7, #12]
 801549a:	60b9      	str	r1, [r7, #8]
 801549c:	607a      	str	r2, [r7, #4]
				       _Category>::__copy_move_b(__first,
 801549e:	687a      	ldr	r2, [r7, #4]
 80154a0:	68b9      	ldr	r1, [r7, #8]
 80154a2:	68f8      	ldr	r0, [r7, #12]
 80154a4:	f000 f822 	bl	80154ec <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIPP8IXFEventEEPT_PKS6_S9_S7_>
 80154a8:	4603      	mov	r3, r0
    }
 80154aa:	4618      	mov	r0, r3
 80154ac:	3710      	adds	r7, #16
 80154ae:	46bd      	mov	sp, r7
 80154b0:	bd80      	pop	{r7, pc}

080154b2 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIPP8IXFEventEEPT_PKS6_S9_S7_>:
	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 80154b2:	b580      	push	{r7, lr}
 80154b4:	b086      	sub	sp, #24
 80154b6:	af00      	add	r7, sp, #0
 80154b8:	60f8      	str	r0, [r7, #12]
 80154ba:	60b9      	str	r1, [r7, #8]
 80154bc:	607a      	str	r2, [r7, #4]
	  const ptrdiff_t _Num = __last - __first;
 80154be:	68ba      	ldr	r2, [r7, #8]
 80154c0:	68fb      	ldr	r3, [r7, #12]
 80154c2:	1ad3      	subs	r3, r2, r3
 80154c4:	109b      	asrs	r3, r3, #2
 80154c6:	617b      	str	r3, [r7, #20]
	  if (_Num)
 80154c8:	697b      	ldr	r3, [r7, #20]
 80154ca:	2b00      	cmp	r3, #0
 80154cc:	d006      	beq.n	80154dc <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIPP8IXFEventEEPT_PKS6_S9_S7_+0x2a>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
 80154ce:	697b      	ldr	r3, [r7, #20]
 80154d0:	009b      	lsls	r3, r3, #2
 80154d2:	461a      	mov	r2, r3
 80154d4:	68f9      	ldr	r1, [r7, #12]
 80154d6:	6878      	ldr	r0, [r7, #4]
 80154d8:	f000 ffda 	bl	8016490 <memmove>
	  return __result + _Num;
 80154dc:	697b      	ldr	r3, [r7, #20]
 80154de:	009b      	lsls	r3, r3, #2
 80154e0:	687a      	ldr	r2, [r7, #4]
 80154e2:	4413      	add	r3, r2
	}
 80154e4:	4618      	mov	r0, r3
 80154e6:	3718      	adds	r7, #24
 80154e8:	46bd      	mov	sp, r7
 80154ea:	bd80      	pop	{r7, pc}

080154ec <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIPP8IXFEventEEPT_PKS6_S9_S7_>:
	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 80154ec:	b580      	push	{r7, lr}
 80154ee:	b086      	sub	sp, #24
 80154f0:	af00      	add	r7, sp, #0
 80154f2:	60f8      	str	r0, [r7, #12]
 80154f4:	60b9      	str	r1, [r7, #8]
 80154f6:	607a      	str	r2, [r7, #4]
	  const ptrdiff_t _Num = __last - __first;
 80154f8:	68ba      	ldr	r2, [r7, #8]
 80154fa:	68fb      	ldr	r3, [r7, #12]
 80154fc:	1ad3      	subs	r3, r2, r3
 80154fe:	109b      	asrs	r3, r3, #2
 8015500:	617b      	str	r3, [r7, #20]
	  if (_Num)
 8015502:	697b      	ldr	r3, [r7, #20]
 8015504:	2b00      	cmp	r3, #0
 8015506:	d00a      	beq.n	801551e <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIPP8IXFEventEEPT_PKS6_S9_S7_+0x32>
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
 8015508:	697b      	ldr	r3, [r7, #20]
 801550a:	009b      	lsls	r3, r3, #2
 801550c:	425b      	negs	r3, r3
 801550e:	687a      	ldr	r2, [r7, #4]
 8015510:	18d0      	adds	r0, r2, r3
 8015512:	697b      	ldr	r3, [r7, #20]
 8015514:	009b      	lsls	r3, r3, #2
 8015516:	461a      	mov	r2, r3
 8015518:	68f9      	ldr	r1, [r7, #12]
 801551a:	f000 ffb9 	bl	8016490 <memmove>
	  return __result - _Num;
 801551e:	697b      	ldr	r3, [r7, #20]
 8015520:	009b      	lsls	r3, r3, #2
 8015522:	425b      	negs	r3, r3
 8015524:	687a      	ldr	r2, [r7, #4]
 8015526:	4413      	add	r3, r2
	}
 8015528:	4618      	mov	r0, r3
 801552a:	3718      	adds	r7, #24
 801552c:	46bd      	mov	sp, r7
 801552e:	bd80      	pop	{r7, pc}

08015530 <_ZN9XFTimeoutC1EiiP11IXFReactive>:
 * Constructor of the class.
 * \param id The id given by the behavioral class to uniquely identifing the timeout
 * \param interval The interval in milliseconds the timeout expires
 * \param pBehavior Pointer to behavioral class to which the timeout belongs.
 */
XFTimeout::XFTimeout(int id, int interval, IXFReactive * pBehavior)
 8015530:	b580      	push	{r7, lr}
 8015532:	b084      	sub	sp, #16
 8015534:	af00      	add	r7, sp, #0
 8015536:	60f8      	str	r0, [r7, #12]
 8015538:	60b9      	str	r1, [r7, #8]
 801553a:	607a      	str	r2, [r7, #4]
 801553c:	603b      	str	r3, [r7, #0]
 : IXFEvent(IXFEvent::Timeout, id, pBehavior),
   _interval(interval),
   _relTicks(interval)
 801553e:	68f8      	ldr	r0, [r7, #12]
 8015540:	683b      	ldr	r3, [r7, #0]
 8015542:	68ba      	ldr	r2, [r7, #8]
 8015544:	2104      	movs	r1, #4
 8015546:	f7fe fc09 	bl	8013d5c <_ZN8IXFEventC1ENS_10eEventTypeEiP11IXFReactive>
 801554a:	4a07      	ldr	r2, [pc, #28]	; (8015568 <_ZN9XFTimeoutC1EiiP11IXFReactive+0x38>)
 801554c:	68fb      	ldr	r3, [r7, #12]
 801554e:	601a      	str	r2, [r3, #0]
 8015550:	68fb      	ldr	r3, [r7, #12]
 8015552:	687a      	ldr	r2, [r7, #4]
 8015554:	615a      	str	r2, [r3, #20]
 8015556:	68fb      	ldr	r3, [r7, #12]
 8015558:	687a      	ldr	r2, [r7, #4]
 801555a:	619a      	str	r2, [r3, #24]
{
}
 801555c:	68fb      	ldr	r3, [r7, #12]
 801555e:	4618      	mov	r0, r3
 8015560:	3710      	adds	r7, #16
 8015562:	46bd      	mov	sp, r7
 8015564:	bd80      	pop	{r7, pc}
 8015566:	bf00      	nop
 8015568:	0801dcfc 	.word	0x0801dcfc

0801556c <_ZN9XFTimeoutD1Ev>:

XFTimeout::~XFTimeout()
 801556c:	b580      	push	{r7, lr}
 801556e:	b082      	sub	sp, #8
 8015570:	af00      	add	r7, sp, #0
 8015572:	6078      	str	r0, [r7, #4]
 8015574:	4a05      	ldr	r2, [pc, #20]	; (801558c <_ZN9XFTimeoutD1Ev+0x20>)
 8015576:	687b      	ldr	r3, [r7, #4]
 8015578:	601a      	str	r2, [r3, #0]
 801557a:	687b      	ldr	r3, [r7, #4]
 801557c:	4618      	mov	r0, r3
 801557e:	f7fe fc13 	bl	8013da8 <_ZN8IXFEventD1Ev>
{

}
 8015582:	687b      	ldr	r3, [r7, #4]
 8015584:	4618      	mov	r0, r3
 8015586:	3708      	adds	r7, #8
 8015588:	46bd      	mov	sp, r7
 801558a:	bd80      	pop	{r7, pc}
 801558c:	0801dcfc 	.word	0x0801dcfc

08015590 <_ZN9XFTimeoutD0Ev>:
XFTimeout::~XFTimeout()
 8015590:	b580      	push	{r7, lr}
 8015592:	b082      	sub	sp, #8
 8015594:	af00      	add	r7, sp, #0
 8015596:	6078      	str	r0, [r7, #4]
}
 8015598:	6878      	ldr	r0, [r7, #4]
 801559a:	f7ff ffe7 	bl	801556c <_ZN9XFTimeoutD1Ev>
 801559e:	211c      	movs	r1, #28
 80155a0:	6878      	ldr	r0, [r7, #4]
 80155a2:	f000 fe03 	bl	80161ac <_ZdlPvj>
 80155a6:	687b      	ldr	r3, [r7, #4]
 80155a8:	4618      	mov	r0, r3
 80155aa:	3708      	adds	r7, #8
 80155ac:	46bd      	mov	sp, r7
 80155ae:	bd80      	pop	{r7, pc}

080155b0 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE10_List_implD1Ev>:
      struct _List_impl
 80155b0:	b580      	push	{r7, lr}
 80155b2:	b082      	sub	sp, #8
 80155b4:	af00      	add	r7, sp, #0
 80155b6:	6078      	str	r0, [r7, #4]
 80155b8:	6878      	ldr	r0, [r7, #4]
 80155ba:	f000 fa8a 	bl	8015ad2 <_ZNSaISt10_List_nodeIP9XFTimeoutEED1Ev>
 80155be:	687b      	ldr	r3, [r7, #4]
 80155c0:	4618      	mov	r0, r3
 80155c2:	3708      	adds	r7, #8
 80155c4:	46bd      	mov	sp, r7
 80155c6:	bd80      	pop	{r7, pc}

080155c8 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EEC1Ev>:
      _List_base() = default;
 80155c8:	b580      	push	{r7, lr}
 80155ca:	b082      	sub	sp, #8
 80155cc:	af00      	add	r7, sp, #0
 80155ce:	6078      	str	r0, [r7, #4]
 80155d0:	687b      	ldr	r3, [r7, #4]
 80155d2:	4618      	mov	r0, r3
 80155d4:	f000 fa6d 	bl	8015ab2 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE10_List_implC1Ev>
 80155d8:	687b      	ldr	r3, [r7, #4]
 80155da:	4618      	mov	r0, r3
 80155dc:	3708      	adds	r7, #8
 80155de:	46bd      	mov	sp, r7
 80155e0:	bd80      	pop	{r7, pc}

080155e2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EEC1Ev>:
      list() = default;
 80155e2:	b580      	push	{r7, lr}
 80155e4:	b082      	sub	sp, #8
 80155e6:	af00      	add	r7, sp, #0
 80155e8:	6078      	str	r0, [r7, #4]
 80155ea:	687b      	ldr	r3, [r7, #4]
 80155ec:	4618      	mov	r0, r3
 80155ee:	f7ff ffeb 	bl	80155c8 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EEC1Ev>
 80155f2:	687b      	ldr	r3, [r7, #4]
 80155f4:	4618      	mov	r0, r3
 80155f6:	3708      	adds	r7, #8
 80155f8:	46bd      	mov	sp, r7
 80155fa:	bd80      	pop	{r7, pc}

080155fc <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EED1Ev>:
      ~list() = default;
 80155fc:	b580      	push	{r7, lr}
 80155fe:	b082      	sub	sp, #8
 8015600:	af00      	add	r7, sp, #0
 8015602:	6078      	str	r0, [r7, #4]
 8015604:	687b      	ldr	r3, [r7, #4]
 8015606:	4618      	mov	r0, r3
 8015608:	f000 fa6f 	bl	8015aea <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EED1Ev>
 801560c:	687b      	ldr	r3, [r7, #4]
 801560e:	4618      	mov	r0, r3
 8015610:	3708      	adds	r7, #8
 8015612:	46bd      	mov	sp, r7
 8015614:	bd80      	pop	{r7, pc}
	...

08015618 <_ZN16XFTimeoutManagerC1Ev>:

// Initialization of static class attributes
XFTimeoutManager * XFTimeoutManager::_pInstance = NULL;


XFTimeoutManager::XFTimeoutManager()
 8015618:	b580      	push	{r7, lr}
 801561a:	b082      	sub	sp, #8
 801561c:	af00      	add	r7, sp, #0
 801561e:	6078      	str	r0, [r7, #4]
 : _tickInterval(0),
   _sysTicksInMs(0)
 8015620:	4a09      	ldr	r2, [pc, #36]	; (8015648 <_ZN16XFTimeoutManagerC1Ev+0x30>)
 8015622:	687b      	ldr	r3, [r7, #4]
 8015624:	601a      	str	r2, [r3, #0]
 8015626:	687b      	ldr	r3, [r7, #4]
 8015628:	2200      	movs	r2, #0
 801562a:	605a      	str	r2, [r3, #4]
 801562c:	687b      	ldr	r3, [r7, #4]
 801562e:	3308      	adds	r3, #8
 8015630:	4618      	mov	r0, r3
 8015632:	f7ff ffd6 	bl	80155e2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EEC1Ev>
 8015636:	687b      	ldr	r3, [r7, #4]
 8015638:	2200      	movs	r2, #0
 801563a:	615a      	str	r2, [r3, #20]
{
}
 801563c:	687b      	ldr	r3, [r7, #4]
 801563e:	4618      	mov	r0, r3
 8015640:	3708      	adds	r7, #8
 8015642:	46bd      	mov	sp, r7
 8015644:	bd80      	pop	{r7, pc}
 8015646:	bf00      	nop
 8015648:	0801dd0c 	.word	0x0801dd0c

0801564c <_ZN16XFTimeoutManagerD1Ev>:

XFTimeoutManager::~XFTimeoutManager()
 801564c:	b580      	push	{r7, lr}
 801564e:	b082      	sub	sp, #8
 8015650:	af00      	add	r7, sp, #0
 8015652:	6078      	str	r0, [r7, #4]
 8015654:	4a06      	ldr	r2, [pc, #24]	; (8015670 <_ZN16XFTimeoutManagerD1Ev+0x24>)
 8015656:	687b      	ldr	r3, [r7, #4]
 8015658:	601a      	str	r2, [r3, #0]
 801565a:	687b      	ldr	r3, [r7, #4]
 801565c:	3308      	adds	r3, #8
 801565e:	4618      	mov	r0, r3
 8015660:	f7ff ffcc 	bl	80155fc <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EED1Ev>
{
}
 8015664:	687b      	ldr	r3, [r7, #4]
 8015666:	4618      	mov	r0, r3
 8015668:	3708      	adds	r7, #8
 801566a:	46bd      	mov	sp, r7
 801566c:	bd80      	pop	{r7, pc}
 801566e:	bf00      	nop
 8015670:	0801dd0c 	.word	0x0801dd0c

08015674 <_ZN16XFTimeoutManagerD0Ev>:
XFTimeoutManager::~XFTimeoutManager()
 8015674:	b580      	push	{r7, lr}
 8015676:	b082      	sub	sp, #8
 8015678:	af00      	add	r7, sp, #0
 801567a:	6078      	str	r0, [r7, #4]
}
 801567c:	6878      	ldr	r0, [r7, #4]
 801567e:	f7ff ffe5 	bl	801564c <_ZN16XFTimeoutManagerD1Ev>
 8015682:	2118      	movs	r1, #24
 8015684:	6878      	ldr	r0, [r7, #4]
 8015686:	f000 fd91 	bl	80161ac <_ZdlPvj>
 801568a:	687b      	ldr	r3, [r7, #4]
 801568c:	4618      	mov	r0, r3
 801568e:	3708      	adds	r7, #8
 8015690:	46bd      	mov	sp, r7
 8015692:	bd80      	pop	{r7, pc}

08015694 <_ZN16XFTimeoutManager11getInstanceEv>:

XFTimeoutManager * XFTimeoutManager::getInstance()
{
 8015694:	b598      	push	{r3, r4, r7, lr}
 8015696:	af00      	add	r7, sp, #0
    if (!_pInstance)
 8015698:	4b08      	ldr	r3, [pc, #32]	; (80156bc <_ZN16XFTimeoutManager11getInstanceEv+0x28>)
 801569a:	681b      	ldr	r3, [r3, #0]
 801569c:	2b00      	cmp	r3, #0
 801569e:	d109      	bne.n	80156b4 <_ZN16XFTimeoutManager11getInstanceEv+0x20>
    {
        _pInstance = new XFTimeoutManager;
 80156a0:	2018      	movs	r0, #24
 80156a2:	f000 fd96 	bl	80161d2 <_Znwj>
 80156a6:	4603      	mov	r3, r0
 80156a8:	461c      	mov	r4, r3
 80156aa:	4620      	mov	r0, r4
 80156ac:	f7ff ffb4 	bl	8015618 <_ZN16XFTimeoutManagerC1Ev>
 80156b0:	4b02      	ldr	r3, [pc, #8]	; (80156bc <_ZN16XFTimeoutManager11getInstanceEv+0x28>)
 80156b2:	601c      	str	r4, [r3, #0]
    }

    return _pInstance;
 80156b4:	4b01      	ldr	r3, [pc, #4]	; (80156bc <_ZN16XFTimeoutManager11getInstanceEv+0x28>)
 80156b6:	681b      	ldr	r3, [r3, #0]
}
 80156b8:	4618      	mov	r0, r3
 80156ba:	bd98      	pop	{r3, r4, r7, pc}
 80156bc:	20001e5c 	.word	0x20001e5c

080156c0 <_ZN16XFTimeoutManager15setTickIntervalEi>:
/**
 * Sets the time interval in milliseconds in which the timeout manager
 * should handle the timeouts.
 */
void XFTimeoutManager::setTickInterval(int tickInterval)
{
 80156c0:	b480      	push	{r7}
 80156c2:	b083      	sub	sp, #12
 80156c4:	af00      	add	r7, sp, #0
 80156c6:	6078      	str	r0, [r7, #4]
 80156c8:	6039      	str	r1, [r7, #0]
    _tickInterval = tickInterval;
 80156ca:	687b      	ldr	r3, [r7, #4]
 80156cc:	683a      	ldr	r2, [r7, #0]
 80156ce:	605a      	str	r2, [r3, #4]
}
 80156d0:	bf00      	nop
 80156d2:	370c      	adds	r7, #12
 80156d4:	46bd      	mov	sp, r7
 80156d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80156da:	4770      	bx	lr

080156dc <_ZN16XFTimeoutManager5startEv>:

/**
 * Starts the timeout manager.
 */
void XFTimeoutManager::start()
{
 80156dc:	b580      	push	{r7, lr}
 80156de:	b082      	sub	sp, #8
 80156e0:	af00      	add	r7, sp, #0
 80156e2:	6078      	str	r0, [r7, #4]
    // Check tickInterval. Set default value if not set
    if (_tickInterval == 0)
 80156e4:	687b      	ldr	r3, [r7, #4]
 80156e6:	685b      	ldr	r3, [r3, #4]
 80156e8:	2b00      	cmp	r3, #0
 80156ea:	d102      	bne.n	80156f2 <_ZN16XFTimeoutManager5startEv+0x16>
    {
        _tickInterval = 10;
 80156ec:	687b      	ldr	r3, [r7, #4]
 80156ee:	220a      	movs	r2, #10
 80156f0:	605a      	str	r2, [r3, #4]
    }

    startHardwareTimer(_tickInterval);
 80156f2:	687b      	ldr	r3, [r7, #4]
 80156f4:	685b      	ldr	r3, [r3, #4]
 80156f6:	4619      	mov	r1, r3
 80156f8:	6878      	ldr	r0, [r7, #4]
 80156fa:	f000 f9cf 	bl	8015a9c <_ZN16XFTimeoutManager18startHardwareTimerEi>
}
 80156fe:	bf00      	nop
 8015700:	3708      	adds	r7, #8
 8015702:	46bd      	mov	sp, r7
 8015704:	bd80      	pop	{r7, pc}

08015706 <_ZN16XFTimeoutManager15scheduleTimeoutEiiP11IXFReactive>:
 * \param timeoutId The timeout id known by the reactive parameter. Is needed by the reactive part to uniquely identify the timeout.
 * \param interval The time in milliseconds to wait until the timeout expires.
 * \param pReactive The reactive instance where to inject the timeout when it timeouts.
 */
void XFTimeoutManager::scheduleTimeout(int timeoutId, int interval, IXFReactive * pReactive)
{
 8015706:	b590      	push	{r4, r7, lr}
 8015708:	b087      	sub	sp, #28
 801570a:	af00      	add	r7, sp, #0
 801570c:	60f8      	str	r0, [r7, #12]
 801570e:	60b9      	str	r1, [r7, #8]
 8015710:	607a      	str	r2, [r7, #4]
 8015712:	603b      	str	r3, [r7, #0]
    XFTimeout * pTimeout = new XFTimeout(timeoutId, interval, pReactive);
 8015714:	201c      	movs	r0, #28
 8015716:	f000 fd5c 	bl	80161d2 <_Znwj>
 801571a:	4603      	mov	r3, r0
 801571c:	461c      	mov	r4, r3
 801571e:	683b      	ldr	r3, [r7, #0]
 8015720:	687a      	ldr	r2, [r7, #4]
 8015722:	68b9      	ldr	r1, [r7, #8]
 8015724:	4620      	mov	r0, r4
 8015726:	f7ff ff03 	bl	8015530 <_ZN9XFTimeoutC1EiiP11IXFReactive>
 801572a:	617c      	str	r4, [r7, #20]

    if (pTimeout)
 801572c:	697b      	ldr	r3, [r7, #20]
 801572e:	2b00      	cmp	r3, #0
 8015730:	d003      	beq.n	801573a <_ZN16XFTimeoutManager15scheduleTimeoutEiiP11IXFReactive+0x34>
    {
        addTimeout(pTimeout);
 8015732:	6979      	ldr	r1, [r7, #20]
 8015734:	68f8      	ldr	r0, [r7, #12]
 8015736:	f000 f8ab 	bl	8015890 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout>
    }
}
 801573a:	bf00      	nop
 801573c:	371c      	adds	r7, #28
 801573e:	46bd      	mov	sp, r7
 8015740:	bd90      	pop	{r4, r7, pc}

08015742 <_ZN16XFTimeoutManager4tickEv>:
/**
 * On each call to this method, XFTimeoutManager::_tickInterval will be removed from the
 * timeouts. When a timeout expires it is injected back to its reactive instance.
 */
void XFTimeoutManager::tick()
{
 8015742:	b590      	push	{r4, r7, lr}
 8015744:	b089      	sub	sp, #36	; 0x24
 8015746:	af00      	add	r7, sp, #0
 8015748:	6078      	str	r0, [r7, #4]
    _sysTicksInMs += tickInterval();
 801574a:	6878      	ldr	r0, [r7, #4]
 801574c:	f7f2 fd63 	bl	8008216 <_ZNK16XFTimeoutManager12tickIntervalEv>
 8015750:	4602      	mov	r2, r0
 8015752:	687b      	ldr	r3, [r7, #4]
 8015754:	695b      	ldr	r3, [r3, #20]
 8015756:	441a      	add	r2, r3
 8015758:	687b      	ldr	r3, [r7, #4]
 801575a:	615a      	str	r2, [r3, #20]

    if (!_timeouts.empty())
 801575c:	687b      	ldr	r3, [r7, #4]
 801575e:	3308      	adds	r3, #8
 8015760:	4618      	mov	r0, r3
 8015762:	f000 f9d2 	bl	8015b0a <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE5emptyEv>
 8015766:	4603      	mov	r3, r0
 8015768:	f083 0301 	eor.w	r3, r3, #1
 801576c:	b2db      	uxtb	r3, r3
 801576e:	2b00      	cmp	r3, #0
 8015770:	f000 808a 	beq.w	8015888 <_ZN16XFTimeoutManager4tickEv+0x146>
    {
        XFTimeout * pFirstTimeout = _timeouts.front();
 8015774:	687b      	ldr	r3, [r7, #4]
 8015776:	3308      	adds	r3, #8
 8015778:	4618      	mov	r0, r3
 801577a:	f000 f9d8 	bl	8015b2e <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5frontEv>
 801577e:	4603      	mov	r3, r0
 8015780:	681b      	ldr	r3, [r3, #0]
 8015782:	61fb      	str	r3, [r7, #28]

        // Subtract time elapsed
        pFirstTimeout->_relTicks -= tickInterval();
 8015784:	6878      	ldr	r0, [r7, #4]
 8015786:	f7f2 fd46 	bl	8008216 <_ZNK16XFTimeoutManager12tickIntervalEv>
 801578a:	4602      	mov	r2, r0
 801578c:	69fb      	ldr	r3, [r7, #28]
 801578e:	699b      	ldr	r3, [r3, #24]
 8015790:	1a9a      	subs	r2, r3, r2
 8015792:	69fb      	ldr	r3, [r7, #28]
 8015794:	619a      	str	r2, [r3, #24]

        // Check timeout timed out
        if (pFirstTimeout->_relTicks <= 0)
 8015796:	69fb      	ldr	r3, [r7, #28]
 8015798:	699b      	ldr	r3, [r3, #24]
 801579a:	2b00      	cmp	r3, #0
 801579c:	dc74      	bgt.n	8015888 <_ZN16XFTimeoutManager4tickEv+0x146>
        {
            // Check remaining ticks can be given further
            if (_timeouts.size() > 1)
 801579e:	687b      	ldr	r3, [r7, #4]
 80157a0:	3308      	adds	r3, #8
 80157a2:	4618      	mov	r0, r3
 80157a4:	f000 f9d6 	bl	8015b54 <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE4sizeEv>
 80157a8:	4603      	mov	r3, r0
 80157aa:	2b01      	cmp	r3, #1
 80157ac:	bf8c      	ite	hi
 80157ae:	2301      	movhi	r3, #1
 80157b0:	2300      	movls	r3, #0
 80157b2:	b2db      	uxtb	r3, r3
 80157b4:	2b00      	cmp	r3, #0
 80157b6:	d018      	beq.n	80157ea <_ZN16XFTimeoutManager4tickEv+0xa8>
            {
                TimeoutList::iterator i = _timeouts.begin();
 80157b8:	687b      	ldr	r3, [r7, #4]
 80157ba:	3308      	adds	r3, #8
 80157bc:	4618      	mov	r0, r3
 80157be:	f000 f9d5 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 80157c2:	4603      	mov	r3, r0
 80157c4:	613b      	str	r3, [r7, #16]

                // Add ticks overrun to next timeout
                i++;
 80157c6:	f107 0310 	add.w	r3, r7, #16
 80157ca:	2100      	movs	r1, #0
 80157cc:	4618      	mov	r0, r3
 80157ce:	f000 f9de 	bl	8015b8e <_ZNSt14_List_iteratorIP9XFTimeoutEppEi>
                (*i)->_relTicks -= pFirstTimeout->_relTicks;
 80157d2:	f107 0310 	add.w	r3, r7, #16
 80157d6:	4618      	mov	r0, r3
 80157d8:	f000 f9ed 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 80157dc:	4603      	mov	r3, r0
 80157de:	681b      	ldr	r3, [r3, #0]
 80157e0:	6999      	ldr	r1, [r3, #24]
 80157e2:	69fa      	ldr	r2, [r7, #28]
 80157e4:	6992      	ldr	r2, [r2, #24]
 80157e6:	1a8a      	subs	r2, r1, r2
 80157e8:	619a      	str	r2, [r3, #24]
            }

            // Inject the timeout back to the behavioral class
            returnTimeout(pFirstTimeout);
 80157ea:	69f9      	ldr	r1, [r7, #28]
 80157ec:	6878      	ldr	r0, [r7, #4]
 80157ee:	f000 f941 	bl	8015a74 <_ZN16XFTimeoutManager13returnTimeoutEP9XFTimeout>

            // Remove timeout
            _timeouts.pop_front();
 80157f2:	687b      	ldr	r3, [r7, #4]
 80157f4:	3308      	adds	r3, #8
 80157f6:	4618      	mov	r0, r3
 80157f8:	f000 f9eb 	bl	8015bd2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE9pop_frontEv>

            // Check if timeouts with same timeout value are present
            for (TimeoutList::iterator it = _timeouts.begin(); it != _timeouts.end(); /*Do not increment here!*/)
 80157fc:	687b      	ldr	r3, [r7, #4]
 80157fe:	3308      	adds	r3, #8
 8015800:	4618      	mov	r0, r3
 8015802:	f000 f9b3 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 8015806:	4603      	mov	r3, r0
 8015808:	60fb      	str	r3, [r7, #12]
 801580a:	687b      	ldr	r3, [r7, #4]
 801580c:	3308      	adds	r3, #8
 801580e:	4618      	mov	r0, r3
 8015810:	f000 f9ef 	bl	8015bf2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE3endEv>
 8015814:	4603      	mov	r3, r0
 8015816:	617b      	str	r3, [r7, #20]
 8015818:	f107 0214 	add.w	r2, r7, #20
 801581c:	f107 030c 	add.w	r3, r7, #12
 8015820:	4611      	mov	r1, r2
 8015822:	4618      	mov	r0, r3
 8015824:	f000 f9f5 	bl	8015c12 <_ZStneRKSt14_List_iteratorIP9XFTimeoutES4_>
 8015828:	4603      	mov	r3, r0
 801582a:	2b00      	cmp	r3, #0
 801582c:	d02c      	beq.n	8015888 <_ZN16XFTimeoutManager4tickEv+0x146>
            {
                if ((*it)->_relTicks == 0)
 801582e:	f107 030c 	add.w	r3, r7, #12
 8015832:	4618      	mov	r0, r3
 8015834:	f000 f9bf 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 8015838:	4603      	mov	r3, r0
 801583a:	681b      	ldr	r3, [r3, #0]
 801583c:	699b      	ldr	r3, [r3, #24]
 801583e:	2b00      	cmp	r3, #0
 8015840:	bf0c      	ite	eq
 8015842:	2301      	moveq	r3, #1
 8015844:	2300      	movne	r3, #0
 8015846:	b2db      	uxtb	r3, r3
 8015848:	2b00      	cmp	r3, #0
 801584a:	d01c      	beq.n	8015886 <_ZN16XFTimeoutManager4tickEv+0x144>
                {
                    returnTimeout(*it);
 801584c:	f107 030c 	add.w	r3, r7, #12
 8015850:	4618      	mov	r0, r3
 8015852:	f000 f9b0 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 8015856:	4603      	mov	r3, r0
 8015858:	681b      	ldr	r3, [r3, #0]
 801585a:	4619      	mov	r1, r3
 801585c:	6878      	ldr	r0, [r7, #4]
 801585e:	f000 f909 	bl	8015a74 <_ZN16XFTimeoutManager13returnTimeoutEP9XFTimeout>
                    it = _timeouts.erase(it);
 8015862:	687b      	ldr	r3, [r7, #4]
 8015864:	f103 0408 	add.w	r4, r3, #8
 8015868:	f107 020c 	add.w	r2, r7, #12
 801586c:	f107 0318 	add.w	r3, r7, #24
 8015870:	4611      	mov	r1, r2
 8015872:	4618      	mov	r0, r3
 8015874:	f000 f9e1 	bl	8015c3a <_ZNSt20_List_const_iteratorIP9XFTimeoutEC1ERKSt14_List_iteratorIS1_E>
 8015878:	69b9      	ldr	r1, [r7, #24]
 801587a:	4620      	mov	r0, r4
 801587c:	f000 f9ed 	bl	8015c5a <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5eraseESt20_List_const_iteratorIS2_E>
 8015880:	4603      	mov	r3, r0
 8015882:	60fb      	str	r3, [r7, #12]
            for (TimeoutList::iterator it = _timeouts.begin(); it != _timeouts.end(); /*Do not increment here!*/)
 8015884:	e7c1      	b.n	801580a <_ZN16XFTimeoutManager4tickEv+0xc8>
                }
                else
                {
                    break;
 8015886:	bf00      	nop
                }
            }
        }
    }
}
 8015888:	bf00      	nop
 801588a:	3724      	adds	r7, #36	; 0x24
 801588c:	46bd      	mov	sp, r7
 801588e:	bd90      	pop	{r4, r7, pc}

08015890 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout>:

void XFTimeoutManager::addTimeout(XFTimeout * pNewTimeout)
{
 8015890:	b590      	push	{r4, r7, lr}
 8015892:	b089      	sub	sp, #36	; 0x24
 8015894:	af00      	add	r7, sp, #0
 8015896:	6078      	str	r0, [r7, #4]
 8015898:	6039      	str	r1, [r7, #0]
    enterCritical();
 801589a:	f7fd fe05 	bl	80134a8 <enterCritical>

    if (!_timeouts.empty())
 801589e:	687b      	ldr	r3, [r7, #4]
 80158a0:	3308      	adds	r3, #8
 80158a2:	4618      	mov	r0, r3
 80158a4:	f000 f931 	bl	8015b0a <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE5emptyEv>
 80158a8:	4603      	mov	r3, r0
 80158aa:	f083 0301 	eor.w	r3, r3, #1
 80158ae:	b2db      	uxtb	r3, r3
 80158b0:	2b00      	cmp	r3, #0
 80158b2:	f000 80cb 	beq.w	8015a4c <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1bc>
    {
        // Insert timeout before timeout(s) triggering later
        TimeoutList::iterator i = _timeouts.begin();
 80158b6:	687b      	ldr	r3, [r7, #4]
 80158b8:	3308      	adds	r3, #8
 80158ba:	4618      	mov	r0, r3
 80158bc:	f000 f956 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 80158c0:	4603      	mov	r3, r0
 80158c2:	60fb      	str	r3, [r7, #12]

        if ((*i)->_relTicks >= pNewTimeout->_relTicks)
 80158c4:	f107 030c 	add.w	r3, r7, #12
 80158c8:	4618      	mov	r0, r3
 80158ca:	f000 f974 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 80158ce:	4603      	mov	r3, r0
 80158d0:	681b      	ldr	r3, [r3, #0]
 80158d2:	699a      	ldr	r2, [r3, #24]
 80158d4:	683b      	ldr	r3, [r7, #0]
 80158d6:	699b      	ldr	r3, [r3, #24]
 80158d8:	429a      	cmp	r2, r3
 80158da:	bfac      	ite	ge
 80158dc:	2301      	movge	r3, #1
 80158de:	2300      	movlt	r3, #0
 80158e0:	b2db      	uxtb	r3, r3
 80158e2:	2b00      	cmp	r3, #0
 80158e4:	d013      	beq.n	801590e <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x7e>
        {
            // A new timeout at the beginning
            _timeouts.push_front(pNewTimeout);
 80158e6:	687b      	ldr	r3, [r7, #4]
 80158e8:	3308      	adds	r3, #8
 80158ea:	463a      	mov	r2, r7
 80158ec:	4611      	mov	r1, r2
 80158ee:	4618      	mov	r0, r3
 80158f0:	f000 f9ce 	bl	8015c90 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE10push_frontERKS2_>

            // Remove time from following timeout
            (*i)->_relTicks -= pNewTimeout->_relTicks;
 80158f4:	f107 030c 	add.w	r3, r7, #12
 80158f8:	4618      	mov	r0, r3
 80158fa:	f000 f95c 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 80158fe:	4603      	mov	r3, r0
 8015900:	681b      	ldr	r3, [r3, #0]
 8015902:	6999      	ldr	r1, [r3, #24]
 8015904:	683a      	ldr	r2, [r7, #0]
 8015906:	6992      	ldr	r2, [r2, #24]
 8015908:	1a8a      	subs	r2, r1, r2
 801590a:	619a      	str	r2, [r3, #24]
 801590c:	e0a5      	b.n	8015a5a <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1ca>
        }
        else
        {
            unsigned int index = 0;
 801590e:	2300      	movs	r3, #0
 8015910:	61fb      	str	r3, [r7, #28]

            // Remove time from new timeout
            pNewTimeout->_relTicks -= (*i)->_relTicks;
 8015912:	f107 030c 	add.w	r3, r7, #12
 8015916:	4618      	mov	r0, r3
 8015918:	f000 f94d 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 801591c:	4603      	mov	r3, r0
 801591e:	681b      	ldr	r3, [r3, #0]
 8015920:	699a      	ldr	r2, [r3, #24]
 8015922:	683b      	ldr	r3, [r7, #0]
 8015924:	6999      	ldr	r1, [r3, #24]
 8015926:	683b      	ldr	r3, [r7, #0]
 8015928:	1a8a      	subs	r2, r1, r2
 801592a:	619a      	str	r2, [r3, #24]
            i++; index++;
 801592c:	f107 030c 	add.w	r3, r7, #12
 8015930:	2100      	movs	r1, #0
 8015932:	4618      	mov	r0, r3
 8015934:	f000 f92b 	bl	8015b8e <_ZNSt14_List_iteratorIP9XFTimeoutEppEi>
 8015938:	69fb      	ldr	r3, [r7, #28]
 801593a:	3301      	adds	r3, #1
 801593c:	61fb      	str	r3, [r7, #28]

            while (i != _timeouts.end() &&
 801593e:	687b      	ldr	r3, [r7, #4]
 8015940:	3308      	adds	r3, #8
 8015942:	4618      	mov	r0, r3
 8015944:	f000 f955 	bl	8015bf2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE3endEv>
 8015948:	4603      	mov	r3, r0
 801594a:	613b      	str	r3, [r7, #16]
 801594c:	f107 0210 	add.w	r2, r7, #16
 8015950:	f107 030c 	add.w	r3, r7, #12
 8015954:	4611      	mov	r1, r2
 8015956:	4618      	mov	r0, r3
 8015958:	f000 f95b 	bl	8015c12 <_ZStneRKSt14_List_iteratorIP9XFTimeoutES4_>
 801595c:	4603      	mov	r3, r0
 801595e:	2b00      	cmp	r3, #0
 8015960:	d00d      	beq.n	801597e <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0xee>
                   (*i)->_relTicks < pNewTimeout->_relTicks)
 8015962:	f107 030c 	add.w	r3, r7, #12
 8015966:	4618      	mov	r0, r3
 8015968:	f000 f925 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 801596c:	4603      	mov	r3, r0
 801596e:	681b      	ldr	r3, [r3, #0]
 8015970:	699a      	ldr	r2, [r3, #24]
 8015972:	683b      	ldr	r3, [r7, #0]
 8015974:	699b      	ldr	r3, [r3, #24]
            while (i != _timeouts.end() &&
 8015976:	429a      	cmp	r2, r3
 8015978:	da01      	bge.n	801597e <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0xee>
 801597a:	2301      	movs	r3, #1
 801597c:	e000      	b.n	8015980 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0xf0>
 801597e:	2300      	movs	r3, #0
 8015980:	2b00      	cmp	r3, #0
 8015982:	d016      	beq.n	80159b2 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x122>
            {
                pNewTimeout->_relTicks -= (*i)->_relTicks;
 8015984:	f107 030c 	add.w	r3, r7, #12
 8015988:	4618      	mov	r0, r3
 801598a:	f000 f914 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 801598e:	4603      	mov	r3, r0
 8015990:	681b      	ldr	r3, [r3, #0]
 8015992:	699a      	ldr	r2, [r3, #24]
 8015994:	683b      	ldr	r3, [r7, #0]
 8015996:	6999      	ldr	r1, [r3, #24]
 8015998:	683b      	ldr	r3, [r7, #0]
 801599a:	1a8a      	subs	r2, r1, r2
 801599c:	619a      	str	r2, [r3, #24]
                i++; index++;
 801599e:	f107 030c 	add.w	r3, r7, #12
 80159a2:	2100      	movs	r1, #0
 80159a4:	4618      	mov	r0, r3
 80159a6:	f000 f8f2 	bl	8015b8e <_ZNSt14_List_iteratorIP9XFTimeoutEppEi>
 80159aa:	69fb      	ldr	r3, [r7, #28]
 80159ac:	3301      	adds	r3, #1
 80159ae:	61fb      	str	r3, [r7, #28]
            while (i != _timeouts.end() &&
 80159b0:	e7c5      	b.n	801593e <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0xae>
            }
            // Insert new timeout before
            i = _timeouts.insert(i, pNewTimeout);
 80159b2:	687b      	ldr	r3, [r7, #4]
 80159b4:	f103 0408 	add.w	r4, r3, #8
 80159b8:	f107 020c 	add.w	r2, r7, #12
 80159bc:	f107 0314 	add.w	r3, r7, #20
 80159c0:	4611      	mov	r1, r2
 80159c2:	4618      	mov	r0, r3
 80159c4:	f000 f939 	bl	8015c3a <_ZNSt20_List_const_iteratorIP9XFTimeoutEC1ERKSt14_List_iteratorIS1_E>
 80159c8:	463b      	mov	r3, r7
 80159ca:	461a      	mov	r2, r3
 80159cc:	6979      	ldr	r1, [r7, #20]
 80159ce:	4620      	mov	r0, r4
 80159d0:	f000 f970 	bl	8015cb4 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE6insertESt20_List_const_iteratorIS2_ERKS2_>
 80159d4:	4603      	mov	r3, r0
 80159d6:	60fb      	str	r3, [r7, #12]

            if (_timeouts.size() > index + 1)
 80159d8:	687b      	ldr	r3, [r7, #4]
 80159da:	3308      	adds	r3, #8
 80159dc:	4618      	mov	r0, r3
 80159de:	f000 f8b9 	bl	8015b54 <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE4sizeEv>
 80159e2:	4602      	mov	r2, r0
 80159e4:	69fb      	ldr	r3, [r7, #28]
 80159e6:	3301      	adds	r3, #1
 80159e8:	429a      	cmp	r2, r3
 80159ea:	bf8c      	ite	hi
 80159ec:	2301      	movhi	r3, #1
 80159ee:	2300      	movls	r3, #0
 80159f0:	b2db      	uxtb	r3, r3
 80159f2:	2b00      	cmp	r3, #0
 80159f4:	d031      	beq.n	8015a5a <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1ca>
            {
                // Remove time from following timeout
                i++;
 80159f6:	f107 030c 	add.w	r3, r7, #12
 80159fa:	2100      	movs	r1, #0
 80159fc:	4618      	mov	r0, r3
 80159fe:	f000 f8c6 	bl	8015b8e <_ZNSt14_List_iteratorIP9XFTimeoutEppEi>
                assert(i != _timeouts.end());
 8015a02:	687b      	ldr	r3, [r7, #4]
 8015a04:	3308      	adds	r3, #8
 8015a06:	4618      	mov	r0, r3
 8015a08:	f000 f8f3 	bl	8015bf2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE3endEv>
 8015a0c:	4603      	mov	r3, r0
 8015a0e:	61bb      	str	r3, [r7, #24]
 8015a10:	f107 0218 	add.w	r2, r7, #24
 8015a14:	f107 030c 	add.w	r3, r7, #12
 8015a18:	4611      	mov	r1, r2
 8015a1a:	4618      	mov	r0, r3
 8015a1c:	f000 f8f9 	bl	8015c12 <_ZStneRKSt14_List_iteratorIP9XFTimeoutES4_>
 8015a20:	4603      	mov	r3, r0
 8015a22:	2b00      	cmp	r3, #0
 8015a24:	d105      	bne.n	8015a32 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1a2>
 8015a26:	4b10      	ldr	r3, [pc, #64]	; (8015a68 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1d8>)
 8015a28:	4a10      	ldr	r2, [pc, #64]	; (8015a6c <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1dc>)
 8015a2a:	21be      	movs	r1, #190	; 0xbe
 8015a2c:	4810      	ldr	r0, [pc, #64]	; (8015a70 <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1e0>)
 8015a2e:	f000 fcb1 	bl	8016394 <__assert_func>
                (*i)->_relTicks -= pNewTimeout->_relTicks;
 8015a32:	f107 030c 	add.w	r3, r7, #12
 8015a36:	4618      	mov	r0, r3
 8015a38:	f000 f8bd 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 8015a3c:	4603      	mov	r3, r0
 8015a3e:	681b      	ldr	r3, [r3, #0]
 8015a40:	6999      	ldr	r1, [r3, #24]
 8015a42:	683a      	ldr	r2, [r7, #0]
 8015a44:	6992      	ldr	r2, [r2, #24]
 8015a46:	1a8a      	subs	r2, r1, r2
 8015a48:	619a      	str	r2, [r3, #24]
 8015a4a:	e006      	b.n	8015a5a <_ZN16XFTimeoutManager10addTimeoutEP9XFTimeout+0x1ca>
            }
        }
    }
    else
    {
        _timeouts.push_front(pNewTimeout);
 8015a4c:	687b      	ldr	r3, [r7, #4]
 8015a4e:	3308      	adds	r3, #8
 8015a50:	463a      	mov	r2, r7
 8015a52:	4611      	mov	r1, r2
 8015a54:	4618      	mov	r0, r3
 8015a56:	f000 f91b 	bl	8015c90 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE10push_frontERKS2_>
    }

    exitCritical();
 8015a5a:	f7fd fd43 	bl	80134e4 <exitCritical>
}
 8015a5e:	bf00      	nop
 8015a60:	3724      	adds	r7, #36	; 0x24
 8015a62:	46bd      	mov	sp, r7
 8015a64:	bd90      	pop	{r4, r7, pc}
 8015a66:	bf00      	nop
 8015a68:	0801b78c 	.word	0x0801b78c
 8015a6c:	0801b7a4 	.word	0x0801b7a4
 8015a70:	0801b7d4 	.word	0x0801b7d4

08015a74 <_ZN16XFTimeoutManager13returnTimeoutEP9XFTimeout>:
/**
 * Returns the timeout back to the queue of the thread executing
 * the behavioral instance.
 */
void XFTimeoutManager::returnTimeout(XFTimeout * pTimeout)
{
 8015a74:	b580      	push	{r7, lr}
 8015a76:	b082      	sub	sp, #8
 8015a78:	af00      	add	r7, sp, #0
 8015a7a:	6078      	str	r0, [r7, #4]
 8015a7c:	6039      	str	r1, [r7, #0]
    pTimeout->getBehavior()->pushEvent(pTimeout);
 8015a7e:	683b      	ldr	r3, [r7, #0]
 8015a80:	4618      	mov	r0, r3
 8015a82:	f7fe fcb9 	bl	80143f8 <_ZNK8IXFEvent11getBehaviorEv>
 8015a86:	4603      	mov	r3, r0
 8015a88:	681a      	ldr	r2, [r3, #0]
 8015a8a:	320c      	adds	r2, #12
 8015a8c:	6812      	ldr	r2, [r2, #0]
 8015a8e:	6839      	ldr	r1, [r7, #0]
 8015a90:	4618      	mov	r0, r3
 8015a92:	4790      	blx	r2
}
 8015a94:	bf00      	nop
 8015a96:	3708      	adds	r7, #8
 8015a98:	46bd      	mov	sp, r7
 8015a9a:	bd80      	pop	{r7, pc}

08015a9c <_ZN16XFTimeoutManager18startHardwareTimerEi>:
 * in a regular interval given by parameter tickTime
 *
 * \param tickTime Time in milliseconds the hardware timer should call XFTimeoutManager::tick()
 */
void XFTimeoutManager::startHardwareTimer(int tickTime)
{
 8015a9c:	b480      	push	{r7}
 8015a9e:	b083      	sub	sp, #12
 8015aa0:	af00      	add	r7, sp, #0
 8015aa2:	6078      	str	r0, [r7, #4]
 8015aa4:	6039      	str	r1, [r7, #0]
    startTimer( tickTime );

#endif /**************************************************************************************************************/


}
 8015aa6:	bf00      	nop
 8015aa8:	370c      	adds	r7, #12
 8015aaa:	46bd      	mov	sp, r7
 8015aac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ab0:	4770      	bx	lr

08015ab2 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE10_List_implC1Ev>:
	_List_impl() _GLIBCXX_NOEXCEPT_IF(
 8015ab2:	b580      	push	{r7, lr}
 8015ab4:	b082      	sub	sp, #8
 8015ab6:	af00      	add	r7, sp, #0
 8015ab8:	6078      	str	r0, [r7, #4]
	: _Node_alloc_type()
 8015aba:	6878      	ldr	r0, [r7, #4]
 8015abc:	f000 f920 	bl	8015d00 <_ZNSaISt10_List_nodeIP9XFTimeoutEEC1Ev>
 8015ac0:	687b      	ldr	r3, [r7, #4]
 8015ac2:	4618      	mov	r0, r3
 8015ac4:	f7f5 fa4a 	bl	800af5c <_ZNSt8__detail17_List_node_headerC1Ev>
	{ }
 8015ac8:	687b      	ldr	r3, [r7, #4]
 8015aca:	4618      	mov	r0, r3
 8015acc:	3708      	adds	r7, #8
 8015ace:	46bd      	mov	sp, r7
 8015ad0:	bd80      	pop	{r7, pc}

08015ad2 <_ZNSaISt10_List_nodeIP9XFTimeoutEED1Ev>:
      ~allocator() _GLIBCXX_NOTHROW { }
 8015ad2:	b580      	push	{r7, lr}
 8015ad4:	b082      	sub	sp, #8
 8015ad6:	af00      	add	r7, sp, #0
 8015ad8:	6078      	str	r0, [r7, #4]
 8015ada:	6878      	ldr	r0, [r7, #4]
 8015adc:	f000 f91c 	bl	8015d18 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEED1Ev>
 8015ae0:	687b      	ldr	r3, [r7, #4]
 8015ae2:	4618      	mov	r0, r3
 8015ae4:	3708      	adds	r7, #8
 8015ae6:	46bd      	mov	sp, r7
 8015ae8:	bd80      	pop	{r7, pc}

08015aea <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EED1Ev>:
      ~_List_base() _GLIBCXX_NOEXCEPT
 8015aea:	b580      	push	{r7, lr}
 8015aec:	b082      	sub	sp, #8
 8015aee:	af00      	add	r7, sp, #0
 8015af0:	6078      	str	r0, [r7, #4]
      { _M_clear(); }
 8015af2:	6878      	ldr	r0, [r7, #4]
 8015af4:	f000 f91b 	bl	8015d2e <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE8_M_clearEv>
 8015af8:	687b      	ldr	r3, [r7, #4]
 8015afa:	4618      	mov	r0, r3
 8015afc:	f7ff fd58 	bl	80155b0 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE10_List_implD1Ev>
 8015b00:	687b      	ldr	r3, [r7, #4]
 8015b02:	4618      	mov	r0, r3
 8015b04:	3708      	adds	r7, #8
 8015b06:	46bd      	mov	sp, r7
 8015b08:	bd80      	pop	{r7, pc}

08015b0a <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE5emptyEv>:
      empty() const _GLIBCXX_NOEXCEPT
 8015b0a:	b480      	push	{r7}
 8015b0c:	b083      	sub	sp, #12
 8015b0e:	af00      	add	r7, sp, #0
 8015b10:	6078      	str	r0, [r7, #4]
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
 8015b12:	687b      	ldr	r3, [r7, #4]
 8015b14:	681a      	ldr	r2, [r3, #0]
 8015b16:	687b      	ldr	r3, [r7, #4]
 8015b18:	429a      	cmp	r2, r3
 8015b1a:	bf0c      	ite	eq
 8015b1c:	2301      	moveq	r3, #1
 8015b1e:	2300      	movne	r3, #0
 8015b20:	b2db      	uxtb	r3, r3
 8015b22:	4618      	mov	r0, r3
 8015b24:	370c      	adds	r7, #12
 8015b26:	46bd      	mov	sp, r7
 8015b28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015b2c:	4770      	bx	lr

08015b2e <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5frontEv>:
      front() _GLIBCXX_NOEXCEPT
 8015b2e:	b580      	push	{r7, lr}
 8015b30:	b084      	sub	sp, #16
 8015b32:	af00      	add	r7, sp, #0
 8015b34:	6078      	str	r0, [r7, #4]
      { return *begin(); }
 8015b36:	6878      	ldr	r0, [r7, #4]
 8015b38:	f000 f818 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 8015b3c:	4603      	mov	r3, r0
 8015b3e:	60fb      	str	r3, [r7, #12]
 8015b40:	f107 030c 	add.w	r3, r7, #12
 8015b44:	4618      	mov	r0, r3
 8015b46:	f000 f836 	bl	8015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>
 8015b4a:	4603      	mov	r3, r0
 8015b4c:	4618      	mov	r0, r3
 8015b4e:	3710      	adds	r7, #16
 8015b50:	46bd      	mov	sp, r7
 8015b52:	bd80      	pop	{r7, pc}

08015b54 <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE4sizeEv>:
      size() const _GLIBCXX_NOEXCEPT
 8015b54:	b580      	push	{r7, lr}
 8015b56:	b082      	sub	sp, #8
 8015b58:	af00      	add	r7, sp, #0
 8015b5a:	6078      	str	r0, [r7, #4]
      { return _M_node_count(); }
 8015b5c:	6878      	ldr	r0, [r7, #4]
 8015b5e:	f000 f90b 	bl	8015d78 <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE13_M_node_countEv>
 8015b62:	4603      	mov	r3, r0
 8015b64:	4618      	mov	r0, r3
 8015b66:	3708      	adds	r7, #8
 8015b68:	46bd      	mov	sp, r7
 8015b6a:	bd80      	pop	{r7, pc}

08015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>:
      begin() _GLIBCXX_NOEXCEPT
 8015b6c:	b580      	push	{r7, lr}
 8015b6e:	b084      	sub	sp, #16
 8015b70:	af00      	add	r7, sp, #0
 8015b72:	6078      	str	r0, [r7, #4]
      { return iterator(this->_M_impl._M_node._M_next); }
 8015b74:	687b      	ldr	r3, [r7, #4]
 8015b76:	681a      	ldr	r2, [r3, #0]
 8015b78:	f107 030c 	add.w	r3, r7, #12
 8015b7c:	4611      	mov	r1, r2
 8015b7e:	4618      	mov	r0, r3
 8015b80:	f000 f907 	bl	8015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>
 8015b84:	68fb      	ldr	r3, [r7, #12]
 8015b86:	4618      	mov	r0, r3
 8015b88:	3710      	adds	r7, #16
 8015b8a:	46bd      	mov	sp, r7
 8015b8c:	bd80      	pop	{r7, pc}

08015b8e <_ZNSt14_List_iteratorIP9XFTimeoutEppEi>:
      operator++(int) _GLIBCXX_NOEXCEPT
 8015b8e:	b480      	push	{r7}
 8015b90:	b085      	sub	sp, #20
 8015b92:	af00      	add	r7, sp, #0
 8015b94:	6078      	str	r0, [r7, #4]
 8015b96:	6039      	str	r1, [r7, #0]
	_Self __tmp = *this;
 8015b98:	687b      	ldr	r3, [r7, #4]
 8015b9a:	681b      	ldr	r3, [r3, #0]
 8015b9c:	60fb      	str	r3, [r7, #12]
	_M_node = _M_node->_M_next;
 8015b9e:	687b      	ldr	r3, [r7, #4]
 8015ba0:	681b      	ldr	r3, [r3, #0]
 8015ba2:	681a      	ldr	r2, [r3, #0]
 8015ba4:	687b      	ldr	r3, [r7, #4]
 8015ba6:	601a      	str	r2, [r3, #0]
	return __tmp;
 8015ba8:	68fb      	ldr	r3, [r7, #12]
      }
 8015baa:	4618      	mov	r0, r3
 8015bac:	3714      	adds	r7, #20
 8015bae:	46bd      	mov	sp, r7
 8015bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015bb4:	4770      	bx	lr

08015bb6 <_ZNKSt14_List_iteratorIP9XFTimeoutEdeEv>:
      operator*() const _GLIBCXX_NOEXCEPT
 8015bb6:	b580      	push	{r7, lr}
 8015bb8:	b082      	sub	sp, #8
 8015bba:	af00      	add	r7, sp, #0
 8015bbc:	6078      	str	r0, [r7, #4]
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }
 8015bbe:	687b      	ldr	r3, [r7, #4]
 8015bc0:	681b      	ldr	r3, [r3, #0]
 8015bc2:	4618      	mov	r0, r3
 8015bc4:	f000 f8f4 	bl	8015db0 <_ZNSt10_List_nodeIP9XFTimeoutE9_M_valptrEv>
 8015bc8:	4603      	mov	r3, r0
 8015bca:	4618      	mov	r0, r3
 8015bcc:	3708      	adds	r7, #8
 8015bce:	46bd      	mov	sp, r7
 8015bd0:	bd80      	pop	{r7, pc}

08015bd2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE9pop_frontEv>:
      pop_front() _GLIBCXX_NOEXCEPT
 8015bd2:	b580      	push	{r7, lr}
 8015bd4:	b082      	sub	sp, #8
 8015bd6:	af00      	add	r7, sp, #0
 8015bd8:	6078      	str	r0, [r7, #4]
      { this->_M_erase(begin()); }
 8015bda:	6878      	ldr	r0, [r7, #4]
 8015bdc:	f7ff ffc6 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 8015be0:	4603      	mov	r3, r0
 8015be2:	4619      	mov	r1, r3
 8015be4:	6878      	ldr	r0, [r7, #4]
 8015be6:	f000 f8f1 	bl	8015dcc <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE8_M_eraseESt14_List_iteratorIS2_E>
 8015bea:	bf00      	nop
 8015bec:	3708      	adds	r7, #8
 8015bee:	46bd      	mov	sp, r7
 8015bf0:	bd80      	pop	{r7, pc}

08015bf2 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE3endEv>:
      end() _GLIBCXX_NOEXCEPT
 8015bf2:	b580      	push	{r7, lr}
 8015bf4:	b084      	sub	sp, #16
 8015bf6:	af00      	add	r7, sp, #0
 8015bf8:	6078      	str	r0, [r7, #4]
      { return iterator(&this->_M_impl._M_node); }
 8015bfa:	687a      	ldr	r2, [r7, #4]
 8015bfc:	f107 030c 	add.w	r3, r7, #12
 8015c00:	4611      	mov	r1, r2
 8015c02:	4618      	mov	r0, r3
 8015c04:	f000 f8c5 	bl	8015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>
 8015c08:	68fb      	ldr	r3, [r7, #12]
 8015c0a:	4618      	mov	r0, r3
 8015c0c:	3710      	adds	r7, #16
 8015c0e:	46bd      	mov	sp, r7
 8015c10:	bd80      	pop	{r7, pc}

08015c12 <_ZStneRKSt14_List_iteratorIP9XFTimeoutES4_>:
      operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 8015c12:	b480      	push	{r7}
 8015c14:	b083      	sub	sp, #12
 8015c16:	af00      	add	r7, sp, #0
 8015c18:	6078      	str	r0, [r7, #4]
 8015c1a:	6039      	str	r1, [r7, #0]
      { return __x._M_node != __y._M_node; }
 8015c1c:	687b      	ldr	r3, [r7, #4]
 8015c1e:	681a      	ldr	r2, [r3, #0]
 8015c20:	683b      	ldr	r3, [r7, #0]
 8015c22:	681b      	ldr	r3, [r3, #0]
 8015c24:	429a      	cmp	r2, r3
 8015c26:	bf14      	ite	ne
 8015c28:	2301      	movne	r3, #1
 8015c2a:	2300      	moveq	r3, #0
 8015c2c:	b2db      	uxtb	r3, r3
 8015c2e:	4618      	mov	r0, r3
 8015c30:	370c      	adds	r7, #12
 8015c32:	46bd      	mov	sp, r7
 8015c34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c38:	4770      	bx	lr

08015c3a <_ZNSt20_List_const_iteratorIP9XFTimeoutEC1ERKSt14_List_iteratorIS1_E>:
      _List_const_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
 8015c3a:	b480      	push	{r7}
 8015c3c:	b083      	sub	sp, #12
 8015c3e:	af00      	add	r7, sp, #0
 8015c40:	6078      	str	r0, [r7, #4]
 8015c42:	6039      	str	r1, [r7, #0]
      : _M_node(__x._M_node) { }
 8015c44:	683b      	ldr	r3, [r7, #0]
 8015c46:	681a      	ldr	r2, [r3, #0]
 8015c48:	687b      	ldr	r3, [r7, #4]
 8015c4a:	601a      	str	r2, [r3, #0]
 8015c4c:	687b      	ldr	r3, [r7, #4]
 8015c4e:	4618      	mov	r0, r3
 8015c50:	370c      	adds	r7, #12
 8015c52:	46bd      	mov	sp, r7
 8015c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c58:	4770      	bx	lr

08015c5a <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5eraseESt20_List_const_iteratorIS2_E>:
    list<_Tp, _Alloc>::
 8015c5a:	b580      	push	{r7, lr}
 8015c5c:	b084      	sub	sp, #16
 8015c5e:	af00      	add	r7, sp, #0
 8015c60:	6078      	str	r0, [r7, #4]
 8015c62:	6039      	str	r1, [r7, #0]
      iterator __ret = iterator(__position._M_node->_M_next);
 8015c64:	683b      	ldr	r3, [r7, #0]
 8015c66:	681a      	ldr	r2, [r3, #0]
 8015c68:	f107 030c 	add.w	r3, r7, #12
 8015c6c:	4611      	mov	r1, r2
 8015c6e:	4618      	mov	r0, r3
 8015c70:	f000 f88f 	bl	8015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>
      _M_erase(__position._M_const_cast());
 8015c74:	463b      	mov	r3, r7
 8015c76:	4618      	mov	r0, r3
 8015c78:	f000 f8ce 	bl	8015e18 <_ZNKSt20_List_const_iteratorIP9XFTimeoutE13_M_const_castEv>
 8015c7c:	4603      	mov	r3, r0
 8015c7e:	4619      	mov	r1, r3
 8015c80:	6878      	ldr	r0, [r7, #4]
 8015c82:	f000 f8a3 	bl	8015dcc <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE8_M_eraseESt14_List_iteratorIS2_E>
      return __ret;
 8015c86:	68fb      	ldr	r3, [r7, #12]
    }
 8015c88:	4618      	mov	r0, r3
 8015c8a:	3710      	adds	r7, #16
 8015c8c:	46bd      	mov	sp, r7
 8015c8e:	bd80      	pop	{r7, pc}

08015c90 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE10push_frontERKS2_>:
      push_front(const value_type& __x)
 8015c90:	b580      	push	{r7, lr}
 8015c92:	b082      	sub	sp, #8
 8015c94:	af00      	add	r7, sp, #0
 8015c96:	6078      	str	r0, [r7, #4]
 8015c98:	6039      	str	r1, [r7, #0]
      { this->_M_insert(begin(), __x); }
 8015c9a:	6878      	ldr	r0, [r7, #4]
 8015c9c:	f7ff ff66 	bl	8015b6c <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE5beginEv>
 8015ca0:	4603      	mov	r3, r0
 8015ca2:	683a      	ldr	r2, [r7, #0]
 8015ca4:	4619      	mov	r1, r3
 8015ca6:	6878      	ldr	r0, [r7, #4]
 8015ca8:	f000 f8c7 	bl	8015e3a <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE9_M_insertIJRKS2_EEEvSt14_List_iteratorIS2_EDpOT_>
 8015cac:	bf00      	nop
 8015cae:	3708      	adds	r7, #8
 8015cb0:	46bd      	mov	sp, r7
 8015cb2:	bd80      	pop	{r7, pc}

08015cb4 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE6insertESt20_List_const_iteratorIS2_ERKS2_>:
    list<_Tp, _Alloc>::
 8015cb4:	b590      	push	{r4, r7, lr}
 8015cb6:	b087      	sub	sp, #28
 8015cb8:	af00      	add	r7, sp, #0
 8015cba:	60f8      	str	r0, [r7, #12]
 8015cbc:	60b9      	str	r1, [r7, #8]
 8015cbe:	607a      	str	r2, [r7, #4]
      _Node* __tmp = _M_create_node(__x);
 8015cc0:	6879      	ldr	r1, [r7, #4]
 8015cc2:	68f8      	ldr	r0, [r7, #12]
 8015cc4:	f000 f8d7 	bl	8015e76 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE14_M_create_nodeIJRKS2_EEEPSt10_List_nodeIS2_EDpOT_>
 8015cc8:	6178      	str	r0, [r7, #20]
      __tmp->_M_hook(__position._M_const_cast()._M_node);
 8015cca:	697c      	ldr	r4, [r7, #20]
 8015ccc:	f107 0308 	add.w	r3, r7, #8
 8015cd0:	4618      	mov	r0, r3
 8015cd2:	f000 f8a1 	bl	8015e18 <_ZNKSt20_List_const_iteratorIP9XFTimeoutE13_M_const_castEv>
 8015cd6:	4603      	mov	r3, r0
 8015cd8:	4619      	mov	r1, r3
 8015cda:	4620      	mov	r0, r4
 8015cdc:	f000 fa91 	bl	8016202 <_ZNSt8__detail15_List_node_base7_M_hookEPS0_>
      this->_M_inc_size(1);
 8015ce0:	68fb      	ldr	r3, [r7, #12]
 8015ce2:	2101      	movs	r1, #1
 8015ce4:	4618      	mov	r0, r3
 8015ce6:	f000 f8fa 	bl	8015ede <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_inc_sizeEj>
      return iterator(__tmp);
 8015cea:	f107 0310 	add.w	r3, r7, #16
 8015cee:	6979      	ldr	r1, [r7, #20]
 8015cf0:	4618      	mov	r0, r3
 8015cf2:	f000 f84e 	bl	8015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>
 8015cf6:	693b      	ldr	r3, [r7, #16]
    }
 8015cf8:	4618      	mov	r0, r3
 8015cfa:	371c      	adds	r7, #28
 8015cfc:	46bd      	mov	sp, r7
 8015cfe:	bd90      	pop	{r4, r7, pc}

08015d00 <_ZNSaISt10_List_nodeIP9XFTimeoutEEC1Ev>:
      allocator() _GLIBCXX_NOTHROW { }
 8015d00:	b580      	push	{r7, lr}
 8015d02:	b082      	sub	sp, #8
 8015d04:	af00      	add	r7, sp, #0
 8015d06:	6078      	str	r0, [r7, #4]
 8015d08:	6878      	ldr	r0, [r7, #4]
 8015d0a:	f000 f8f9 	bl	8015f00 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEEC1Ev>
 8015d0e:	687b      	ldr	r3, [r7, #4]
 8015d10:	4618      	mov	r0, r3
 8015d12:	3708      	adds	r7, #8
 8015d14:	46bd      	mov	sp, r7
 8015d16:	bd80      	pop	{r7, pc}

08015d18 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEED1Ev>:
      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8015d18:	b480      	push	{r7}
 8015d1a:	b083      	sub	sp, #12
 8015d1c:	af00      	add	r7, sp, #0
 8015d1e:	6078      	str	r0, [r7, #4]
 8015d20:	687b      	ldr	r3, [r7, #4]
 8015d22:	4618      	mov	r0, r3
 8015d24:	370c      	adds	r7, #12
 8015d26:	46bd      	mov	sp, r7
 8015d28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015d2c:	4770      	bx	lr

08015d2e <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE8_M_clearEv>:
    _List_base<_Tp, _Alloc>::
 8015d2e:	b580      	push	{r7, lr}
 8015d30:	b086      	sub	sp, #24
 8015d32:	af00      	add	r7, sp, #0
 8015d34:	6078      	str	r0, [r7, #4]
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
 8015d36:	687b      	ldr	r3, [r7, #4]
 8015d38:	681b      	ldr	r3, [r3, #0]
 8015d3a:	617b      	str	r3, [r7, #20]
      while (__cur != &_M_impl._M_node)
 8015d3c:	687b      	ldr	r3, [r7, #4]
 8015d3e:	697a      	ldr	r2, [r7, #20]
 8015d40:	429a      	cmp	r2, r3
 8015d42:	d015      	beq.n	8015d70 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE8_M_clearEv+0x42>
	  _Node* __tmp = static_cast<_Node*>(__cur);
 8015d44:	697b      	ldr	r3, [r7, #20]
 8015d46:	613b      	str	r3, [r7, #16]
	  __cur = __tmp->_M_next;
 8015d48:	693b      	ldr	r3, [r7, #16]
 8015d4a:	681b      	ldr	r3, [r3, #0]
 8015d4c:	617b      	str	r3, [r7, #20]
	  _Tp* __val = __tmp->_M_valptr();
 8015d4e:	6938      	ldr	r0, [r7, #16]
 8015d50:	f000 f82e 	bl	8015db0 <_ZNSt10_List_nodeIP9XFTimeoutE9_M_valptrEv>
 8015d54:	60f8      	str	r0, [r7, #12]
	  _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);
 8015d56:	6878      	ldr	r0, [r7, #4]
 8015d58:	f000 f8dd 	bl	8015f16 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE21_M_get_Node_allocatorEv>
 8015d5c:	4603      	mov	r3, r0
 8015d5e:	68f9      	ldr	r1, [r7, #12]
 8015d60:	4618      	mov	r0, r3
 8015d62:	f000 f8e3 	bl	8015f2c <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE7destroyIS2_EEvRS4_PT_>
	  _M_put_node(__tmp);
 8015d66:	6939      	ldr	r1, [r7, #16]
 8015d68:	6878      	ldr	r0, [r7, #4]
 8015d6a:	f000 f8ec 	bl	8015f46 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_put_nodeEPSt10_List_nodeIS2_E>
      while (__cur != &_M_impl._M_node)
 8015d6e:	e7e5      	b.n	8015d3c <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE8_M_clearEv+0xe>
    }
 8015d70:	bf00      	nop
 8015d72:	3718      	adds	r7, #24
 8015d74:	46bd      	mov	sp, r7
 8015d76:	bd80      	pop	{r7, pc}

08015d78 <_ZNKSt7__cxx114listIP9XFTimeoutSaIS2_EE13_M_node_countEv>:
      _M_node_count() const
 8015d78:	b580      	push	{r7, lr}
 8015d7a:	b082      	sub	sp, #8
 8015d7c:	af00      	add	r7, sp, #0
 8015d7e:	6078      	str	r0, [r7, #4]
      { return this->_M_get_size(); }
 8015d80:	687b      	ldr	r3, [r7, #4]
 8015d82:	4618      	mov	r0, r3
 8015d84:	f000 f8ee 	bl	8015f64 <_ZNKSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_get_sizeEv>
 8015d88:	4603      	mov	r3, r0
 8015d8a:	4618      	mov	r0, r3
 8015d8c:	3708      	adds	r7, #8
 8015d8e:	46bd      	mov	sp, r7
 8015d90:	bd80      	pop	{r7, pc}

08015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>:
      _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
 8015d92:	b480      	push	{r7}
 8015d94:	b083      	sub	sp, #12
 8015d96:	af00      	add	r7, sp, #0
 8015d98:	6078      	str	r0, [r7, #4]
 8015d9a:	6039      	str	r1, [r7, #0]
      : _M_node(__x) { }
 8015d9c:	687b      	ldr	r3, [r7, #4]
 8015d9e:	683a      	ldr	r2, [r7, #0]
 8015da0:	601a      	str	r2, [r3, #0]
 8015da2:	687b      	ldr	r3, [r7, #4]
 8015da4:	4618      	mov	r0, r3
 8015da6:	370c      	adds	r7, #12
 8015da8:	46bd      	mov	sp, r7
 8015daa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015dae:	4770      	bx	lr

08015db0 <_ZNSt10_List_nodeIP9XFTimeoutE9_M_valptrEv>:
      _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
 8015db0:	b580      	push	{r7, lr}
 8015db2:	b082      	sub	sp, #8
 8015db4:	af00      	add	r7, sp, #0
 8015db6:	6078      	str	r0, [r7, #4]
 8015db8:	687b      	ldr	r3, [r7, #4]
 8015dba:	3308      	adds	r3, #8
 8015dbc:	4618      	mov	r0, r3
 8015dbe:	f000 f8dd 	bl	8015f7c <_ZN9__gnu_cxx16__aligned_membufIP9XFTimeoutE6_M_ptrEv>
 8015dc2:	4603      	mov	r3, r0
 8015dc4:	4618      	mov	r0, r3
 8015dc6:	3708      	adds	r7, #8
 8015dc8:	46bd      	mov	sp, r7
 8015dca:	bd80      	pop	{r7, pc}

08015dcc <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE8_M_eraseESt14_List_iteratorIS2_E>:
      _M_erase(iterator __position) _GLIBCXX_NOEXCEPT
 8015dcc:	b590      	push	{r4, r7, lr}
 8015dce:	b085      	sub	sp, #20
 8015dd0:	af00      	add	r7, sp, #0
 8015dd2:	6078      	str	r0, [r7, #4]
 8015dd4:	6039      	str	r1, [r7, #0]
	this->_M_dec_size(1);
 8015dd6:	687b      	ldr	r3, [r7, #4]
 8015dd8:	2101      	movs	r1, #1
 8015dda:	4618      	mov	r0, r3
 8015ddc:	f000 f8da 	bl	8015f94 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_dec_sizeEj>
	__position._M_node->_M_unhook();
 8015de0:	683b      	ldr	r3, [r7, #0]
 8015de2:	4618      	mov	r0, r3
 8015de4:	f000 fa14 	bl	8016210 <_ZNSt8__detail15_List_node_base9_M_unhookEv>
	_Node* __n = static_cast<_Node*>(__position._M_node);
 8015de8:	683b      	ldr	r3, [r7, #0]
 8015dea:	60fb      	str	r3, [r7, #12]
	_Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());
 8015dec:	687b      	ldr	r3, [r7, #4]
 8015dee:	4618      	mov	r0, r3
 8015df0:	f000 f891 	bl	8015f16 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE21_M_get_Node_allocatorEv>
 8015df4:	4604      	mov	r4, r0
 8015df6:	68f8      	ldr	r0, [r7, #12]
 8015df8:	f7ff ffda 	bl	8015db0 <_ZNSt10_List_nodeIP9XFTimeoutE9_M_valptrEv>
 8015dfc:	4603      	mov	r3, r0
 8015dfe:	4619      	mov	r1, r3
 8015e00:	4620      	mov	r0, r4
 8015e02:	f000 f893 	bl	8015f2c <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE7destroyIS2_EEvRS4_PT_>
	_M_put_node(__n);
 8015e06:	687b      	ldr	r3, [r7, #4]
 8015e08:	68f9      	ldr	r1, [r7, #12]
 8015e0a:	4618      	mov	r0, r3
 8015e0c:	f000 f89b 	bl	8015f46 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_put_nodeEPSt10_List_nodeIS2_E>
      }
 8015e10:	bf00      	nop
 8015e12:	3714      	adds	r7, #20
 8015e14:	46bd      	mov	sp, r7
 8015e16:	bd90      	pop	{r4, r7, pc}

08015e18 <_ZNKSt20_List_const_iteratorIP9XFTimeoutE13_M_const_castEv>:
      _M_const_cast() const _GLIBCXX_NOEXCEPT
 8015e18:	b580      	push	{r7, lr}
 8015e1a:	b084      	sub	sp, #16
 8015e1c:	af00      	add	r7, sp, #0
 8015e1e:	6078      	str	r0, [r7, #4]
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }
 8015e20:	687b      	ldr	r3, [r7, #4]
 8015e22:	681a      	ldr	r2, [r3, #0]
 8015e24:	f107 030c 	add.w	r3, r7, #12
 8015e28:	4611      	mov	r1, r2
 8015e2a:	4618      	mov	r0, r3
 8015e2c:	f7ff ffb1 	bl	8015d92 <_ZNSt14_List_iteratorIP9XFTimeoutEC1EPNSt8__detail15_List_node_baseE>
 8015e30:	68fb      	ldr	r3, [r7, #12]
 8015e32:	4618      	mov	r0, r3
 8015e34:	3710      	adds	r7, #16
 8015e36:	46bd      	mov	sp, r7
 8015e38:	bd80      	pop	{r7, pc}

08015e3a <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE9_M_insertIJRKS2_EEEvSt14_List_iteratorIS2_EDpOT_>:
       _M_insert(iterator __position, _Args&&... __args)
 8015e3a:	b580      	push	{r7, lr}
 8015e3c:	b086      	sub	sp, #24
 8015e3e:	af00      	add	r7, sp, #0
 8015e40:	60f8      	str	r0, [r7, #12]
 8015e42:	60b9      	str	r1, [r7, #8]
 8015e44:	607a      	str	r2, [r7, #4]
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 8015e46:	6878      	ldr	r0, [r7, #4]
 8015e48:	f000 f8b5 	bl	8015fb6 <_ZSt7forwardIRKP9XFTimeoutEOT_RNSt16remove_referenceIS4_E4typeE>
 8015e4c:	4603      	mov	r3, r0
 8015e4e:	4619      	mov	r1, r3
 8015e50:	68f8      	ldr	r0, [r7, #12]
 8015e52:	f000 f810 	bl	8015e76 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE14_M_create_nodeIJRKS2_EEEPSt10_List_nodeIS2_EDpOT_>
 8015e56:	6178      	str	r0, [r7, #20]
	 __tmp->_M_hook(__position._M_node);
 8015e58:	697b      	ldr	r3, [r7, #20]
 8015e5a:	68ba      	ldr	r2, [r7, #8]
 8015e5c:	4611      	mov	r1, r2
 8015e5e:	4618      	mov	r0, r3
 8015e60:	f000 f9cf 	bl	8016202 <_ZNSt8__detail15_List_node_base7_M_hookEPS0_>
	 this->_M_inc_size(1);
 8015e64:	68fb      	ldr	r3, [r7, #12]
 8015e66:	2101      	movs	r1, #1
 8015e68:	4618      	mov	r0, r3
 8015e6a:	f000 f838 	bl	8015ede <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_inc_sizeEj>
       }
 8015e6e:	bf00      	nop
 8015e70:	3718      	adds	r7, #24
 8015e72:	46bd      	mov	sp, r7
 8015e74:	bd80      	pop	{r7, pc}

08015e76 <_ZNSt7__cxx114listIP9XFTimeoutSaIS2_EE14_M_create_nodeIJRKS2_EEEPSt10_List_nodeIS2_EDpOT_>:
	_M_create_node(_Args&&... __args)
 8015e76:	b590      	push	{r4, r7, lr}
 8015e78:	b087      	sub	sp, #28
 8015e7a:	af00      	add	r7, sp, #0
 8015e7c:	6078      	str	r0, [r7, #4]
 8015e7e:	6039      	str	r1, [r7, #0]
	  auto __p = this->_M_get_node();
 8015e80:	687b      	ldr	r3, [r7, #4]
 8015e82:	4618      	mov	r0, r3
 8015e84:	f000 f8a2 	bl	8015fcc <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_get_nodeEv>
 8015e88:	6178      	str	r0, [r7, #20]
	  auto& __alloc = _M_get_Node_allocator();
 8015e8a:	687b      	ldr	r3, [r7, #4]
 8015e8c:	4618      	mov	r0, r3
 8015e8e:	f000 f842 	bl	8015f16 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE21_M_get_Node_allocatorEv>
 8015e92:	6138      	str	r0, [r7, #16]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 8015e94:	f107 0308 	add.w	r3, r7, #8
 8015e98:	697a      	ldr	r2, [r7, #20]
 8015e9a:	6939      	ldr	r1, [r7, #16]
 8015e9c:	4618      	mov	r0, r3
 8015e9e:	f000 f8a3 	bl	8015fe8 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEEC1ERS4_PS3_>
	  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
 8015ea2:	6978      	ldr	r0, [r7, #20]
 8015ea4:	f7ff ff84 	bl	8015db0 <_ZNSt10_List_nodeIP9XFTimeoutE9_M_valptrEv>
 8015ea8:	4604      	mov	r4, r0
 8015eaa:	6838      	ldr	r0, [r7, #0]
 8015eac:	f000 f883 	bl	8015fb6 <_ZSt7forwardIRKP9XFTimeoutEOT_RNSt16remove_referenceIS4_E4typeE>
 8015eb0:	4603      	mov	r3, r0
 8015eb2:	461a      	mov	r2, r3
 8015eb4:	4621      	mov	r1, r4
 8015eb6:	6938      	ldr	r0, [r7, #16]
 8015eb8:	f000 f8bf 	bl	801603a <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE9constructIS2_JRKS2_EEEvRS4_PT_DpOT0_>
	  __guard = nullptr;
 8015ebc:	f107 0308 	add.w	r3, r7, #8
 8015ec0:	2100      	movs	r1, #0
 8015ec2:	4618      	mov	r0, r3
 8015ec4:	f000 f8cc 	bl	8016060 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEEaSEDn>
	  return __p;
 8015ec8:	697c      	ldr	r4, [r7, #20]
	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
 8015eca:	f107 0308 	add.w	r3, r7, #8
 8015ece:	4618      	mov	r0, r3
 8015ed0:	f000 f89e 	bl	8016010 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEED1Ev>
	  return __p;
 8015ed4:	4623      	mov	r3, r4
	}
 8015ed6:	4618      	mov	r0, r3
 8015ed8:	371c      	adds	r7, #28
 8015eda:	46bd      	mov	sp, r7
 8015edc:	bd90      	pop	{r4, r7, pc}

08015ede <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_inc_sizeEj>:
      void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }
 8015ede:	b480      	push	{r7}
 8015ee0:	b083      	sub	sp, #12
 8015ee2:	af00      	add	r7, sp, #0
 8015ee4:	6078      	str	r0, [r7, #4]
 8015ee6:	6039      	str	r1, [r7, #0]
 8015ee8:	687b      	ldr	r3, [r7, #4]
 8015eea:	689a      	ldr	r2, [r3, #8]
 8015eec:	683b      	ldr	r3, [r7, #0]
 8015eee:	441a      	add	r2, r3
 8015ef0:	687b      	ldr	r3, [r7, #4]
 8015ef2:	609a      	str	r2, [r3, #8]
 8015ef4:	bf00      	nop
 8015ef6:	370c      	adds	r7, #12
 8015ef8:	46bd      	mov	sp, r7
 8015efa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015efe:	4770      	bx	lr

08015f00 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEEC1Ev>:
      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
 8015f00:	b480      	push	{r7}
 8015f02:	b083      	sub	sp, #12
 8015f04:	af00      	add	r7, sp, #0
 8015f06:	6078      	str	r0, [r7, #4]
 8015f08:	687b      	ldr	r3, [r7, #4]
 8015f0a:	4618      	mov	r0, r3
 8015f0c:	370c      	adds	r7, #12
 8015f0e:	46bd      	mov	sp, r7
 8015f10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f14:	4770      	bx	lr

08015f16 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE21_M_get_Node_allocatorEv>:
      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
 8015f16:	b480      	push	{r7}
 8015f18:	b083      	sub	sp, #12
 8015f1a:	af00      	add	r7, sp, #0
 8015f1c:	6078      	str	r0, [r7, #4]
      { return _M_impl; }
 8015f1e:	687b      	ldr	r3, [r7, #4]
 8015f20:	4618      	mov	r0, r3
 8015f22:	370c      	adds	r7, #12
 8015f24:	46bd      	mov	sp, r7
 8015f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f2a:	4770      	bx	lr

08015f2c <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE7destroyIS2_EEvRS4_PT_>:
	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 8015f2c:	b580      	push	{r7, lr}
 8015f2e:	b082      	sub	sp, #8
 8015f30:	af00      	add	r7, sp, #0
 8015f32:	6078      	str	r0, [r7, #4]
 8015f34:	6039      	str	r1, [r7, #0]
	  __a.destroy(__p);
 8015f36:	6839      	ldr	r1, [r7, #0]
 8015f38:	6878      	ldr	r0, [r7, #4]
 8015f3a:	f000 f8a0 	bl	801607e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE7destroyIS3_EEvPT_>
	}
 8015f3e:	bf00      	nop
 8015f40:	3708      	adds	r7, #8
 8015f42:	46bd      	mov	sp, r7
 8015f44:	bd80      	pop	{r7, pc}

08015f46 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_put_nodeEPSt10_List_nodeIS2_E>:
      _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT
 8015f46:	b580      	push	{r7, lr}
 8015f48:	b082      	sub	sp, #8
 8015f4a:	af00      	add	r7, sp, #0
 8015f4c:	6078      	str	r0, [r7, #4]
 8015f4e:	6039      	str	r1, [r7, #0]
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }
 8015f50:	687b      	ldr	r3, [r7, #4]
 8015f52:	2201      	movs	r2, #1
 8015f54:	6839      	ldr	r1, [r7, #0]
 8015f56:	4618      	mov	r0, r3
 8015f58:	f000 f89c 	bl	8016094 <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE10deallocateERS4_PS3_j>
 8015f5c:	bf00      	nop
 8015f5e:	3708      	adds	r7, #8
 8015f60:	46bd      	mov	sp, r7
 8015f62:	bd80      	pop	{r7, pc}

08015f64 <_ZNKSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_get_sizeEv>:
      size_t _M_get_size() const { return _M_impl._M_node._M_size; }
 8015f64:	b480      	push	{r7}
 8015f66:	b083      	sub	sp, #12
 8015f68:	af00      	add	r7, sp, #0
 8015f6a:	6078      	str	r0, [r7, #4]
 8015f6c:	687b      	ldr	r3, [r7, #4]
 8015f6e:	689b      	ldr	r3, [r3, #8]
 8015f70:	4618      	mov	r0, r3
 8015f72:	370c      	adds	r7, #12
 8015f74:	46bd      	mov	sp, r7
 8015f76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f7a:	4770      	bx	lr

08015f7c <_ZN9__gnu_cxx16__aligned_membufIP9XFTimeoutE6_M_ptrEv>:
      _M_ptr() noexcept
 8015f7c:	b580      	push	{r7, lr}
 8015f7e:	b082      	sub	sp, #8
 8015f80:	af00      	add	r7, sp, #0
 8015f82:	6078      	str	r0, [r7, #4]
      { return static_cast<_Tp*>(_M_addr()); }
 8015f84:	6878      	ldr	r0, [r7, #4]
 8015f86:	f000 f894 	bl	80160b2 <_ZN9__gnu_cxx16__aligned_membufIP9XFTimeoutE7_M_addrEv>
 8015f8a:	4603      	mov	r3, r0
 8015f8c:	4618      	mov	r0, r3
 8015f8e:	3708      	adds	r7, #8
 8015f90:	46bd      	mov	sp, r7
 8015f92:	bd80      	pop	{r7, pc}

08015f94 <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_dec_sizeEj>:
      void _M_dec_size(size_t __n) { _M_impl._M_node._M_size -= __n; }
 8015f94:	b480      	push	{r7}
 8015f96:	b083      	sub	sp, #12
 8015f98:	af00      	add	r7, sp, #0
 8015f9a:	6078      	str	r0, [r7, #4]
 8015f9c:	6039      	str	r1, [r7, #0]
 8015f9e:	687b      	ldr	r3, [r7, #4]
 8015fa0:	689a      	ldr	r2, [r3, #8]
 8015fa2:	683b      	ldr	r3, [r7, #0]
 8015fa4:	1ad2      	subs	r2, r2, r3
 8015fa6:	687b      	ldr	r3, [r7, #4]
 8015fa8:	609a      	str	r2, [r3, #8]
 8015faa:	bf00      	nop
 8015fac:	370c      	adds	r7, #12
 8015fae:	46bd      	mov	sp, r7
 8015fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015fb4:	4770      	bx	lr

08015fb6 <_ZSt7forwardIRKP9XFTimeoutEOT_RNSt16remove_referenceIS4_E4typeE>:
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 8015fb6:	b480      	push	{r7}
 8015fb8:	b083      	sub	sp, #12
 8015fba:	af00      	add	r7, sp, #0
 8015fbc:	6078      	str	r0, [r7, #4]
    { return static_cast<_Tp&&>(__t); }
 8015fbe:	687b      	ldr	r3, [r7, #4]
 8015fc0:	4618      	mov	r0, r3
 8015fc2:	370c      	adds	r7, #12
 8015fc4:	46bd      	mov	sp, r7
 8015fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015fca:	4770      	bx	lr

08015fcc <_ZNSt7__cxx1110_List_baseIP9XFTimeoutSaIS2_EE11_M_get_nodeEv>:
      _M_get_node()
 8015fcc:	b580      	push	{r7, lr}
 8015fce:	b082      	sub	sp, #8
 8015fd0:	af00      	add	r7, sp, #0
 8015fd2:	6078      	str	r0, [r7, #4]
      { return _Node_alloc_traits::allocate(_M_impl, 1); }
 8015fd4:	687b      	ldr	r3, [r7, #4]
 8015fd6:	2101      	movs	r1, #1
 8015fd8:	4618      	mov	r0, r3
 8015fda:	f000 f875 	bl	80160c8 <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE8allocateERS4_j>
 8015fde:	4603      	mov	r3, r0
 8015fe0:	4618      	mov	r0, r3
 8015fe2:	3708      	adds	r7, #8
 8015fe4:	46bd      	mov	sp, r7
 8015fe6:	bd80      	pop	{r7, pc}

08015fe8 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEEC1ERS4_PS3_>:
      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
 8015fe8:	b580      	push	{r7, lr}
 8015fea:	b084      	sub	sp, #16
 8015fec:	af00      	add	r7, sp, #0
 8015fee:	60f8      	str	r0, [r7, #12]
 8015ff0:	60b9      	str	r1, [r7, #8]
 8015ff2:	607a      	str	r2, [r7, #4]
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
 8015ff4:	68b8      	ldr	r0, [r7, #8]
 8015ff6:	f000 f876 	bl	80160e6 <_ZSt11__addressofISaISt10_List_nodeIP9XFTimeoutEEEPT_RS5_>
 8015ffa:	4602      	mov	r2, r0
 8015ffc:	68fb      	ldr	r3, [r7, #12]
 8015ffe:	601a      	str	r2, [r3, #0]
 8016000:	68fb      	ldr	r3, [r7, #12]
 8016002:	687a      	ldr	r2, [r7, #4]
 8016004:	605a      	str	r2, [r3, #4]
      { }
 8016006:	68fb      	ldr	r3, [r7, #12]
 8016008:	4618      	mov	r0, r3
 801600a:	3710      	adds	r7, #16
 801600c:	46bd      	mov	sp, r7
 801600e:	bd80      	pop	{r7, pc}

08016010 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEED1Ev>:
      ~__allocated_ptr()
 8016010:	b580      	push	{r7, lr}
 8016012:	b082      	sub	sp, #8
 8016014:	af00      	add	r7, sp, #0
 8016016:	6078      	str	r0, [r7, #4]
	if (_M_ptr != nullptr)
 8016018:	687b      	ldr	r3, [r7, #4]
 801601a:	685b      	ldr	r3, [r3, #4]
 801601c:	2b00      	cmp	r3, #0
 801601e:	d007      	beq.n	8016030 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEED1Ev+0x20>
	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
 8016020:	687b      	ldr	r3, [r7, #4]
 8016022:	6818      	ldr	r0, [r3, #0]
 8016024:	687b      	ldr	r3, [r7, #4]
 8016026:	685b      	ldr	r3, [r3, #4]
 8016028:	2201      	movs	r2, #1
 801602a:	4619      	mov	r1, r3
 801602c:	f000 f832 	bl	8016094 <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE10deallocateERS4_PS3_j>
      }
 8016030:	687b      	ldr	r3, [r7, #4]
 8016032:	4618      	mov	r0, r3
 8016034:	3708      	adds	r7, #8
 8016036:	46bd      	mov	sp, r7
 8016038:	bd80      	pop	{r7, pc}

0801603a <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE9constructIS2_JRKS2_EEEvRS4_PT_DpOT0_>:
	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
 801603a:	b580      	push	{r7, lr}
 801603c:	b084      	sub	sp, #16
 801603e:	af00      	add	r7, sp, #0
 8016040:	60f8      	str	r0, [r7, #12]
 8016042:	60b9      	str	r1, [r7, #8]
 8016044:	607a      	str	r2, [r7, #4]
	  __a.construct(__p, std::forward<_Args>(__args)...);
 8016046:	6878      	ldr	r0, [r7, #4]
 8016048:	f7ff ffb5 	bl	8015fb6 <_ZSt7forwardIRKP9XFTimeoutEOT_RNSt16remove_referenceIS4_E4typeE>
 801604c:	4603      	mov	r3, r0
 801604e:	461a      	mov	r2, r3
 8016050:	68b9      	ldr	r1, [r7, #8]
 8016052:	68f8      	ldr	r0, [r7, #12]
 8016054:	f000 f852 	bl	80160fc <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE9constructIS3_JRKS3_EEEvPT_DpOT0_>
	}
 8016058:	bf00      	nop
 801605a:	3710      	adds	r7, #16
 801605c:	46bd      	mov	sp, r7
 801605e:	bd80      	pop	{r7, pc}

08016060 <_ZNSt15__allocated_ptrISaISt10_List_nodeIP9XFTimeoutEEEaSEDn>:
      operator=(std::nullptr_t) noexcept
 8016060:	b480      	push	{r7}
 8016062:	b083      	sub	sp, #12
 8016064:	af00      	add	r7, sp, #0
 8016066:	6078      	str	r0, [r7, #4]
 8016068:	6039      	str	r1, [r7, #0]
	_M_ptr = nullptr;
 801606a:	687b      	ldr	r3, [r7, #4]
 801606c:	2200      	movs	r2, #0
 801606e:	605a      	str	r2, [r3, #4]
	return *this;
 8016070:	687b      	ldr	r3, [r7, #4]
      }
 8016072:	4618      	mov	r0, r3
 8016074:	370c      	adds	r7, #12
 8016076:	46bd      	mov	sp, r7
 8016078:	f85d 7b04 	ldr.w	r7, [sp], #4
 801607c:	4770      	bx	lr

0801607e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE7destroyIS3_EEvPT_>:
	destroy(_Up* __p)
 801607e:	b480      	push	{r7}
 8016080:	b083      	sub	sp, #12
 8016082:	af00      	add	r7, sp, #0
 8016084:	6078      	str	r0, [r7, #4]
 8016086:	6039      	str	r1, [r7, #0]
	{ __p->~_Up(); }
 8016088:	bf00      	nop
 801608a:	370c      	adds	r7, #12
 801608c:	46bd      	mov	sp, r7
 801608e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016092:	4770      	bx	lr

08016094 <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE10deallocateERS4_PS3_j>:
      deallocate(allocator_type& __a, pointer __p, size_type __n)
 8016094:	b580      	push	{r7, lr}
 8016096:	b084      	sub	sp, #16
 8016098:	af00      	add	r7, sp, #0
 801609a:	60f8      	str	r0, [r7, #12]
 801609c:	60b9      	str	r1, [r7, #8]
 801609e:	607a      	str	r2, [r7, #4]
      { __a.deallocate(__p, __n); }
 80160a0:	687a      	ldr	r2, [r7, #4]
 80160a2:	68b9      	ldr	r1, [r7, #8]
 80160a4:	68f8      	ldr	r0, [r7, #12]
 80160a6:	f000 f83f 	bl	8016128 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE10deallocateEPS4_j>
 80160aa:	bf00      	nop
 80160ac:	3710      	adds	r7, #16
 80160ae:	46bd      	mov	sp, r7
 80160b0:	bd80      	pop	{r7, pc}

080160b2 <_ZN9__gnu_cxx16__aligned_membufIP9XFTimeoutE7_M_addrEv>:
      _M_addr() noexcept
 80160b2:	b480      	push	{r7}
 80160b4:	b083      	sub	sp, #12
 80160b6:	af00      	add	r7, sp, #0
 80160b8:	6078      	str	r0, [r7, #4]
      { return static_cast<void*>(&_M_storage); }
 80160ba:	687b      	ldr	r3, [r7, #4]
 80160bc:	4618      	mov	r0, r3
 80160be:	370c      	adds	r7, #12
 80160c0:	46bd      	mov	sp, r7
 80160c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160c6:	4770      	bx	lr

080160c8 <_ZNSt16allocator_traitsISaISt10_List_nodeIP9XFTimeoutEEE8allocateERS4_j>:
      allocate(allocator_type& __a, size_type __n)
 80160c8:	b580      	push	{r7, lr}
 80160ca:	b082      	sub	sp, #8
 80160cc:	af00      	add	r7, sp, #0
 80160ce:	6078      	str	r0, [r7, #4]
 80160d0:	6039      	str	r1, [r7, #0]
      { return __a.allocate(__n); }
 80160d2:	2200      	movs	r2, #0
 80160d4:	6839      	ldr	r1, [r7, #0]
 80160d6:	6878      	ldr	r0, [r7, #4]
 80160d8:	f000 f839 	bl	801614e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE8allocateEjPKv>
 80160dc:	4603      	mov	r3, r0
 80160de:	4618      	mov	r0, r3
 80160e0:	3708      	adds	r7, #8
 80160e2:	46bd      	mov	sp, r7
 80160e4:	bd80      	pop	{r7, pc}

080160e6 <_ZSt11__addressofISaISt10_List_nodeIP9XFTimeoutEEEPT_RS5_>:
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 80160e6:	b480      	push	{r7}
 80160e8:	b083      	sub	sp, #12
 80160ea:	af00      	add	r7, sp, #0
 80160ec:	6078      	str	r0, [r7, #4]
    { return __builtin_addressof(__r); }
 80160ee:	687b      	ldr	r3, [r7, #4]
 80160f0:	4618      	mov	r0, r3
 80160f2:	370c      	adds	r7, #12
 80160f4:	46bd      	mov	sp, r7
 80160f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160fa:	4770      	bx	lr

080160fc <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE9constructIS3_JRKS3_EEEvPT_DpOT0_>:
	construct(_Up* __p, _Args&&... __args)
 80160fc:	b590      	push	{r4, r7, lr}
 80160fe:	b085      	sub	sp, #20
 8016100:	af00      	add	r7, sp, #0
 8016102:	60f8      	str	r0, [r7, #12]
 8016104:	60b9      	str	r1, [r7, #8]
 8016106:	607a      	str	r2, [r7, #4]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 8016108:	6878      	ldr	r0, [r7, #4]
 801610a:	f7ff ff54 	bl	8015fb6 <_ZSt7forwardIRKP9XFTimeoutEOT_RNSt16remove_referenceIS4_E4typeE>
 801610e:	4603      	mov	r3, r0
 8016110:	681c      	ldr	r4, [r3, #0]
 8016112:	68bb      	ldr	r3, [r7, #8]
 8016114:	4619      	mov	r1, r3
 8016116:	2004      	movs	r0, #4
 8016118:	f7f1 faf6 	bl	8007708 <_ZnwjPv>
 801611c:	4603      	mov	r3, r0
 801611e:	601c      	str	r4, [r3, #0]
 8016120:	bf00      	nop
 8016122:	3714      	adds	r7, #20
 8016124:	46bd      	mov	sp, r7
 8016126:	bd90      	pop	{r4, r7, pc}

08016128 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE10deallocateEPS4_j>:
      deallocate(_Tp* __p, size_type __t)
 8016128:	b580      	push	{r7, lr}
 801612a:	b084      	sub	sp, #16
 801612c:	af00      	add	r7, sp, #0
 801612e:	60f8      	str	r0, [r7, #12]
 8016130:	60b9      	str	r1, [r7, #8]
 8016132:	607a      	str	r2, [r7, #4]
	::operator delete(__p
 8016134:	687a      	ldr	r2, [r7, #4]
 8016136:	4613      	mov	r3, r2
 8016138:	005b      	lsls	r3, r3, #1
 801613a:	4413      	add	r3, r2
 801613c:	009b      	lsls	r3, r3, #2
 801613e:	4619      	mov	r1, r3
 8016140:	68b8      	ldr	r0, [r7, #8]
 8016142:	f000 f833 	bl	80161ac <_ZdlPvj>
      }
 8016146:	bf00      	nop
 8016148:	3710      	adds	r7, #16
 801614a:	46bd      	mov	sp, r7
 801614c:	bd80      	pop	{r7, pc}

0801614e <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE8allocateEjPKv>:
      allocate(size_type __n, const void* = static_cast<const void*>(0))
 801614e:	b580      	push	{r7, lr}
 8016150:	b084      	sub	sp, #16
 8016152:	af00      	add	r7, sp, #0
 8016154:	60f8      	str	r0, [r7, #12]
 8016156:	60b9      	str	r1, [r7, #8]
 8016158:	607a      	str	r2, [r7, #4]
	if (__n > this->_M_max_size())
 801615a:	68f8      	ldr	r0, [r7, #12]
 801615c:	f000 f818 	bl	8016190 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE11_M_max_sizeEv>
 8016160:	4602      	mov	r2, r0
 8016162:	68bb      	ldr	r3, [r7, #8]
 8016164:	4293      	cmp	r3, r2
 8016166:	bf8c      	ite	hi
 8016168:	2301      	movhi	r3, #1
 801616a:	2300      	movls	r3, #0
 801616c:	b2db      	uxtb	r3, r3
 801616e:	2b00      	cmp	r3, #0
 8016170:	d001      	beq.n	8016176 <_ZN9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE8allocateEjPKv+0x28>
	  std::__throw_bad_alloc();
 8016172:	f000 f852 	bl	801621a <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 8016176:	68ba      	ldr	r2, [r7, #8]
 8016178:	4613      	mov	r3, r2
 801617a:	005b      	lsls	r3, r3, #1
 801617c:	4413      	add	r3, r2
 801617e:	009b      	lsls	r3, r3, #2
 8016180:	4618      	mov	r0, r3
 8016182:	f000 f826 	bl	80161d2 <_Znwj>
 8016186:	4603      	mov	r3, r0
      }
 8016188:	4618      	mov	r0, r3
 801618a:	3710      	adds	r7, #16
 801618c:	46bd      	mov	sp, r7
 801618e:	bd80      	pop	{r7, pc}

08016190 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE11_M_max_sizeEv>:
      _M_max_size() const _GLIBCXX_USE_NOEXCEPT
 8016190:	b480      	push	{r7}
 8016192:	b083      	sub	sp, #12
 8016194:	af00      	add	r7, sp, #0
 8016196:	6078      	str	r0, [r7, #4]
	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
 8016198:	4b03      	ldr	r3, [pc, #12]	; (80161a8 <_ZNK9__gnu_cxx13new_allocatorISt10_List_nodeIP9XFTimeoutEE11_M_max_sizeEv+0x18>)
      }
 801619a:	4618      	mov	r0, r3
 801619c:	370c      	adds	r7, #12
 801619e:	46bd      	mov	sp, r7
 80161a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80161a4:	4770      	bx	lr
 80161a6:	bf00      	nop
 80161a8:	0aaaaaaa 	.word	0x0aaaaaaa

080161ac <_ZdlPvj>:
 80161ac:	f000 b8cd 	b.w	801634a <_ZdlPv>

080161b0 <_ZdaPv>:
 80161b0:	f000 b8cb 	b.w	801634a <_ZdlPv>

080161b4 <__cxa_guard_acquire>:
 80161b4:	6803      	ldr	r3, [r0, #0]
 80161b6:	07db      	lsls	r3, r3, #31
 80161b8:	d406      	bmi.n	80161c8 <__cxa_guard_acquire+0x14>
 80161ba:	7843      	ldrb	r3, [r0, #1]
 80161bc:	b103      	cbz	r3, 80161c0 <__cxa_guard_acquire+0xc>
 80161be:	deff      	udf	#255	; 0xff
 80161c0:	2301      	movs	r3, #1
 80161c2:	7043      	strb	r3, [r0, #1]
 80161c4:	4618      	mov	r0, r3
 80161c6:	4770      	bx	lr
 80161c8:	2000      	movs	r0, #0
 80161ca:	4770      	bx	lr

080161cc <__cxa_guard_release>:
 80161cc:	2301      	movs	r3, #1
 80161ce:	6003      	str	r3, [r0, #0]
 80161d0:	4770      	bx	lr

080161d2 <_Znwj>:
 80161d2:	2801      	cmp	r0, #1
 80161d4:	bf38      	it	cc
 80161d6:	2001      	movcc	r0, #1
 80161d8:	b510      	push	{r4, lr}
 80161da:	4604      	mov	r4, r0
 80161dc:	4620      	mov	r0, r4
 80161de:	f000 f939 	bl	8016454 <malloc>
 80161e2:	b930      	cbnz	r0, 80161f2 <_Znwj+0x20>
 80161e4:	f000 f8c6 	bl	8016374 <_ZSt15get_new_handlerv>
 80161e8:	b908      	cbnz	r0, 80161ee <_Znwj+0x1c>
 80161ea:	f000 f8cb 	bl	8016384 <abort>
 80161ee:	4780      	blx	r0
 80161f0:	e7f4      	b.n	80161dc <_Znwj+0xa>
 80161f2:	bd10      	pop	{r4, pc}

080161f4 <_Znaj>:
 80161f4:	f7ff bfed 	b.w	80161d2 <_Znwj>

080161f8 <__cxa_pure_virtual>:
 80161f8:	b508      	push	{r3, lr}
 80161fa:	f000 f8b5 	bl	8016368 <_ZSt9terminatev>

080161fe <_ZNSaIcEC1Ev>:
 80161fe:	4770      	bx	lr

08016200 <_ZNSaIcED1Ev>:
 8016200:	4770      	bx	lr

08016202 <_ZNSt8__detail15_List_node_base7_M_hookEPS0_>:
 8016202:	684b      	ldr	r3, [r1, #4]
 8016204:	6043      	str	r3, [r0, #4]
 8016206:	684b      	ldr	r3, [r1, #4]
 8016208:	6001      	str	r1, [r0, #0]
 801620a:	6018      	str	r0, [r3, #0]
 801620c:	6048      	str	r0, [r1, #4]
 801620e:	4770      	bx	lr

08016210 <_ZNSt8__detail15_List_node_base9_M_unhookEv>:
 8016210:	e9d0 3200 	ldrd	r3, r2, [r0]
 8016214:	6013      	str	r3, [r2, #0]
 8016216:	605a      	str	r2, [r3, #4]
 8016218:	4770      	bx	lr

0801621a <_ZSt17__throw_bad_allocv>:
 801621a:	b508      	push	{r3, lr}
 801621c:	f000 f8b2 	bl	8016384 <abort>

08016220 <_ZSt19__throw_logic_errorPKc>:
 8016220:	b508      	push	{r3, lr}
 8016222:	f000 f8af 	bl	8016384 <abort>

08016226 <_ZSt20__throw_length_errorPKc>:
 8016226:	b508      	push	{r3, lr}
 8016228:	f000 f8ac 	bl	8016384 <abort>

0801622c <_ZSt25__throw_bad_function_callv>:
 801622c:	b508      	push	{r3, lr}
 801622e:	f000 f8a9 	bl	8016384 <abort>

08016232 <_ZNSt11char_traitsIcE4copyEPcPKcj.isra.0>:
 8016232:	b10a      	cbz	r2, 8016238 <_ZNSt11char_traitsIcE4copyEPcPKcj.isra.0+0x6>
 8016234:	f000 b91e 	b.w	8016474 <memcpy>
 8016238:	4770      	bx	lr
	...

0801623c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>:
 801623c:	b508      	push	{r3, lr}
 801623e:	680b      	ldr	r3, [r1, #0]
 8016240:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8016244:	d302      	bcc.n	801624c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x10>
 8016246:	480d      	ldr	r0, [pc, #52]	; (801627c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x40>)
 8016248:	f7ff ffed 	bl	8016226 <_ZSt20__throw_length_errorPKc>
 801624c:	4293      	cmp	r3, r2
 801624e:	d90b      	bls.n	8016268 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x2c>
 8016250:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
 8016254:	ea4f 0042 	mov.w	r0, r2, lsl #1
 8016258:	d206      	bcs.n	8016268 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x2c>
 801625a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 801625e:	bf2a      	itet	cs
 8016260:	f06f 4340 	mvncs.w	r3, #3221225472	; 0xc0000000
 8016264:	6008      	strcc	r0, [r1, #0]
 8016266:	600b      	strcs	r3, [r1, #0]
 8016268:	6808      	ldr	r0, [r1, #0]
 801626a:	3001      	adds	r0, #1
 801626c:	d501      	bpl.n	8016272 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x36>
 801626e:	f7ff ffd4 	bl	801621a <_ZSt17__throw_bad_allocv>
 8016272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8016276:	f7ff bfac 	b.w	80161d2 <_Znwj>
 801627a:	bf00      	nop
 801627c:	0801dd18 	.word	0x0801dd18

08016280 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>:
 8016280:	f850 3b08 	ldr.w	r3, [r0], #8
 8016284:	4283      	cmp	r3, r0
 8016286:	d002      	beq.n	801628e <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv+0xe>
 8016288:	4618      	mov	r0, r3
 801628a:	f000 b85e 	b.w	801634a <_ZdlPv>
 801628e:	4770      	bx	lr

08016290 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>:
 8016290:	2a01      	cmp	r2, #1
 8016292:	b410      	push	{r4}
 8016294:	d104      	bne.n	80162a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj+0x10>
 8016296:	780a      	ldrb	r2, [r1, #0]
 8016298:	f85d 4b04 	ldr.w	r4, [sp], #4
 801629c:	7002      	strb	r2, [r0, #0]
 801629e:	4770      	bx	lr
 80162a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80162a4:	f7ff bfc5 	b.w	8016232 <_ZNSt11char_traitsIcE4copyEPcPKcj.isra.0>

080162a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcPKcS7_>:
 80162a8:	b508      	push	{r3, lr}
 80162aa:	1a52      	subs	r2, r2, r1
 80162ac:	f7ff fff0 	bl	8016290 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
 80162b0:	bd08      	pop	{r3, pc}

080162b2 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev>:
 80162b2:	b510      	push	{r4, lr}
 80162b4:	4604      	mov	r4, r0
 80162b6:	f7ff ffe3 	bl	8016280 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
 80162ba:	4620      	mov	r0, r4
 80162bc:	bd10      	pop	{r4, pc}

080162be <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv>:
 80162be:	6840      	ldr	r0, [r0, #4]
 80162c0:	4770      	bx	lr

080162c2 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5emptyEv>:
 80162c2:	6840      	ldr	r0, [r0, #4]
 80162c4:	fab0 f080 	clz	r0, r0
 80162c8:	0940      	lsrs	r0, r0, #5
 80162ca:	4770      	bx	lr

080162cc <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEixEj>:
 80162cc:	6800      	ldr	r0, [r0, #0]
 80162ce:	4408      	add	r0, r1
 80162d0:	4770      	bx	lr

080162d2 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv>:
 80162d2:	6800      	ldr	r0, [r0, #0]
 80162d4:	4770      	bx	lr
	...

080162d8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>:
 80162d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80162da:	4604      	mov	r4, r0
 80162dc:	4616      	mov	r6, r2
 80162de:	460d      	mov	r5, r1
 80162e0:	b919      	cbnz	r1, 80162ea <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag+0x12>
 80162e2:	b112      	cbz	r2, 80162ea <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag+0x12>
 80162e4:	480d      	ldr	r0, [pc, #52]	; (801631c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag+0x44>)
 80162e6:	f7ff ff9b 	bl	8016220 <_ZSt19__throw_logic_errorPKc>
 80162ea:	1b73      	subs	r3, r6, r5
 80162ec:	2b0f      	cmp	r3, #15
 80162ee:	9301      	str	r3, [sp, #4]
 80162f0:	d907      	bls.n	8016302 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag+0x2a>
 80162f2:	2200      	movs	r2, #0
 80162f4:	a901      	add	r1, sp, #4
 80162f6:	4620      	mov	r0, r4
 80162f8:	f7ff ffa0 	bl	801623c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>
 80162fc:	9b01      	ldr	r3, [sp, #4]
 80162fe:	6020      	str	r0, [r4, #0]
 8016300:	60a3      	str	r3, [r4, #8]
 8016302:	4632      	mov	r2, r6
 8016304:	4629      	mov	r1, r5
 8016306:	6820      	ldr	r0, [r4, #0]
 8016308:	f7ff ffce 	bl	80162a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcPKcS7_>
 801630c:	9b01      	ldr	r3, [sp, #4]
 801630e:	6822      	ldr	r2, [r4, #0]
 8016310:	6063      	str	r3, [r4, #4]
 8016312:	2100      	movs	r1, #0
 8016314:	54d1      	strb	r1, [r2, r3]
 8016316:	b002      	add	sp, #8
 8016318:	bd70      	pop	{r4, r5, r6, pc}
 801631a:	bf00      	nop
 801631c:	0801dd30 	.word	0x0801dd30

08016320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_>:
 8016320:	b538      	push	{r3, r4, r5, lr}
 8016322:	f100 0308 	add.w	r3, r0, #8
 8016326:	4604      	mov	r4, r0
 8016328:	6003      	str	r3, [r0, #0]
 801632a:	460d      	mov	r5, r1
 801632c:	b159      	cbz	r1, 8016346 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_+0x26>
 801632e:	4608      	mov	r0, r1
 8016330:	f7e9 ff9e 	bl	8000270 <strlen>
 8016334:	182a      	adds	r2, r5, r0
 8016336:	4620      	mov	r0, r4
 8016338:	f04f 0300 	mov.w	r3, #0
 801633c:	4629      	mov	r1, r5
 801633e:	f7ff ffcb 	bl	80162d8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>
 8016342:	4620      	mov	r0, r4
 8016344:	bd38      	pop	{r3, r4, r5, pc}
 8016346:	2201      	movs	r2, #1
 8016348:	e7f5      	b.n	8016336 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_+0x16>

0801634a <_ZdlPv>:
 801634a:	f000 b88b 	b.w	8016464 <free>

0801634e <_ZN10__cxxabiv111__terminateEPFvvE>:
 801634e:	b508      	push	{r3, lr}
 8016350:	4780      	blx	r0
 8016352:	f000 f817 	bl	8016384 <abort>
	...

08016358 <_ZSt13get_terminatev>:
 8016358:	4b02      	ldr	r3, [pc, #8]	; (8016364 <_ZSt13get_terminatev+0xc>)
 801635a:	6818      	ldr	r0, [r3, #0]
 801635c:	f3bf 8f5b 	dmb	ish
 8016360:	4770      	bx	lr
 8016362:	bf00      	nop
 8016364:	20000014 	.word	0x20000014

08016368 <_ZSt9terminatev>:
 8016368:	b508      	push	{r3, lr}
 801636a:	f7ff fff5 	bl	8016358 <_ZSt13get_terminatev>
 801636e:	f7ff ffee 	bl	801634e <_ZN10__cxxabiv111__terminateEPFvvE>
	...

08016374 <_ZSt15get_new_handlerv>:
 8016374:	4b02      	ldr	r3, [pc, #8]	; (8016380 <_ZSt15get_new_handlerv+0xc>)
 8016376:	6818      	ldr	r0, [r3, #0]
 8016378:	f3bf 8f5b 	dmb	ish
 801637c:	4770      	bx	lr
 801637e:	bf00      	nop
 8016380:	20001e60 	.word	0x20001e60

08016384 <abort>:
 8016384:	b508      	push	{r3, lr}
 8016386:	2006      	movs	r0, #6
 8016388:	f000 fcaa 	bl	8016ce0 <raise>
 801638c:	2001      	movs	r0, #1
 801638e:	f7ea ff0f 	bl	80011b0 <_exit>
	...

08016394 <__assert_func>:
 8016394:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8016396:	4614      	mov	r4, r2
 8016398:	461a      	mov	r2, r3
 801639a:	4b09      	ldr	r3, [pc, #36]	; (80163c0 <__assert_func+0x2c>)
 801639c:	681b      	ldr	r3, [r3, #0]
 801639e:	4605      	mov	r5, r0
 80163a0:	68d8      	ldr	r0, [r3, #12]
 80163a2:	b14c      	cbz	r4, 80163b8 <__assert_func+0x24>
 80163a4:	4b07      	ldr	r3, [pc, #28]	; (80163c4 <__assert_func+0x30>)
 80163a6:	9100      	str	r1, [sp, #0]
 80163a8:	e9cd 3401 	strd	r3, r4, [sp, #4]
 80163ac:	4906      	ldr	r1, [pc, #24]	; (80163c8 <__assert_func+0x34>)
 80163ae:	462b      	mov	r3, r5
 80163b0:	f000 f81a 	bl	80163e8 <fiprintf>
 80163b4:	f7ff ffe6 	bl	8016384 <abort>
 80163b8:	4b04      	ldr	r3, [pc, #16]	; (80163cc <__assert_func+0x38>)
 80163ba:	461c      	mov	r4, r3
 80163bc:	e7f3      	b.n	80163a6 <__assert_func+0x12>
 80163be:	bf00      	nop
 80163c0:	20000018 	.word	0x20000018
 80163c4:	0801dd5a 	.word	0x0801dd5a
 80163c8:	0801dd67 	.word	0x0801dd67
 80163cc:	0801dd95 	.word	0x0801dd95

080163d0 <atexit>:
 80163d0:	2300      	movs	r3, #0
 80163d2:	4601      	mov	r1, r0
 80163d4:	461a      	mov	r2, r3
 80163d6:	4618      	mov	r0, r3
 80163d8:	f000 bdd2 	b.w	8016f80 <__register_exitproc>

080163dc <__errno>:
 80163dc:	4b01      	ldr	r3, [pc, #4]	; (80163e4 <__errno+0x8>)
 80163de:	6818      	ldr	r0, [r3, #0]
 80163e0:	4770      	bx	lr
 80163e2:	bf00      	nop
 80163e4:	20000018 	.word	0x20000018

080163e8 <fiprintf>:
 80163e8:	b40e      	push	{r1, r2, r3}
 80163ea:	b503      	push	{r0, r1, lr}
 80163ec:	4601      	mov	r1, r0
 80163ee:	ab03      	add	r3, sp, #12
 80163f0:	4805      	ldr	r0, [pc, #20]	; (8016408 <fiprintf+0x20>)
 80163f2:	f853 2b04 	ldr.w	r2, [r3], #4
 80163f6:	6800      	ldr	r0, [r0, #0]
 80163f8:	9301      	str	r3, [sp, #4]
 80163fa:	f000 f975 	bl	80166e8 <_vfiprintf_r>
 80163fe:	b002      	add	sp, #8
 8016400:	f85d eb04 	ldr.w	lr, [sp], #4
 8016404:	b003      	add	sp, #12
 8016406:	4770      	bx	lr
 8016408:	20000018 	.word	0x20000018

0801640c <__libc_init_array>:
 801640c:	b570      	push	{r4, r5, r6, lr}
 801640e:	4d0d      	ldr	r5, [pc, #52]	; (8016444 <__libc_init_array+0x38>)
 8016410:	4c0d      	ldr	r4, [pc, #52]	; (8016448 <__libc_init_array+0x3c>)
 8016412:	1b64      	subs	r4, r4, r5
 8016414:	10a4      	asrs	r4, r4, #2
 8016416:	2600      	movs	r6, #0
 8016418:	42a6      	cmp	r6, r4
 801641a:	d109      	bne.n	8016430 <__libc_init_array+0x24>
 801641c:	4d0b      	ldr	r5, [pc, #44]	; (801644c <__libc_init_array+0x40>)
 801641e:	4c0c      	ldr	r4, [pc, #48]	; (8016450 <__libc_init_array+0x44>)
 8016420:	f001 fa7a 	bl	8017918 <_init>
 8016424:	1b64      	subs	r4, r4, r5
 8016426:	10a4      	asrs	r4, r4, #2
 8016428:	2600      	movs	r6, #0
 801642a:	42a6      	cmp	r6, r4
 801642c:	d105      	bne.n	801643a <__libc_init_array+0x2e>
 801642e:	bd70      	pop	{r4, r5, r6, pc}
 8016430:	f855 3b04 	ldr.w	r3, [r5], #4
 8016434:	4798      	blx	r3
 8016436:	3601      	adds	r6, #1
 8016438:	e7ee      	b.n	8016418 <__libc_init_array+0xc>
 801643a:	f855 3b04 	ldr.w	r3, [r5], #4
 801643e:	4798      	blx	r3
 8016440:	3601      	adds	r6, #1
 8016442:	e7f2      	b.n	801642a <__libc_init_array+0x1e>
 8016444:	0801de38 	.word	0x0801de38
 8016448:	0801de38 	.word	0x0801de38
 801644c:	0801de38 	.word	0x0801de38
 8016450:	0801dea0 	.word	0x0801dea0

08016454 <malloc>:
 8016454:	4b02      	ldr	r3, [pc, #8]	; (8016460 <malloc+0xc>)
 8016456:	4601      	mov	r1, r0
 8016458:	6818      	ldr	r0, [r3, #0]
 801645a:	f000 b8a7 	b.w	80165ac <_malloc_r>
 801645e:	bf00      	nop
 8016460:	20000018 	.word	0x20000018

08016464 <free>:
 8016464:	4b02      	ldr	r3, [pc, #8]	; (8016470 <free+0xc>)
 8016466:	4601      	mov	r1, r0
 8016468:	6818      	ldr	r0, [r3, #0]
 801646a:	f000 b833 	b.w	80164d4 <_free_r>
 801646e:	bf00      	nop
 8016470:	20000018 	.word	0x20000018

08016474 <memcpy>:
 8016474:	440a      	add	r2, r1
 8016476:	4291      	cmp	r1, r2
 8016478:	f100 33ff 	add.w	r3, r0, #4294967295
 801647c:	d100      	bne.n	8016480 <memcpy+0xc>
 801647e:	4770      	bx	lr
 8016480:	b510      	push	{r4, lr}
 8016482:	f811 4b01 	ldrb.w	r4, [r1], #1
 8016486:	f803 4f01 	strb.w	r4, [r3, #1]!
 801648a:	4291      	cmp	r1, r2
 801648c:	d1f9      	bne.n	8016482 <memcpy+0xe>
 801648e:	bd10      	pop	{r4, pc}

08016490 <memmove>:
 8016490:	4288      	cmp	r0, r1
 8016492:	b510      	push	{r4, lr}
 8016494:	eb01 0402 	add.w	r4, r1, r2
 8016498:	d902      	bls.n	80164a0 <memmove+0x10>
 801649a:	4284      	cmp	r4, r0
 801649c:	4623      	mov	r3, r4
 801649e:	d807      	bhi.n	80164b0 <memmove+0x20>
 80164a0:	1e43      	subs	r3, r0, #1
 80164a2:	42a1      	cmp	r1, r4
 80164a4:	d008      	beq.n	80164b8 <memmove+0x28>
 80164a6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80164aa:	f803 2f01 	strb.w	r2, [r3, #1]!
 80164ae:	e7f8      	b.n	80164a2 <memmove+0x12>
 80164b0:	4402      	add	r2, r0
 80164b2:	4601      	mov	r1, r0
 80164b4:	428a      	cmp	r2, r1
 80164b6:	d100      	bne.n	80164ba <memmove+0x2a>
 80164b8:	bd10      	pop	{r4, pc}
 80164ba:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80164be:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80164c2:	e7f7      	b.n	80164b4 <memmove+0x24>

080164c4 <memset>:
 80164c4:	4402      	add	r2, r0
 80164c6:	4603      	mov	r3, r0
 80164c8:	4293      	cmp	r3, r2
 80164ca:	d100      	bne.n	80164ce <memset+0xa>
 80164cc:	4770      	bx	lr
 80164ce:	f803 1b01 	strb.w	r1, [r3], #1
 80164d2:	e7f9      	b.n	80164c8 <memset+0x4>

080164d4 <_free_r>:
 80164d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80164d6:	2900      	cmp	r1, #0
 80164d8:	d044      	beq.n	8016564 <_free_r+0x90>
 80164da:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80164de:	9001      	str	r0, [sp, #4]
 80164e0:	2b00      	cmp	r3, #0
 80164e2:	f1a1 0404 	sub.w	r4, r1, #4
 80164e6:	bfb8      	it	lt
 80164e8:	18e4      	addlt	r4, r4, r3
 80164ea:	f000 ffcb 	bl	8017484 <__malloc_lock>
 80164ee:	4a1e      	ldr	r2, [pc, #120]	; (8016568 <_free_r+0x94>)
 80164f0:	9801      	ldr	r0, [sp, #4]
 80164f2:	6813      	ldr	r3, [r2, #0]
 80164f4:	b933      	cbnz	r3, 8016504 <_free_r+0x30>
 80164f6:	6063      	str	r3, [r4, #4]
 80164f8:	6014      	str	r4, [r2, #0]
 80164fa:	b003      	add	sp, #12
 80164fc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8016500:	f000 bfc6 	b.w	8017490 <__malloc_unlock>
 8016504:	42a3      	cmp	r3, r4
 8016506:	d908      	bls.n	801651a <_free_r+0x46>
 8016508:	6825      	ldr	r5, [r4, #0]
 801650a:	1961      	adds	r1, r4, r5
 801650c:	428b      	cmp	r3, r1
 801650e:	bf01      	itttt	eq
 8016510:	6819      	ldreq	r1, [r3, #0]
 8016512:	685b      	ldreq	r3, [r3, #4]
 8016514:	1949      	addeq	r1, r1, r5
 8016516:	6021      	streq	r1, [r4, #0]
 8016518:	e7ed      	b.n	80164f6 <_free_r+0x22>
 801651a:	461a      	mov	r2, r3
 801651c:	685b      	ldr	r3, [r3, #4]
 801651e:	b10b      	cbz	r3, 8016524 <_free_r+0x50>
 8016520:	42a3      	cmp	r3, r4
 8016522:	d9fa      	bls.n	801651a <_free_r+0x46>
 8016524:	6811      	ldr	r1, [r2, #0]
 8016526:	1855      	adds	r5, r2, r1
 8016528:	42a5      	cmp	r5, r4
 801652a:	d10b      	bne.n	8016544 <_free_r+0x70>
 801652c:	6824      	ldr	r4, [r4, #0]
 801652e:	4421      	add	r1, r4
 8016530:	1854      	adds	r4, r2, r1
 8016532:	42a3      	cmp	r3, r4
 8016534:	6011      	str	r1, [r2, #0]
 8016536:	d1e0      	bne.n	80164fa <_free_r+0x26>
 8016538:	681c      	ldr	r4, [r3, #0]
 801653a:	685b      	ldr	r3, [r3, #4]
 801653c:	6053      	str	r3, [r2, #4]
 801653e:	4421      	add	r1, r4
 8016540:	6011      	str	r1, [r2, #0]
 8016542:	e7da      	b.n	80164fa <_free_r+0x26>
 8016544:	d902      	bls.n	801654c <_free_r+0x78>
 8016546:	230c      	movs	r3, #12
 8016548:	6003      	str	r3, [r0, #0]
 801654a:	e7d6      	b.n	80164fa <_free_r+0x26>
 801654c:	6825      	ldr	r5, [r4, #0]
 801654e:	1961      	adds	r1, r4, r5
 8016550:	428b      	cmp	r3, r1
 8016552:	bf04      	itt	eq
 8016554:	6819      	ldreq	r1, [r3, #0]
 8016556:	685b      	ldreq	r3, [r3, #4]
 8016558:	6063      	str	r3, [r4, #4]
 801655a:	bf04      	itt	eq
 801655c:	1949      	addeq	r1, r1, r5
 801655e:	6021      	streq	r1, [r4, #0]
 8016560:	6054      	str	r4, [r2, #4]
 8016562:	e7ca      	b.n	80164fa <_free_r+0x26>
 8016564:	b003      	add	sp, #12
 8016566:	bd30      	pop	{r4, r5, pc}
 8016568:	20001e64 	.word	0x20001e64

0801656c <sbrk_aligned>:
 801656c:	b570      	push	{r4, r5, r6, lr}
 801656e:	4e0e      	ldr	r6, [pc, #56]	; (80165a8 <sbrk_aligned+0x3c>)
 8016570:	460c      	mov	r4, r1
 8016572:	6831      	ldr	r1, [r6, #0]
 8016574:	4605      	mov	r5, r0
 8016576:	b911      	cbnz	r1, 801657e <sbrk_aligned+0x12>
 8016578:	f000 fb7a 	bl	8016c70 <_sbrk_r>
 801657c:	6030      	str	r0, [r6, #0]
 801657e:	4621      	mov	r1, r4
 8016580:	4628      	mov	r0, r5
 8016582:	f000 fb75 	bl	8016c70 <_sbrk_r>
 8016586:	1c43      	adds	r3, r0, #1
 8016588:	d00a      	beq.n	80165a0 <sbrk_aligned+0x34>
 801658a:	1cc4      	adds	r4, r0, #3
 801658c:	f024 0403 	bic.w	r4, r4, #3
 8016590:	42a0      	cmp	r0, r4
 8016592:	d007      	beq.n	80165a4 <sbrk_aligned+0x38>
 8016594:	1a21      	subs	r1, r4, r0
 8016596:	4628      	mov	r0, r5
 8016598:	f000 fb6a 	bl	8016c70 <_sbrk_r>
 801659c:	3001      	adds	r0, #1
 801659e:	d101      	bne.n	80165a4 <sbrk_aligned+0x38>
 80165a0:	f04f 34ff 	mov.w	r4, #4294967295
 80165a4:	4620      	mov	r0, r4
 80165a6:	bd70      	pop	{r4, r5, r6, pc}
 80165a8:	20001e68 	.word	0x20001e68

080165ac <_malloc_r>:
 80165ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80165b0:	1ccd      	adds	r5, r1, #3
 80165b2:	f025 0503 	bic.w	r5, r5, #3
 80165b6:	3508      	adds	r5, #8
 80165b8:	2d0c      	cmp	r5, #12
 80165ba:	bf38      	it	cc
 80165bc:	250c      	movcc	r5, #12
 80165be:	2d00      	cmp	r5, #0
 80165c0:	4607      	mov	r7, r0
 80165c2:	db01      	blt.n	80165c8 <_malloc_r+0x1c>
 80165c4:	42a9      	cmp	r1, r5
 80165c6:	d905      	bls.n	80165d4 <_malloc_r+0x28>
 80165c8:	230c      	movs	r3, #12
 80165ca:	603b      	str	r3, [r7, #0]
 80165cc:	2600      	movs	r6, #0
 80165ce:	4630      	mov	r0, r6
 80165d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80165d4:	4e2e      	ldr	r6, [pc, #184]	; (8016690 <_malloc_r+0xe4>)
 80165d6:	f000 ff55 	bl	8017484 <__malloc_lock>
 80165da:	6833      	ldr	r3, [r6, #0]
 80165dc:	461c      	mov	r4, r3
 80165de:	bb34      	cbnz	r4, 801662e <_malloc_r+0x82>
 80165e0:	4629      	mov	r1, r5
 80165e2:	4638      	mov	r0, r7
 80165e4:	f7ff ffc2 	bl	801656c <sbrk_aligned>
 80165e8:	1c43      	adds	r3, r0, #1
 80165ea:	4604      	mov	r4, r0
 80165ec:	d14d      	bne.n	801668a <_malloc_r+0xde>
 80165ee:	6834      	ldr	r4, [r6, #0]
 80165f0:	4626      	mov	r6, r4
 80165f2:	2e00      	cmp	r6, #0
 80165f4:	d140      	bne.n	8016678 <_malloc_r+0xcc>
 80165f6:	6823      	ldr	r3, [r4, #0]
 80165f8:	4631      	mov	r1, r6
 80165fa:	4638      	mov	r0, r7
 80165fc:	eb04 0803 	add.w	r8, r4, r3
 8016600:	f000 fb36 	bl	8016c70 <_sbrk_r>
 8016604:	4580      	cmp	r8, r0
 8016606:	d13a      	bne.n	801667e <_malloc_r+0xd2>
 8016608:	6821      	ldr	r1, [r4, #0]
 801660a:	3503      	adds	r5, #3
 801660c:	1a6d      	subs	r5, r5, r1
 801660e:	f025 0503 	bic.w	r5, r5, #3
 8016612:	3508      	adds	r5, #8
 8016614:	2d0c      	cmp	r5, #12
 8016616:	bf38      	it	cc
 8016618:	250c      	movcc	r5, #12
 801661a:	4629      	mov	r1, r5
 801661c:	4638      	mov	r0, r7
 801661e:	f7ff ffa5 	bl	801656c <sbrk_aligned>
 8016622:	3001      	adds	r0, #1
 8016624:	d02b      	beq.n	801667e <_malloc_r+0xd2>
 8016626:	6823      	ldr	r3, [r4, #0]
 8016628:	442b      	add	r3, r5
 801662a:	6023      	str	r3, [r4, #0]
 801662c:	e00e      	b.n	801664c <_malloc_r+0xa0>
 801662e:	6822      	ldr	r2, [r4, #0]
 8016630:	1b52      	subs	r2, r2, r5
 8016632:	d41e      	bmi.n	8016672 <_malloc_r+0xc6>
 8016634:	2a0b      	cmp	r2, #11
 8016636:	d916      	bls.n	8016666 <_malloc_r+0xba>
 8016638:	1961      	adds	r1, r4, r5
 801663a:	42a3      	cmp	r3, r4
 801663c:	6025      	str	r5, [r4, #0]
 801663e:	bf18      	it	ne
 8016640:	6059      	strne	r1, [r3, #4]
 8016642:	6863      	ldr	r3, [r4, #4]
 8016644:	bf08      	it	eq
 8016646:	6031      	streq	r1, [r6, #0]
 8016648:	5162      	str	r2, [r4, r5]
 801664a:	604b      	str	r3, [r1, #4]
 801664c:	4638      	mov	r0, r7
 801664e:	f104 060b 	add.w	r6, r4, #11
 8016652:	f000 ff1d 	bl	8017490 <__malloc_unlock>
 8016656:	f026 0607 	bic.w	r6, r6, #7
 801665a:	1d23      	adds	r3, r4, #4
 801665c:	1af2      	subs	r2, r6, r3
 801665e:	d0b6      	beq.n	80165ce <_malloc_r+0x22>
 8016660:	1b9b      	subs	r3, r3, r6
 8016662:	50a3      	str	r3, [r4, r2]
 8016664:	e7b3      	b.n	80165ce <_malloc_r+0x22>
 8016666:	6862      	ldr	r2, [r4, #4]
 8016668:	42a3      	cmp	r3, r4
 801666a:	bf0c      	ite	eq
 801666c:	6032      	streq	r2, [r6, #0]
 801666e:	605a      	strne	r2, [r3, #4]
 8016670:	e7ec      	b.n	801664c <_malloc_r+0xa0>
 8016672:	4623      	mov	r3, r4
 8016674:	6864      	ldr	r4, [r4, #4]
 8016676:	e7b2      	b.n	80165de <_malloc_r+0x32>
 8016678:	4634      	mov	r4, r6
 801667a:	6876      	ldr	r6, [r6, #4]
 801667c:	e7b9      	b.n	80165f2 <_malloc_r+0x46>
 801667e:	230c      	movs	r3, #12
 8016680:	603b      	str	r3, [r7, #0]
 8016682:	4638      	mov	r0, r7
 8016684:	f000 ff04 	bl	8017490 <__malloc_unlock>
 8016688:	e7a1      	b.n	80165ce <_malloc_r+0x22>
 801668a:	6025      	str	r5, [r4, #0]
 801668c:	e7de      	b.n	801664c <_malloc_r+0xa0>
 801668e:	bf00      	nop
 8016690:	20001e64 	.word	0x20001e64

08016694 <__sfputc_r>:
 8016694:	6893      	ldr	r3, [r2, #8]
 8016696:	3b01      	subs	r3, #1
 8016698:	2b00      	cmp	r3, #0
 801669a:	b410      	push	{r4}
 801669c:	6093      	str	r3, [r2, #8]
 801669e:	da08      	bge.n	80166b2 <__sfputc_r+0x1e>
 80166a0:	6994      	ldr	r4, [r2, #24]
 80166a2:	42a3      	cmp	r3, r4
 80166a4:	db01      	blt.n	80166aa <__sfputc_r+0x16>
 80166a6:	290a      	cmp	r1, #10
 80166a8:	d103      	bne.n	80166b2 <__sfputc_r+0x1e>
 80166aa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80166ae:	f000 bba7 	b.w	8016e00 <__swbuf_r>
 80166b2:	6813      	ldr	r3, [r2, #0]
 80166b4:	1c58      	adds	r0, r3, #1
 80166b6:	6010      	str	r0, [r2, #0]
 80166b8:	7019      	strb	r1, [r3, #0]
 80166ba:	4608      	mov	r0, r1
 80166bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80166c0:	4770      	bx	lr

080166c2 <__sfputs_r>:
 80166c2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80166c4:	4606      	mov	r6, r0
 80166c6:	460f      	mov	r7, r1
 80166c8:	4614      	mov	r4, r2
 80166ca:	18d5      	adds	r5, r2, r3
 80166cc:	42ac      	cmp	r4, r5
 80166ce:	d101      	bne.n	80166d4 <__sfputs_r+0x12>
 80166d0:	2000      	movs	r0, #0
 80166d2:	e007      	b.n	80166e4 <__sfputs_r+0x22>
 80166d4:	f814 1b01 	ldrb.w	r1, [r4], #1
 80166d8:	463a      	mov	r2, r7
 80166da:	4630      	mov	r0, r6
 80166dc:	f7ff ffda 	bl	8016694 <__sfputc_r>
 80166e0:	1c43      	adds	r3, r0, #1
 80166e2:	d1f3      	bne.n	80166cc <__sfputs_r+0xa>
 80166e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080166e8 <_vfiprintf_r>:
 80166e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80166ec:	460d      	mov	r5, r1
 80166ee:	b09d      	sub	sp, #116	; 0x74
 80166f0:	4614      	mov	r4, r2
 80166f2:	4698      	mov	r8, r3
 80166f4:	4606      	mov	r6, r0
 80166f6:	b118      	cbz	r0, 8016700 <_vfiprintf_r+0x18>
 80166f8:	6983      	ldr	r3, [r0, #24]
 80166fa:	b90b      	cbnz	r3, 8016700 <_vfiprintf_r+0x18>
 80166fc:	f000 fdbc 	bl	8017278 <__sinit>
 8016700:	4b89      	ldr	r3, [pc, #548]	; (8016928 <_vfiprintf_r+0x240>)
 8016702:	429d      	cmp	r5, r3
 8016704:	d11b      	bne.n	801673e <_vfiprintf_r+0x56>
 8016706:	6875      	ldr	r5, [r6, #4]
 8016708:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801670a:	07d9      	lsls	r1, r3, #31
 801670c:	d405      	bmi.n	801671a <_vfiprintf_r+0x32>
 801670e:	89ab      	ldrh	r3, [r5, #12]
 8016710:	059a      	lsls	r2, r3, #22
 8016712:	d402      	bmi.n	801671a <_vfiprintf_r+0x32>
 8016714:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8016716:	f000 fe4d 	bl	80173b4 <__retarget_lock_acquire_recursive>
 801671a:	89ab      	ldrh	r3, [r5, #12]
 801671c:	071b      	lsls	r3, r3, #28
 801671e:	d501      	bpl.n	8016724 <_vfiprintf_r+0x3c>
 8016720:	692b      	ldr	r3, [r5, #16]
 8016722:	b9eb      	cbnz	r3, 8016760 <_vfiprintf_r+0x78>
 8016724:	4629      	mov	r1, r5
 8016726:	4630      	mov	r0, r6
 8016728:	f000 fbbc 	bl	8016ea4 <__swsetup_r>
 801672c:	b1c0      	cbz	r0, 8016760 <_vfiprintf_r+0x78>
 801672e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8016730:	07dc      	lsls	r4, r3, #31
 8016732:	d50e      	bpl.n	8016752 <_vfiprintf_r+0x6a>
 8016734:	f04f 30ff 	mov.w	r0, #4294967295
 8016738:	b01d      	add	sp, #116	; 0x74
 801673a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801673e:	4b7b      	ldr	r3, [pc, #492]	; (801692c <_vfiprintf_r+0x244>)
 8016740:	429d      	cmp	r5, r3
 8016742:	d101      	bne.n	8016748 <_vfiprintf_r+0x60>
 8016744:	68b5      	ldr	r5, [r6, #8]
 8016746:	e7df      	b.n	8016708 <_vfiprintf_r+0x20>
 8016748:	4b79      	ldr	r3, [pc, #484]	; (8016930 <_vfiprintf_r+0x248>)
 801674a:	429d      	cmp	r5, r3
 801674c:	bf08      	it	eq
 801674e:	68f5      	ldreq	r5, [r6, #12]
 8016750:	e7da      	b.n	8016708 <_vfiprintf_r+0x20>
 8016752:	89ab      	ldrh	r3, [r5, #12]
 8016754:	0598      	lsls	r0, r3, #22
 8016756:	d4ed      	bmi.n	8016734 <_vfiprintf_r+0x4c>
 8016758:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801675a:	f000 fe2d 	bl	80173b8 <__retarget_lock_release_recursive>
 801675e:	e7e9      	b.n	8016734 <_vfiprintf_r+0x4c>
 8016760:	2300      	movs	r3, #0
 8016762:	9309      	str	r3, [sp, #36]	; 0x24
 8016764:	2320      	movs	r3, #32
 8016766:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801676a:	f8cd 800c 	str.w	r8, [sp, #12]
 801676e:	2330      	movs	r3, #48	; 0x30
 8016770:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8016934 <_vfiprintf_r+0x24c>
 8016774:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8016778:	f04f 0901 	mov.w	r9, #1
 801677c:	4623      	mov	r3, r4
 801677e:	469a      	mov	sl, r3
 8016780:	f813 2b01 	ldrb.w	r2, [r3], #1
 8016784:	b10a      	cbz	r2, 801678a <_vfiprintf_r+0xa2>
 8016786:	2a25      	cmp	r2, #37	; 0x25
 8016788:	d1f9      	bne.n	801677e <_vfiprintf_r+0x96>
 801678a:	ebba 0b04 	subs.w	fp, sl, r4
 801678e:	d00b      	beq.n	80167a8 <_vfiprintf_r+0xc0>
 8016790:	465b      	mov	r3, fp
 8016792:	4622      	mov	r2, r4
 8016794:	4629      	mov	r1, r5
 8016796:	4630      	mov	r0, r6
 8016798:	f7ff ff93 	bl	80166c2 <__sfputs_r>
 801679c:	3001      	adds	r0, #1
 801679e:	f000 80aa 	beq.w	80168f6 <_vfiprintf_r+0x20e>
 80167a2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80167a4:	445a      	add	r2, fp
 80167a6:	9209      	str	r2, [sp, #36]	; 0x24
 80167a8:	f89a 3000 	ldrb.w	r3, [sl]
 80167ac:	2b00      	cmp	r3, #0
 80167ae:	f000 80a2 	beq.w	80168f6 <_vfiprintf_r+0x20e>
 80167b2:	2300      	movs	r3, #0
 80167b4:	f04f 32ff 	mov.w	r2, #4294967295
 80167b8:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80167bc:	f10a 0a01 	add.w	sl, sl, #1
 80167c0:	9304      	str	r3, [sp, #16]
 80167c2:	9307      	str	r3, [sp, #28]
 80167c4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80167c8:	931a      	str	r3, [sp, #104]	; 0x68
 80167ca:	4654      	mov	r4, sl
 80167cc:	2205      	movs	r2, #5
 80167ce:	f814 1b01 	ldrb.w	r1, [r4], #1
 80167d2:	4858      	ldr	r0, [pc, #352]	; (8016934 <_vfiprintf_r+0x24c>)
 80167d4:	f7e9 fcfc 	bl	80001d0 <memchr>
 80167d8:	9a04      	ldr	r2, [sp, #16]
 80167da:	b9d8      	cbnz	r0, 8016814 <_vfiprintf_r+0x12c>
 80167dc:	06d1      	lsls	r1, r2, #27
 80167de:	bf44      	itt	mi
 80167e0:	2320      	movmi	r3, #32
 80167e2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80167e6:	0713      	lsls	r3, r2, #28
 80167e8:	bf44      	itt	mi
 80167ea:	232b      	movmi	r3, #43	; 0x2b
 80167ec:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80167f0:	f89a 3000 	ldrb.w	r3, [sl]
 80167f4:	2b2a      	cmp	r3, #42	; 0x2a
 80167f6:	d015      	beq.n	8016824 <_vfiprintf_r+0x13c>
 80167f8:	9a07      	ldr	r2, [sp, #28]
 80167fa:	4654      	mov	r4, sl
 80167fc:	2000      	movs	r0, #0
 80167fe:	f04f 0c0a 	mov.w	ip, #10
 8016802:	4621      	mov	r1, r4
 8016804:	f811 3b01 	ldrb.w	r3, [r1], #1
 8016808:	3b30      	subs	r3, #48	; 0x30
 801680a:	2b09      	cmp	r3, #9
 801680c:	d94e      	bls.n	80168ac <_vfiprintf_r+0x1c4>
 801680e:	b1b0      	cbz	r0, 801683e <_vfiprintf_r+0x156>
 8016810:	9207      	str	r2, [sp, #28]
 8016812:	e014      	b.n	801683e <_vfiprintf_r+0x156>
 8016814:	eba0 0308 	sub.w	r3, r0, r8
 8016818:	fa09 f303 	lsl.w	r3, r9, r3
 801681c:	4313      	orrs	r3, r2
 801681e:	9304      	str	r3, [sp, #16]
 8016820:	46a2      	mov	sl, r4
 8016822:	e7d2      	b.n	80167ca <_vfiprintf_r+0xe2>
 8016824:	9b03      	ldr	r3, [sp, #12]
 8016826:	1d19      	adds	r1, r3, #4
 8016828:	681b      	ldr	r3, [r3, #0]
 801682a:	9103      	str	r1, [sp, #12]
 801682c:	2b00      	cmp	r3, #0
 801682e:	bfbb      	ittet	lt
 8016830:	425b      	neglt	r3, r3
 8016832:	f042 0202 	orrlt.w	r2, r2, #2
 8016836:	9307      	strge	r3, [sp, #28]
 8016838:	9307      	strlt	r3, [sp, #28]
 801683a:	bfb8      	it	lt
 801683c:	9204      	strlt	r2, [sp, #16]
 801683e:	7823      	ldrb	r3, [r4, #0]
 8016840:	2b2e      	cmp	r3, #46	; 0x2e
 8016842:	d10c      	bne.n	801685e <_vfiprintf_r+0x176>
 8016844:	7863      	ldrb	r3, [r4, #1]
 8016846:	2b2a      	cmp	r3, #42	; 0x2a
 8016848:	d135      	bne.n	80168b6 <_vfiprintf_r+0x1ce>
 801684a:	9b03      	ldr	r3, [sp, #12]
 801684c:	1d1a      	adds	r2, r3, #4
 801684e:	681b      	ldr	r3, [r3, #0]
 8016850:	9203      	str	r2, [sp, #12]
 8016852:	2b00      	cmp	r3, #0
 8016854:	bfb8      	it	lt
 8016856:	f04f 33ff 	movlt.w	r3, #4294967295
 801685a:	3402      	adds	r4, #2
 801685c:	9305      	str	r3, [sp, #20]
 801685e:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8016944 <_vfiprintf_r+0x25c>
 8016862:	7821      	ldrb	r1, [r4, #0]
 8016864:	2203      	movs	r2, #3
 8016866:	4650      	mov	r0, sl
 8016868:	f7e9 fcb2 	bl	80001d0 <memchr>
 801686c:	b140      	cbz	r0, 8016880 <_vfiprintf_r+0x198>
 801686e:	2340      	movs	r3, #64	; 0x40
 8016870:	eba0 000a 	sub.w	r0, r0, sl
 8016874:	fa03 f000 	lsl.w	r0, r3, r0
 8016878:	9b04      	ldr	r3, [sp, #16]
 801687a:	4303      	orrs	r3, r0
 801687c:	3401      	adds	r4, #1
 801687e:	9304      	str	r3, [sp, #16]
 8016880:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016884:	482c      	ldr	r0, [pc, #176]	; (8016938 <_vfiprintf_r+0x250>)
 8016886:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801688a:	2206      	movs	r2, #6
 801688c:	f7e9 fca0 	bl	80001d0 <memchr>
 8016890:	2800      	cmp	r0, #0
 8016892:	d03f      	beq.n	8016914 <_vfiprintf_r+0x22c>
 8016894:	4b29      	ldr	r3, [pc, #164]	; (801693c <_vfiprintf_r+0x254>)
 8016896:	bb1b      	cbnz	r3, 80168e0 <_vfiprintf_r+0x1f8>
 8016898:	9b03      	ldr	r3, [sp, #12]
 801689a:	3307      	adds	r3, #7
 801689c:	f023 0307 	bic.w	r3, r3, #7
 80168a0:	3308      	adds	r3, #8
 80168a2:	9303      	str	r3, [sp, #12]
 80168a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80168a6:	443b      	add	r3, r7
 80168a8:	9309      	str	r3, [sp, #36]	; 0x24
 80168aa:	e767      	b.n	801677c <_vfiprintf_r+0x94>
 80168ac:	fb0c 3202 	mla	r2, ip, r2, r3
 80168b0:	460c      	mov	r4, r1
 80168b2:	2001      	movs	r0, #1
 80168b4:	e7a5      	b.n	8016802 <_vfiprintf_r+0x11a>
 80168b6:	2300      	movs	r3, #0
 80168b8:	3401      	adds	r4, #1
 80168ba:	9305      	str	r3, [sp, #20]
 80168bc:	4619      	mov	r1, r3
 80168be:	f04f 0c0a 	mov.w	ip, #10
 80168c2:	4620      	mov	r0, r4
 80168c4:	f810 2b01 	ldrb.w	r2, [r0], #1
 80168c8:	3a30      	subs	r2, #48	; 0x30
 80168ca:	2a09      	cmp	r2, #9
 80168cc:	d903      	bls.n	80168d6 <_vfiprintf_r+0x1ee>
 80168ce:	2b00      	cmp	r3, #0
 80168d0:	d0c5      	beq.n	801685e <_vfiprintf_r+0x176>
 80168d2:	9105      	str	r1, [sp, #20]
 80168d4:	e7c3      	b.n	801685e <_vfiprintf_r+0x176>
 80168d6:	fb0c 2101 	mla	r1, ip, r1, r2
 80168da:	4604      	mov	r4, r0
 80168dc:	2301      	movs	r3, #1
 80168de:	e7f0      	b.n	80168c2 <_vfiprintf_r+0x1da>
 80168e0:	ab03      	add	r3, sp, #12
 80168e2:	9300      	str	r3, [sp, #0]
 80168e4:	462a      	mov	r2, r5
 80168e6:	4b16      	ldr	r3, [pc, #88]	; (8016940 <_vfiprintf_r+0x258>)
 80168e8:	a904      	add	r1, sp, #16
 80168ea:	4630      	mov	r0, r6
 80168ec:	f3af 8000 	nop.w
 80168f0:	4607      	mov	r7, r0
 80168f2:	1c78      	adds	r0, r7, #1
 80168f4:	d1d6      	bne.n	80168a4 <_vfiprintf_r+0x1bc>
 80168f6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80168f8:	07d9      	lsls	r1, r3, #31
 80168fa:	d405      	bmi.n	8016908 <_vfiprintf_r+0x220>
 80168fc:	89ab      	ldrh	r3, [r5, #12]
 80168fe:	059a      	lsls	r2, r3, #22
 8016900:	d402      	bmi.n	8016908 <_vfiprintf_r+0x220>
 8016902:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8016904:	f000 fd58 	bl	80173b8 <__retarget_lock_release_recursive>
 8016908:	89ab      	ldrh	r3, [r5, #12]
 801690a:	065b      	lsls	r3, r3, #25
 801690c:	f53f af12 	bmi.w	8016734 <_vfiprintf_r+0x4c>
 8016910:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016912:	e711      	b.n	8016738 <_vfiprintf_r+0x50>
 8016914:	ab03      	add	r3, sp, #12
 8016916:	9300      	str	r3, [sp, #0]
 8016918:	462a      	mov	r2, r5
 801691a:	4b09      	ldr	r3, [pc, #36]	; (8016940 <_vfiprintf_r+0x258>)
 801691c:	a904      	add	r1, sp, #16
 801691e:	4630      	mov	r0, r6
 8016920:	f000 f880 	bl	8016a24 <_printf_i>
 8016924:	e7e4      	b.n	80168f0 <_vfiprintf_r+0x208>
 8016926:	bf00      	nop
 8016928:	0801ddf0 	.word	0x0801ddf0
 801692c:	0801de10 	.word	0x0801de10
 8016930:	0801ddd0 	.word	0x0801ddd0
 8016934:	0801dd9c 	.word	0x0801dd9c
 8016938:	0801dda6 	.word	0x0801dda6
 801693c:	00000000 	.word	0x00000000
 8016940:	080166c3 	.word	0x080166c3
 8016944:	0801dda2 	.word	0x0801dda2

08016948 <_printf_common>:
 8016948:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801694c:	4616      	mov	r6, r2
 801694e:	4699      	mov	r9, r3
 8016950:	688a      	ldr	r2, [r1, #8]
 8016952:	690b      	ldr	r3, [r1, #16]
 8016954:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8016958:	4293      	cmp	r3, r2
 801695a:	bfb8      	it	lt
 801695c:	4613      	movlt	r3, r2
 801695e:	6033      	str	r3, [r6, #0]
 8016960:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8016964:	4607      	mov	r7, r0
 8016966:	460c      	mov	r4, r1
 8016968:	b10a      	cbz	r2, 801696e <_printf_common+0x26>
 801696a:	3301      	adds	r3, #1
 801696c:	6033      	str	r3, [r6, #0]
 801696e:	6823      	ldr	r3, [r4, #0]
 8016970:	0699      	lsls	r1, r3, #26
 8016972:	bf42      	ittt	mi
 8016974:	6833      	ldrmi	r3, [r6, #0]
 8016976:	3302      	addmi	r3, #2
 8016978:	6033      	strmi	r3, [r6, #0]
 801697a:	6825      	ldr	r5, [r4, #0]
 801697c:	f015 0506 	ands.w	r5, r5, #6
 8016980:	d106      	bne.n	8016990 <_printf_common+0x48>
 8016982:	f104 0a19 	add.w	sl, r4, #25
 8016986:	68e3      	ldr	r3, [r4, #12]
 8016988:	6832      	ldr	r2, [r6, #0]
 801698a:	1a9b      	subs	r3, r3, r2
 801698c:	42ab      	cmp	r3, r5
 801698e:	dc26      	bgt.n	80169de <_printf_common+0x96>
 8016990:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8016994:	1e13      	subs	r3, r2, #0
 8016996:	6822      	ldr	r2, [r4, #0]
 8016998:	bf18      	it	ne
 801699a:	2301      	movne	r3, #1
 801699c:	0692      	lsls	r2, r2, #26
 801699e:	d42b      	bmi.n	80169f8 <_printf_common+0xb0>
 80169a0:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80169a4:	4649      	mov	r1, r9
 80169a6:	4638      	mov	r0, r7
 80169a8:	47c0      	blx	r8
 80169aa:	3001      	adds	r0, #1
 80169ac:	d01e      	beq.n	80169ec <_printf_common+0xa4>
 80169ae:	6823      	ldr	r3, [r4, #0]
 80169b0:	68e5      	ldr	r5, [r4, #12]
 80169b2:	6832      	ldr	r2, [r6, #0]
 80169b4:	f003 0306 	and.w	r3, r3, #6
 80169b8:	2b04      	cmp	r3, #4
 80169ba:	bf08      	it	eq
 80169bc:	1aad      	subeq	r5, r5, r2
 80169be:	68a3      	ldr	r3, [r4, #8]
 80169c0:	6922      	ldr	r2, [r4, #16]
 80169c2:	bf0c      	ite	eq
 80169c4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80169c8:	2500      	movne	r5, #0
 80169ca:	4293      	cmp	r3, r2
 80169cc:	bfc4      	itt	gt
 80169ce:	1a9b      	subgt	r3, r3, r2
 80169d0:	18ed      	addgt	r5, r5, r3
 80169d2:	2600      	movs	r6, #0
 80169d4:	341a      	adds	r4, #26
 80169d6:	42b5      	cmp	r5, r6
 80169d8:	d11a      	bne.n	8016a10 <_printf_common+0xc8>
 80169da:	2000      	movs	r0, #0
 80169dc:	e008      	b.n	80169f0 <_printf_common+0xa8>
 80169de:	2301      	movs	r3, #1
 80169e0:	4652      	mov	r2, sl
 80169e2:	4649      	mov	r1, r9
 80169e4:	4638      	mov	r0, r7
 80169e6:	47c0      	blx	r8
 80169e8:	3001      	adds	r0, #1
 80169ea:	d103      	bne.n	80169f4 <_printf_common+0xac>
 80169ec:	f04f 30ff 	mov.w	r0, #4294967295
 80169f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80169f4:	3501      	adds	r5, #1
 80169f6:	e7c6      	b.n	8016986 <_printf_common+0x3e>
 80169f8:	18e1      	adds	r1, r4, r3
 80169fa:	1c5a      	adds	r2, r3, #1
 80169fc:	2030      	movs	r0, #48	; 0x30
 80169fe:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8016a02:	4422      	add	r2, r4
 8016a04:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8016a08:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8016a0c:	3302      	adds	r3, #2
 8016a0e:	e7c7      	b.n	80169a0 <_printf_common+0x58>
 8016a10:	2301      	movs	r3, #1
 8016a12:	4622      	mov	r2, r4
 8016a14:	4649      	mov	r1, r9
 8016a16:	4638      	mov	r0, r7
 8016a18:	47c0      	blx	r8
 8016a1a:	3001      	adds	r0, #1
 8016a1c:	d0e6      	beq.n	80169ec <_printf_common+0xa4>
 8016a1e:	3601      	adds	r6, #1
 8016a20:	e7d9      	b.n	80169d6 <_printf_common+0x8e>
	...

08016a24 <_printf_i>:
 8016a24:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8016a28:	7e0f      	ldrb	r7, [r1, #24]
 8016a2a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8016a2c:	2f78      	cmp	r7, #120	; 0x78
 8016a2e:	4691      	mov	r9, r2
 8016a30:	4680      	mov	r8, r0
 8016a32:	460c      	mov	r4, r1
 8016a34:	469a      	mov	sl, r3
 8016a36:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8016a3a:	d807      	bhi.n	8016a4c <_printf_i+0x28>
 8016a3c:	2f62      	cmp	r7, #98	; 0x62
 8016a3e:	d80a      	bhi.n	8016a56 <_printf_i+0x32>
 8016a40:	2f00      	cmp	r7, #0
 8016a42:	f000 80d8 	beq.w	8016bf6 <_printf_i+0x1d2>
 8016a46:	2f58      	cmp	r7, #88	; 0x58
 8016a48:	f000 80a3 	beq.w	8016b92 <_printf_i+0x16e>
 8016a4c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8016a50:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8016a54:	e03a      	b.n	8016acc <_printf_i+0xa8>
 8016a56:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8016a5a:	2b15      	cmp	r3, #21
 8016a5c:	d8f6      	bhi.n	8016a4c <_printf_i+0x28>
 8016a5e:	a101      	add	r1, pc, #4	; (adr r1, 8016a64 <_printf_i+0x40>)
 8016a60:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8016a64:	08016abd 	.word	0x08016abd
 8016a68:	08016ad1 	.word	0x08016ad1
 8016a6c:	08016a4d 	.word	0x08016a4d
 8016a70:	08016a4d 	.word	0x08016a4d
 8016a74:	08016a4d 	.word	0x08016a4d
 8016a78:	08016a4d 	.word	0x08016a4d
 8016a7c:	08016ad1 	.word	0x08016ad1
 8016a80:	08016a4d 	.word	0x08016a4d
 8016a84:	08016a4d 	.word	0x08016a4d
 8016a88:	08016a4d 	.word	0x08016a4d
 8016a8c:	08016a4d 	.word	0x08016a4d
 8016a90:	08016bdd 	.word	0x08016bdd
 8016a94:	08016b01 	.word	0x08016b01
 8016a98:	08016bbf 	.word	0x08016bbf
 8016a9c:	08016a4d 	.word	0x08016a4d
 8016aa0:	08016a4d 	.word	0x08016a4d
 8016aa4:	08016bff 	.word	0x08016bff
 8016aa8:	08016a4d 	.word	0x08016a4d
 8016aac:	08016b01 	.word	0x08016b01
 8016ab0:	08016a4d 	.word	0x08016a4d
 8016ab4:	08016a4d 	.word	0x08016a4d
 8016ab8:	08016bc7 	.word	0x08016bc7
 8016abc:	682b      	ldr	r3, [r5, #0]
 8016abe:	1d1a      	adds	r2, r3, #4
 8016ac0:	681b      	ldr	r3, [r3, #0]
 8016ac2:	602a      	str	r2, [r5, #0]
 8016ac4:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8016ac8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8016acc:	2301      	movs	r3, #1
 8016ace:	e0a3      	b.n	8016c18 <_printf_i+0x1f4>
 8016ad0:	6820      	ldr	r0, [r4, #0]
 8016ad2:	6829      	ldr	r1, [r5, #0]
 8016ad4:	0606      	lsls	r6, r0, #24
 8016ad6:	f101 0304 	add.w	r3, r1, #4
 8016ada:	d50a      	bpl.n	8016af2 <_printf_i+0xce>
 8016adc:	680e      	ldr	r6, [r1, #0]
 8016ade:	602b      	str	r3, [r5, #0]
 8016ae0:	2e00      	cmp	r6, #0
 8016ae2:	da03      	bge.n	8016aec <_printf_i+0xc8>
 8016ae4:	232d      	movs	r3, #45	; 0x2d
 8016ae6:	4276      	negs	r6, r6
 8016ae8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8016aec:	485e      	ldr	r0, [pc, #376]	; (8016c68 <_printf_i+0x244>)
 8016aee:	230a      	movs	r3, #10
 8016af0:	e019      	b.n	8016b26 <_printf_i+0x102>
 8016af2:	680e      	ldr	r6, [r1, #0]
 8016af4:	602b      	str	r3, [r5, #0]
 8016af6:	f010 0f40 	tst.w	r0, #64	; 0x40
 8016afa:	bf18      	it	ne
 8016afc:	b236      	sxthne	r6, r6
 8016afe:	e7ef      	b.n	8016ae0 <_printf_i+0xbc>
 8016b00:	682b      	ldr	r3, [r5, #0]
 8016b02:	6820      	ldr	r0, [r4, #0]
 8016b04:	1d19      	adds	r1, r3, #4
 8016b06:	6029      	str	r1, [r5, #0]
 8016b08:	0601      	lsls	r1, r0, #24
 8016b0a:	d501      	bpl.n	8016b10 <_printf_i+0xec>
 8016b0c:	681e      	ldr	r6, [r3, #0]
 8016b0e:	e002      	b.n	8016b16 <_printf_i+0xf2>
 8016b10:	0646      	lsls	r6, r0, #25
 8016b12:	d5fb      	bpl.n	8016b0c <_printf_i+0xe8>
 8016b14:	881e      	ldrh	r6, [r3, #0]
 8016b16:	4854      	ldr	r0, [pc, #336]	; (8016c68 <_printf_i+0x244>)
 8016b18:	2f6f      	cmp	r7, #111	; 0x6f
 8016b1a:	bf0c      	ite	eq
 8016b1c:	2308      	moveq	r3, #8
 8016b1e:	230a      	movne	r3, #10
 8016b20:	2100      	movs	r1, #0
 8016b22:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8016b26:	6865      	ldr	r5, [r4, #4]
 8016b28:	60a5      	str	r5, [r4, #8]
 8016b2a:	2d00      	cmp	r5, #0
 8016b2c:	bfa2      	ittt	ge
 8016b2e:	6821      	ldrge	r1, [r4, #0]
 8016b30:	f021 0104 	bicge.w	r1, r1, #4
 8016b34:	6021      	strge	r1, [r4, #0]
 8016b36:	b90e      	cbnz	r6, 8016b3c <_printf_i+0x118>
 8016b38:	2d00      	cmp	r5, #0
 8016b3a:	d04d      	beq.n	8016bd8 <_printf_i+0x1b4>
 8016b3c:	4615      	mov	r5, r2
 8016b3e:	fbb6 f1f3 	udiv	r1, r6, r3
 8016b42:	fb03 6711 	mls	r7, r3, r1, r6
 8016b46:	5dc7      	ldrb	r7, [r0, r7]
 8016b48:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8016b4c:	4637      	mov	r7, r6
 8016b4e:	42bb      	cmp	r3, r7
 8016b50:	460e      	mov	r6, r1
 8016b52:	d9f4      	bls.n	8016b3e <_printf_i+0x11a>
 8016b54:	2b08      	cmp	r3, #8
 8016b56:	d10b      	bne.n	8016b70 <_printf_i+0x14c>
 8016b58:	6823      	ldr	r3, [r4, #0]
 8016b5a:	07de      	lsls	r6, r3, #31
 8016b5c:	d508      	bpl.n	8016b70 <_printf_i+0x14c>
 8016b5e:	6923      	ldr	r3, [r4, #16]
 8016b60:	6861      	ldr	r1, [r4, #4]
 8016b62:	4299      	cmp	r1, r3
 8016b64:	bfde      	ittt	le
 8016b66:	2330      	movle	r3, #48	; 0x30
 8016b68:	f805 3c01 	strble.w	r3, [r5, #-1]
 8016b6c:	f105 35ff 	addle.w	r5, r5, #4294967295
 8016b70:	1b52      	subs	r2, r2, r5
 8016b72:	6122      	str	r2, [r4, #16]
 8016b74:	f8cd a000 	str.w	sl, [sp]
 8016b78:	464b      	mov	r3, r9
 8016b7a:	aa03      	add	r2, sp, #12
 8016b7c:	4621      	mov	r1, r4
 8016b7e:	4640      	mov	r0, r8
 8016b80:	f7ff fee2 	bl	8016948 <_printf_common>
 8016b84:	3001      	adds	r0, #1
 8016b86:	d14c      	bne.n	8016c22 <_printf_i+0x1fe>
 8016b88:	f04f 30ff 	mov.w	r0, #4294967295
 8016b8c:	b004      	add	sp, #16
 8016b8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016b92:	4835      	ldr	r0, [pc, #212]	; (8016c68 <_printf_i+0x244>)
 8016b94:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8016b98:	6829      	ldr	r1, [r5, #0]
 8016b9a:	6823      	ldr	r3, [r4, #0]
 8016b9c:	f851 6b04 	ldr.w	r6, [r1], #4
 8016ba0:	6029      	str	r1, [r5, #0]
 8016ba2:	061d      	lsls	r5, r3, #24
 8016ba4:	d514      	bpl.n	8016bd0 <_printf_i+0x1ac>
 8016ba6:	07df      	lsls	r7, r3, #31
 8016ba8:	bf44      	itt	mi
 8016baa:	f043 0320 	orrmi.w	r3, r3, #32
 8016bae:	6023      	strmi	r3, [r4, #0]
 8016bb0:	b91e      	cbnz	r6, 8016bba <_printf_i+0x196>
 8016bb2:	6823      	ldr	r3, [r4, #0]
 8016bb4:	f023 0320 	bic.w	r3, r3, #32
 8016bb8:	6023      	str	r3, [r4, #0]
 8016bba:	2310      	movs	r3, #16
 8016bbc:	e7b0      	b.n	8016b20 <_printf_i+0xfc>
 8016bbe:	6823      	ldr	r3, [r4, #0]
 8016bc0:	f043 0320 	orr.w	r3, r3, #32
 8016bc4:	6023      	str	r3, [r4, #0]
 8016bc6:	2378      	movs	r3, #120	; 0x78
 8016bc8:	4828      	ldr	r0, [pc, #160]	; (8016c6c <_printf_i+0x248>)
 8016bca:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8016bce:	e7e3      	b.n	8016b98 <_printf_i+0x174>
 8016bd0:	0659      	lsls	r1, r3, #25
 8016bd2:	bf48      	it	mi
 8016bd4:	b2b6      	uxthmi	r6, r6
 8016bd6:	e7e6      	b.n	8016ba6 <_printf_i+0x182>
 8016bd8:	4615      	mov	r5, r2
 8016bda:	e7bb      	b.n	8016b54 <_printf_i+0x130>
 8016bdc:	682b      	ldr	r3, [r5, #0]
 8016bde:	6826      	ldr	r6, [r4, #0]
 8016be0:	6961      	ldr	r1, [r4, #20]
 8016be2:	1d18      	adds	r0, r3, #4
 8016be4:	6028      	str	r0, [r5, #0]
 8016be6:	0635      	lsls	r5, r6, #24
 8016be8:	681b      	ldr	r3, [r3, #0]
 8016bea:	d501      	bpl.n	8016bf0 <_printf_i+0x1cc>
 8016bec:	6019      	str	r1, [r3, #0]
 8016bee:	e002      	b.n	8016bf6 <_printf_i+0x1d2>
 8016bf0:	0670      	lsls	r0, r6, #25
 8016bf2:	d5fb      	bpl.n	8016bec <_printf_i+0x1c8>
 8016bf4:	8019      	strh	r1, [r3, #0]
 8016bf6:	2300      	movs	r3, #0
 8016bf8:	6123      	str	r3, [r4, #16]
 8016bfa:	4615      	mov	r5, r2
 8016bfc:	e7ba      	b.n	8016b74 <_printf_i+0x150>
 8016bfe:	682b      	ldr	r3, [r5, #0]
 8016c00:	1d1a      	adds	r2, r3, #4
 8016c02:	602a      	str	r2, [r5, #0]
 8016c04:	681d      	ldr	r5, [r3, #0]
 8016c06:	6862      	ldr	r2, [r4, #4]
 8016c08:	2100      	movs	r1, #0
 8016c0a:	4628      	mov	r0, r5
 8016c0c:	f7e9 fae0 	bl	80001d0 <memchr>
 8016c10:	b108      	cbz	r0, 8016c16 <_printf_i+0x1f2>
 8016c12:	1b40      	subs	r0, r0, r5
 8016c14:	6060      	str	r0, [r4, #4]
 8016c16:	6863      	ldr	r3, [r4, #4]
 8016c18:	6123      	str	r3, [r4, #16]
 8016c1a:	2300      	movs	r3, #0
 8016c1c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8016c20:	e7a8      	b.n	8016b74 <_printf_i+0x150>
 8016c22:	6923      	ldr	r3, [r4, #16]
 8016c24:	462a      	mov	r2, r5
 8016c26:	4649      	mov	r1, r9
 8016c28:	4640      	mov	r0, r8
 8016c2a:	47d0      	blx	sl
 8016c2c:	3001      	adds	r0, #1
 8016c2e:	d0ab      	beq.n	8016b88 <_printf_i+0x164>
 8016c30:	6823      	ldr	r3, [r4, #0]
 8016c32:	079b      	lsls	r3, r3, #30
 8016c34:	d413      	bmi.n	8016c5e <_printf_i+0x23a>
 8016c36:	68e0      	ldr	r0, [r4, #12]
 8016c38:	9b03      	ldr	r3, [sp, #12]
 8016c3a:	4298      	cmp	r0, r3
 8016c3c:	bfb8      	it	lt
 8016c3e:	4618      	movlt	r0, r3
 8016c40:	e7a4      	b.n	8016b8c <_printf_i+0x168>
 8016c42:	2301      	movs	r3, #1
 8016c44:	4632      	mov	r2, r6
 8016c46:	4649      	mov	r1, r9
 8016c48:	4640      	mov	r0, r8
 8016c4a:	47d0      	blx	sl
 8016c4c:	3001      	adds	r0, #1
 8016c4e:	d09b      	beq.n	8016b88 <_printf_i+0x164>
 8016c50:	3501      	adds	r5, #1
 8016c52:	68e3      	ldr	r3, [r4, #12]
 8016c54:	9903      	ldr	r1, [sp, #12]
 8016c56:	1a5b      	subs	r3, r3, r1
 8016c58:	42ab      	cmp	r3, r5
 8016c5a:	dcf2      	bgt.n	8016c42 <_printf_i+0x21e>
 8016c5c:	e7eb      	b.n	8016c36 <_printf_i+0x212>
 8016c5e:	2500      	movs	r5, #0
 8016c60:	f104 0619 	add.w	r6, r4, #25
 8016c64:	e7f5      	b.n	8016c52 <_printf_i+0x22e>
 8016c66:	bf00      	nop
 8016c68:	0801ddad 	.word	0x0801ddad
 8016c6c:	0801ddbe 	.word	0x0801ddbe

08016c70 <_sbrk_r>:
 8016c70:	b538      	push	{r3, r4, r5, lr}
 8016c72:	4d06      	ldr	r5, [pc, #24]	; (8016c8c <_sbrk_r+0x1c>)
 8016c74:	2300      	movs	r3, #0
 8016c76:	4604      	mov	r4, r0
 8016c78:	4608      	mov	r0, r1
 8016c7a:	602b      	str	r3, [r5, #0]
 8016c7c:	f7ea fb06 	bl	800128c <_sbrk>
 8016c80:	1c43      	adds	r3, r0, #1
 8016c82:	d102      	bne.n	8016c8a <_sbrk_r+0x1a>
 8016c84:	682b      	ldr	r3, [r5, #0]
 8016c86:	b103      	cbz	r3, 8016c8a <_sbrk_r+0x1a>
 8016c88:	6023      	str	r3, [r4, #0]
 8016c8a:	bd38      	pop	{r3, r4, r5, pc}
 8016c8c:	20001f00 	.word	0x20001f00

08016c90 <_raise_r>:
 8016c90:	291f      	cmp	r1, #31
 8016c92:	b538      	push	{r3, r4, r5, lr}
 8016c94:	4604      	mov	r4, r0
 8016c96:	460d      	mov	r5, r1
 8016c98:	d904      	bls.n	8016ca4 <_raise_r+0x14>
 8016c9a:	2316      	movs	r3, #22
 8016c9c:	6003      	str	r3, [r0, #0]
 8016c9e:	f04f 30ff 	mov.w	r0, #4294967295
 8016ca2:	bd38      	pop	{r3, r4, r5, pc}
 8016ca4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8016ca6:	b112      	cbz	r2, 8016cae <_raise_r+0x1e>
 8016ca8:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8016cac:	b94b      	cbnz	r3, 8016cc2 <_raise_r+0x32>
 8016cae:	4620      	mov	r0, r4
 8016cb0:	f000 f830 	bl	8016d14 <_getpid_r>
 8016cb4:	462a      	mov	r2, r5
 8016cb6:	4601      	mov	r1, r0
 8016cb8:	4620      	mov	r0, r4
 8016cba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8016cbe:	f000 b817 	b.w	8016cf0 <_kill_r>
 8016cc2:	2b01      	cmp	r3, #1
 8016cc4:	d00a      	beq.n	8016cdc <_raise_r+0x4c>
 8016cc6:	1c59      	adds	r1, r3, #1
 8016cc8:	d103      	bne.n	8016cd2 <_raise_r+0x42>
 8016cca:	2316      	movs	r3, #22
 8016ccc:	6003      	str	r3, [r0, #0]
 8016cce:	2001      	movs	r0, #1
 8016cd0:	e7e7      	b.n	8016ca2 <_raise_r+0x12>
 8016cd2:	2400      	movs	r4, #0
 8016cd4:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8016cd8:	4628      	mov	r0, r5
 8016cda:	4798      	blx	r3
 8016cdc:	2000      	movs	r0, #0
 8016cde:	e7e0      	b.n	8016ca2 <_raise_r+0x12>

08016ce0 <raise>:
 8016ce0:	4b02      	ldr	r3, [pc, #8]	; (8016cec <raise+0xc>)
 8016ce2:	4601      	mov	r1, r0
 8016ce4:	6818      	ldr	r0, [r3, #0]
 8016ce6:	f7ff bfd3 	b.w	8016c90 <_raise_r>
 8016cea:	bf00      	nop
 8016cec:	20000018 	.word	0x20000018

08016cf0 <_kill_r>:
 8016cf0:	b538      	push	{r3, r4, r5, lr}
 8016cf2:	4d07      	ldr	r5, [pc, #28]	; (8016d10 <_kill_r+0x20>)
 8016cf4:	2300      	movs	r3, #0
 8016cf6:	4604      	mov	r4, r0
 8016cf8:	4608      	mov	r0, r1
 8016cfa:	4611      	mov	r1, r2
 8016cfc:	602b      	str	r3, [r5, #0]
 8016cfe:	f7ea fa47 	bl	8001190 <_kill>
 8016d02:	1c43      	adds	r3, r0, #1
 8016d04:	d102      	bne.n	8016d0c <_kill_r+0x1c>
 8016d06:	682b      	ldr	r3, [r5, #0]
 8016d08:	b103      	cbz	r3, 8016d0c <_kill_r+0x1c>
 8016d0a:	6023      	str	r3, [r4, #0]
 8016d0c:	bd38      	pop	{r3, r4, r5, pc}
 8016d0e:	bf00      	nop
 8016d10:	20001f00 	.word	0x20001f00

08016d14 <_getpid_r>:
 8016d14:	f7ea ba34 	b.w	8001180 <_getpid>

08016d18 <sniprintf>:
 8016d18:	b40c      	push	{r2, r3}
 8016d1a:	b530      	push	{r4, r5, lr}
 8016d1c:	4b17      	ldr	r3, [pc, #92]	; (8016d7c <sniprintf+0x64>)
 8016d1e:	1e0c      	subs	r4, r1, #0
 8016d20:	681d      	ldr	r5, [r3, #0]
 8016d22:	b09d      	sub	sp, #116	; 0x74
 8016d24:	da08      	bge.n	8016d38 <sniprintf+0x20>
 8016d26:	238b      	movs	r3, #139	; 0x8b
 8016d28:	602b      	str	r3, [r5, #0]
 8016d2a:	f04f 30ff 	mov.w	r0, #4294967295
 8016d2e:	b01d      	add	sp, #116	; 0x74
 8016d30:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8016d34:	b002      	add	sp, #8
 8016d36:	4770      	bx	lr
 8016d38:	f44f 7302 	mov.w	r3, #520	; 0x208
 8016d3c:	f8ad 3014 	strh.w	r3, [sp, #20]
 8016d40:	bf14      	ite	ne
 8016d42:	f104 33ff 	addne.w	r3, r4, #4294967295
 8016d46:	4623      	moveq	r3, r4
 8016d48:	9304      	str	r3, [sp, #16]
 8016d4a:	9307      	str	r3, [sp, #28]
 8016d4c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016d50:	9002      	str	r0, [sp, #8]
 8016d52:	9006      	str	r0, [sp, #24]
 8016d54:	f8ad 3016 	strh.w	r3, [sp, #22]
 8016d58:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8016d5a:	ab21      	add	r3, sp, #132	; 0x84
 8016d5c:	a902      	add	r1, sp, #8
 8016d5e:	4628      	mov	r0, r5
 8016d60:	9301      	str	r3, [sp, #4]
 8016d62:	f000 fc25 	bl	80175b0 <_svfiprintf_r>
 8016d66:	1c43      	adds	r3, r0, #1
 8016d68:	bfbc      	itt	lt
 8016d6a:	238b      	movlt	r3, #139	; 0x8b
 8016d6c:	602b      	strlt	r3, [r5, #0]
 8016d6e:	2c00      	cmp	r4, #0
 8016d70:	d0dd      	beq.n	8016d2e <sniprintf+0x16>
 8016d72:	9b02      	ldr	r3, [sp, #8]
 8016d74:	2200      	movs	r2, #0
 8016d76:	701a      	strb	r2, [r3, #0]
 8016d78:	e7d9      	b.n	8016d2e <sniprintf+0x16>
 8016d7a:	bf00      	nop
 8016d7c:	20000018 	.word	0x20000018

08016d80 <siprintf>:
 8016d80:	b40e      	push	{r1, r2, r3}
 8016d82:	b500      	push	{lr}
 8016d84:	b09c      	sub	sp, #112	; 0x70
 8016d86:	ab1d      	add	r3, sp, #116	; 0x74
 8016d88:	9002      	str	r0, [sp, #8]
 8016d8a:	9006      	str	r0, [sp, #24]
 8016d8c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8016d90:	4809      	ldr	r0, [pc, #36]	; (8016db8 <siprintf+0x38>)
 8016d92:	9107      	str	r1, [sp, #28]
 8016d94:	9104      	str	r1, [sp, #16]
 8016d96:	4909      	ldr	r1, [pc, #36]	; (8016dbc <siprintf+0x3c>)
 8016d98:	f853 2b04 	ldr.w	r2, [r3], #4
 8016d9c:	9105      	str	r1, [sp, #20]
 8016d9e:	6800      	ldr	r0, [r0, #0]
 8016da0:	9301      	str	r3, [sp, #4]
 8016da2:	a902      	add	r1, sp, #8
 8016da4:	f000 fc04 	bl	80175b0 <_svfiprintf_r>
 8016da8:	9b02      	ldr	r3, [sp, #8]
 8016daa:	2200      	movs	r2, #0
 8016dac:	701a      	strb	r2, [r3, #0]
 8016dae:	b01c      	add	sp, #112	; 0x70
 8016db0:	f85d eb04 	ldr.w	lr, [sp], #4
 8016db4:	b003      	add	sp, #12
 8016db6:	4770      	bx	lr
 8016db8:	20000018 	.word	0x20000018
 8016dbc:	ffff0208 	.word	0xffff0208

08016dc0 <_vsiprintf_r>:
 8016dc0:	b500      	push	{lr}
 8016dc2:	b09b      	sub	sp, #108	; 0x6c
 8016dc4:	9100      	str	r1, [sp, #0]
 8016dc6:	9104      	str	r1, [sp, #16]
 8016dc8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8016dcc:	9105      	str	r1, [sp, #20]
 8016dce:	9102      	str	r1, [sp, #8]
 8016dd0:	4905      	ldr	r1, [pc, #20]	; (8016de8 <_vsiprintf_r+0x28>)
 8016dd2:	9103      	str	r1, [sp, #12]
 8016dd4:	4669      	mov	r1, sp
 8016dd6:	f000 fbeb 	bl	80175b0 <_svfiprintf_r>
 8016dda:	9b00      	ldr	r3, [sp, #0]
 8016ddc:	2200      	movs	r2, #0
 8016dde:	701a      	strb	r2, [r3, #0]
 8016de0:	b01b      	add	sp, #108	; 0x6c
 8016de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8016de6:	bf00      	nop
 8016de8:	ffff0208 	.word	0xffff0208

08016dec <vsiprintf>:
 8016dec:	4613      	mov	r3, r2
 8016dee:	460a      	mov	r2, r1
 8016df0:	4601      	mov	r1, r0
 8016df2:	4802      	ldr	r0, [pc, #8]	; (8016dfc <vsiprintf+0x10>)
 8016df4:	6800      	ldr	r0, [r0, #0]
 8016df6:	f7ff bfe3 	b.w	8016dc0 <_vsiprintf_r>
 8016dfa:	bf00      	nop
 8016dfc:	20000018 	.word	0x20000018

08016e00 <__swbuf_r>:
 8016e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016e02:	460e      	mov	r6, r1
 8016e04:	4614      	mov	r4, r2
 8016e06:	4605      	mov	r5, r0
 8016e08:	b118      	cbz	r0, 8016e12 <__swbuf_r+0x12>
 8016e0a:	6983      	ldr	r3, [r0, #24]
 8016e0c:	b90b      	cbnz	r3, 8016e12 <__swbuf_r+0x12>
 8016e0e:	f000 fa33 	bl	8017278 <__sinit>
 8016e12:	4b21      	ldr	r3, [pc, #132]	; (8016e98 <__swbuf_r+0x98>)
 8016e14:	429c      	cmp	r4, r3
 8016e16:	d12b      	bne.n	8016e70 <__swbuf_r+0x70>
 8016e18:	686c      	ldr	r4, [r5, #4]
 8016e1a:	69a3      	ldr	r3, [r4, #24]
 8016e1c:	60a3      	str	r3, [r4, #8]
 8016e1e:	89a3      	ldrh	r3, [r4, #12]
 8016e20:	071a      	lsls	r2, r3, #28
 8016e22:	d52f      	bpl.n	8016e84 <__swbuf_r+0x84>
 8016e24:	6923      	ldr	r3, [r4, #16]
 8016e26:	b36b      	cbz	r3, 8016e84 <__swbuf_r+0x84>
 8016e28:	6923      	ldr	r3, [r4, #16]
 8016e2a:	6820      	ldr	r0, [r4, #0]
 8016e2c:	1ac0      	subs	r0, r0, r3
 8016e2e:	6963      	ldr	r3, [r4, #20]
 8016e30:	b2f6      	uxtb	r6, r6
 8016e32:	4283      	cmp	r3, r0
 8016e34:	4637      	mov	r7, r6
 8016e36:	dc04      	bgt.n	8016e42 <__swbuf_r+0x42>
 8016e38:	4621      	mov	r1, r4
 8016e3a:	4628      	mov	r0, r5
 8016e3c:	f000 f988 	bl	8017150 <_fflush_r>
 8016e40:	bb30      	cbnz	r0, 8016e90 <__swbuf_r+0x90>
 8016e42:	68a3      	ldr	r3, [r4, #8]
 8016e44:	3b01      	subs	r3, #1
 8016e46:	60a3      	str	r3, [r4, #8]
 8016e48:	6823      	ldr	r3, [r4, #0]
 8016e4a:	1c5a      	adds	r2, r3, #1
 8016e4c:	6022      	str	r2, [r4, #0]
 8016e4e:	701e      	strb	r6, [r3, #0]
 8016e50:	6963      	ldr	r3, [r4, #20]
 8016e52:	3001      	adds	r0, #1
 8016e54:	4283      	cmp	r3, r0
 8016e56:	d004      	beq.n	8016e62 <__swbuf_r+0x62>
 8016e58:	89a3      	ldrh	r3, [r4, #12]
 8016e5a:	07db      	lsls	r3, r3, #31
 8016e5c:	d506      	bpl.n	8016e6c <__swbuf_r+0x6c>
 8016e5e:	2e0a      	cmp	r6, #10
 8016e60:	d104      	bne.n	8016e6c <__swbuf_r+0x6c>
 8016e62:	4621      	mov	r1, r4
 8016e64:	4628      	mov	r0, r5
 8016e66:	f000 f973 	bl	8017150 <_fflush_r>
 8016e6a:	b988      	cbnz	r0, 8016e90 <__swbuf_r+0x90>
 8016e6c:	4638      	mov	r0, r7
 8016e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8016e70:	4b0a      	ldr	r3, [pc, #40]	; (8016e9c <__swbuf_r+0x9c>)
 8016e72:	429c      	cmp	r4, r3
 8016e74:	d101      	bne.n	8016e7a <__swbuf_r+0x7a>
 8016e76:	68ac      	ldr	r4, [r5, #8]
 8016e78:	e7cf      	b.n	8016e1a <__swbuf_r+0x1a>
 8016e7a:	4b09      	ldr	r3, [pc, #36]	; (8016ea0 <__swbuf_r+0xa0>)
 8016e7c:	429c      	cmp	r4, r3
 8016e7e:	bf08      	it	eq
 8016e80:	68ec      	ldreq	r4, [r5, #12]
 8016e82:	e7ca      	b.n	8016e1a <__swbuf_r+0x1a>
 8016e84:	4621      	mov	r1, r4
 8016e86:	4628      	mov	r0, r5
 8016e88:	f000 f80c 	bl	8016ea4 <__swsetup_r>
 8016e8c:	2800      	cmp	r0, #0
 8016e8e:	d0cb      	beq.n	8016e28 <__swbuf_r+0x28>
 8016e90:	f04f 37ff 	mov.w	r7, #4294967295
 8016e94:	e7ea      	b.n	8016e6c <__swbuf_r+0x6c>
 8016e96:	bf00      	nop
 8016e98:	0801ddf0 	.word	0x0801ddf0
 8016e9c:	0801de10 	.word	0x0801de10
 8016ea0:	0801ddd0 	.word	0x0801ddd0

08016ea4 <__swsetup_r>:
 8016ea4:	4b32      	ldr	r3, [pc, #200]	; (8016f70 <__swsetup_r+0xcc>)
 8016ea6:	b570      	push	{r4, r5, r6, lr}
 8016ea8:	681d      	ldr	r5, [r3, #0]
 8016eaa:	4606      	mov	r6, r0
 8016eac:	460c      	mov	r4, r1
 8016eae:	b125      	cbz	r5, 8016eba <__swsetup_r+0x16>
 8016eb0:	69ab      	ldr	r3, [r5, #24]
 8016eb2:	b913      	cbnz	r3, 8016eba <__swsetup_r+0x16>
 8016eb4:	4628      	mov	r0, r5
 8016eb6:	f000 f9df 	bl	8017278 <__sinit>
 8016eba:	4b2e      	ldr	r3, [pc, #184]	; (8016f74 <__swsetup_r+0xd0>)
 8016ebc:	429c      	cmp	r4, r3
 8016ebe:	d10f      	bne.n	8016ee0 <__swsetup_r+0x3c>
 8016ec0:	686c      	ldr	r4, [r5, #4]
 8016ec2:	89a3      	ldrh	r3, [r4, #12]
 8016ec4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8016ec8:	0719      	lsls	r1, r3, #28
 8016eca:	d42c      	bmi.n	8016f26 <__swsetup_r+0x82>
 8016ecc:	06dd      	lsls	r5, r3, #27
 8016ece:	d411      	bmi.n	8016ef4 <__swsetup_r+0x50>
 8016ed0:	2309      	movs	r3, #9
 8016ed2:	6033      	str	r3, [r6, #0]
 8016ed4:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8016ed8:	81a3      	strh	r3, [r4, #12]
 8016eda:	f04f 30ff 	mov.w	r0, #4294967295
 8016ede:	e03e      	b.n	8016f5e <__swsetup_r+0xba>
 8016ee0:	4b25      	ldr	r3, [pc, #148]	; (8016f78 <__swsetup_r+0xd4>)
 8016ee2:	429c      	cmp	r4, r3
 8016ee4:	d101      	bne.n	8016eea <__swsetup_r+0x46>
 8016ee6:	68ac      	ldr	r4, [r5, #8]
 8016ee8:	e7eb      	b.n	8016ec2 <__swsetup_r+0x1e>
 8016eea:	4b24      	ldr	r3, [pc, #144]	; (8016f7c <__swsetup_r+0xd8>)
 8016eec:	429c      	cmp	r4, r3
 8016eee:	bf08      	it	eq
 8016ef0:	68ec      	ldreq	r4, [r5, #12]
 8016ef2:	e7e6      	b.n	8016ec2 <__swsetup_r+0x1e>
 8016ef4:	0758      	lsls	r0, r3, #29
 8016ef6:	d512      	bpl.n	8016f1e <__swsetup_r+0x7a>
 8016ef8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8016efa:	b141      	cbz	r1, 8016f0e <__swsetup_r+0x6a>
 8016efc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8016f00:	4299      	cmp	r1, r3
 8016f02:	d002      	beq.n	8016f0a <__swsetup_r+0x66>
 8016f04:	4630      	mov	r0, r6
 8016f06:	f7ff fae5 	bl	80164d4 <_free_r>
 8016f0a:	2300      	movs	r3, #0
 8016f0c:	6363      	str	r3, [r4, #52]	; 0x34
 8016f0e:	89a3      	ldrh	r3, [r4, #12]
 8016f10:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8016f14:	81a3      	strh	r3, [r4, #12]
 8016f16:	2300      	movs	r3, #0
 8016f18:	6063      	str	r3, [r4, #4]
 8016f1a:	6923      	ldr	r3, [r4, #16]
 8016f1c:	6023      	str	r3, [r4, #0]
 8016f1e:	89a3      	ldrh	r3, [r4, #12]
 8016f20:	f043 0308 	orr.w	r3, r3, #8
 8016f24:	81a3      	strh	r3, [r4, #12]
 8016f26:	6923      	ldr	r3, [r4, #16]
 8016f28:	b94b      	cbnz	r3, 8016f3e <__swsetup_r+0x9a>
 8016f2a:	89a3      	ldrh	r3, [r4, #12]
 8016f2c:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8016f30:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8016f34:	d003      	beq.n	8016f3e <__swsetup_r+0x9a>
 8016f36:	4621      	mov	r1, r4
 8016f38:	4630      	mov	r0, r6
 8016f3a:	f000 fa63 	bl	8017404 <__smakebuf_r>
 8016f3e:	89a0      	ldrh	r0, [r4, #12]
 8016f40:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8016f44:	f010 0301 	ands.w	r3, r0, #1
 8016f48:	d00a      	beq.n	8016f60 <__swsetup_r+0xbc>
 8016f4a:	2300      	movs	r3, #0
 8016f4c:	60a3      	str	r3, [r4, #8]
 8016f4e:	6963      	ldr	r3, [r4, #20]
 8016f50:	425b      	negs	r3, r3
 8016f52:	61a3      	str	r3, [r4, #24]
 8016f54:	6923      	ldr	r3, [r4, #16]
 8016f56:	b943      	cbnz	r3, 8016f6a <__swsetup_r+0xc6>
 8016f58:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8016f5c:	d1ba      	bne.n	8016ed4 <__swsetup_r+0x30>
 8016f5e:	bd70      	pop	{r4, r5, r6, pc}
 8016f60:	0781      	lsls	r1, r0, #30
 8016f62:	bf58      	it	pl
 8016f64:	6963      	ldrpl	r3, [r4, #20]
 8016f66:	60a3      	str	r3, [r4, #8]
 8016f68:	e7f4      	b.n	8016f54 <__swsetup_r+0xb0>
 8016f6a:	2000      	movs	r0, #0
 8016f6c:	e7f7      	b.n	8016f5e <__swsetup_r+0xba>
 8016f6e:	bf00      	nop
 8016f70:	20000018 	.word	0x20000018
 8016f74:	0801ddf0 	.word	0x0801ddf0
 8016f78:	0801de10 	.word	0x0801de10
 8016f7c:	0801ddd0 	.word	0x0801ddd0

08016f80 <__register_exitproc>:
 8016f80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016f84:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 8017040 <__register_exitproc+0xc0>
 8016f88:	4606      	mov	r6, r0
 8016f8a:	f8d8 0000 	ldr.w	r0, [r8]
 8016f8e:	461f      	mov	r7, r3
 8016f90:	460d      	mov	r5, r1
 8016f92:	4691      	mov	r9, r2
 8016f94:	f000 fa0e 	bl	80173b4 <__retarget_lock_acquire_recursive>
 8016f98:	4b25      	ldr	r3, [pc, #148]	; (8017030 <__register_exitproc+0xb0>)
 8016f9a:	681c      	ldr	r4, [r3, #0]
 8016f9c:	b934      	cbnz	r4, 8016fac <__register_exitproc+0x2c>
 8016f9e:	4c25      	ldr	r4, [pc, #148]	; (8017034 <__register_exitproc+0xb4>)
 8016fa0:	601c      	str	r4, [r3, #0]
 8016fa2:	4b25      	ldr	r3, [pc, #148]	; (8017038 <__register_exitproc+0xb8>)
 8016fa4:	b113      	cbz	r3, 8016fac <__register_exitproc+0x2c>
 8016fa6:	681b      	ldr	r3, [r3, #0]
 8016fa8:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 8016fac:	6863      	ldr	r3, [r4, #4]
 8016fae:	2b1f      	cmp	r3, #31
 8016fb0:	dd07      	ble.n	8016fc2 <__register_exitproc+0x42>
 8016fb2:	f8d8 0000 	ldr.w	r0, [r8]
 8016fb6:	f000 f9ff 	bl	80173b8 <__retarget_lock_release_recursive>
 8016fba:	f04f 30ff 	mov.w	r0, #4294967295
 8016fbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016fc2:	b34e      	cbz	r6, 8017018 <__register_exitproc+0x98>
 8016fc4:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8016fc8:	b988      	cbnz	r0, 8016fee <__register_exitproc+0x6e>
 8016fca:	4b1c      	ldr	r3, [pc, #112]	; (801703c <__register_exitproc+0xbc>)
 8016fcc:	b923      	cbnz	r3, 8016fd8 <__register_exitproc+0x58>
 8016fce:	f8d8 0000 	ldr.w	r0, [r8]
 8016fd2:	f000 f9f0 	bl	80173b6 <__retarget_lock_release>
 8016fd6:	e7f0      	b.n	8016fba <__register_exitproc+0x3a>
 8016fd8:	f44f 7084 	mov.w	r0, #264	; 0x108
 8016fdc:	f7ff fa3a 	bl	8016454 <malloc>
 8016fe0:	2800      	cmp	r0, #0
 8016fe2:	d0f4      	beq.n	8016fce <__register_exitproc+0x4e>
 8016fe4:	2300      	movs	r3, #0
 8016fe6:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
 8016fea:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 8016fee:	6863      	ldr	r3, [r4, #4]
 8016ff0:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
 8016ff4:	2201      	movs	r2, #1
 8016ff6:	409a      	lsls	r2, r3
 8016ff8:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 8016ffc:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
 8017000:	4313      	orrs	r3, r2
 8017002:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 8017006:	2e02      	cmp	r6, #2
 8017008:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
 801700c:	bf02      	ittt	eq
 801700e:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
 8017012:	4313      	orreq	r3, r2
 8017014:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
 8017018:	6863      	ldr	r3, [r4, #4]
 801701a:	f8d8 0000 	ldr.w	r0, [r8]
 801701e:	1c5a      	adds	r2, r3, #1
 8017020:	3302      	adds	r3, #2
 8017022:	6062      	str	r2, [r4, #4]
 8017024:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
 8017028:	f000 f9c6 	bl	80173b8 <__retarget_lock_release_recursive>
 801702c:	2000      	movs	r0, #0
 801702e:	e7c6      	b.n	8016fbe <__register_exitproc+0x3e>
 8017030:	20001ef8 	.word	0x20001ef8
 8017034:	20001e6c 	.word	0x20001e6c
 8017038:	00000000 	.word	0x00000000
 801703c:	08016455 	.word	0x08016455
 8017040:	2000007c 	.word	0x2000007c

08017044 <__sflush_r>:
 8017044:	898a      	ldrh	r2, [r1, #12]
 8017046:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801704a:	4605      	mov	r5, r0
 801704c:	0710      	lsls	r0, r2, #28
 801704e:	460c      	mov	r4, r1
 8017050:	d458      	bmi.n	8017104 <__sflush_r+0xc0>
 8017052:	684b      	ldr	r3, [r1, #4]
 8017054:	2b00      	cmp	r3, #0
 8017056:	dc05      	bgt.n	8017064 <__sflush_r+0x20>
 8017058:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 801705a:	2b00      	cmp	r3, #0
 801705c:	dc02      	bgt.n	8017064 <__sflush_r+0x20>
 801705e:	2000      	movs	r0, #0
 8017060:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017064:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8017066:	2e00      	cmp	r6, #0
 8017068:	d0f9      	beq.n	801705e <__sflush_r+0x1a>
 801706a:	2300      	movs	r3, #0
 801706c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8017070:	682f      	ldr	r7, [r5, #0]
 8017072:	602b      	str	r3, [r5, #0]
 8017074:	d032      	beq.n	80170dc <__sflush_r+0x98>
 8017076:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8017078:	89a3      	ldrh	r3, [r4, #12]
 801707a:	075a      	lsls	r2, r3, #29
 801707c:	d505      	bpl.n	801708a <__sflush_r+0x46>
 801707e:	6863      	ldr	r3, [r4, #4]
 8017080:	1ac0      	subs	r0, r0, r3
 8017082:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8017084:	b10b      	cbz	r3, 801708a <__sflush_r+0x46>
 8017086:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8017088:	1ac0      	subs	r0, r0, r3
 801708a:	2300      	movs	r3, #0
 801708c:	4602      	mov	r2, r0
 801708e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8017090:	6a21      	ldr	r1, [r4, #32]
 8017092:	4628      	mov	r0, r5
 8017094:	47b0      	blx	r6
 8017096:	1c43      	adds	r3, r0, #1
 8017098:	89a3      	ldrh	r3, [r4, #12]
 801709a:	d106      	bne.n	80170aa <__sflush_r+0x66>
 801709c:	6829      	ldr	r1, [r5, #0]
 801709e:	291d      	cmp	r1, #29
 80170a0:	d82c      	bhi.n	80170fc <__sflush_r+0xb8>
 80170a2:	4a2a      	ldr	r2, [pc, #168]	; (801714c <__sflush_r+0x108>)
 80170a4:	40ca      	lsrs	r2, r1
 80170a6:	07d6      	lsls	r6, r2, #31
 80170a8:	d528      	bpl.n	80170fc <__sflush_r+0xb8>
 80170aa:	2200      	movs	r2, #0
 80170ac:	6062      	str	r2, [r4, #4]
 80170ae:	04d9      	lsls	r1, r3, #19
 80170b0:	6922      	ldr	r2, [r4, #16]
 80170b2:	6022      	str	r2, [r4, #0]
 80170b4:	d504      	bpl.n	80170c0 <__sflush_r+0x7c>
 80170b6:	1c42      	adds	r2, r0, #1
 80170b8:	d101      	bne.n	80170be <__sflush_r+0x7a>
 80170ba:	682b      	ldr	r3, [r5, #0]
 80170bc:	b903      	cbnz	r3, 80170c0 <__sflush_r+0x7c>
 80170be:	6560      	str	r0, [r4, #84]	; 0x54
 80170c0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80170c2:	602f      	str	r7, [r5, #0]
 80170c4:	2900      	cmp	r1, #0
 80170c6:	d0ca      	beq.n	801705e <__sflush_r+0x1a>
 80170c8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80170cc:	4299      	cmp	r1, r3
 80170ce:	d002      	beq.n	80170d6 <__sflush_r+0x92>
 80170d0:	4628      	mov	r0, r5
 80170d2:	f7ff f9ff 	bl	80164d4 <_free_r>
 80170d6:	2000      	movs	r0, #0
 80170d8:	6360      	str	r0, [r4, #52]	; 0x34
 80170da:	e7c1      	b.n	8017060 <__sflush_r+0x1c>
 80170dc:	6a21      	ldr	r1, [r4, #32]
 80170de:	2301      	movs	r3, #1
 80170e0:	4628      	mov	r0, r5
 80170e2:	47b0      	blx	r6
 80170e4:	1c41      	adds	r1, r0, #1
 80170e6:	d1c7      	bne.n	8017078 <__sflush_r+0x34>
 80170e8:	682b      	ldr	r3, [r5, #0]
 80170ea:	2b00      	cmp	r3, #0
 80170ec:	d0c4      	beq.n	8017078 <__sflush_r+0x34>
 80170ee:	2b1d      	cmp	r3, #29
 80170f0:	d001      	beq.n	80170f6 <__sflush_r+0xb2>
 80170f2:	2b16      	cmp	r3, #22
 80170f4:	d101      	bne.n	80170fa <__sflush_r+0xb6>
 80170f6:	602f      	str	r7, [r5, #0]
 80170f8:	e7b1      	b.n	801705e <__sflush_r+0x1a>
 80170fa:	89a3      	ldrh	r3, [r4, #12]
 80170fc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8017100:	81a3      	strh	r3, [r4, #12]
 8017102:	e7ad      	b.n	8017060 <__sflush_r+0x1c>
 8017104:	690f      	ldr	r7, [r1, #16]
 8017106:	2f00      	cmp	r7, #0
 8017108:	d0a9      	beq.n	801705e <__sflush_r+0x1a>
 801710a:	0793      	lsls	r3, r2, #30
 801710c:	680e      	ldr	r6, [r1, #0]
 801710e:	bf08      	it	eq
 8017110:	694b      	ldreq	r3, [r1, #20]
 8017112:	600f      	str	r7, [r1, #0]
 8017114:	bf18      	it	ne
 8017116:	2300      	movne	r3, #0
 8017118:	eba6 0807 	sub.w	r8, r6, r7
 801711c:	608b      	str	r3, [r1, #8]
 801711e:	f1b8 0f00 	cmp.w	r8, #0
 8017122:	dd9c      	ble.n	801705e <__sflush_r+0x1a>
 8017124:	6a21      	ldr	r1, [r4, #32]
 8017126:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8017128:	4643      	mov	r3, r8
 801712a:	463a      	mov	r2, r7
 801712c:	4628      	mov	r0, r5
 801712e:	47b0      	blx	r6
 8017130:	2800      	cmp	r0, #0
 8017132:	dc06      	bgt.n	8017142 <__sflush_r+0xfe>
 8017134:	89a3      	ldrh	r3, [r4, #12]
 8017136:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801713a:	81a3      	strh	r3, [r4, #12]
 801713c:	f04f 30ff 	mov.w	r0, #4294967295
 8017140:	e78e      	b.n	8017060 <__sflush_r+0x1c>
 8017142:	4407      	add	r7, r0
 8017144:	eba8 0800 	sub.w	r8, r8, r0
 8017148:	e7e9      	b.n	801711e <__sflush_r+0xda>
 801714a:	bf00      	nop
 801714c:	20400001 	.word	0x20400001

08017150 <_fflush_r>:
 8017150:	b538      	push	{r3, r4, r5, lr}
 8017152:	690b      	ldr	r3, [r1, #16]
 8017154:	4605      	mov	r5, r0
 8017156:	460c      	mov	r4, r1
 8017158:	b913      	cbnz	r3, 8017160 <_fflush_r+0x10>
 801715a:	2500      	movs	r5, #0
 801715c:	4628      	mov	r0, r5
 801715e:	bd38      	pop	{r3, r4, r5, pc}
 8017160:	b118      	cbz	r0, 801716a <_fflush_r+0x1a>
 8017162:	6983      	ldr	r3, [r0, #24]
 8017164:	b90b      	cbnz	r3, 801716a <_fflush_r+0x1a>
 8017166:	f000 f887 	bl	8017278 <__sinit>
 801716a:	4b14      	ldr	r3, [pc, #80]	; (80171bc <_fflush_r+0x6c>)
 801716c:	429c      	cmp	r4, r3
 801716e:	d11b      	bne.n	80171a8 <_fflush_r+0x58>
 8017170:	686c      	ldr	r4, [r5, #4]
 8017172:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8017176:	2b00      	cmp	r3, #0
 8017178:	d0ef      	beq.n	801715a <_fflush_r+0xa>
 801717a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 801717c:	07d0      	lsls	r0, r2, #31
 801717e:	d404      	bmi.n	801718a <_fflush_r+0x3a>
 8017180:	0599      	lsls	r1, r3, #22
 8017182:	d402      	bmi.n	801718a <_fflush_r+0x3a>
 8017184:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8017186:	f000 f915 	bl	80173b4 <__retarget_lock_acquire_recursive>
 801718a:	4628      	mov	r0, r5
 801718c:	4621      	mov	r1, r4
 801718e:	f7ff ff59 	bl	8017044 <__sflush_r>
 8017192:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8017194:	07da      	lsls	r2, r3, #31
 8017196:	4605      	mov	r5, r0
 8017198:	d4e0      	bmi.n	801715c <_fflush_r+0xc>
 801719a:	89a3      	ldrh	r3, [r4, #12]
 801719c:	059b      	lsls	r3, r3, #22
 801719e:	d4dd      	bmi.n	801715c <_fflush_r+0xc>
 80171a0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80171a2:	f000 f909 	bl	80173b8 <__retarget_lock_release_recursive>
 80171a6:	e7d9      	b.n	801715c <_fflush_r+0xc>
 80171a8:	4b05      	ldr	r3, [pc, #20]	; (80171c0 <_fflush_r+0x70>)
 80171aa:	429c      	cmp	r4, r3
 80171ac:	d101      	bne.n	80171b2 <_fflush_r+0x62>
 80171ae:	68ac      	ldr	r4, [r5, #8]
 80171b0:	e7df      	b.n	8017172 <_fflush_r+0x22>
 80171b2:	4b04      	ldr	r3, [pc, #16]	; (80171c4 <_fflush_r+0x74>)
 80171b4:	429c      	cmp	r4, r3
 80171b6:	bf08      	it	eq
 80171b8:	68ec      	ldreq	r4, [r5, #12]
 80171ba:	e7da      	b.n	8017172 <_fflush_r+0x22>
 80171bc:	0801ddf0 	.word	0x0801ddf0
 80171c0:	0801de10 	.word	0x0801de10
 80171c4:	0801ddd0 	.word	0x0801ddd0

080171c8 <std>:
 80171c8:	2300      	movs	r3, #0
 80171ca:	b510      	push	{r4, lr}
 80171cc:	4604      	mov	r4, r0
 80171ce:	e9c0 3300 	strd	r3, r3, [r0]
 80171d2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80171d6:	6083      	str	r3, [r0, #8]
 80171d8:	8181      	strh	r1, [r0, #12]
 80171da:	6643      	str	r3, [r0, #100]	; 0x64
 80171dc:	81c2      	strh	r2, [r0, #14]
 80171de:	6183      	str	r3, [r0, #24]
 80171e0:	4619      	mov	r1, r3
 80171e2:	2208      	movs	r2, #8
 80171e4:	305c      	adds	r0, #92	; 0x5c
 80171e6:	f7ff f96d 	bl	80164c4 <memset>
 80171ea:	4b05      	ldr	r3, [pc, #20]	; (8017200 <std+0x38>)
 80171ec:	6263      	str	r3, [r4, #36]	; 0x24
 80171ee:	4b05      	ldr	r3, [pc, #20]	; (8017204 <std+0x3c>)
 80171f0:	62a3      	str	r3, [r4, #40]	; 0x28
 80171f2:	4b05      	ldr	r3, [pc, #20]	; (8017208 <std+0x40>)
 80171f4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80171f6:	4b05      	ldr	r3, [pc, #20]	; (801720c <std+0x44>)
 80171f8:	6224      	str	r4, [r4, #32]
 80171fa:	6323      	str	r3, [r4, #48]	; 0x30
 80171fc:	bd10      	pop	{r4, pc}
 80171fe:	bf00      	nop
 8017200:	080177b1 	.word	0x080177b1
 8017204:	080177d3 	.word	0x080177d3
 8017208:	0801780b 	.word	0x0801780b
 801720c:	0801782f 	.word	0x0801782f

08017210 <_cleanup_r>:
 8017210:	4901      	ldr	r1, [pc, #4]	; (8017218 <_cleanup_r+0x8>)
 8017212:	f000 b8af 	b.w	8017374 <_fwalk_reent>
 8017216:	bf00      	nop
 8017218:	08017151 	.word	0x08017151

0801721c <__sfmoreglue>:
 801721c:	b570      	push	{r4, r5, r6, lr}
 801721e:	2268      	movs	r2, #104	; 0x68
 8017220:	1e4d      	subs	r5, r1, #1
 8017222:	4355      	muls	r5, r2
 8017224:	460e      	mov	r6, r1
 8017226:	f105 0174 	add.w	r1, r5, #116	; 0x74
 801722a:	f7ff f9bf 	bl	80165ac <_malloc_r>
 801722e:	4604      	mov	r4, r0
 8017230:	b140      	cbz	r0, 8017244 <__sfmoreglue+0x28>
 8017232:	2100      	movs	r1, #0
 8017234:	e9c0 1600 	strd	r1, r6, [r0]
 8017238:	300c      	adds	r0, #12
 801723a:	60a0      	str	r0, [r4, #8]
 801723c:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8017240:	f7ff f940 	bl	80164c4 <memset>
 8017244:	4620      	mov	r0, r4
 8017246:	bd70      	pop	{r4, r5, r6, pc}

08017248 <__sfp_lock_acquire>:
 8017248:	4801      	ldr	r0, [pc, #4]	; (8017250 <__sfp_lock_acquire+0x8>)
 801724a:	f000 b8b3 	b.w	80173b4 <__retarget_lock_acquire_recursive>
 801724e:	bf00      	nop
 8017250:	20001efe 	.word	0x20001efe

08017254 <__sfp_lock_release>:
 8017254:	4801      	ldr	r0, [pc, #4]	; (801725c <__sfp_lock_release+0x8>)
 8017256:	f000 b8af 	b.w	80173b8 <__retarget_lock_release_recursive>
 801725a:	bf00      	nop
 801725c:	20001efe 	.word	0x20001efe

08017260 <__sinit_lock_acquire>:
 8017260:	4801      	ldr	r0, [pc, #4]	; (8017268 <__sinit_lock_acquire+0x8>)
 8017262:	f000 b8a7 	b.w	80173b4 <__retarget_lock_acquire_recursive>
 8017266:	bf00      	nop
 8017268:	20001eff 	.word	0x20001eff

0801726c <__sinit_lock_release>:
 801726c:	4801      	ldr	r0, [pc, #4]	; (8017274 <__sinit_lock_release+0x8>)
 801726e:	f000 b8a3 	b.w	80173b8 <__retarget_lock_release_recursive>
 8017272:	bf00      	nop
 8017274:	20001eff 	.word	0x20001eff

08017278 <__sinit>:
 8017278:	b510      	push	{r4, lr}
 801727a:	4604      	mov	r4, r0
 801727c:	f7ff fff0 	bl	8017260 <__sinit_lock_acquire>
 8017280:	69a3      	ldr	r3, [r4, #24]
 8017282:	b11b      	cbz	r3, 801728c <__sinit+0x14>
 8017284:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8017288:	f7ff bff0 	b.w	801726c <__sinit_lock_release>
 801728c:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8017290:	6523      	str	r3, [r4, #80]	; 0x50
 8017292:	4b13      	ldr	r3, [pc, #76]	; (80172e0 <__sinit+0x68>)
 8017294:	4a13      	ldr	r2, [pc, #76]	; (80172e4 <__sinit+0x6c>)
 8017296:	681b      	ldr	r3, [r3, #0]
 8017298:	62a2      	str	r2, [r4, #40]	; 0x28
 801729a:	42a3      	cmp	r3, r4
 801729c:	bf04      	itt	eq
 801729e:	2301      	moveq	r3, #1
 80172a0:	61a3      	streq	r3, [r4, #24]
 80172a2:	4620      	mov	r0, r4
 80172a4:	f000 f820 	bl	80172e8 <__sfp>
 80172a8:	6060      	str	r0, [r4, #4]
 80172aa:	4620      	mov	r0, r4
 80172ac:	f000 f81c 	bl	80172e8 <__sfp>
 80172b0:	60a0      	str	r0, [r4, #8]
 80172b2:	4620      	mov	r0, r4
 80172b4:	f000 f818 	bl	80172e8 <__sfp>
 80172b8:	2200      	movs	r2, #0
 80172ba:	60e0      	str	r0, [r4, #12]
 80172bc:	2104      	movs	r1, #4
 80172be:	6860      	ldr	r0, [r4, #4]
 80172c0:	f7ff ff82 	bl	80171c8 <std>
 80172c4:	68a0      	ldr	r0, [r4, #8]
 80172c6:	2201      	movs	r2, #1
 80172c8:	2109      	movs	r1, #9
 80172ca:	f7ff ff7d 	bl	80171c8 <std>
 80172ce:	68e0      	ldr	r0, [r4, #12]
 80172d0:	2202      	movs	r2, #2
 80172d2:	2112      	movs	r1, #18
 80172d4:	f7ff ff78 	bl	80171c8 <std>
 80172d8:	2301      	movs	r3, #1
 80172da:	61a3      	str	r3, [r4, #24]
 80172dc:	e7d2      	b.n	8017284 <__sinit+0xc>
 80172de:	bf00      	nop
 80172e0:	0801dd98 	.word	0x0801dd98
 80172e4:	08017211 	.word	0x08017211

080172e8 <__sfp>:
 80172e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80172ea:	4607      	mov	r7, r0
 80172ec:	f7ff ffac 	bl	8017248 <__sfp_lock_acquire>
 80172f0:	4b1e      	ldr	r3, [pc, #120]	; (801736c <__sfp+0x84>)
 80172f2:	681e      	ldr	r6, [r3, #0]
 80172f4:	69b3      	ldr	r3, [r6, #24]
 80172f6:	b913      	cbnz	r3, 80172fe <__sfp+0x16>
 80172f8:	4630      	mov	r0, r6
 80172fa:	f7ff ffbd 	bl	8017278 <__sinit>
 80172fe:	3648      	adds	r6, #72	; 0x48
 8017300:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8017304:	3b01      	subs	r3, #1
 8017306:	d503      	bpl.n	8017310 <__sfp+0x28>
 8017308:	6833      	ldr	r3, [r6, #0]
 801730a:	b30b      	cbz	r3, 8017350 <__sfp+0x68>
 801730c:	6836      	ldr	r6, [r6, #0]
 801730e:	e7f7      	b.n	8017300 <__sfp+0x18>
 8017310:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8017314:	b9d5      	cbnz	r5, 801734c <__sfp+0x64>
 8017316:	4b16      	ldr	r3, [pc, #88]	; (8017370 <__sfp+0x88>)
 8017318:	60e3      	str	r3, [r4, #12]
 801731a:	f104 0058 	add.w	r0, r4, #88	; 0x58
 801731e:	6665      	str	r5, [r4, #100]	; 0x64
 8017320:	f000 f847 	bl	80173b2 <__retarget_lock_init_recursive>
 8017324:	f7ff ff96 	bl	8017254 <__sfp_lock_release>
 8017328:	e9c4 5501 	strd	r5, r5, [r4, #4]
 801732c:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8017330:	6025      	str	r5, [r4, #0]
 8017332:	61a5      	str	r5, [r4, #24]
 8017334:	2208      	movs	r2, #8
 8017336:	4629      	mov	r1, r5
 8017338:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 801733c:	f7ff f8c2 	bl	80164c4 <memset>
 8017340:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8017344:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8017348:	4620      	mov	r0, r4
 801734a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801734c:	3468      	adds	r4, #104	; 0x68
 801734e:	e7d9      	b.n	8017304 <__sfp+0x1c>
 8017350:	2104      	movs	r1, #4
 8017352:	4638      	mov	r0, r7
 8017354:	f7ff ff62 	bl	801721c <__sfmoreglue>
 8017358:	4604      	mov	r4, r0
 801735a:	6030      	str	r0, [r6, #0]
 801735c:	2800      	cmp	r0, #0
 801735e:	d1d5      	bne.n	801730c <__sfp+0x24>
 8017360:	f7ff ff78 	bl	8017254 <__sfp_lock_release>
 8017364:	230c      	movs	r3, #12
 8017366:	603b      	str	r3, [r7, #0]
 8017368:	e7ee      	b.n	8017348 <__sfp+0x60>
 801736a:	bf00      	nop
 801736c:	0801dd98 	.word	0x0801dd98
 8017370:	ffff0001 	.word	0xffff0001

08017374 <_fwalk_reent>:
 8017374:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8017378:	4606      	mov	r6, r0
 801737a:	4688      	mov	r8, r1
 801737c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8017380:	2700      	movs	r7, #0
 8017382:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8017386:	f1b9 0901 	subs.w	r9, r9, #1
 801738a:	d505      	bpl.n	8017398 <_fwalk_reent+0x24>
 801738c:	6824      	ldr	r4, [r4, #0]
 801738e:	2c00      	cmp	r4, #0
 8017390:	d1f7      	bne.n	8017382 <_fwalk_reent+0xe>
 8017392:	4638      	mov	r0, r7
 8017394:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8017398:	89ab      	ldrh	r3, [r5, #12]
 801739a:	2b01      	cmp	r3, #1
 801739c:	d907      	bls.n	80173ae <_fwalk_reent+0x3a>
 801739e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80173a2:	3301      	adds	r3, #1
 80173a4:	d003      	beq.n	80173ae <_fwalk_reent+0x3a>
 80173a6:	4629      	mov	r1, r5
 80173a8:	4630      	mov	r0, r6
 80173aa:	47c0      	blx	r8
 80173ac:	4307      	orrs	r7, r0
 80173ae:	3568      	adds	r5, #104	; 0x68
 80173b0:	e7e9      	b.n	8017386 <_fwalk_reent+0x12>

080173b2 <__retarget_lock_init_recursive>:
 80173b2:	4770      	bx	lr

080173b4 <__retarget_lock_acquire_recursive>:
 80173b4:	4770      	bx	lr

080173b6 <__retarget_lock_release>:
 80173b6:	4770      	bx	lr

080173b8 <__retarget_lock_release_recursive>:
 80173b8:	4770      	bx	lr

080173ba <__swhatbuf_r>:
 80173ba:	b570      	push	{r4, r5, r6, lr}
 80173bc:	460e      	mov	r6, r1
 80173be:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80173c2:	2900      	cmp	r1, #0
 80173c4:	b096      	sub	sp, #88	; 0x58
 80173c6:	4614      	mov	r4, r2
 80173c8:	461d      	mov	r5, r3
 80173ca:	da08      	bge.n	80173de <__swhatbuf_r+0x24>
 80173cc:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 80173d0:	2200      	movs	r2, #0
 80173d2:	602a      	str	r2, [r5, #0]
 80173d4:	061a      	lsls	r2, r3, #24
 80173d6:	d410      	bmi.n	80173fa <__swhatbuf_r+0x40>
 80173d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80173dc:	e00e      	b.n	80173fc <__swhatbuf_r+0x42>
 80173de:	466a      	mov	r2, sp
 80173e0:	f000 fa4c 	bl	801787c <_fstat_r>
 80173e4:	2800      	cmp	r0, #0
 80173e6:	dbf1      	blt.n	80173cc <__swhatbuf_r+0x12>
 80173e8:	9a01      	ldr	r2, [sp, #4]
 80173ea:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80173ee:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80173f2:	425a      	negs	r2, r3
 80173f4:	415a      	adcs	r2, r3
 80173f6:	602a      	str	r2, [r5, #0]
 80173f8:	e7ee      	b.n	80173d8 <__swhatbuf_r+0x1e>
 80173fa:	2340      	movs	r3, #64	; 0x40
 80173fc:	2000      	movs	r0, #0
 80173fe:	6023      	str	r3, [r4, #0]
 8017400:	b016      	add	sp, #88	; 0x58
 8017402:	bd70      	pop	{r4, r5, r6, pc}

08017404 <__smakebuf_r>:
 8017404:	898b      	ldrh	r3, [r1, #12]
 8017406:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8017408:	079d      	lsls	r5, r3, #30
 801740a:	4606      	mov	r6, r0
 801740c:	460c      	mov	r4, r1
 801740e:	d507      	bpl.n	8017420 <__smakebuf_r+0x1c>
 8017410:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8017414:	6023      	str	r3, [r4, #0]
 8017416:	6123      	str	r3, [r4, #16]
 8017418:	2301      	movs	r3, #1
 801741a:	6163      	str	r3, [r4, #20]
 801741c:	b002      	add	sp, #8
 801741e:	bd70      	pop	{r4, r5, r6, pc}
 8017420:	ab01      	add	r3, sp, #4
 8017422:	466a      	mov	r2, sp
 8017424:	f7ff ffc9 	bl	80173ba <__swhatbuf_r>
 8017428:	9900      	ldr	r1, [sp, #0]
 801742a:	4605      	mov	r5, r0
 801742c:	4630      	mov	r0, r6
 801742e:	f7ff f8bd 	bl	80165ac <_malloc_r>
 8017432:	b948      	cbnz	r0, 8017448 <__smakebuf_r+0x44>
 8017434:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8017438:	059a      	lsls	r2, r3, #22
 801743a:	d4ef      	bmi.n	801741c <__smakebuf_r+0x18>
 801743c:	f023 0303 	bic.w	r3, r3, #3
 8017440:	f043 0302 	orr.w	r3, r3, #2
 8017444:	81a3      	strh	r3, [r4, #12]
 8017446:	e7e3      	b.n	8017410 <__smakebuf_r+0xc>
 8017448:	4b0d      	ldr	r3, [pc, #52]	; (8017480 <__smakebuf_r+0x7c>)
 801744a:	62b3      	str	r3, [r6, #40]	; 0x28
 801744c:	89a3      	ldrh	r3, [r4, #12]
 801744e:	6020      	str	r0, [r4, #0]
 8017450:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8017454:	81a3      	strh	r3, [r4, #12]
 8017456:	9b00      	ldr	r3, [sp, #0]
 8017458:	6163      	str	r3, [r4, #20]
 801745a:	9b01      	ldr	r3, [sp, #4]
 801745c:	6120      	str	r0, [r4, #16]
 801745e:	b15b      	cbz	r3, 8017478 <__smakebuf_r+0x74>
 8017460:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8017464:	4630      	mov	r0, r6
 8017466:	f000 fa1b 	bl	80178a0 <_isatty_r>
 801746a:	b128      	cbz	r0, 8017478 <__smakebuf_r+0x74>
 801746c:	89a3      	ldrh	r3, [r4, #12]
 801746e:	f023 0303 	bic.w	r3, r3, #3
 8017472:	f043 0301 	orr.w	r3, r3, #1
 8017476:	81a3      	strh	r3, [r4, #12]
 8017478:	89a0      	ldrh	r0, [r4, #12]
 801747a:	4305      	orrs	r5, r0
 801747c:	81a5      	strh	r5, [r4, #12]
 801747e:	e7cd      	b.n	801741c <__smakebuf_r+0x18>
 8017480:	08017211 	.word	0x08017211

08017484 <__malloc_lock>:
 8017484:	4801      	ldr	r0, [pc, #4]	; (801748c <__malloc_lock+0x8>)
 8017486:	f7ff bf95 	b.w	80173b4 <__retarget_lock_acquire_recursive>
 801748a:	bf00      	nop
 801748c:	20001efd 	.word	0x20001efd

08017490 <__malloc_unlock>:
 8017490:	4801      	ldr	r0, [pc, #4]	; (8017498 <__malloc_unlock+0x8>)
 8017492:	f7ff bf91 	b.w	80173b8 <__retarget_lock_release_recursive>
 8017496:	bf00      	nop
 8017498:	20001efd 	.word	0x20001efd

0801749c <_realloc_r>:
 801749c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80174a0:	4680      	mov	r8, r0
 80174a2:	4614      	mov	r4, r2
 80174a4:	460e      	mov	r6, r1
 80174a6:	b921      	cbnz	r1, 80174b2 <_realloc_r+0x16>
 80174a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80174ac:	4611      	mov	r1, r2
 80174ae:	f7ff b87d 	b.w	80165ac <_malloc_r>
 80174b2:	b92a      	cbnz	r2, 80174c0 <_realloc_r+0x24>
 80174b4:	f7ff f80e 	bl	80164d4 <_free_r>
 80174b8:	4625      	mov	r5, r4
 80174ba:	4628      	mov	r0, r5
 80174bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80174c0:	f000 fa10 	bl	80178e4 <_malloc_usable_size_r>
 80174c4:	4284      	cmp	r4, r0
 80174c6:	4607      	mov	r7, r0
 80174c8:	d802      	bhi.n	80174d0 <_realloc_r+0x34>
 80174ca:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80174ce:	d812      	bhi.n	80174f6 <_realloc_r+0x5a>
 80174d0:	4621      	mov	r1, r4
 80174d2:	4640      	mov	r0, r8
 80174d4:	f7ff f86a 	bl	80165ac <_malloc_r>
 80174d8:	4605      	mov	r5, r0
 80174da:	2800      	cmp	r0, #0
 80174dc:	d0ed      	beq.n	80174ba <_realloc_r+0x1e>
 80174de:	42bc      	cmp	r4, r7
 80174e0:	4622      	mov	r2, r4
 80174e2:	4631      	mov	r1, r6
 80174e4:	bf28      	it	cs
 80174e6:	463a      	movcs	r2, r7
 80174e8:	f7fe ffc4 	bl	8016474 <memcpy>
 80174ec:	4631      	mov	r1, r6
 80174ee:	4640      	mov	r0, r8
 80174f0:	f7fe fff0 	bl	80164d4 <_free_r>
 80174f4:	e7e1      	b.n	80174ba <_realloc_r+0x1e>
 80174f6:	4635      	mov	r5, r6
 80174f8:	e7df      	b.n	80174ba <_realloc_r+0x1e>

080174fa <__ssputs_r>:
 80174fa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80174fe:	688e      	ldr	r6, [r1, #8]
 8017500:	429e      	cmp	r6, r3
 8017502:	4682      	mov	sl, r0
 8017504:	460c      	mov	r4, r1
 8017506:	4690      	mov	r8, r2
 8017508:	461f      	mov	r7, r3
 801750a:	d838      	bhi.n	801757e <__ssputs_r+0x84>
 801750c:	898a      	ldrh	r2, [r1, #12]
 801750e:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8017512:	d032      	beq.n	801757a <__ssputs_r+0x80>
 8017514:	6825      	ldr	r5, [r4, #0]
 8017516:	6909      	ldr	r1, [r1, #16]
 8017518:	eba5 0901 	sub.w	r9, r5, r1
 801751c:	6965      	ldr	r5, [r4, #20]
 801751e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8017522:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8017526:	3301      	adds	r3, #1
 8017528:	444b      	add	r3, r9
 801752a:	106d      	asrs	r5, r5, #1
 801752c:	429d      	cmp	r5, r3
 801752e:	bf38      	it	cc
 8017530:	461d      	movcc	r5, r3
 8017532:	0553      	lsls	r3, r2, #21
 8017534:	d531      	bpl.n	801759a <__ssputs_r+0xa0>
 8017536:	4629      	mov	r1, r5
 8017538:	f7ff f838 	bl	80165ac <_malloc_r>
 801753c:	4606      	mov	r6, r0
 801753e:	b950      	cbnz	r0, 8017556 <__ssputs_r+0x5c>
 8017540:	230c      	movs	r3, #12
 8017542:	f8ca 3000 	str.w	r3, [sl]
 8017546:	89a3      	ldrh	r3, [r4, #12]
 8017548:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801754c:	81a3      	strh	r3, [r4, #12]
 801754e:	f04f 30ff 	mov.w	r0, #4294967295
 8017552:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8017556:	6921      	ldr	r1, [r4, #16]
 8017558:	464a      	mov	r2, r9
 801755a:	f7fe ff8b 	bl	8016474 <memcpy>
 801755e:	89a3      	ldrh	r3, [r4, #12]
 8017560:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8017564:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8017568:	81a3      	strh	r3, [r4, #12]
 801756a:	6126      	str	r6, [r4, #16]
 801756c:	6165      	str	r5, [r4, #20]
 801756e:	444e      	add	r6, r9
 8017570:	eba5 0509 	sub.w	r5, r5, r9
 8017574:	6026      	str	r6, [r4, #0]
 8017576:	60a5      	str	r5, [r4, #8]
 8017578:	463e      	mov	r6, r7
 801757a:	42be      	cmp	r6, r7
 801757c:	d900      	bls.n	8017580 <__ssputs_r+0x86>
 801757e:	463e      	mov	r6, r7
 8017580:	6820      	ldr	r0, [r4, #0]
 8017582:	4632      	mov	r2, r6
 8017584:	4641      	mov	r1, r8
 8017586:	f7fe ff83 	bl	8016490 <memmove>
 801758a:	68a3      	ldr	r3, [r4, #8]
 801758c:	1b9b      	subs	r3, r3, r6
 801758e:	60a3      	str	r3, [r4, #8]
 8017590:	6823      	ldr	r3, [r4, #0]
 8017592:	4433      	add	r3, r6
 8017594:	6023      	str	r3, [r4, #0]
 8017596:	2000      	movs	r0, #0
 8017598:	e7db      	b.n	8017552 <__ssputs_r+0x58>
 801759a:	462a      	mov	r2, r5
 801759c:	f7ff ff7e 	bl	801749c <_realloc_r>
 80175a0:	4606      	mov	r6, r0
 80175a2:	2800      	cmp	r0, #0
 80175a4:	d1e1      	bne.n	801756a <__ssputs_r+0x70>
 80175a6:	6921      	ldr	r1, [r4, #16]
 80175a8:	4650      	mov	r0, sl
 80175aa:	f7fe ff93 	bl	80164d4 <_free_r>
 80175ae:	e7c7      	b.n	8017540 <__ssputs_r+0x46>

080175b0 <_svfiprintf_r>:
 80175b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80175b4:	4698      	mov	r8, r3
 80175b6:	898b      	ldrh	r3, [r1, #12]
 80175b8:	061b      	lsls	r3, r3, #24
 80175ba:	b09d      	sub	sp, #116	; 0x74
 80175bc:	4607      	mov	r7, r0
 80175be:	460d      	mov	r5, r1
 80175c0:	4614      	mov	r4, r2
 80175c2:	d50e      	bpl.n	80175e2 <_svfiprintf_r+0x32>
 80175c4:	690b      	ldr	r3, [r1, #16]
 80175c6:	b963      	cbnz	r3, 80175e2 <_svfiprintf_r+0x32>
 80175c8:	2140      	movs	r1, #64	; 0x40
 80175ca:	f7fe ffef 	bl	80165ac <_malloc_r>
 80175ce:	6028      	str	r0, [r5, #0]
 80175d0:	6128      	str	r0, [r5, #16]
 80175d2:	b920      	cbnz	r0, 80175de <_svfiprintf_r+0x2e>
 80175d4:	230c      	movs	r3, #12
 80175d6:	603b      	str	r3, [r7, #0]
 80175d8:	f04f 30ff 	mov.w	r0, #4294967295
 80175dc:	e0d1      	b.n	8017782 <_svfiprintf_r+0x1d2>
 80175de:	2340      	movs	r3, #64	; 0x40
 80175e0:	616b      	str	r3, [r5, #20]
 80175e2:	2300      	movs	r3, #0
 80175e4:	9309      	str	r3, [sp, #36]	; 0x24
 80175e6:	2320      	movs	r3, #32
 80175e8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80175ec:	f8cd 800c 	str.w	r8, [sp, #12]
 80175f0:	2330      	movs	r3, #48	; 0x30
 80175f2:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 801779c <_svfiprintf_r+0x1ec>
 80175f6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80175fa:	f04f 0901 	mov.w	r9, #1
 80175fe:	4623      	mov	r3, r4
 8017600:	469a      	mov	sl, r3
 8017602:	f813 2b01 	ldrb.w	r2, [r3], #1
 8017606:	b10a      	cbz	r2, 801760c <_svfiprintf_r+0x5c>
 8017608:	2a25      	cmp	r2, #37	; 0x25
 801760a:	d1f9      	bne.n	8017600 <_svfiprintf_r+0x50>
 801760c:	ebba 0b04 	subs.w	fp, sl, r4
 8017610:	d00b      	beq.n	801762a <_svfiprintf_r+0x7a>
 8017612:	465b      	mov	r3, fp
 8017614:	4622      	mov	r2, r4
 8017616:	4629      	mov	r1, r5
 8017618:	4638      	mov	r0, r7
 801761a:	f7ff ff6e 	bl	80174fa <__ssputs_r>
 801761e:	3001      	adds	r0, #1
 8017620:	f000 80aa 	beq.w	8017778 <_svfiprintf_r+0x1c8>
 8017624:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8017626:	445a      	add	r2, fp
 8017628:	9209      	str	r2, [sp, #36]	; 0x24
 801762a:	f89a 3000 	ldrb.w	r3, [sl]
 801762e:	2b00      	cmp	r3, #0
 8017630:	f000 80a2 	beq.w	8017778 <_svfiprintf_r+0x1c8>
 8017634:	2300      	movs	r3, #0
 8017636:	f04f 32ff 	mov.w	r2, #4294967295
 801763a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801763e:	f10a 0a01 	add.w	sl, sl, #1
 8017642:	9304      	str	r3, [sp, #16]
 8017644:	9307      	str	r3, [sp, #28]
 8017646:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801764a:	931a      	str	r3, [sp, #104]	; 0x68
 801764c:	4654      	mov	r4, sl
 801764e:	2205      	movs	r2, #5
 8017650:	f814 1b01 	ldrb.w	r1, [r4], #1
 8017654:	4851      	ldr	r0, [pc, #324]	; (801779c <_svfiprintf_r+0x1ec>)
 8017656:	f7e8 fdbb 	bl	80001d0 <memchr>
 801765a:	9a04      	ldr	r2, [sp, #16]
 801765c:	b9d8      	cbnz	r0, 8017696 <_svfiprintf_r+0xe6>
 801765e:	06d0      	lsls	r0, r2, #27
 8017660:	bf44      	itt	mi
 8017662:	2320      	movmi	r3, #32
 8017664:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8017668:	0711      	lsls	r1, r2, #28
 801766a:	bf44      	itt	mi
 801766c:	232b      	movmi	r3, #43	; 0x2b
 801766e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8017672:	f89a 3000 	ldrb.w	r3, [sl]
 8017676:	2b2a      	cmp	r3, #42	; 0x2a
 8017678:	d015      	beq.n	80176a6 <_svfiprintf_r+0xf6>
 801767a:	9a07      	ldr	r2, [sp, #28]
 801767c:	4654      	mov	r4, sl
 801767e:	2000      	movs	r0, #0
 8017680:	f04f 0c0a 	mov.w	ip, #10
 8017684:	4621      	mov	r1, r4
 8017686:	f811 3b01 	ldrb.w	r3, [r1], #1
 801768a:	3b30      	subs	r3, #48	; 0x30
 801768c:	2b09      	cmp	r3, #9
 801768e:	d94e      	bls.n	801772e <_svfiprintf_r+0x17e>
 8017690:	b1b0      	cbz	r0, 80176c0 <_svfiprintf_r+0x110>
 8017692:	9207      	str	r2, [sp, #28]
 8017694:	e014      	b.n	80176c0 <_svfiprintf_r+0x110>
 8017696:	eba0 0308 	sub.w	r3, r0, r8
 801769a:	fa09 f303 	lsl.w	r3, r9, r3
 801769e:	4313      	orrs	r3, r2
 80176a0:	9304      	str	r3, [sp, #16]
 80176a2:	46a2      	mov	sl, r4
 80176a4:	e7d2      	b.n	801764c <_svfiprintf_r+0x9c>
 80176a6:	9b03      	ldr	r3, [sp, #12]
 80176a8:	1d19      	adds	r1, r3, #4
 80176aa:	681b      	ldr	r3, [r3, #0]
 80176ac:	9103      	str	r1, [sp, #12]
 80176ae:	2b00      	cmp	r3, #0
 80176b0:	bfbb      	ittet	lt
 80176b2:	425b      	neglt	r3, r3
 80176b4:	f042 0202 	orrlt.w	r2, r2, #2
 80176b8:	9307      	strge	r3, [sp, #28]
 80176ba:	9307      	strlt	r3, [sp, #28]
 80176bc:	bfb8      	it	lt
 80176be:	9204      	strlt	r2, [sp, #16]
 80176c0:	7823      	ldrb	r3, [r4, #0]
 80176c2:	2b2e      	cmp	r3, #46	; 0x2e
 80176c4:	d10c      	bne.n	80176e0 <_svfiprintf_r+0x130>
 80176c6:	7863      	ldrb	r3, [r4, #1]
 80176c8:	2b2a      	cmp	r3, #42	; 0x2a
 80176ca:	d135      	bne.n	8017738 <_svfiprintf_r+0x188>
 80176cc:	9b03      	ldr	r3, [sp, #12]
 80176ce:	1d1a      	adds	r2, r3, #4
 80176d0:	681b      	ldr	r3, [r3, #0]
 80176d2:	9203      	str	r2, [sp, #12]
 80176d4:	2b00      	cmp	r3, #0
 80176d6:	bfb8      	it	lt
 80176d8:	f04f 33ff 	movlt.w	r3, #4294967295
 80176dc:	3402      	adds	r4, #2
 80176de:	9305      	str	r3, [sp, #20]
 80176e0:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 80177ac <_svfiprintf_r+0x1fc>
 80176e4:	7821      	ldrb	r1, [r4, #0]
 80176e6:	2203      	movs	r2, #3
 80176e8:	4650      	mov	r0, sl
 80176ea:	f7e8 fd71 	bl	80001d0 <memchr>
 80176ee:	b140      	cbz	r0, 8017702 <_svfiprintf_r+0x152>
 80176f0:	2340      	movs	r3, #64	; 0x40
 80176f2:	eba0 000a 	sub.w	r0, r0, sl
 80176f6:	fa03 f000 	lsl.w	r0, r3, r0
 80176fa:	9b04      	ldr	r3, [sp, #16]
 80176fc:	4303      	orrs	r3, r0
 80176fe:	3401      	adds	r4, #1
 8017700:	9304      	str	r3, [sp, #16]
 8017702:	f814 1b01 	ldrb.w	r1, [r4], #1
 8017706:	4826      	ldr	r0, [pc, #152]	; (80177a0 <_svfiprintf_r+0x1f0>)
 8017708:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801770c:	2206      	movs	r2, #6
 801770e:	f7e8 fd5f 	bl	80001d0 <memchr>
 8017712:	2800      	cmp	r0, #0
 8017714:	d038      	beq.n	8017788 <_svfiprintf_r+0x1d8>
 8017716:	4b23      	ldr	r3, [pc, #140]	; (80177a4 <_svfiprintf_r+0x1f4>)
 8017718:	bb1b      	cbnz	r3, 8017762 <_svfiprintf_r+0x1b2>
 801771a:	9b03      	ldr	r3, [sp, #12]
 801771c:	3307      	adds	r3, #7
 801771e:	f023 0307 	bic.w	r3, r3, #7
 8017722:	3308      	adds	r3, #8
 8017724:	9303      	str	r3, [sp, #12]
 8017726:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017728:	4433      	add	r3, r6
 801772a:	9309      	str	r3, [sp, #36]	; 0x24
 801772c:	e767      	b.n	80175fe <_svfiprintf_r+0x4e>
 801772e:	fb0c 3202 	mla	r2, ip, r2, r3
 8017732:	460c      	mov	r4, r1
 8017734:	2001      	movs	r0, #1
 8017736:	e7a5      	b.n	8017684 <_svfiprintf_r+0xd4>
 8017738:	2300      	movs	r3, #0
 801773a:	3401      	adds	r4, #1
 801773c:	9305      	str	r3, [sp, #20]
 801773e:	4619      	mov	r1, r3
 8017740:	f04f 0c0a 	mov.w	ip, #10
 8017744:	4620      	mov	r0, r4
 8017746:	f810 2b01 	ldrb.w	r2, [r0], #1
 801774a:	3a30      	subs	r2, #48	; 0x30
 801774c:	2a09      	cmp	r2, #9
 801774e:	d903      	bls.n	8017758 <_svfiprintf_r+0x1a8>
 8017750:	2b00      	cmp	r3, #0
 8017752:	d0c5      	beq.n	80176e0 <_svfiprintf_r+0x130>
 8017754:	9105      	str	r1, [sp, #20]
 8017756:	e7c3      	b.n	80176e0 <_svfiprintf_r+0x130>
 8017758:	fb0c 2101 	mla	r1, ip, r1, r2
 801775c:	4604      	mov	r4, r0
 801775e:	2301      	movs	r3, #1
 8017760:	e7f0      	b.n	8017744 <_svfiprintf_r+0x194>
 8017762:	ab03      	add	r3, sp, #12
 8017764:	9300      	str	r3, [sp, #0]
 8017766:	462a      	mov	r2, r5
 8017768:	4b0f      	ldr	r3, [pc, #60]	; (80177a8 <_svfiprintf_r+0x1f8>)
 801776a:	a904      	add	r1, sp, #16
 801776c:	4638      	mov	r0, r7
 801776e:	f3af 8000 	nop.w
 8017772:	1c42      	adds	r2, r0, #1
 8017774:	4606      	mov	r6, r0
 8017776:	d1d6      	bne.n	8017726 <_svfiprintf_r+0x176>
 8017778:	89ab      	ldrh	r3, [r5, #12]
 801777a:	065b      	lsls	r3, r3, #25
 801777c:	f53f af2c 	bmi.w	80175d8 <_svfiprintf_r+0x28>
 8017780:	9809      	ldr	r0, [sp, #36]	; 0x24
 8017782:	b01d      	add	sp, #116	; 0x74
 8017784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017788:	ab03      	add	r3, sp, #12
 801778a:	9300      	str	r3, [sp, #0]
 801778c:	462a      	mov	r2, r5
 801778e:	4b06      	ldr	r3, [pc, #24]	; (80177a8 <_svfiprintf_r+0x1f8>)
 8017790:	a904      	add	r1, sp, #16
 8017792:	4638      	mov	r0, r7
 8017794:	f7ff f946 	bl	8016a24 <_printf_i>
 8017798:	e7eb      	b.n	8017772 <_svfiprintf_r+0x1c2>
 801779a:	bf00      	nop
 801779c:	0801dd9c 	.word	0x0801dd9c
 80177a0:	0801dda6 	.word	0x0801dda6
 80177a4:	00000000 	.word	0x00000000
 80177a8:	080174fb 	.word	0x080174fb
 80177ac:	0801dda2 	.word	0x0801dda2

080177b0 <__sread>:
 80177b0:	b510      	push	{r4, lr}
 80177b2:	460c      	mov	r4, r1
 80177b4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80177b8:	f000 f89c 	bl	80178f4 <_read_r>
 80177bc:	2800      	cmp	r0, #0
 80177be:	bfab      	itete	ge
 80177c0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 80177c2:	89a3      	ldrhlt	r3, [r4, #12]
 80177c4:	181b      	addge	r3, r3, r0
 80177c6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80177ca:	bfac      	ite	ge
 80177cc:	6563      	strge	r3, [r4, #84]	; 0x54
 80177ce:	81a3      	strhlt	r3, [r4, #12]
 80177d0:	bd10      	pop	{r4, pc}

080177d2 <__swrite>:
 80177d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80177d6:	461f      	mov	r7, r3
 80177d8:	898b      	ldrh	r3, [r1, #12]
 80177da:	05db      	lsls	r3, r3, #23
 80177dc:	4605      	mov	r5, r0
 80177de:	460c      	mov	r4, r1
 80177e0:	4616      	mov	r6, r2
 80177e2:	d505      	bpl.n	80177f0 <__swrite+0x1e>
 80177e4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80177e8:	2302      	movs	r3, #2
 80177ea:	2200      	movs	r2, #0
 80177ec:	f000 f868 	bl	80178c0 <_lseek_r>
 80177f0:	89a3      	ldrh	r3, [r4, #12]
 80177f2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80177f6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80177fa:	81a3      	strh	r3, [r4, #12]
 80177fc:	4632      	mov	r2, r6
 80177fe:	463b      	mov	r3, r7
 8017800:	4628      	mov	r0, r5
 8017802:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8017806:	f000 b817 	b.w	8017838 <_write_r>

0801780a <__sseek>:
 801780a:	b510      	push	{r4, lr}
 801780c:	460c      	mov	r4, r1
 801780e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017812:	f000 f855 	bl	80178c0 <_lseek_r>
 8017816:	1c43      	adds	r3, r0, #1
 8017818:	89a3      	ldrh	r3, [r4, #12]
 801781a:	bf15      	itete	ne
 801781c:	6560      	strne	r0, [r4, #84]	; 0x54
 801781e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8017822:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8017826:	81a3      	strheq	r3, [r4, #12]
 8017828:	bf18      	it	ne
 801782a:	81a3      	strhne	r3, [r4, #12]
 801782c:	bd10      	pop	{r4, pc}

0801782e <__sclose>:
 801782e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017832:	f000 b813 	b.w	801785c <_close_r>
	...

08017838 <_write_r>:
 8017838:	b538      	push	{r3, r4, r5, lr}
 801783a:	4d07      	ldr	r5, [pc, #28]	; (8017858 <_write_r+0x20>)
 801783c:	4604      	mov	r4, r0
 801783e:	4608      	mov	r0, r1
 8017840:	4611      	mov	r1, r2
 8017842:	2200      	movs	r2, #0
 8017844:	602a      	str	r2, [r5, #0]
 8017846:	461a      	mov	r2, r3
 8017848:	f7e9 fcdc 	bl	8001204 <_write>
 801784c:	1c43      	adds	r3, r0, #1
 801784e:	d102      	bne.n	8017856 <_write_r+0x1e>
 8017850:	682b      	ldr	r3, [r5, #0]
 8017852:	b103      	cbz	r3, 8017856 <_write_r+0x1e>
 8017854:	6023      	str	r3, [r4, #0]
 8017856:	bd38      	pop	{r3, r4, r5, pc}
 8017858:	20001f00 	.word	0x20001f00

0801785c <_close_r>:
 801785c:	b538      	push	{r3, r4, r5, lr}
 801785e:	4d06      	ldr	r5, [pc, #24]	; (8017878 <_close_r+0x1c>)
 8017860:	2300      	movs	r3, #0
 8017862:	4604      	mov	r4, r0
 8017864:	4608      	mov	r0, r1
 8017866:	602b      	str	r3, [r5, #0]
 8017868:	f7e9 fcdb 	bl	8001222 <_close>
 801786c:	1c43      	adds	r3, r0, #1
 801786e:	d102      	bne.n	8017876 <_close_r+0x1a>
 8017870:	682b      	ldr	r3, [r5, #0]
 8017872:	b103      	cbz	r3, 8017876 <_close_r+0x1a>
 8017874:	6023      	str	r3, [r4, #0]
 8017876:	bd38      	pop	{r3, r4, r5, pc}
 8017878:	20001f00 	.word	0x20001f00

0801787c <_fstat_r>:
 801787c:	b538      	push	{r3, r4, r5, lr}
 801787e:	4d07      	ldr	r5, [pc, #28]	; (801789c <_fstat_r+0x20>)
 8017880:	2300      	movs	r3, #0
 8017882:	4604      	mov	r4, r0
 8017884:	4608      	mov	r0, r1
 8017886:	4611      	mov	r1, r2
 8017888:	602b      	str	r3, [r5, #0]
 801788a:	f7e9 fcd6 	bl	800123a <_fstat>
 801788e:	1c43      	adds	r3, r0, #1
 8017890:	d102      	bne.n	8017898 <_fstat_r+0x1c>
 8017892:	682b      	ldr	r3, [r5, #0]
 8017894:	b103      	cbz	r3, 8017898 <_fstat_r+0x1c>
 8017896:	6023      	str	r3, [r4, #0]
 8017898:	bd38      	pop	{r3, r4, r5, pc}
 801789a:	bf00      	nop
 801789c:	20001f00 	.word	0x20001f00

080178a0 <_isatty_r>:
 80178a0:	b538      	push	{r3, r4, r5, lr}
 80178a2:	4d06      	ldr	r5, [pc, #24]	; (80178bc <_isatty_r+0x1c>)
 80178a4:	2300      	movs	r3, #0
 80178a6:	4604      	mov	r4, r0
 80178a8:	4608      	mov	r0, r1
 80178aa:	602b      	str	r3, [r5, #0]
 80178ac:	f7e9 fcd5 	bl	800125a <_isatty>
 80178b0:	1c43      	adds	r3, r0, #1
 80178b2:	d102      	bne.n	80178ba <_isatty_r+0x1a>
 80178b4:	682b      	ldr	r3, [r5, #0]
 80178b6:	b103      	cbz	r3, 80178ba <_isatty_r+0x1a>
 80178b8:	6023      	str	r3, [r4, #0]
 80178ba:	bd38      	pop	{r3, r4, r5, pc}
 80178bc:	20001f00 	.word	0x20001f00

080178c0 <_lseek_r>:
 80178c0:	b538      	push	{r3, r4, r5, lr}
 80178c2:	4d07      	ldr	r5, [pc, #28]	; (80178e0 <_lseek_r+0x20>)
 80178c4:	4604      	mov	r4, r0
 80178c6:	4608      	mov	r0, r1
 80178c8:	4611      	mov	r1, r2
 80178ca:	2200      	movs	r2, #0
 80178cc:	602a      	str	r2, [r5, #0]
 80178ce:	461a      	mov	r2, r3
 80178d0:	f7e9 fcce 	bl	8001270 <_lseek>
 80178d4:	1c43      	adds	r3, r0, #1
 80178d6:	d102      	bne.n	80178de <_lseek_r+0x1e>
 80178d8:	682b      	ldr	r3, [r5, #0]
 80178da:	b103      	cbz	r3, 80178de <_lseek_r+0x1e>
 80178dc:	6023      	str	r3, [r4, #0]
 80178de:	bd38      	pop	{r3, r4, r5, pc}
 80178e0:	20001f00 	.word	0x20001f00

080178e4 <_malloc_usable_size_r>:
 80178e4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80178e8:	1f18      	subs	r0, r3, #4
 80178ea:	2b00      	cmp	r3, #0
 80178ec:	bfbc      	itt	lt
 80178ee:	580b      	ldrlt	r3, [r1, r0]
 80178f0:	18c0      	addlt	r0, r0, r3
 80178f2:	4770      	bx	lr

080178f4 <_read_r>:
 80178f4:	b538      	push	{r3, r4, r5, lr}
 80178f6:	4d07      	ldr	r5, [pc, #28]	; (8017914 <_read_r+0x20>)
 80178f8:	4604      	mov	r4, r0
 80178fa:	4608      	mov	r0, r1
 80178fc:	4611      	mov	r1, r2
 80178fe:	2200      	movs	r2, #0
 8017900:	602a      	str	r2, [r5, #0]
 8017902:	461a      	mov	r2, r3
 8017904:	f7e9 fc61 	bl	80011ca <_read>
 8017908:	1c43      	adds	r3, r0, #1
 801790a:	d102      	bne.n	8017912 <_read_r+0x1e>
 801790c:	682b      	ldr	r3, [r5, #0]
 801790e:	b103      	cbz	r3, 8017912 <_read_r+0x1e>
 8017910:	6023      	str	r3, [r4, #0]
 8017912:	bd38      	pop	{r3, r4, r5, pc}
 8017914:	20001f00 	.word	0x20001f00

08017918 <_init>:
 8017918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801791a:	bf00      	nop
 801791c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801791e:	bc08      	pop	{r3}
 8017920:	469e      	mov	lr, r3
 8017922:	4770      	bx	lr

08017924 <_fini>:
 8017924:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017926:	bf00      	nop
 8017928:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801792a:	bc08      	pop	{r3}
 801792c:	469e      	mov	lr, r3
 801792e:	4770      	bx	lr
