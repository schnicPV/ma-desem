#include "mcu/mcu.h"
#include "main.h"
#include "button.h"

Button::Button()
 : pManager(nullptr),
   state(RELEASED)
{
}

Button::~Button()
{
}

void Button::initialize()
{
	// Initialize hardware
	initializeHardware();

	// Read actual button state (GPIO state)
	// (It may be pressed already at start up!)
	state = checkButtonState();
}

void Button::initializeHardware()
{
	// The blue button of the Nucleo board is on MCU pin PC13.

    // Note: GPIO configuration code is generated by STM32CubeIDE
    //       and is located in the 'Core/Src/main.c' file.
    //
    //       Double-click on the hal-project.ioc file for more details.
    //
    // This means that in this method no additional hardware initialization
    // code must be called. It is already implemented in the MX_GPIO_Init()
    // function in the 'Core/Src/main.c' file and also called in the main()
    // function!
}

void Button::initializeRelations(ToButtonManager * p)
{
	setButtonManager(p);
}

void Button::setButtonManager(ToButtonManager * p)
{
	pManager = p;
}

void Button::start()
{
	startBehavior();	// Start state machine
}

BState Button::checkButtonState()
{
	// TODO: Implement method accordingly.
	bool state_released = readGpio();
	if(state_released)
	{
		return RELEASED;
	}
	else
	{
		return PRESSED;
	}
}

bool Button::readGpio()
{
    // TODO: Call HAL_GPIO_ReadPin(...) function to get actual GPIO level of the button.
	GPIO_PinState current_state = HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);
	switch(current_state)
	{
	case GPIO_PIN_RESET:
		return false;
	case GPIO_PIN_SET:
		return true;
	default:
		printf("[ERROR] undefined GPIO Pin read!");
		return false;
	}
}

EventStatus Button::processEvent()
{
    // Do we handle the event?
    EventStatus result = EventStatus::Unknown;

    // TODO: Implement state-machine here.
    return result;
}
